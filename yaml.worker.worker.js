/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 45);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Type; });
/* harmony import */ var _exception__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(4);


var TYPE_CONSTRUCTOR_OPTIONS = [
    'kind',
    'resolve',
    'construct',
    'instanceOf',
    'predicate',
    'represent',
    'defaultStyle',
    'styleAliases',
];
var YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];
function compileStyleAliases(map) {
    var result = {};
    if (null !== map) {
        Object.keys(map).forEach(function (style) {
            map[style].forEach(function (alias) {
                result[String(alias)] = style;
            });
        });
    }
    return result;
}
var Type = /** @class */ (function () {
    function Type(tag, options) {
        options = options || {};
        Object.keys(options).forEach(function (name) {
            if (-1 === TYPE_CONSTRUCTOR_OPTIONS.indexOf(name)) {
                throw new _exception__WEBPACK_IMPORTED_MODULE_0__["default"]('Unknown option "' +
                    name +
                    '" is met in definition of "' +
                    tag +
                    '" YAML type.');
            }
        });
        // TODO: Add tag format check.
        this.tag = tag;
        this.kind = options['kind'] || null;
        this.resolve =
            options['resolve'] ||
                function () {
                    return true;
                };
        this.construct =
            options['construct'] ||
                function (data) {
                    return data;
                };
        this.instanceOf = options['instanceOf'] || null;
        this.predicate = options['predicate'] || null;
        this.represent = options['represent'] || null;
        this.defaultStyle = options['defaultStyle'] || null;
        this.styleAliases = compileStyleAliases(options['styleAliases'] || null);
        if (-1 === YAML_NODE_KINDS.indexOf(this.kind)) {
            throw new _exception__WEBPACK_IMPORTED_MODULE_0__["default"]('Unknown kind "' +
                this.kind +
                '" is specified for "' +
                tag +
                '" YAML type.');
        }
    }
    return Type;
}());



/***/ }),
/* 1 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNothing", function() { return isNothing; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isObject", function() { return isObject; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toArray", function() { return toArray; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "extend", function() { return extend; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "repeat", function() { return repeat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isNegativeZero", function() { return isNegativeZero; });

function isNothing(subject) {
    return typeof subject === 'undefined' || null === subject;
}
function isObject(subject) {
    return typeof subject === 'object' && null !== subject;
}
function toArray(sequence) {
    if (Array.isArray(sequence)) {
        return sequence;
    }
    else if (isNothing(sequence)) {
        return [];
    }
    return [sequence];
}
function extend(target, source) {
    var index, length, key, sourceKeys;
    if (source) {
        sourceKeys = Object.keys(source);
        for (index = 0, length = sourceKeys.length; index < length; index += 1) {
            key = sourceKeys[index];
            target[key] = source[key];
        }
    }
    return target;
}
function repeat(string, count) {
    var result = '', cycle;
    for (cycle = 0; cycle < count; cycle += 1) {
        result += string;
    }
    return result;
}
function isNegativeZero(number) {
    return 0 === number && Number.NEGATIVE_INFINITY === 1 / number;
}


/***/ }),
/* 2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Kind; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "e", function() { return newMapping; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "b", function() { return newAnchorRef; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "f", function() { return newScalar; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "c", function() { return newItems; });
/* unused harmony export newSeq */
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "d", function() { return newMap; });
var Kind;
(function (Kind) {
    Kind[Kind["SCALAR"] = 0] = "SCALAR";
    Kind[Kind["MAPPING"] = 1] = "MAPPING";
    Kind[Kind["MAP"] = 2] = "MAP";
    Kind[Kind["SEQ"] = 3] = "SEQ";
    Kind[Kind["ANCHOR_REF"] = 4] = "ANCHOR_REF";
    Kind[Kind["INCLUDE_REF"] = 5] = "INCLUDE_REF";
})(Kind || (Kind = {}));
function newMapping(key, value) {
    var end = value ? value.endPosition : key.endPosition + 1; //FIXME.workaround, end should be defied by position of ':'
    //console.log('key: ' + key.value + ' ' + key.startPosition + '..' + key.endPosition + ' ' + value + ' end: ' + end);
    var node = {
        key: key,
        value: value,
        startPosition: key.startPosition,
        endPosition: end,
        kind: Kind.MAPPING,
        parent: null,
        errors: [],
    };
    return node;
}
function newAnchorRef(key, start, end, value) {
    return {
        errors: [],
        referencesAnchor: key,
        value: value,
        startPosition: start,
        endPosition: end,
        kind: Kind.ANCHOR_REF,
        parent: null,
    };
}
function newScalar(v) {
    if (v === void 0) { v = ''; }
    var result = {
        errors: [],
        startPosition: -1,
        endPosition: -1,
        value: '' + v,
        kind: Kind.SCALAR,
        parent: null,
        doubleQuoted: false,
        rawValue: '' + v,
    };
    if (typeof v !== 'string') {
        result.valueObject = v;
    }
    return result;
}
function newItems() {
    return {
        errors: [],
        startPosition: -1,
        endPosition: -1,
        items: [],
        kind: Kind.SEQ,
        parent: null,
    };
}
function newSeq() {
    return newItems();
}
function newMap(mappings) {
    return {
        errors: [],
        startPosition: -1,
        endPosition: -1,
        mappings: mappings ? mappings : [],
        kind: Kind.MAP,
        parent: null,
    };
}


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var YAMLException = __webpack_require__(10);

var TYPE_CONSTRUCTOR_OPTIONS = [
  'kind',
  'resolve',
  'construct',
  'instanceOf',
  'predicate',
  'represent',
  'defaultStyle',
  'styleAliases'
];

var YAML_NODE_KINDS = [
  'scalar',
  'sequence',
  'mapping'
];

function compileStyleAliases(map) {
  var result = {};

  if (map !== null) {
    Object.keys(map).forEach(function (style) {
      map[style].forEach(function (alias) {
        result[String(alias)] = style;
      });
    });
  }

  return result;
}

function Type(tag, options) {
  options = options || {};

  Object.keys(options).forEach(function (name) {
    if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
      throw new YAMLException('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
    }
  });

  // TODO: Add tag format check.
  this.tag          = tag;
  this.kind         = options['kind']         || null;
  this.resolve      = options['resolve']      || function () { return true; };
  this.construct    = options['construct']    || function (data) { return data; };
  this.instanceOf   = options['instanceOf']   || null;
  this.predicate    = options['predicate']    || null;
  this.represent    = options['represent']    || null;
  this.defaultStyle = options['defaultStyle'] || null;
  this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

  if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
    throw new YAMLException('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
  }
}

module.exports = Type;


/***/ }),
/* 4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);

var __values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var YAMLException = /** @class */ (function () {
    function YAMLException(reason, mark, isWarning) {
        if (mark === void 0) { mark = null; }
        if (isWarning === void 0) { isWarning = false; }
        this.name = 'YAMLException';
        this.reason = reason;
        this.mark = mark;
        this.message = this.toString(false);
        this.isWarning = isWarning;
    }
    YAMLException.isInstance = function (instance) {
        var e_1, _a;
        if (instance != null &&
            instance.getClassIdentifier &&
            typeof instance.getClassIdentifier == 'function') {
            try {
                for (var _b = __values(instance.getClassIdentifier()), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var currentIdentifier = _c.value;
                    if (currentIdentifier == YAMLException.CLASS_IDENTIFIER)
                        return true;
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
        }
        return false;
    };
    YAMLException.prototype.getClassIdentifier = function () {
        var superIdentifiers = [];
        return superIdentifiers.concat(YAMLException.CLASS_IDENTIFIER);
    };
    YAMLException.prototype.toString = function (compact) {
        if (compact === void 0) { compact = false; }
        var result;
        result = 'JS-YAML: ' + (this.reason || '(unknown reason)');
        if (!compact && this.mark) {
            result += ' ' + this.mark.toString();
        }
        return result;
    };
    YAMLException.CLASS_IDENTIFIER = 'yaml-ast-parser.YAMLException';
    return YAMLException;
}());
/* harmony default export */ __webpack_exports__["default"] = (YAMLException);


/***/ }),
/* 5 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "a", function() { return Schema; });
/* harmony import */ var _common__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(1);
/* harmony import */ var _exception__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(4);
/* harmony import */ var _type__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(0);

/*eslint-disable max-len*/



function compileList(schema, name, result) {
    var exclude = [];
    schema.include.forEach(function (includedSchema) {
        result = compileList(includedSchema, name, result);
    });
    schema[name].forEach(function (currentType) {
        result.forEach(function (previousType, previousIndex) {
            if (previousType.tag === currentType.tag) {
                exclude.push(previousIndex);
            }
        });
        result.push(currentType);
    });
    return result.filter(function (type, index) {
        return -1 === exclude.indexOf(index);
    });
}
function compileMap( /* lists... */) {
    var result = {}, index, length;
    function collectType(type) {
        result[type.tag] = type;
    }
    for (index = 0, length = arguments.length; index < length; index += 1) {
        arguments[index].forEach(collectType);
    }
    return result;
}
var Schema = /** @class */ (function () {
    function Schema(definition) {
        this.include = definition.include || [];
        this.implicit = definition.implicit || [];
        this.explicit = definition.explicit || [];
        this.implicit.forEach(function (type) {
            if (type.loadKind && 'scalar' !== type.loadKind) {
                throw new _exception__WEBPACK_IMPORTED_MODULE_1__["default"]('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
            }
        });
        this.compiledImplicit = compileList(this, 'implicit', []);
        this.compiledExplicit = compileList(this, 'explicit', []);
        this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
    }
    Schema.DEFAULT = null;
    Schema.create = function createSchema() {
        var schemas, types;
        switch (arguments.length) {
            case 1:
                schemas = Schema.DEFAULT;
                types = arguments[0];
                break;
            case 2:
                schemas = arguments[0];
                types = arguments[1];
                break;
            default:
                throw new _exception__WEBPACK_IMPORTED_MODULE_1__["default"]('Wrong number of arguments for Schema.create function');
        }
        schemas = _common__WEBPACK_IMPORTED_MODULE_0__["toArray"](schemas);
        types = _common__WEBPACK_IMPORTED_MODULE_0__["toArray"](types);
        if (!schemas.every(function (schema) {
            return schema instanceof Schema;
        })) {
            throw new _exception__WEBPACK_IMPORTED_MODULE_1__["default"]('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
        }
        if (!types.every(function (type) {
            return type instanceof _type__WEBPACK_IMPORTED_MODULE_2__[/* Type */ "a"];
        })) {
            throw new _exception__WEBPACK_IMPORTED_MODULE_1__["default"]('Specified list of YAML types (or a single Type object) contains a non-Type object.');
        }
        return new Schema({
            include: schemas,
            explicit: types,
        });
    };
    return Schema;
}());



/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var yaml = __webpack_require__(18);


module.exports = yaml;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



function isNothing(subject) {
  return (typeof subject === 'undefined') || (subject === null);
}


function isObject(subject) {
  return (typeof subject === 'object') && (subject !== null);
}


function toArray(sequence) {
  if (Array.isArray(sequence)) return sequence;
  else if (isNothing(sequence)) return [];

  return [ sequence ];
}


function extend(target, source) {
  var index, length, key, sourceKeys;

  if (source) {
    sourceKeys = Object.keys(source);

    for (index = 0, length = sourceKeys.length; index < length; index += 1) {
      key = sourceKeys[index];
      target[key] = source[key];
    }
  }

  return target;
}


function repeat(string, count) {
  var result = '', cycle;

  for (cycle = 0; cycle < count; cycle += 1) {
    result += string;
  }

  return result;
}


function isNegativeZero(number) {
  return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);
}


module.exports.isNothing      = isNothing;
module.exports.isObject       = isObject;
module.exports.toArray        = toArray;
module.exports.repeat         = repeat;
module.exports.isNegativeZero = isNegativeZero;
module.exports.extend         = extend;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*eslint-disable max-len*/

var common        = __webpack_require__(7);
var YAMLException = __webpack_require__(10);
var Type          = __webpack_require__(3);


function compileList(schema, name, result) {
  var exclude = [];

  schema.include.forEach(function (includedSchema) {
    result = compileList(includedSchema, name, result);
  });

  schema[name].forEach(function (currentType) {
    result.forEach(function (previousType, previousIndex) {
      if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
        exclude.push(previousIndex);
      }
    });

    result.push(currentType);
  });

  return result.filter(function (type, index) {
    return exclude.indexOf(index) === -1;
  });
}


function compileMap(/* lists... */) {
  var result = {
        scalar: {},
        sequence: {},
        mapping: {},
        fallback: {}
      }, index, length;

  function collectType(type) {
    result[type.kind][type.tag] = result['fallback'][type.tag] = type;
  }

  for (index = 0, length = arguments.length; index < length; index += 1) {
    arguments[index].forEach(collectType);
  }
  return result;
}


function Schema(definition) {
  this.include  = definition.include  || [];
  this.implicit = definition.implicit || [];
  this.explicit = definition.explicit || [];

  this.implicit.forEach(function (type) {
    if (type.loadKind && type.loadKind !== 'scalar') {
      throw new YAMLException('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
    }
  });

  this.compiledImplicit = compileList(this, 'implicit', []);
  this.compiledExplicit = compileList(this, 'explicit', []);
  this.compiledTypeMap  = compileMap(this.compiledImplicit, this.compiledExplicit);
}


Schema.DEFAULT = null;


Schema.create = function createSchema() {
  var schemas, types;

  switch (arguments.length) {
    case 1:
      schemas = Schema.DEFAULT;
      types = arguments[0];
      break;

    case 2:
      schemas = arguments[0];
      types = arguments[1];
      break;

    default:
      throw new YAMLException('Wrong number of arguments for Schema.create function');
  }

  schemas = common.toArray(schemas);
  types = common.toArray(types);

  if (!schemas.every(function (schema) { return schema instanceof Schema; })) {
    throw new YAMLException('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
  }

  if (!types.every(function (type) { return type instanceof Type; })) {
    throw new YAMLException('Specified list of YAML types (or a single Type object) contains a non-Type object.');
  }

  return new Schema({
    include: schemas,
    explicit: types
  });
};


module.exports = Schema;


/***/ }),
/* 9 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/schema.js
var schema = __webpack_require__(5);

// EXTERNAL MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/type.js
var type = __webpack_require__(0);

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/type/str.js


/* harmony default export */ var str = (new type["a" /* Type */]('tag:yaml.org,2002:str', {
    kind: 'scalar',
    construct: function (data) {
        return null !== data ? data : '';
    },
}));

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/type/seq.js


/* harmony default export */ var seq = (new type["a" /* Type */]('tag:yaml.org,2002:seq', {
    kind: 'sequence',
    construct: function (data) {
        return null !== data ? data : [];
    },
}));

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/type/map.js


/* harmony default export */ var map = (new type["a" /* Type */]('tag:yaml.org,2002:map', {
    kind: 'mapping',
    construct: function (data) {
        return null !== data ? data : {};
    },
}));

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/schema/failsafe.js
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346





/* harmony default export */ var failsafe = (new schema["a" /* Schema */]({
    explicit: [str, seq, map],
}));

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/type/null.js


function resolveYamlNull(data) {
    if (null === data) {
        return true;
    }
    var max = data.length;
    return ((max === 1 && data === '~') ||
        (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL')));
}
function constructYamlNull() {
    return null;
}
function isNull(object) {
    return null === object;
}
/* harmony default export */ var type_null = (new type["a" /* Type */]('tag:yaml.org,2002:null', {
    kind: 'scalar',
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
        canonical: function () {
            return '~';
        },
        lowercase: function () {
            return 'null';
        },
        uppercase: function () {
            return 'NULL';
        },
        camelcase: function () {
            return 'Null';
        },
    },
    defaultStyle: 'lowercase',
}));

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/type/bool.js


function resolveYamlBoolean(data) {
    if (null === data) {
        return false;
    }
    var max = data.length;
    return ((max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
        (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE')));
}
function constructYamlBoolean(data) {
    return data === 'true' || data === 'True' || data === 'TRUE';
}
function isBoolean(object) {
    return '[object Boolean]' === Object.prototype.toString.call(object);
}
/* harmony default export */ var bool = (new type["a" /* Type */]('tag:yaml.org,2002:bool', {
    kind: 'scalar',
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
        lowercase: function (object) {
            return object ? 'true' : 'false';
        },
        uppercase: function (object) {
            return object ? 'TRUE' : 'FALSE';
        },
        camelcase: function (object) {
            return object ? 'True' : 'False';
        },
    },
    defaultStyle: 'lowercase',
}));

// EXTERNAL MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/common.js
var common = __webpack_require__(1);

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/type/int.js



function isHexCode(c) {
    return ((0x30 /* 0 */ <= c && c <= 0x39) /* 9 */ ||
        (0x41 /* A */ <= c && c <= 0x46) /* F */ ||
        (0x61 /* a */ <= c && c <= 0x66) /* f */);
}
function isOctCode(c) {
    return 0x30 /* 0 */ <= c && c <= 0x37 /* 7 */;
}
function isDecCode(c) {
    return 0x30 /* 0 */ <= c && c <= 0x39 /* 9 */;
}
function resolveYamlInteger(data) {
    if (null === data) {
        return false;
    }
    var max = data.length, index = 0, hasDigits = false, ch;
    if (!max) {
        return false;
    }
    ch = data[index];
    // sign
    if (ch === '-' || ch === '+') {
        ch = data[++index];
    }
    if (ch === '0') {
        // 0
        if (index + 1 === max) {
            return true;
        }
        ch = data[++index];
        // base 2, base 8, base 16
        if (ch === 'b') {
            // base 2
            index++;
            for (; index < max; index++) {
                ch = data[index];
                if (ch === '_') {
                    continue;
                }
                if (ch !== '0' && ch !== '1') {
                    return false;
                }
                hasDigits = true;
            }
            return hasDigits;
        }
        if (ch === 'x') {
            // base 16
            index++;
            for (; index < max; index++) {
                ch = data[index];
                if (ch === '_') {
                    continue;
                }
                if (!isHexCode(data.charCodeAt(index))) {
                    return false;
                }
                hasDigits = true;
            }
            return hasDigits;
        }
        // base 8
        for (; index < max; index++) {
            ch = data[index];
            if (ch === '_') {
                continue;
            }
            if (!isOctCode(data.charCodeAt(index))) {
                return false;
            }
            hasDigits = true;
        }
        return hasDigits;
    }
    // base 10 (except 0) or base 60
    for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') {
            continue;
        }
        if (ch === ':') {
            break;
        }
        if (!isDecCode(data.charCodeAt(index))) {
            return false;
        }
        hasDigits = true;
    }
    if (!hasDigits) {
        return false;
    }
    // if !base60 - done;
    if (ch !== ':') {
        return true;
    }
    // base60 almost not used, no needs to optimize
    return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}
function constructYamlInteger(data) {
    var value = data, sign = 1, ch, base, digits = [];
    if (value.indexOf('_') !== -1) {
        value = value.replace(/_/g, '');
    }
    ch = value[0];
    if (ch === '-' || ch === '+') {
        if (ch === '-') {
            sign = -1;
        }
        value = value.slice(1);
        ch = value[0];
    }
    if ('0' === value) {
        return 0;
    }
    if (ch === '0') {
        if (value[1] === 'b') {
            return sign * parseInt(value.slice(2), 2);
        }
        if (value[1] === 'x') {
            return sign * parseInt(value, 16);
        }
        return sign * parseInt(value, 8);
    }
    if (value.indexOf(':') !== -1) {
        value.split(':').forEach(function (v) {
            digits.unshift(parseInt(v, 10));
        });
        value = 0;
        base = 1;
        digits.forEach(function (d) {
            value += d * base;
            base *= 60;
        });
        return sign * value;
    }
    return sign * parseInt(value, 10);
}
function isInteger(object) {
    return ('[object Number]' === Object.prototype.toString.call(object) &&
        0 === object % 1 &&
        !common["isNegativeZero"](object));
}
/* harmony default export */ var type_int = (new type["a" /* Type */]('tag:yaml.org,2002:int', {
    kind: 'scalar',
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
        binary: function (object) {
            return '0b' + object.toString(2);
        },
        octal: function (object) {
            return '0' + object.toString(8);
        },
        decimal: function (object) {
            return object.toString(10);
        },
        hexadecimal: function (object) {
            return '0x' + object.toString(16).toUpperCase();
        },
    },
    defaultStyle: 'decimal',
    styleAliases: {
        binary: [2, 'bin'],
        octal: [8, 'oct'],
        decimal: [10, 'dec'],
        hexadecimal: [16, 'hex'],
    },
}));

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/type/float.js



var YAML_FLOAT_PATTERN = new RegExp('^(?:[-+]?(?:[0-9][0-9_]*)\\.[0-9_]*(?:[eE][-+][0-9]+)?' +
    '|\\.[0-9_]+(?:[eE][-+][0-9]+)?' +
    '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
    '|[-+]?\\.(?:inf|Inf|INF)' +
    '|\\.(?:nan|NaN|NAN))$');
function resolveYamlFloat(data) {
    if (null === data) {
        return false;
    }
    var value, sign, base, digits;
    if (!YAML_FLOAT_PATTERN.test(data)) {
        return false;
    }
    return true;
}
function constructYamlFloat(data) {
    var value, sign, base, digits;
    value = data.replace(/_/g, '').toLowerCase();
    sign = '-' === value[0] ? -1 : 1;
    digits = [];
    if (0 <= '+-'.indexOf(value[0])) {
        value = value.slice(1);
    }
    if ('.inf' === value) {
        return 1 === sign ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    }
    else if ('.nan' === value) {
        return NaN;
    }
    else if (0 <= value.indexOf(':')) {
        value.split(':').forEach(function (v) {
            digits.unshift(parseFloat(v, 10));
        });
        value = 0.0;
        base = 1;
        digits.forEach(function (d) {
            value += d * base;
            base *= 60;
        });
        return sign * value;
    }
    return sign * parseFloat(value, 10);
}
function representYamlFloat(object, style) {
    if (isNaN(object)) {
        switch (style) {
            case 'lowercase':
                return '.nan';
            case 'uppercase':
                return '.NAN';
            case 'camelcase':
                return '.NaN';
        }
    }
    else if (Number.POSITIVE_INFINITY === object) {
        switch (style) {
            case 'lowercase':
                return '.inf';
            case 'uppercase':
                return '.INF';
            case 'camelcase':
                return '.Inf';
        }
    }
    else if (Number.NEGATIVE_INFINITY === object) {
        switch (style) {
            case 'lowercase':
                return '-.inf';
            case 'uppercase':
                return '-.INF';
            case 'camelcase':
                return '-.Inf';
        }
    }
    else if (common["isNegativeZero"](object)) {
        return '-0.0';
    }
    return object.toString(10);
}
function isFloat(object) {
    return ('[object Number]' === Object.prototype.toString.call(object) &&
        (0 !== object % 1 || common["isNegativeZero"](object)));
}
/* harmony default export */ var type_float = (new type["a" /* Type */]('tag:yaml.org,2002:float', {
    kind: 'scalar',
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: 'lowercase',
}));

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/schema/json.js
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.







/* harmony default export */ var json = (new schema["a" /* Schema */]({
    include: [failsafe],
    implicit: [type_null, bool, type_int, type_float],
}));

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/schema/core.js
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.



/* harmony default export */ var core = (new schema["a" /* Schema */]({
    include: [json],
}));

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/type/timestamp.js


var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year
    '-([0-9][0-9]?)' + // [2] month
    '-([0-9][0-9]?)' + // [3] day
    '(?:(?:[Tt]|[ \\t]+)' + // ...
    '([0-9][0-9]?)' + // [4] hour
    ':([0-9][0-9])' + // [5] minute
    ':([0-9][0-9])' + // [6] second
    '(?:\\.([0-9]*))?' + // [7] fraction
    '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
    '(?::([0-9][0-9]))?))?)?$'); // [11] tz_minute
function resolveYamlTimestamp(data) {
    if (null === data) {
        return false;
    }
    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    match = YAML_TIMESTAMP_REGEXP.exec(data);
    if (null === match) {
        return false;
    }
    return true;
}
function constructYamlTimestamp(data) {
    var match, year, month, day, hour, minute, second, fraction = 0, delta = null, tz_hour, tz_minute, date;
    match = YAML_TIMESTAMP_REGEXP.exec(data);
    if (null === match) {
        throw new Error('Date resolve error');
    }
    // match: [1] year [2] month [3] day
    year = +match[1];
    month = +match[2] - 1; // JS month starts with 0
    day = +match[3];
    if (!match[4]) {
        // no hour
        return new Date(Date.UTC(year, month, day));
    }
    // match: [4] hour [5] minute [6] second [7] fraction
    hour = +match[4];
    minute = +match[5];
    second = +match[6];
    if (match[7]) {
        fraction = match[7].slice(0, 3);
        while (fraction.length < 3) {
            // milli-seconds
            fraction = fraction + '0';
        }
        fraction = +fraction;
    }
    // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute
    if (match[9]) {
        tz_hour = +match[10];
        tz_minute = +(match[11] || 0);
        delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
        if ('-' === match[9]) {
            delta = -delta;
        }
    }
    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta) {
        date.setTime(date.getTime() - delta);
    }
    return date;
}
function representYamlTimestamp(object /*, style*/) {
    return object.toISOString();
}
/* harmony default export */ var timestamp = (new type["a" /* Type */]('tag:yaml.org,2002:timestamp', {
    kind: 'scalar',
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp,
}));

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/type/merge.js


function resolveYamlMerge(data) {
    return '<<' === data || null === data;
}
/* harmony default export */ var merge = (new type["a" /* Type */]('tag:yaml.org,2002:merge', {
    kind: 'scalar',
    resolve: resolveYamlMerge,
}));

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/type/binary.js


// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';
function resolveYamlBinary(data) {
    if (null === data) {
        return false;
    }
    var code, idx, bitlen = 0, len = 0, max = data.length, map = BASE64_MAP;
    // Convert one by one.
    for (idx = 0; idx < max; idx++) {
        code = map.indexOf(data.charAt(idx));
        // Skip CR/LF
        if (code > 64) {
            continue;
        }
        // Fail on illegal characters
        if (code < 0) {
            return false;
        }
        bitlen += 6;
    }
    // If there are any bits left, source was corrupted
    return bitlen % 8 === 0;
}
function constructYamlBinary(data) {
    var code, idx, tailbits, input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
    max = input.length, map = BASE64_MAP, bits = 0, result = [];
    // Collect by 6*4 bits (3 bytes)
    for (idx = 0; idx < max; idx++) {
        if (idx % 4 === 0 && idx) {
            result.push((bits >> 16) & 0xff);
            result.push((bits >> 8) & 0xff);
            result.push(bits & 0xff);
        }
        bits = (bits << 6) | map.indexOf(input.charAt(idx));
    }
    // Dump tail
    tailbits = (max % 4) * 6;
    if (tailbits === 0) {
        result.push((bits >> 16) & 0xff);
        result.push((bits >> 8) & 0xff);
        result.push(bits & 0xff);
    }
    else if (tailbits === 18) {
        result.push((bits >> 10) & 0xff);
        result.push((bits >> 2) & 0xff);
    }
    else if (tailbits === 12) {
        result.push((bits >> 4) & 0xff);
    }
    // Wrap into Buffer for NodeJS and leave Array for browser
    if (NodeBuffer) {
        return new NodeBuffer(result);
    }
    return result;
}
function representYamlBinary(object /*, style*/) {
    var result = '', bits = 0, idx, tail, max = object.length, map = BASE64_MAP;
    // Convert every three bytes to 4 ASCII characters.
    for (idx = 0; idx < max; idx++) {
        if (idx % 3 === 0 && idx) {
            result += map[(bits >> 18) & 0x3f];
            result += map[(bits >> 12) & 0x3f];
            result += map[(bits >> 6) & 0x3f];
            result += map[bits & 0x3f];
        }
        bits = (bits << 8) + object[idx];
    }
    // Dump tail
    tail = max % 3;
    if (tail === 0) {
        result += map[(bits >> 18) & 0x3f];
        result += map[(bits >> 12) & 0x3f];
        result += map[(bits >> 6) & 0x3f];
        result += map[bits & 0x3f];
    }
    else if (tail === 2) {
        result += map[(bits >> 10) & 0x3f];
        result += map[(bits >> 4) & 0x3f];
        result += map[(bits << 2) & 0x3f];
        result += map[64];
    }
    else if (tail === 1) {
        result += map[(bits >> 2) & 0x3f];
        result += map[(bits << 4) & 0x3f];
        result += map[64];
        result += map[64];
    }
    return result;
}
function isBinary(object) {
    return NodeBuffer && NodeBuffer.isBuffer(object);
}
/* harmony default export */ var binary = (new type["a" /* Type */]('tag:yaml.org,2002:binary', {
    kind: 'scalar',
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary,
}));

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/type/omap.js


var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString = Object.prototype.toString;
function resolveYamlOmap(data) {
    if (null === data) {
        return true;
    }
    var objectKeys = [], index, length, pair, pairKey, pairHasKey, object = data;
    for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        pairHasKey = false;
        if ('[object Object]' !== _toString.call(pair)) {
            return false;
        }
        for (pairKey in pair) {
            if (_hasOwnProperty.call(pair, pairKey)) {
                if (!pairHasKey) {
                    pairHasKey = true;
                }
                else {
                    return false;
                }
            }
        }
        if (!pairHasKey) {
            return false;
        }
        if (-1 === objectKeys.indexOf(pairKey)) {
            objectKeys.push(pairKey);
        }
        else {
            return false;
        }
    }
    return true;
}
function constructYamlOmap(data) {
    return null !== data ? data : [];
}
/* harmony default export */ var omap = (new type["a" /* Type */]('tag:yaml.org,2002:omap', {
    kind: 'sequence',
    resolve: resolveYamlOmap,
    construct: constructYamlOmap,
}));

// EXTERNAL MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/yamlAST.js
var yamlAST = __webpack_require__(2);

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/type/pairs.js



var pairs_toString = Object.prototype.toString;
function resolveYamlPairs(data) {
    if (null === data) {
        return true;
    }
    if (data.kind != yamlAST["a" /* Kind */].SEQ) {
        return false;
    }
    var index, length, pair, keys, result, object = data.items;
    for (index = 0, length = object.length; index < length; index += 1) {
        pair = object[index];
        if ('[object Object]' !== pairs_toString.call(pair)) {
            return false;
        }
        if (!Array.isArray(pair.mappings)) {
            return false;
        }
        if (1 !== pair.mappings.length) {
            return false;
        }
    }
    return true;
}
function constructYamlPairs(data) {
    if (null === data || !Array.isArray(data.items)) {
        return [];
    }
    var index, length, keys, result, object = data.items;
    result = yamlAST["c" /* newItems */]();
    result.parent = data.parent;
    result.startPosition = data.startPosition;
    result.endPosition = data.endPosition;
    for (index = 0, length = object.length; index < length; index += 1) {
        var pair = object[index];
        var mapping = pair.mappings[0];
        var pairSeq = yamlAST["c" /* newItems */]();
        pairSeq.parent = result;
        pairSeq.startPosition = mapping.key.startPosition;
        pairSeq.endPosition = mapping.value.startPosition;
        mapping.key.parent = pairSeq;
        mapping.value.parent = pairSeq;
        pairSeq.items = [mapping.key, mapping.value];
        result.items.push(pairSeq);
    }
    return result;
}
/* harmony default export */ var pairs = (new type["a" /* Type */]('tag:yaml.org,2002:pairs', {
    kind: 'sequence',
    resolve: resolveYamlPairs,
    construct: constructYamlPairs,
}));

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/type/set.js



var set_hasOwnProperty = Object.prototype.hasOwnProperty;
function resolveYamlSet(data) {
    if (null === data) {
        return true;
    }
    if (data.kind != yamlAST["a" /* Kind */].MAP) {
        return false;
    }
    return true;
}
function constructYamlSet(data) {
    return null !== data ? data : {};
}
/* harmony default export */ var set = (new type["a" /* Type */]('tag:yaml.org,2002:set', {
    kind: 'mapping',
    resolve: resolveYamlSet,
    construct: constructYamlSet,
}));

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/schema/default_safe.js
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)









var default_safe_schema = new schema["a" /* Schema */]({
    include: [core],
    implicit: [timestamp, merge],
    explicit: [binary, omap, pairs, set],
});
/* harmony default export */ var default_safe = __webpack_exports__["default"] = (default_safe_schema);


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// YAML error class. http://stackoverflow.com/questions/8458984
//


function YAMLException(reason, mark) {
  // Super constructor
  Error.call(this);

  this.name = 'YAMLException';
  this.reason = reason;
  this.mark = mark;
  this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : '');

  // Include stack trace in error object
  if (Error.captureStackTrace) {
    // Chrome and NodeJS
    Error.captureStackTrace(this, this.constructor);
  } else {
    // FF, IE 10+ and Safari 6+. Fallback for others
    this.stack = (new Error()).stack || '';
  }
}


// Inherit from Error
YAMLException.prototype = Object.create(Error.prototype);
YAMLException.prototype.constructor = YAMLException;


YAMLException.prototype.toString = function toString(compact) {
  var result = this.name + ': ';

  result += this.reason || '(unknown reason)';

  if (!compact && this.mark) {
    result += ' ' + this.mark.toString();
  }

  return result;
};


module.exports = YAMLException;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// JS-YAML's default schema for `safeLoad` function.
// It is not described in the YAML specification.
//
// This schema is based on standard YAML's Core schema and includes most of
// extra types described at YAML tag repository. (http://yaml.org/type/)





var Schema = __webpack_require__(8);


module.exports = new Schema({
  include: [
    __webpack_require__(15)
  ],
  implicit: [
    __webpack_require__(28),
    __webpack_require__(29)
  ],
  explicit: [
    __webpack_require__(30),
    __webpack_require__(35),
    __webpack_require__(36),
    __webpack_require__(37)
  ]
});


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// JS-YAML's default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.





var Schema = __webpack_require__(8);


module.exports = Schema.DEFAULT = new Schema({
  include: [
    __webpack_require__(11)
  ],
  explicit: [
    __webpack_require__(38),
    __webpack_require__(39),
    __webpack_require__(40)
  ]
});


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Standard YAML's Failsafe schema.
// http://www.yaml.org/spec/1.2/spec.html#id2802346





var Schema = __webpack_require__(8);


module.exports = new Schema({
  explicit: [
    __webpack_require__(21),
    __webpack_require__(22),
    __webpack_require__(23)
  ]
});


/***/ }),
/* 14 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXTERNAL MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/schema.js
var schema = __webpack_require__(5);

// EXTERNAL MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/schema/default_safe.js + 16 modules
var default_safe = __webpack_require__(9);

// EXTERNAL MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/type.js
var type = __webpack_require__(0);

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/type/js/undefined.js


function resolveJavascriptUndefined() {
    return true;
}
function constructJavascriptUndefined() {
    /*eslint-disable no-undefined*/
    return undefined;
}
function representJavascriptUndefined() {
    return '';
}
function isUndefined(object) {
    return 'undefined' === typeof object;
}
/* harmony default export */ var js_undefined = (new type["a" /* Type */]('tag:yaml.org,2002:js/undefined', {
    kind: 'scalar',
    resolve: resolveJavascriptUndefined,
    construct: constructJavascriptUndefined,
    predicate: isUndefined,
    represent: representJavascriptUndefined,
}));

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/type/js/regexp.js


function resolveJavascriptRegExp(data) {
    if (null === data) {
        return false;
    }
    if (0 === data.length) {
        return false;
    }
    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = '';
    // if regexp starts with '/' it can have modifiers and must be properly closed
    // `/foo/gim` - modifiers tail can be maximum 3 chars
    if ('/' === regexp[0]) {
        if (tail) {
            modifiers = tail[1];
        }
        if (modifiers.length > 3) {
            return false;
        }
        // if expression starts with /, is should be properly terminated
        if (regexp[regexp.length - modifiers.length - 1] !== '/') {
            return false;
        }
        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
    }
    try {
        var dummy = new RegExp(regexp, modifiers);
        return true;
    }
    catch (error) {
        return false;
    }
}
function constructJavascriptRegExp(data) {
    var regexp = data, tail = /\/([gim]*)$/.exec(data), modifiers = '';
    // `/foo/gim` - tail can be maximum 4 chars
    if ('/' === regexp[0]) {
        if (tail) {
            modifiers = tail[1];
        }
        regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
    }
    return new RegExp(regexp, modifiers);
}
function representJavascriptRegExp(object /*, style*/) {
    var result = '/' + object.source + '/';
    if (object.global) {
        result += 'g';
    }
    if (object.multiline) {
        result += 'm';
    }
    if (object.ignoreCase) {
        result += 'i';
    }
    return result;
}
function isRegExp(object) {
    return '[object RegExp]' === Object.prototype.toString.call(object);
}
/* harmony default export */ var regexp = (new type["a" /* Type */]('tag:yaml.org,2002:js/regexp', {
    kind: 'scalar',
    resolve: resolveJavascriptRegExp,
    construct: constructJavascriptRegExp,
    predicate: isRegExp,
    represent: representJavascriptRegExp,
}));

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/schema/default_full.js
// JS-YAML's default schema for `load` function.
// It is not described in the YAML specification.
//
// This schema is based on JS-YAML's default safe schema and includes
// JavaScript-specific types: !!js/undefined, !!js/regexp and !!js/function.
//
// Also this schema is used as default base schema at `Schema.create` function.





var default_full_schema = new schema["a" /* Schema */]({
    include: [default_safe["default"]],
    explicit: [js_undefined, regexp],
});
schema["a" /* Schema */].DEFAULT = default_full_schema;
/* harmony default export */ var default_full = __webpack_exports__["default"] = (default_full_schema);


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Standard YAML's Core schema.
// http://www.yaml.org/spec/1.2/spec.html#id2804923
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, Core schema has no distinctions from JSON schema is JS-YAML.





var Schema = __webpack_require__(8);


module.exports = new Schema({
  include: [
    __webpack_require__(16)
  ]
});


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
// Standard YAML's JSON schema.
// http://www.yaml.org/spec/1.2/spec.html#id2803231
//
// NOTE: JS-YAML does not support schema-specific tag resolution restrictions.
// So, this schema is not such strict as defined in the YAML specification.
// It allows numbers in binary notaion, use `Null` and `NULL` as `null`, etc.





var Schema = __webpack_require__(8);


module.exports = new Schema({
  include: [
    __webpack_require__(13)
  ],
  implicit: [
    __webpack_require__(24),
    __webpack_require__(25),
    __webpack_require__(26),
    __webpack_require__(27)
  ]
});


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

/*!
Copyright (c) 2014 Taylor Hakes
Copyright (c) 2014 Forbes Lindesay
 */
(function (global, factory) {
	 true ? factory() :
		undefined;
}(this, (function () {
	'use strict';

	/**
	 * @this {Promise}
	 */
	function finallyConstructor(callback) {
		var constructor = this.constructor;
		return this.then(
			function (value) {
				return constructor.resolve(callback()).then(function () {
					return value;
				});
			},
			function (reason) {
				return constructor.resolve(callback()).then(function () {
					return constructor.reject(reason);
				});
			}
		);
	}

	// Store setTimeout reference so promise-polyfill will be unaffected by
	// other code modifying setTimeout (like sinon.useFakeTimers())
	var setTimeoutFunc = setTimeout;

	function noop() { }

	// Polyfill for Function.prototype.bind
	function bind(fn, thisArg) {
		return function () {
			fn.apply(thisArg, arguments);
		};
	}

	/**
	 * @constructor
	 * @param {Function} fn
	 */
	function Promise(fn) {
		if (!(this instanceof Promise))
			throw new TypeError('Promises must be constructed via new');
		if (typeof fn !== 'function') throw new TypeError('not a function');
		/** @type {!number} */
		this._state = 0;
		/** @type {!boolean} */
		this._handled = false;
		/** @type {Promise|undefined} */
		this._value = undefined;
		/** @type {!Array<!Function>} */
		this._deferreds = [];

		doResolve(fn, this);
	}

	function handle(self, deferred) {
		while (self._state === 3) {
			self = self._value;
		}
		if (self._state === 0) {
			self._deferreds.push(deferred);
			return;
		}
		self._handled = true;
		Promise._immediateFn(function () {
			var cb = self._state === 1 ? deferred.onFulfilled : deferred.onRejected;
			if (cb === null) {
				(self._state === 1 ? resolve : reject)(deferred.promise, self._value);
				return;
			}
			var ret;
			try {
				ret = cb(self._value);
			} catch (e) {
				reject(deferred.promise, e);
				return;
			}
			resolve(deferred.promise, ret);
		});
	}

	function resolve(self, newValue) {
		try {
			// Promise Resolution Procedure: https://github.com/promises-aplus/promises-spec#the-promise-resolution-procedure
			if (newValue === self)
				throw new TypeError('A promise cannot be resolved with itself.');
			if (
				newValue &&
				(typeof newValue === 'object' || typeof newValue === 'function')
			) {
				var then = newValue.then;
				if (newValue instanceof Promise) {
					self._state = 3;
					self._value = newValue;
					finale(self);
					return;
				} else if (typeof then === 'function') {
					doResolve(bind(then, newValue), self);
					return;
				}
			}
			self._state = 1;
			self._value = newValue;
			finale(self);
		} catch (e) {
			reject(self, e);
		}
	}

	function reject(self, newValue) {
		self._state = 2;
		self._value = newValue;
		finale(self);
	}

	function finale(self) {
		if (self._state === 2 && self._deferreds.length === 0) {
			Promise._immediateFn(function () {
				if (!self._handled) {
					Promise._unhandledRejectionFn(self._value);
				}
			});
		}

		for (var i = 0, len = self._deferreds.length; i < len; i++) {
			handle(self, self._deferreds[i]);
		}
		self._deferreds = null;
	}

	/**
	 * @constructor
	 */
	function Handler(onFulfilled, onRejected, promise) {
		this.onFulfilled = typeof onFulfilled === 'function' ? onFulfilled : null;
		this.onRejected = typeof onRejected === 'function' ? onRejected : null;
		this.promise = promise;
	}

	/**
	 * Take a potentially misbehaving resolver function and make sure
	 * onFulfilled and onRejected are only called once.
	 *
	 * Makes no guarantees about asynchrony.
	 */
	function doResolve(fn, self) {
		var done = false;
		try {
			fn(
				function (value) {
					if (done) return;
					done = true;
					resolve(self, value);
				},
				function (reason) {
					if (done) return;
					done = true;
					reject(self, reason);
				}
			);
		} catch (ex) {
			if (done) return;
			done = true;
			reject(self, ex);
		}
	}

	Promise.prototype['catch'] = function (onRejected) {
		return this.then(null, onRejected);
	};

	Promise.prototype.then = function (onFulfilled, onRejected) {
		// @ts-ignore
		var prom = new this.constructor(noop);

		handle(this, new Handler(onFulfilled, onRejected, prom));
		return prom;
	};

	Promise.prototype['finally'] = finallyConstructor;

	Promise.all = function (arr) {
		return new Promise(function (resolve, reject) {
			if (!arr || typeof arr.length === 'undefined')
				throw new TypeError('Promise.all accepts an array');
			var args = Array.prototype.slice.call(arr);
			if (args.length === 0) return resolve([]);
			var remaining = args.length;

			function res(i, val) {
				try {
					if (val && (typeof val === 'object' || typeof val === 'function')) {
						var then = val.then;
						if (typeof then === 'function') {
							then.call(
								val,
								function (val) {
									res(i, val);
								},
								reject
							);
							return;
						}
					}
					args[i] = val;
					if (--remaining === 0) {
						resolve(args);
					}
				} catch (ex) {
					reject(ex);
				}
			}

			for (var i = 0; i < args.length; i++) {
				res(i, args[i]);
			}
		});
	};

	Promise.resolve = function (value) {
		if (value && typeof value === 'object' && value.constructor === Promise) {
			return value;
		}

		return new Promise(function (resolve) {
			resolve(value);
		});
	};

	Promise.reject = function (value) {
		return new Promise(function (resolve, reject) {
			reject(value);
		});
	};

	Promise.race = function (values) {
		return new Promise(function (resolve, reject) {
			for (var i = 0, len = values.length; i < len; i++) {
				values[i].then(resolve, reject);
			}
		});
	};

	// Use polyfill for setImmediate for performance gains
	Promise._immediateFn =
		(typeof setImmediate === 'function' &&
			function (fn) {
				setImmediate(fn);
			}) ||
		function (fn) {
			setTimeoutFunc(fn, 0);
		};

	Promise._unhandledRejectionFn = function _unhandledRejectionFn(err) {
		if (typeof console !== 'undefined' && console) {
			console.warn('Possible Unhandled Promise Rejection:', err); // eslint-disable-line no-console
		}
	};

	/** @suppress {undefinedVars} */
	var globalNS = (function () {
		// the only reliable means to get the global object is
		// `Function('return this')()`
		// However, this causes CSP violations in Chrome apps.
		if (typeof self !== 'undefined') {
			return self;
		}
		if (typeof window !== 'undefined') {
			return window;
		}
		if (typeof global !== 'undefined') {
			return global;
		}
		throw new Error('unable to locate global object');
	})();

	if (!('Promise' in globalNS)) {
		globalNS['Promise'] = Promise;
	} else if (!globalNS.Promise.prototype['finally']) {
		globalNS.Promise.prototype['finally'] = finallyConstructor;
	}

})));


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var loader = __webpack_require__(19);
var dumper = __webpack_require__(42);


function deprecated(name) {
  return function () {
    throw new Error('Function ' + name + ' is deprecated and cannot be used.');
  };
}


module.exports.Type                = __webpack_require__(3);
module.exports.Schema              = __webpack_require__(8);
module.exports.FAILSAFE_SCHEMA     = __webpack_require__(13);
module.exports.JSON_SCHEMA         = __webpack_require__(16);
module.exports.CORE_SCHEMA         = __webpack_require__(15);
module.exports.DEFAULT_SAFE_SCHEMA = __webpack_require__(11);
module.exports.DEFAULT_FULL_SCHEMA = __webpack_require__(12);
module.exports.load                = loader.load;
module.exports.loadAll             = loader.loadAll;
module.exports.safeLoad            = loader.safeLoad;
module.exports.safeLoadAll         = loader.safeLoadAll;
module.exports.dump                = dumper.dump;
module.exports.safeDump            = dumper.safeDump;
module.exports.YAMLException       = __webpack_require__(10);

// Deprecated schema names from JS-YAML 2.0.x
module.exports.MINIMAL_SCHEMA = __webpack_require__(13);
module.exports.SAFE_SCHEMA    = __webpack_require__(11);
module.exports.DEFAULT_SCHEMA = __webpack_require__(12);

// Deprecated functions from JS-YAML 1.x.x
module.exports.scan           = deprecated('scan');
module.exports.parse          = deprecated('parse');
module.exports.compose        = deprecated('compose');
module.exports.addConstructor = deprecated('addConstructor');


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*eslint-disable max-len,no-use-before-define*/

var common              = __webpack_require__(7);
var YAMLException       = __webpack_require__(10);
var Mark                = __webpack_require__(20);
var DEFAULT_SAFE_SCHEMA = __webpack_require__(11);
var DEFAULT_FULL_SCHEMA = __webpack_require__(12);


var _hasOwnProperty = Object.prototype.hasOwnProperty;


var CONTEXT_FLOW_IN   = 1;
var CONTEXT_FLOW_OUT  = 2;
var CONTEXT_BLOCK_IN  = 3;
var CONTEXT_BLOCK_OUT = 4;


var CHOMPING_CLIP  = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP  = 3;


var PATTERN_NON_PRINTABLE         = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS       = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI               = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;


function _class(obj) { return Object.prototype.toString.call(obj); }

function is_EOL(c) {
  return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);
}

function is_WHITE_SPACE(c) {
  return (c === 0x09/* Tab */) || (c === 0x20/* Space */);
}

function is_WS_OR_EOL(c) {
  return (c === 0x09/* Tab */) ||
         (c === 0x20/* Space */) ||
         (c === 0x0A/* LF */) ||
         (c === 0x0D/* CR */);
}

function is_FLOW_INDICATOR(c) {
  return c === 0x2C/* , */ ||
         c === 0x5B/* [ */ ||
         c === 0x5D/* ] */ ||
         c === 0x7B/* { */ ||
         c === 0x7D/* } */;
}

function fromHexCode(c) {
  var lc;

  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  /*eslint-disable no-bitwise*/
  lc = c | 0x20;

  if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {
    return lc - 0x61 + 10;
  }

  return -1;
}

function escapedHexLen(c) {
  if (c === 0x78/* x */) { return 2; }
  if (c === 0x75/* u */) { return 4; }
  if (c === 0x55/* U */) { return 8; }
  return 0;
}

function fromDecimalCode(c) {
  if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {
    return c - 0x30;
  }

  return -1;
}

function simpleEscapeSequence(c) {
  /* eslint-disable indent */
  return (c === 0x30/* 0 */) ? '\x00' :
        (c === 0x61/* a */) ? '\x07' :
        (c === 0x62/* b */) ? '\x08' :
        (c === 0x74/* t */) ? '\x09' :
        (c === 0x09/* Tab */) ? '\x09' :
        (c === 0x6E/* n */) ? '\x0A' :
        (c === 0x76/* v */) ? '\x0B' :
        (c === 0x66/* f */) ? '\x0C' :
        (c === 0x72/* r */) ? '\x0D' :
        (c === 0x65/* e */) ? '\x1B' :
        (c === 0x20/* Space */) ? ' ' :
        (c === 0x22/* " */) ? '\x22' :
        (c === 0x2F/* / */) ? '/' :
        (c === 0x5C/* \ */) ? '\x5C' :
        (c === 0x4E/* N */) ? '\x85' :
        (c === 0x5F/* _ */) ? '\xA0' :
        (c === 0x4C/* L */) ? '\u2028' :
        (c === 0x50/* P */) ? '\u2029' : '';
}

function charFromCodepoint(c) {
  if (c <= 0xFFFF) {
    return String.fromCharCode(c);
  }
  // Encode UTF-16 surrogate pair
  // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
  return String.fromCharCode(
    ((c - 0x010000) >> 10) + 0xD800,
    ((c - 0x010000) & 0x03FF) + 0xDC00
  );
}

var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
for (var i = 0; i < 256; i++) {
  simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
  simpleEscapeMap[i] = simpleEscapeSequence(i);
}


function State(input, options) {
  this.input = input;

  this.filename  = options['filename']  || null;
  this.schema    = options['schema']    || DEFAULT_FULL_SCHEMA;
  this.onWarning = options['onWarning'] || null;
  this.legacy    = options['legacy']    || false;
  this.json      = options['json']      || false;
  this.listener  = options['listener']  || null;

  this.implicitTypes = this.schema.compiledImplicit;
  this.typeMap       = this.schema.compiledTypeMap;

  this.length     = input.length;
  this.position   = 0;
  this.line       = 0;
  this.lineStart  = 0;
  this.lineIndent = 0;

  this.documents = [];

  /*
  this.version;
  this.checkLineBreaks;
  this.tagMap;
  this.anchorMap;
  this.tag;
  this.anchor;
  this.kind;
  this.result;*/

}


function generateError(state, message) {
  return new YAMLException(
    message,
    new Mark(state.filename, state.input, state.position, state.line, (state.position - state.lineStart)));
}

function throwError(state, message) {
  throw generateError(state, message);
}

function throwWarning(state, message) {
  if (state.onWarning) {
    state.onWarning.call(null, generateError(state, message));
  }
}


var directiveHandlers = {

  YAML: function handleYamlDirective(state, name, args) {

    var match, major, minor;

    if (state.version !== null) {
      throwError(state, 'duplication of %YAML directive');
    }

    if (args.length !== 1) {
      throwError(state, 'YAML directive accepts exactly one argument');
    }

    match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

    if (match === null) {
      throwError(state, 'ill-formed argument of the YAML directive');
    }

    major = parseInt(match[1], 10);
    minor = parseInt(match[2], 10);

    if (major !== 1) {
      throwError(state, 'unacceptable YAML version of the document');
    }

    state.version = args[0];
    state.checkLineBreaks = (minor < 2);

    if (minor !== 1 && minor !== 2) {
      throwWarning(state, 'unsupported YAML version of the document');
    }
  },

  TAG: function handleTagDirective(state, name, args) {

    var handle, prefix;

    if (args.length !== 2) {
      throwError(state, 'TAG directive accepts exactly two arguments');
    }

    handle = args[0];
    prefix = args[1];

    if (!PATTERN_TAG_HANDLE.test(handle)) {
      throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
    }

    if (_hasOwnProperty.call(state.tagMap, handle)) {
      throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
    }

    if (!PATTERN_TAG_URI.test(prefix)) {
      throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
    }

    state.tagMap[handle] = prefix;
  }
};


function captureSegment(state, start, end, checkJson) {
  var _position, _length, _character, _result;

  if (start < end) {
    _result = state.input.slice(start, end);

    if (checkJson) {
      for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
        _character = _result.charCodeAt(_position);
        if (!(_character === 0x09 ||
              (0x20 <= _character && _character <= 0x10FFFF))) {
          throwError(state, 'expected valid JSON character');
        }
      }
    } else if (PATTERN_NON_PRINTABLE.test(_result)) {
      throwError(state, 'the stream contains non-printable characters');
    }

    state.result += _result;
  }
}

function mergeMappings(state, destination, source, overridableKeys) {
  var sourceKeys, key, index, quantity;

  if (!common.isObject(source)) {
    throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
  }

  sourceKeys = Object.keys(source);

  for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
    key = sourceKeys[index];

    if (!_hasOwnProperty.call(destination, key)) {
      destination[key] = source[key];
      overridableKeys[key] = true;
    }
  }
}

function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
  var index, quantity;

  // The output is a plain object here, so keys can only be strings.
  // We need to convert keyNode to a string, but doing so can hang the process
  // (deeply nested arrays that explode exponentially using aliases).
  if (Array.isArray(keyNode)) {
    keyNode = Array.prototype.slice.call(keyNode);

    for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
      if (Array.isArray(keyNode[index])) {
        throwError(state, 'nested arrays are not supported inside keys');
      }

      if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
        keyNode[index] = '[object Object]';
      }
    }
  }

  // Avoid code execution in load() via toString property
  // (still use its own toString for arrays, timestamps,
  // and whatever user schema extensions happen to have @@toStringTag)
  if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
    keyNode = '[object Object]';
  }


  keyNode = String(keyNode);

  if (_result === null) {
    _result = {};
  }

  if (keyTag === 'tag:yaml.org,2002:merge') {
    if (Array.isArray(valueNode)) {
      for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
        mergeMappings(state, _result, valueNode[index], overridableKeys);
      }
    } else {
      mergeMappings(state, _result, valueNode, overridableKeys);
    }
  } else {
    if (!state.json &&
        !_hasOwnProperty.call(overridableKeys, keyNode) &&
        _hasOwnProperty.call(_result, keyNode)) {
      state.line = startLine || state.line;
      state.position = startPos || state.position;
      throwError(state, 'duplicated mapping key');
    }
    _result[keyNode] = valueNode;
    delete overridableKeys[keyNode];
  }

  return _result;
}

function readLineBreak(state) {
  var ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x0A/* LF */) {
    state.position++;
  } else if (ch === 0x0D/* CR */) {
    state.position++;
    if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {
      state.position++;
    }
  } else {
    throwError(state, 'a line break is expected');
  }

  state.line += 1;
  state.lineStart = state.position;
}

function skipSeparationSpace(state, allowComments, checkIndent) {
  var lineBreaks = 0,
      ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    while (is_WHITE_SPACE(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (allowComments && ch === 0x23/* # */) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);
    }

    if (is_EOL(ch)) {
      readLineBreak(state);

      ch = state.input.charCodeAt(state.position);
      lineBreaks++;
      state.lineIndent = 0;

      while (ch === 0x20/* Space */) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }
    } else {
      break;
    }
  }

  if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
    throwWarning(state, 'deficient indentation');
  }

  return lineBreaks;
}

function testDocumentSeparator(state) {
  var _position = state.position,
      ch;

  ch = state.input.charCodeAt(_position);

  // Condition state.position === state.lineStart is tested
  // in parent on each call, for efficiency. No needs to test here again.
  if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&
      ch === state.input.charCodeAt(_position + 1) &&
      ch === state.input.charCodeAt(_position + 2)) {

    _position += 3;

    ch = state.input.charCodeAt(_position);

    if (ch === 0 || is_WS_OR_EOL(ch)) {
      return true;
    }
  }

  return false;
}

function writeFoldedLines(state, count) {
  if (count === 1) {
    state.result += ' ';
  } else if (count > 1) {
    state.result += common.repeat('\n', count - 1);
  }
}


function readPlainScalar(state, nodeIndent, withinFlowCollection) {
  var preceding,
      following,
      captureStart,
      captureEnd,
      hasPendingContent,
      _line,
      _lineStart,
      _lineIndent,
      _kind = state.kind,
      _result = state.result,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (is_WS_OR_EOL(ch)      ||
      is_FLOW_INDICATOR(ch) ||
      ch === 0x23/* # */    ||
      ch === 0x26/* & */    ||
      ch === 0x2A/* * */    ||
      ch === 0x21/* ! */    ||
      ch === 0x7C/* | */    ||
      ch === 0x3E/* > */    ||
      ch === 0x27/* ' */    ||
      ch === 0x22/* " */    ||
      ch === 0x25/* % */    ||
      ch === 0x40/* @ */    ||
      ch === 0x60/* ` */) {
    return false;
  }

  if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {
    following = state.input.charCodeAt(state.position + 1);

    if (is_WS_OR_EOL(following) ||
        withinFlowCollection && is_FLOW_INDICATOR(following)) {
      return false;
    }
  }

  state.kind = 'scalar';
  state.result = '';
  captureStart = captureEnd = state.position;
  hasPendingContent = false;

  while (ch !== 0) {
    if (ch === 0x3A/* : */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following) ||
          withinFlowCollection && is_FLOW_INDICATOR(following)) {
        break;
      }

    } else if (ch === 0x23/* # */) {
      preceding = state.input.charCodeAt(state.position - 1);

      if (is_WS_OR_EOL(preceding)) {
        break;
      }

    } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
               withinFlowCollection && is_FLOW_INDICATOR(ch)) {
      break;

    } else if (is_EOL(ch)) {
      _line = state.line;
      _lineStart = state.lineStart;
      _lineIndent = state.lineIndent;
      skipSeparationSpace(state, false, -1);

      if (state.lineIndent >= nodeIndent) {
        hasPendingContent = true;
        ch = state.input.charCodeAt(state.position);
        continue;
      } else {
        state.position = captureEnd;
        state.line = _line;
        state.lineStart = _lineStart;
        state.lineIndent = _lineIndent;
        break;
      }
    }

    if (hasPendingContent) {
      captureSegment(state, captureStart, captureEnd, false);
      writeFoldedLines(state, state.line - _line);
      captureStart = captureEnd = state.position;
      hasPendingContent = false;
    }

    if (!is_WHITE_SPACE(ch)) {
      captureEnd = state.position + 1;
    }

    ch = state.input.charCodeAt(++state.position);
  }

  captureSegment(state, captureStart, captureEnd, false);

  if (state.result) {
    return true;
  }

  state.kind = _kind;
  state.result = _result;
  return false;
}

function readSingleQuotedScalar(state, nodeIndent) {
  var ch,
      captureStart, captureEnd;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x27/* ' */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x27/* ' */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x27/* ' */) {
        captureStart = state.position;
        state.position++;
        captureEnd = state.position;
      } else {
        return true;
      }

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a single quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a single quoted scalar');
}

function readDoubleQuotedScalar(state, nodeIndent) {
  var captureStart,
      captureEnd,
      hexLength,
      hexResult,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x22/* " */) {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';
  state.position++;
  captureStart = captureEnd = state.position;

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    if (ch === 0x22/* " */) {
      captureSegment(state, captureStart, state.position, true);
      state.position++;
      return true;

    } else if (ch === 0x5C/* \ */) {
      captureSegment(state, captureStart, state.position, true);
      ch = state.input.charCodeAt(++state.position);

      if (is_EOL(ch)) {
        skipSeparationSpace(state, false, nodeIndent);

        // TODO: rework to inline fn with no type cast?
      } else if (ch < 256 && simpleEscapeCheck[ch]) {
        state.result += simpleEscapeMap[ch];
        state.position++;

      } else if ((tmp = escapedHexLen(ch)) > 0) {
        hexLength = tmp;
        hexResult = 0;

        for (; hexLength > 0; hexLength--) {
          ch = state.input.charCodeAt(++state.position);

          if ((tmp = fromHexCode(ch)) >= 0) {
            hexResult = (hexResult << 4) + tmp;

          } else {
            throwError(state, 'expected hexadecimal character');
          }
        }

        state.result += charFromCodepoint(hexResult);

        state.position++;

      } else {
        throwError(state, 'unknown escape sequence');
      }

      captureStart = captureEnd = state.position;

    } else if (is_EOL(ch)) {
      captureSegment(state, captureStart, captureEnd, true);
      writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
      captureStart = captureEnd = state.position;

    } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
      throwError(state, 'unexpected end of the document within a double quoted scalar');

    } else {
      state.position++;
      captureEnd = state.position;
    }
  }

  throwError(state, 'unexpected end of the stream within a double quoted scalar');
}

function readFlowCollection(state, nodeIndent) {
  var readNext = true,
      _line,
      _tag     = state.tag,
      _result,
      _anchor  = state.anchor,
      following,
      terminator,
      isPair,
      isExplicitPair,
      isMapping,
      overridableKeys = {},
      keyNode,
      keyTag,
      valueNode,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x5B/* [ */) {
    terminator = 0x5D;/* ] */
    isMapping = false;
    _result = [];
  } else if (ch === 0x7B/* { */) {
    terminator = 0x7D;/* } */
    isMapping = true;
    _result = {};
  } else {
    return false;
  }

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(++state.position);

  while (ch !== 0) {
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === terminator) {
      state.position++;
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = isMapping ? 'mapping' : 'sequence';
      state.result = _result;
      return true;
    } else if (!readNext) {
      throwError(state, 'missed comma between flow collection entries');
    }

    keyTag = keyNode = valueNode = null;
    isPair = isExplicitPair = false;

    if (ch === 0x3F/* ? */) {
      following = state.input.charCodeAt(state.position + 1);

      if (is_WS_OR_EOL(following)) {
        isPair = isExplicitPair = true;
        state.position++;
        skipSeparationSpace(state, true, nodeIndent);
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
    keyTag = state.tag;
    keyNode = state.result;
    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {
      isPair = true;
      ch = state.input.charCodeAt(++state.position);
      skipSeparationSpace(state, true, nodeIndent);
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      valueNode = state.result;
    }

    if (isMapping) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
    } else if (isPair) {
      _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
    } else {
      _result.push(keyNode);
    }

    skipSeparationSpace(state, true, nodeIndent);

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x2C/* , */) {
      readNext = true;
      ch = state.input.charCodeAt(++state.position);
    } else {
      readNext = false;
    }
  }

  throwError(state, 'unexpected end of the stream within a flow collection');
}

function readBlockScalar(state, nodeIndent) {
  var captureStart,
      folding,
      chomping       = CHOMPING_CLIP,
      didReadContent = false,
      detectedIndent = false,
      textIndent     = nodeIndent,
      emptyLines     = 0,
      atMoreIndented = false,
      tmp,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch === 0x7C/* | */) {
    folding = false;
  } else if (ch === 0x3E/* > */) {
    folding = true;
  } else {
    return false;
  }

  state.kind = 'scalar';
  state.result = '';

  while (ch !== 0) {
    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {
      if (CHOMPING_CLIP === chomping) {
        chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;
      } else {
        throwError(state, 'repeat of a chomping mode identifier');
      }

    } else if ((tmp = fromDecimalCode(ch)) >= 0) {
      if (tmp === 0) {
        throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
      } else if (!detectedIndent) {
        textIndent = nodeIndent + tmp - 1;
        detectedIndent = true;
      } else {
        throwError(state, 'repeat of an indentation width identifier');
      }

    } else {
      break;
    }
  }

  if (is_WHITE_SPACE(ch)) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (is_WHITE_SPACE(ch));

    if (ch === 0x23/* # */) {
      do { ch = state.input.charCodeAt(++state.position); }
      while (!is_EOL(ch) && (ch !== 0));
    }
  }

  while (ch !== 0) {
    readLineBreak(state);
    state.lineIndent = 0;

    ch = state.input.charCodeAt(state.position);

    while ((!detectedIndent || state.lineIndent < textIndent) &&
           (ch === 0x20/* Space */)) {
      state.lineIndent++;
      ch = state.input.charCodeAt(++state.position);
    }

    if (!detectedIndent && state.lineIndent > textIndent) {
      textIndent = state.lineIndent;
    }

    if (is_EOL(ch)) {
      emptyLines++;
      continue;
    }

    // End of the scalar.
    if (state.lineIndent < textIndent) {

      // Perform the chomping.
      if (chomping === CHOMPING_KEEP) {
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      } else if (chomping === CHOMPING_CLIP) {
        if (didReadContent) { // i.e. only if the scalar is not empty.
          state.result += '\n';
        }
      }

      // Break this `while` cycle and go to the funciton's epilogue.
      break;
    }

    // Folded style: use fancy rules to handle line breaks.
    if (folding) {

      // Lines starting with white space characters (more-indented lines) are not folded.
      if (is_WHITE_SPACE(ch)) {
        atMoreIndented = true;
        // except for the first content line (cf. Example 8.1)
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);

      // End of more-indented block.
      } else if (atMoreIndented) {
        atMoreIndented = false;
        state.result += common.repeat('\n', emptyLines + 1);

      // Just one line break - perceive as the same line.
      } else if (emptyLines === 0) {
        if (didReadContent) { // i.e. only if we have already read some scalar content.
          state.result += ' ';
        }

      // Several line breaks - perceive as different lines.
      } else {
        state.result += common.repeat('\n', emptyLines);
      }

    // Literal style: just add exact number of line breaks between content lines.
    } else {
      // Keep all line breaks except the header line break.
      state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
    }

    didReadContent = true;
    detectedIndent = true;
    emptyLines = 0;
    captureStart = state.position;

    while (!is_EOL(ch) && (ch !== 0)) {
      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, state.position, false);
  }

  return true;
}

function readBlockSequence(state, nodeIndent) {
  var _line,
      _tag      = state.tag,
      _anchor   = state.anchor,
      _result   = [],
      following,
      detected  = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {

    if (ch !== 0x2D/* - */) {
      break;
    }

    following = state.input.charCodeAt(state.position + 1);

    if (!is_WS_OR_EOL(following)) {
      break;
    }

    detected = true;
    state.position++;

    if (skipSeparationSpace(state, true, -1)) {
      if (state.lineIndent <= nodeIndent) {
        _result.push(null);
        ch = state.input.charCodeAt(state.position);
        continue;
      }
    }

    _line = state.line;
    composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
    _result.push(state.result);
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {
      throwError(state, 'bad indentation of a sequence entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'sequence';
    state.result = _result;
    return true;
  }
  return false;
}

function readBlockMapping(state, nodeIndent, flowIndent) {
  var following,
      allowCompact,
      _line,
      _pos,
      _tag          = state.tag,
      _anchor       = state.anchor,
      _result       = {},
      overridableKeys = {},
      keyTag        = null,
      keyNode       = null,
      valueNode     = null,
      atExplicitKey = false,
      detected      = false,
      ch;

  if (state.anchor !== null) {
    state.anchorMap[state.anchor] = _result;
  }

  ch = state.input.charCodeAt(state.position);

  while (ch !== 0) {
    following = state.input.charCodeAt(state.position + 1);
    _line = state.line; // Save the current line.
    _pos = state.position;

    //
    // Explicit notation case. There are two separate blocks:
    // first for the key (denoted by "?") and second for the value (denoted by ":")
    //
    if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {

      if (ch === 0x3F/* ? */) {
        if (atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
          keyTag = keyNode = valueNode = null;
        }

        detected = true;
        atExplicitKey = true;
        allowCompact = true;

      } else if (atExplicitKey) {
        // i.e. 0x3A/* : */ === character after the explicit key.
        atExplicitKey = false;
        allowCompact = true;

      } else {
        throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
      }

      state.position += 1;
      ch = following;

    //
    // Implicit notation case. Flow-style node as the key first, then ":", and the value.
    //
    } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {

      if (state.line === _line) {
        ch = state.input.charCodeAt(state.position);

        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x3A/* : */) {
          ch = state.input.charCodeAt(++state.position);

          if (!is_WS_OR_EOL(ch)) {
            throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
          }

          if (atExplicitKey) {
            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
            keyTag = keyNode = valueNode = null;
          }

          detected = true;
          atExplicitKey = false;
          allowCompact = false;
          keyTag = state.tag;
          keyNode = state.result;

        } else if (detected) {
          throwError(state, 'can not read an implicit mapping pair; a colon is missed');

        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }

      } else if (detected) {
        throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');

      } else {
        state.tag = _tag;
        state.anchor = _anchor;
        return true; // Keep the result of `composeNode`.
      }

    } else {
      break; // Reading is done. Go to the epilogue.
    }

    //
    // Common reading code for both explicit and implicit notations.
    //
    if (state.line === _line || state.lineIndent > nodeIndent) {
      if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
        if (atExplicitKey) {
          keyNode = state.result;
        } else {
          valueNode = state.result;
        }
      }

      if (!atExplicitKey) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
        keyTag = keyNode = valueNode = null;
      }

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);
    }

    if (state.lineIndent > nodeIndent && (ch !== 0)) {
      throwError(state, 'bad indentation of a mapping entry');
    } else if (state.lineIndent < nodeIndent) {
      break;
    }
  }

  //
  // Epilogue.
  //

  // Special case: last mapping's node contains only the key in explicit notation.
  if (atExplicitKey) {
    storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
  }

  // Expose the resulting mapping.
  if (detected) {
    state.tag = _tag;
    state.anchor = _anchor;
    state.kind = 'mapping';
    state.result = _result;
  }

  return detected;
}

function readTagProperty(state) {
  var _position,
      isVerbatim = false,
      isNamed    = false,
      tagHandle,
      tagName,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x21/* ! */) return false;

  if (state.tag !== null) {
    throwError(state, 'duplication of a tag property');
  }

  ch = state.input.charCodeAt(++state.position);

  if (ch === 0x3C/* < */) {
    isVerbatim = true;
    ch = state.input.charCodeAt(++state.position);

  } else if (ch === 0x21/* ! */) {
    isNamed = true;
    tagHandle = '!!';
    ch = state.input.charCodeAt(++state.position);

  } else {
    tagHandle = '!';
  }

  _position = state.position;

  if (isVerbatim) {
    do { ch = state.input.charCodeAt(++state.position); }
    while (ch !== 0 && ch !== 0x3E/* > */);

    if (state.position < state.length) {
      tagName = state.input.slice(_position, state.position);
      ch = state.input.charCodeAt(++state.position);
    } else {
      throwError(state, 'unexpected end of the stream within a verbatim tag');
    }
  } else {
    while (ch !== 0 && !is_WS_OR_EOL(ch)) {

      if (ch === 0x21/* ! */) {
        if (!isNamed) {
          tagHandle = state.input.slice(_position - 1, state.position + 1);

          if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
            throwError(state, 'named tag handle cannot contain such characters');
          }

          isNamed = true;
          _position = state.position + 1;
        } else {
          throwError(state, 'tag suffix cannot contain exclamation marks');
        }
      }

      ch = state.input.charCodeAt(++state.position);
    }

    tagName = state.input.slice(_position, state.position);

    if (PATTERN_FLOW_INDICATORS.test(tagName)) {
      throwError(state, 'tag suffix cannot contain flow indicator characters');
    }
  }

  if (tagName && !PATTERN_TAG_URI.test(tagName)) {
    throwError(state, 'tag name cannot contain such characters: ' + tagName);
  }

  if (isVerbatim) {
    state.tag = tagName;

  } else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
    state.tag = state.tagMap[tagHandle] + tagName;

  } else if (tagHandle === '!') {
    state.tag = '!' + tagName;

  } else if (tagHandle === '!!') {
    state.tag = 'tag:yaml.org,2002:' + tagName;

  } else {
    throwError(state, 'undeclared tag handle "' + tagHandle + '"');
  }

  return true;
}

function readAnchorProperty(state) {
  var _position,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x26/* & */) return false;

  if (state.anchor !== null) {
    throwError(state, 'duplication of an anchor property');
  }

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an anchor node must contain at least one character');
  }

  state.anchor = state.input.slice(_position, state.position);
  return true;
}

function readAlias(state) {
  var _position, alias,
      ch;

  ch = state.input.charCodeAt(state.position);

  if (ch !== 0x2A/* * */) return false;

  ch = state.input.charCodeAt(++state.position);
  _position = state.position;

  while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
    ch = state.input.charCodeAt(++state.position);
  }

  if (state.position === _position) {
    throwError(state, 'name of an alias node must contain at least one character');
  }

  alias = state.input.slice(_position, state.position);

  if (!state.anchorMap.hasOwnProperty(alias)) {
    throwError(state, 'unidentified alias "' + alias + '"');
  }

  state.result = state.anchorMap[alias];
  skipSeparationSpace(state, true, -1);
  return true;
}

function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
  var allowBlockStyles,
      allowBlockScalars,
      allowBlockCollections,
      indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
      atNewLine  = false,
      hasContent = false,
      typeIndex,
      typeQuantity,
      type,
      flowIndent,
      blockIndent;

  if (state.listener !== null) {
    state.listener('open', state);
  }

  state.tag    = null;
  state.anchor = null;
  state.kind   = null;
  state.result = null;

  allowBlockStyles = allowBlockScalars = allowBlockCollections =
    CONTEXT_BLOCK_OUT === nodeContext ||
    CONTEXT_BLOCK_IN  === nodeContext;

  if (allowToSeek) {
    if (skipSeparationSpace(state, true, -1)) {
      atNewLine = true;

      if (state.lineIndent > parentIndent) {
        indentStatus = 1;
      } else if (state.lineIndent === parentIndent) {
        indentStatus = 0;
      } else if (state.lineIndent < parentIndent) {
        indentStatus = -1;
      }
    }
  }

  if (indentStatus === 1) {
    while (readTagProperty(state) || readAnchorProperty(state)) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;
        allowBlockCollections = allowBlockStyles;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      } else {
        allowBlockCollections = false;
      }
    }
  }

  if (allowBlockCollections) {
    allowBlockCollections = atNewLine || allowCompact;
  }

  if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
    if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
      flowIndent = parentIndent;
    } else {
      flowIndent = parentIndent + 1;
    }

    blockIndent = state.position - state.lineStart;

    if (indentStatus === 1) {
      if (allowBlockCollections &&
          (readBlockSequence(state, blockIndent) ||
           readBlockMapping(state, blockIndent, flowIndent)) ||
          readFlowCollection(state, flowIndent)) {
        hasContent = true;
      } else {
        if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
            readSingleQuotedScalar(state, flowIndent) ||
            readDoubleQuotedScalar(state, flowIndent)) {
          hasContent = true;

        } else if (readAlias(state)) {
          hasContent = true;

          if (state.tag !== null || state.anchor !== null) {
            throwError(state, 'alias node should not have any properties');
          }

        } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
          hasContent = true;

          if (state.tag === null) {
            state.tag = '?';
          }
        }

        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else if (indentStatus === 0) {
      // Special case: block sequences are allowed to have same indentation level as the parent.
      // http://www.yaml.org/spec/1.2/spec.html#id2799784
      hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
    }
  }

  if (state.tag !== null && state.tag !== '!') {
    if (state.tag === '?') {
      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
        type = state.implicitTypes[typeIndex];

        // Implicit resolving is not allowed for non-scalar types, and '?'
        // non-specific tag is only assigned to plain scalars. So, it isn't
        // needed to check for 'kind' conformity.

        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched
          state.result = type.construct(state.result);
          state.tag = type.tag;
          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
          break;
        }
      }
    } else if (_hasOwnProperty.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
      type = state.typeMap[state.kind || 'fallback'][state.tag];

      if (state.result !== null && type.kind !== state.kind) {
        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
      }

      if (!type.resolve(state.result)) { // `state.result` updated in resolver if matched
        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
      } else {
        state.result = type.construct(state.result);
        if (state.anchor !== null) {
          state.anchorMap[state.anchor] = state.result;
        }
      }
    } else {
      throwError(state, 'unknown tag !<' + state.tag + '>');
    }
  }

  if (state.listener !== null) {
    state.listener('close', state);
  }
  return state.tag !== null ||  state.anchor !== null || hasContent;
}

function readDocument(state) {
  var documentStart = state.position,
      _position,
      directiveName,
      directiveArgs,
      hasDirectives = false,
      ch;

  state.version = null;
  state.checkLineBreaks = state.legacy;
  state.tagMap = {};
  state.anchorMap = {};

  while ((ch = state.input.charCodeAt(state.position)) !== 0) {
    skipSeparationSpace(state, true, -1);

    ch = state.input.charCodeAt(state.position);

    if (state.lineIndent > 0 || ch !== 0x25/* % */) {
      break;
    }

    hasDirectives = true;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    directiveName = state.input.slice(_position, state.position);
    directiveArgs = [];

    if (directiveName.length < 1) {
      throwError(state, 'directive name must not be less than one character in length');
    }

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (ch === 0x23/* # */) {
        do { ch = state.input.charCodeAt(++state.position); }
        while (ch !== 0 && !is_EOL(ch));
        break;
      }

      if (is_EOL(ch)) break;

      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveArgs.push(state.input.slice(_position, state.position));
    }

    if (ch !== 0) readLineBreak(state);

    if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
      directiveHandlers[directiveName](state, directiveName, directiveArgs);
    } else {
      throwWarning(state, 'unknown document directive "' + directiveName + '"');
    }
  }

  skipSeparationSpace(state, true, -1);

  if (state.lineIndent === 0 &&
      state.input.charCodeAt(state.position)     === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&
      state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {
    state.position += 3;
    skipSeparationSpace(state, true, -1);

  } else if (hasDirectives) {
    throwError(state, 'directives end mark is expected');
  }

  composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
  skipSeparationSpace(state, true, -1);

  if (state.checkLineBreaks &&
      PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
    throwWarning(state, 'non-ASCII line breaks are interpreted as content');
  }

  state.documents.push(state.result);

  if (state.position === state.lineStart && testDocumentSeparator(state)) {

    if (state.input.charCodeAt(state.position) === 0x2E/* . */) {
      state.position += 3;
      skipSeparationSpace(state, true, -1);
    }
    return;
  }

  if (state.position < (state.length - 1)) {
    throwError(state, 'end of the stream or a document separator is expected');
  } else {
    return;
  }
}


function loadDocuments(input, options) {
  input = String(input);
  options = options || {};

  if (input.length !== 0) {

    // Add tailing `\n` if not exists
    if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&
        input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {
      input += '\n';
    }

    // Strip BOM
    if (input.charCodeAt(0) === 0xFEFF) {
      input = input.slice(1);
    }
  }

  var state = new State(input, options);

  // Use 0 as string terminator. That significantly simplifies bounds check.
  state.input += '\0';

  while (state.input.charCodeAt(state.position) === 0x20/* Space */) {
    state.lineIndent += 1;
    state.position += 1;
  }

  while (state.position < (state.length - 1)) {
    readDocument(state);
  }

  return state.documents;
}


function loadAll(input, iterator, options) {
  var documents = loadDocuments(input, options), index, length;

  if (typeof iterator !== 'function') {
    return documents;
  }

  for (index = 0, length = documents.length; index < length; index += 1) {
    iterator(documents[index]);
  }
}


function load(input, options) {
  var documents = loadDocuments(input, options);

  if (documents.length === 0) {
    /*eslint-disable no-undefined*/
    return undefined;
  } else if (documents.length === 1) {
    return documents[0];
  }
  throw new YAMLException('expected a single document in the stream, but found more');
}


function safeLoadAll(input, output, options) {
  if (typeof output === 'function') {
    loadAll(input, output, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  } else {
    return loadAll(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
  }
}


function safeLoad(input, options) {
  return load(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}


module.exports.loadAll     = loadAll;
module.exports.load        = load;
module.exports.safeLoadAll = safeLoadAll;
module.exports.safeLoad    = safeLoad;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";



var common = __webpack_require__(7);


function Mark(name, buffer, position, line, column) {
  this.name     = name;
  this.buffer   = buffer;
  this.position = position;
  this.line     = line;
  this.column   = column;
}


Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
  var head, start, tail, end, snippet;

  if (!this.buffer) return null;

  indent = indent || 4;
  maxLength = maxLength || 75;

  head = '';
  start = this.position;

  while (start > 0 && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1)) === -1) {
    start -= 1;
    if (this.position - start > (maxLength / 2 - 1)) {
      head = ' ... ';
      start += 5;
      break;
    }
  }

  tail = '';
  end = this.position;

  while (end < this.buffer.length && '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end)) === -1) {
    end += 1;
    if (end - this.position > (maxLength / 2 - 1)) {
      tail = ' ... ';
      end -= 5;
      break;
    }
  }

  snippet = this.buffer.slice(start, end);

  return common.repeat(' ', indent) + head + snippet + tail + '\n' +
         common.repeat(' ', indent + this.position - start + head.length) + '^';
};


Mark.prototype.toString = function toString(compact) {
  var snippet, where = '';

  if (this.name) {
    where += 'in "' + this.name + '" ';
  }

  where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

  if (!compact) {
    snippet = this.getSnippet();

    if (snippet) {
      where += ':\n' + snippet;
    }
  }

  return where;
};


module.exports = Mark;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(3);

module.exports = new Type('tag:yaml.org,2002:str', {
  kind: 'scalar',
  construct: function (data) { return data !== null ? data : ''; }
});


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(3);

module.exports = new Type('tag:yaml.org,2002:seq', {
  kind: 'sequence',
  construct: function (data) { return data !== null ? data : []; }
});


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(3);

module.exports = new Type('tag:yaml.org,2002:map', {
  kind: 'mapping',
  construct: function (data) { return data !== null ? data : {}; }
});


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(3);

function resolveYamlNull(data) {
  if (data === null) return true;

  var max = data.length;

  return (max === 1 && data === '~') ||
         (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));
}

function constructYamlNull() {
  return null;
}

function isNull(object) {
  return object === null;
}

module.exports = new Type('tag:yaml.org,2002:null', {
  kind: 'scalar',
  resolve: resolveYamlNull,
  construct: constructYamlNull,
  predicate: isNull,
  represent: {
    canonical: function () { return '~';    },
    lowercase: function () { return 'null'; },
    uppercase: function () { return 'NULL'; },
    camelcase: function () { return 'Null'; }
  },
  defaultStyle: 'lowercase'
});


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(3);

function resolveYamlBoolean(data) {
  if (data === null) return false;

  var max = data.length;

  return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||
         (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));
}

function constructYamlBoolean(data) {
  return data === 'true' ||
         data === 'True' ||
         data === 'TRUE';
}

function isBoolean(object) {
  return Object.prototype.toString.call(object) === '[object Boolean]';
}

module.exports = new Type('tag:yaml.org,2002:bool', {
  kind: 'scalar',
  resolve: resolveYamlBoolean,
  construct: constructYamlBoolean,
  predicate: isBoolean,
  represent: {
    lowercase: function (object) { return object ? 'true' : 'false'; },
    uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },
    camelcase: function (object) { return object ? 'True' : 'False'; }
  },
  defaultStyle: 'lowercase'
});


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var common = __webpack_require__(7);
var Type   = __webpack_require__(3);

function isHexCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||
         ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||
         ((0x61/* a */ <= c) && (c <= 0x66/* f */));
}

function isOctCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));
}

function isDecCode(c) {
  return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));
}

function resolveYamlInteger(data) {
  if (data === null) return false;

  var max = data.length,
      index = 0,
      hasDigits = false,
      ch;

  if (!max) return false;

  ch = data[index];

  // sign
  if (ch === '-' || ch === '+') {
    ch = data[++index];
  }

  if (ch === '0') {
    // 0
    if (index + 1 === max) return true;
    ch = data[++index];

    // base 2, base 8, base 16

    if (ch === 'b') {
      // base 2
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (ch !== '0' && ch !== '1') return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }


    if (ch === 'x') {
      // base 16
      index++;

      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isHexCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }
      return hasDigits && ch !== '_';
    }

    // base 8
    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (!isOctCode(data.charCodeAt(index))) return false;
      hasDigits = true;
    }
    return hasDigits && ch !== '_';
  }

  // base 10 (except 0) or base 60

  // value should not start with `_`;
  if (ch === '_') return false;

  for (; index < max; index++) {
    ch = data[index];
    if (ch === '_') continue;
    if (ch === ':') break;
    if (!isDecCode(data.charCodeAt(index))) {
      return false;
    }
    hasDigits = true;
  }

  // Should have digits and should not end with `_`
  if (!hasDigits || ch === '_') return false;

  // if !base60 - done;
  if (ch !== ':') return true;

  // base60 almost not used, no needs to optimize
  return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
}

function constructYamlInteger(data) {
  var value = data, sign = 1, ch, base, digits = [];

  if (value.indexOf('_') !== -1) {
    value = value.replace(/_/g, '');
  }

  ch = value[0];

  if (ch === '-' || ch === '+') {
    if (ch === '-') sign = -1;
    value = value.slice(1);
    ch = value[0];
  }

  if (value === '0') return 0;

  if (ch === '0') {
    if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
    if (value[1] === 'x') return sign * parseInt(value, 16);
    return sign * parseInt(value, 8);
  }

  if (value.indexOf(':') !== -1) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseInt(v, 10));
    });

    value = 0;
    base = 1;

    digits.forEach(function (d) {
      value += (d * base);
      base *= 60;
    });

    return sign * value;

  }

  return sign * parseInt(value, 10);
}

function isInteger(object) {
  return (Object.prototype.toString.call(object)) === '[object Number]' &&
         (object % 1 === 0 && !common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:int', {
  kind: 'scalar',
  resolve: resolveYamlInteger,
  construct: constructYamlInteger,
  predicate: isInteger,
  represent: {
    binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },
    octal:       function (obj) { return obj >= 0 ? '0'  + obj.toString(8) : '-0'  + obj.toString(8).slice(1); },
    decimal:     function (obj) { return obj.toString(10); },
    /* eslint-disable max-len */
    hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }
  },
  defaultStyle: 'decimal',
  styleAliases: {
    binary:      [ 2,  'bin' ],
    octal:       [ 8,  'oct' ],
    decimal:     [ 10, 'dec' ],
    hexadecimal: [ 16, 'hex' ]
  }
});


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var common = __webpack_require__(7);
var Type   = __webpack_require__(3);

var YAML_FLOAT_PATTERN = new RegExp(
  // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +
  // .2e4, .2
  // special case, seems not from spec
  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +
  // 20:59
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' +
  // .inf
  '|[-+]?\\.(?:inf|Inf|INF)' +
  // .nan
  '|\\.(?:nan|NaN|NAN))$');

function resolveYamlFloat(data) {
  if (data === null) return false;

  if (!YAML_FLOAT_PATTERN.test(data) ||
      // Quick hack to not allow integers end with `_`
      // Probably should update regexp & check speed
      data[data.length - 1] === '_') {
    return false;
  }

  return true;
}

function constructYamlFloat(data) {
  var value, sign, base, digits;

  value  = data.replace(/_/g, '').toLowerCase();
  sign   = value[0] === '-' ? -1 : 1;
  digits = [];

  if ('+-'.indexOf(value[0]) >= 0) {
    value = value.slice(1);
  }

  if (value === '.inf') {
    return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;

  } else if (value === '.nan') {
    return NaN;

  } else if (value.indexOf(':') >= 0) {
    value.split(':').forEach(function (v) {
      digits.unshift(parseFloat(v, 10));
    });

    value = 0.0;
    base = 1;

    digits.forEach(function (d) {
      value += d * base;
      base *= 60;
    });

    return sign * value;

  }
  return sign * parseFloat(value, 10);
}


var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

function representYamlFloat(object, style) {
  var res;

  if (isNaN(object)) {
    switch (style) {
      case 'lowercase': return '.nan';
      case 'uppercase': return '.NAN';
      case 'camelcase': return '.NaN';
    }
  } else if (Number.POSITIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '.inf';
      case 'uppercase': return '.INF';
      case 'camelcase': return '.Inf';
    }
  } else if (Number.NEGATIVE_INFINITY === object) {
    switch (style) {
      case 'lowercase': return '-.inf';
      case 'uppercase': return '-.INF';
      case 'camelcase': return '-.Inf';
    }
  } else if (common.isNegativeZero(object)) {
    return '-0.0';
  }

  res = object.toString(10);

  // JS stringifier can build scientific format without dots: 5e-100,
  // while YAML requres dot: 5.e-100. Fix it with simple hack

  return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
}

function isFloat(object) {
  return (Object.prototype.toString.call(object) === '[object Number]') &&
         (object % 1 !== 0 || common.isNegativeZero(object));
}

module.exports = new Type('tag:yaml.org,2002:float', {
  kind: 'scalar',
  resolve: resolveYamlFloat,
  construct: constructYamlFloat,
  predicate: isFloat,
  represent: representYamlFloat,
  defaultStyle: 'lowercase'
});


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(3);

var YAML_DATE_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9])'                    + // [2] month
  '-([0-9][0-9])$');                   // [3] day

var YAML_TIMESTAMP_REGEXP = new RegExp(
  '^([0-9][0-9][0-9][0-9])'          + // [1] year
  '-([0-9][0-9]?)'                   + // [2] month
  '-([0-9][0-9]?)'                   + // [3] day
  '(?:[Tt]|[ \\t]+)'                 + // ...
  '([0-9][0-9]?)'                    + // [4] hour
  ':([0-9][0-9])'                    + // [5] minute
  ':([0-9][0-9])'                    + // [6] second
  '(?:\\.([0-9]*))?'                 + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$');           // [11] tz_minute

function resolveYamlTimestamp(data) {
  if (data === null) return false;
  if (YAML_DATE_REGEXP.exec(data) !== null) return true;
  if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
  return false;
}

function constructYamlTimestamp(data) {
  var match, year, month, day, hour, minute, second, fraction = 0,
      delta = null, tz_hour, tz_minute, date;

  match = YAML_DATE_REGEXP.exec(data);
  if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);

  if (match === null) throw new Error('Date resolve error');

  // match: [1] year [2] month [3] day

  year = +(match[1]);
  month = +(match[2]) - 1; // JS month starts with 0
  day = +(match[3]);

  if (!match[4]) { // no hour
    return new Date(Date.UTC(year, month, day));
  }

  // match: [4] hour [5] minute [6] second [7] fraction

  hour = +(match[4]);
  minute = +(match[5]);
  second = +(match[6]);

  if (match[7]) {
    fraction = match[7].slice(0, 3);
    while (fraction.length < 3) { // milli-seconds
      fraction += '0';
    }
    fraction = +fraction;
  }

  // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute

  if (match[9]) {
    tz_hour = +(match[10]);
    tz_minute = +(match[11] || 0);
    delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds
    if (match[9] === '-') delta = -delta;
  }

  date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));

  if (delta) date.setTime(date.getTime() - delta);

  return date;
}

function representYamlTimestamp(object /*, style*/) {
  return object.toISOString();
}

module.exports = new Type('tag:yaml.org,2002:timestamp', {
  kind: 'scalar',
  resolve: resolveYamlTimestamp,
  construct: constructYamlTimestamp,
  instanceOf: Date,
  represent: representYamlTimestamp
});


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(3);

function resolveYamlMerge(data) {
  return data === '<<' || data === null;
}

module.exports = new Type('tag:yaml.org,2002:merge', {
  kind: 'scalar',
  resolve: resolveYamlMerge
});


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var require;

/*eslint-disable no-bitwise*/

var NodeBuffer;

try {
  // A trick for browserified version, to not include `Buffer` shim
  var _require = require;
  NodeBuffer = __webpack_require__(31).Buffer;
} catch (__) {}

var Type       = __webpack_require__(3);


// [ 64, 65, 66 ] -> [ padding, CR, LF ]
var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';


function resolveYamlBinary(data) {
  if (data === null) return false;

  var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;

  // Convert one by one.
  for (idx = 0; idx < max; idx++) {
    code = map.indexOf(data.charAt(idx));

    // Skip CR/LF
    if (code > 64) continue;

    // Fail on illegal characters
    if (code < 0) return false;

    bitlen += 6;
  }

  // If there are any bits left, source was corrupted
  return (bitlen % 8) === 0;
}

function constructYamlBinary(data) {
  var idx, tailbits,
      input = data.replace(/[\r\n=]/g, ''), // remove CR/LF & padding to simplify scan
      max = input.length,
      map = BASE64_MAP,
      bits = 0,
      result = [];

  // Collect by 6*4 bits (3 bytes)

  for (idx = 0; idx < max; idx++) {
    if ((idx % 4 === 0) && idx) {
      result.push((bits >> 16) & 0xFF);
      result.push((bits >> 8) & 0xFF);
      result.push(bits & 0xFF);
    }

    bits = (bits << 6) | map.indexOf(input.charAt(idx));
  }

  // Dump tail

  tailbits = (max % 4) * 6;

  if (tailbits === 0) {
    result.push((bits >> 16) & 0xFF);
    result.push((bits >> 8) & 0xFF);
    result.push(bits & 0xFF);
  } else if (tailbits === 18) {
    result.push((bits >> 10) & 0xFF);
    result.push((bits >> 2) & 0xFF);
  } else if (tailbits === 12) {
    result.push((bits >> 4) & 0xFF);
  }

  // Wrap into Buffer for NodeJS and leave Array for browser
  if (NodeBuffer) {
    // Support node 6.+ Buffer API when available
    return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
  }

  return result;
}

function representYamlBinary(object /*, style*/) {
  var result = '', bits = 0, idx, tail,
      max = object.length,
      map = BASE64_MAP;

  // Convert every three bytes to 4 ASCII characters.

  for (idx = 0; idx < max; idx++) {
    if ((idx % 3 === 0) && idx) {
      result += map[(bits >> 18) & 0x3F];
      result += map[(bits >> 12) & 0x3F];
      result += map[(bits >> 6) & 0x3F];
      result += map[bits & 0x3F];
    }

    bits = (bits << 8) + object[idx];
  }

  // Dump tail

  tail = max % 3;

  if (tail === 0) {
    result += map[(bits >> 18) & 0x3F];
    result += map[(bits >> 12) & 0x3F];
    result += map[(bits >> 6) & 0x3F];
    result += map[bits & 0x3F];
  } else if (tail === 2) {
    result += map[(bits >> 10) & 0x3F];
    result += map[(bits >> 4) & 0x3F];
    result += map[(bits << 2) & 0x3F];
    result += map[64];
  } else if (tail === 1) {
    result += map[(bits >> 2) & 0x3F];
    result += map[(bits << 4) & 0x3F];
    result += map[64];
    result += map[64];
  }

  return result;
}

function isBinary(object) {
  return NodeBuffer && NodeBuffer.isBuffer(object);
}

module.exports = new Type('tag:yaml.org,2002:binary', {
  kind: 'scalar',
  resolve: resolveYamlBinary,
  construct: constructYamlBinary,
  predicate: isBinary,
  represent: representYamlBinary
});


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <http://feross.org>
 * @license  MIT
 */
/* eslint-disable no-proto */



var base64 = __webpack_require__(32)
var ieee754 = __webpack_require__(33)
var isArray = __webpack_require__(34)

exports.Buffer = Buffer
exports.SlowBuffer = SlowBuffer
exports.INSPECT_MAX_BYTES = 50

/**
 * If `Buffer.TYPED_ARRAY_SUPPORT`:
 *   === true    Use Uint8Array implementation (fastest)
 *   === false   Use Object implementation (most compatible, even IE6)
 *
 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
 * Opera 11.6+, iOS 4.2+.
 *
 * Due to various browser bugs, sometimes the Object implementation will be used even
 * when the browser supports typed arrays.
 *
 * Note:
 *
 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
 *
 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
 *
 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
 *     incorrect length in some situations.

 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
 * get the Object implementation, which is slower but behaves correctly.
 */
Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
  ? global.TYPED_ARRAY_SUPPORT
  : typedArraySupport()

/*
 * Export kMaxLength after typed array support is determined.
 */
exports.kMaxLength = kMaxLength()

function typedArraySupport () {
  try {
    var arr = new Uint8Array(1)
    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
    return arr.foo() === 42 && // typed array instances can be augmented
        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
  } catch (e) {
    return false
  }
}

function kMaxLength () {
  return Buffer.TYPED_ARRAY_SUPPORT
    ? 0x7fffffff
    : 0x3fffffff
}

function createBuffer (that, length) {
  if (kMaxLength() < length) {
    throw new RangeError('Invalid typed array length')
  }
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = new Uint8Array(length)
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    if (that === null) {
      that = new Buffer(length)
    }
    that.length = length
  }

  return that
}

/**
 * The Buffer constructor returns instances of `Uint8Array` that have their
 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
 * returns a single octet.
 *
 * The `Uint8Array` prototype remains unmodified.
 */

function Buffer (arg, encodingOrOffset, length) {
  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
    return new Buffer(arg, encodingOrOffset, length)
  }

  // Common case.
  if (typeof arg === 'number') {
    if (typeof encodingOrOffset === 'string') {
      throw new Error(
        'If encoding is specified then the first argument must be a string'
      )
    }
    return allocUnsafe(this, arg)
  }
  return from(this, arg, encodingOrOffset, length)
}

Buffer.poolSize = 8192 // not used by this implementation

// TODO: Legacy, not needed anymore. Remove in next major version.
Buffer._augment = function (arr) {
  arr.__proto__ = Buffer.prototype
  return arr
}

function from (that, value, encodingOrOffset, length) {
  if (typeof value === 'number') {
    throw new TypeError('"value" argument must not be a number')
  }

  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
    return fromArrayBuffer(that, value, encodingOrOffset, length)
  }

  if (typeof value === 'string') {
    return fromString(that, value, encodingOrOffset)
  }

  return fromObject(that, value)
}

/**
 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
 * if value is a number.
 * Buffer.from(str[, encoding])
 * Buffer.from(array)
 * Buffer.from(buffer)
 * Buffer.from(arrayBuffer[, byteOffset[, length]])
 **/
Buffer.from = function (value, encodingOrOffset, length) {
  return from(null, value, encodingOrOffset, length)
}

if (Buffer.TYPED_ARRAY_SUPPORT) {
  Buffer.prototype.__proto__ = Uint8Array.prototype
  Buffer.__proto__ = Uint8Array
  if (typeof Symbol !== 'undefined' && Symbol.species &&
      Buffer[Symbol.species] === Buffer) {
    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
    Object.defineProperty(Buffer, Symbol.species, {
      value: null,
      configurable: true
    })
  }
}

function assertSize (size) {
  if (typeof size !== 'number') {
    throw new TypeError('"size" argument must be a number')
  } else if (size < 0) {
    throw new RangeError('"size" argument must not be negative')
  }
}

function alloc (that, size, fill, encoding) {
  assertSize(size)
  if (size <= 0) {
    return createBuffer(that, size)
  }
  if (fill !== undefined) {
    // Only pay attention to encoding if it's a string. This
    // prevents accidentally sending in a number that would
    // be interpretted as a start offset.
    return typeof encoding === 'string'
      ? createBuffer(that, size).fill(fill, encoding)
      : createBuffer(that, size).fill(fill)
  }
  return createBuffer(that, size)
}

/**
 * Creates a new filled Buffer instance.
 * alloc(size[, fill[, encoding]])
 **/
Buffer.alloc = function (size, fill, encoding) {
  return alloc(null, size, fill, encoding)
}

function allocUnsafe (that, size) {
  assertSize(size)
  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) {
    for (var i = 0; i < size; ++i) {
      that[i] = 0
    }
  }
  return that
}

/**
 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
 * */
Buffer.allocUnsafe = function (size) {
  return allocUnsafe(null, size)
}
/**
 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
 */
Buffer.allocUnsafeSlow = function (size) {
  return allocUnsafe(null, size)
}

function fromString (that, string, encoding) {
  if (typeof encoding !== 'string' || encoding === '') {
    encoding = 'utf8'
  }

  if (!Buffer.isEncoding(encoding)) {
    throw new TypeError('"encoding" must be a valid string encoding')
  }

  var length = byteLength(string, encoding) | 0
  that = createBuffer(that, length)

  var actual = that.write(string, encoding)

  if (actual !== length) {
    // Writing a hex string, for example, that contains invalid characters will
    // cause everything after the first invalid character to be ignored. (e.g.
    // 'abxxcd' will be treated as 'ab')
    that = that.slice(0, actual)
  }

  return that
}

function fromArrayLike (that, array) {
  var length = array.length < 0 ? 0 : checked(array.length) | 0
  that = createBuffer(that, length)
  for (var i = 0; i < length; i += 1) {
    that[i] = array[i] & 255
  }
  return that
}

function fromArrayBuffer (that, array, byteOffset, length) {
  array.byteLength // this throws if `array` is not a valid ArrayBuffer

  if (byteOffset < 0 || array.byteLength < byteOffset) {
    throw new RangeError('\'offset\' is out of bounds')
  }

  if (array.byteLength < byteOffset + (length || 0)) {
    throw new RangeError('\'length\' is out of bounds')
  }

  if (byteOffset === undefined && length === undefined) {
    array = new Uint8Array(array)
  } else if (length === undefined) {
    array = new Uint8Array(array, byteOffset)
  } else {
    array = new Uint8Array(array, byteOffset, length)
  }

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    // Return an augmented `Uint8Array` instance, for best performance
    that = array
    that.__proto__ = Buffer.prototype
  } else {
    // Fallback: Return an object instance of the Buffer class
    that = fromArrayLike(that, array)
  }
  return that
}

function fromObject (that, obj) {
  if (Buffer.isBuffer(obj)) {
    var len = checked(obj.length) | 0
    that = createBuffer(that, len)

    if (that.length === 0) {
      return that
    }

    obj.copy(that, 0, 0, len)
    return that
  }

  if (obj) {
    if ((typeof ArrayBuffer !== 'undefined' &&
        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
      if (typeof obj.length !== 'number' || isnan(obj.length)) {
        return createBuffer(that, 0)
      }
      return fromArrayLike(that, obj)
    }

    if (obj.type === 'Buffer' && isArray(obj.data)) {
      return fromArrayLike(that, obj.data)
    }
  }

  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
}

function checked (length) {
  // Note: cannot use `length < kMaxLength()` here because that fails when
  // length is NaN (which is otherwise coerced to zero.)
  if (length >= kMaxLength()) {
    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
                         'size: 0x' + kMaxLength().toString(16) + ' bytes')
  }
  return length | 0
}

function SlowBuffer (length) {
  if (+length != length) { // eslint-disable-line eqeqeq
    length = 0
  }
  return Buffer.alloc(+length)
}

Buffer.isBuffer = function isBuffer (b) {
  return !!(b != null && b._isBuffer)
}

Buffer.compare = function compare (a, b) {
  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
    throw new TypeError('Arguments must be Buffers')
  }

  if (a === b) return 0

  var x = a.length
  var y = b.length

  for (var i = 0, len = Math.min(x, y); i < len; ++i) {
    if (a[i] !== b[i]) {
      x = a[i]
      y = b[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

Buffer.isEncoding = function isEncoding (encoding) {
  switch (String(encoding).toLowerCase()) {
    case 'hex':
    case 'utf8':
    case 'utf-8':
    case 'ascii':
    case 'latin1':
    case 'binary':
    case 'base64':
    case 'ucs2':
    case 'ucs-2':
    case 'utf16le':
    case 'utf-16le':
      return true
    default:
      return false
  }
}

Buffer.concat = function concat (list, length) {
  if (!isArray(list)) {
    throw new TypeError('"list" argument must be an Array of Buffers')
  }

  if (list.length === 0) {
    return Buffer.alloc(0)
  }

  var i
  if (length === undefined) {
    length = 0
    for (i = 0; i < list.length; ++i) {
      length += list[i].length
    }
  }

  var buffer = Buffer.allocUnsafe(length)
  var pos = 0
  for (i = 0; i < list.length; ++i) {
    var buf = list[i]
    if (!Buffer.isBuffer(buf)) {
      throw new TypeError('"list" argument must be an Array of Buffers')
    }
    buf.copy(buffer, pos)
    pos += buf.length
  }
  return buffer
}

function byteLength (string, encoding) {
  if (Buffer.isBuffer(string)) {
    return string.length
  }
  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
    return string.byteLength
  }
  if (typeof string !== 'string') {
    string = '' + string
  }

  var len = string.length
  if (len === 0) return 0

  // Use a for loop to avoid recursion
  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'ascii':
      case 'latin1':
      case 'binary':
        return len
      case 'utf8':
      case 'utf-8':
      case undefined:
        return utf8ToBytes(string).length
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return len * 2
      case 'hex':
        return len >>> 1
      case 'base64':
        return base64ToBytes(string).length
      default:
        if (loweredCase) return utf8ToBytes(string).length // assume utf8
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}
Buffer.byteLength = byteLength

function slowToString (encoding, start, end) {
  var loweredCase = false

  // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
  // property of a typed array.

  // This behaves neither like String nor Uint8Array in that we set start/end
  // to their upper/lower bounds if the value passed is out of range.
  // undefined is handled specially as per ECMA-262 6th Edition,
  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
  if (start === undefined || start < 0) {
    start = 0
  }
  // Return early if start > this.length. Done here to prevent potential uint32
  // coercion fail below.
  if (start > this.length) {
    return ''
  }

  if (end === undefined || end > this.length) {
    end = this.length
  }

  if (end <= 0) {
    return ''
  }

  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.
  end >>>= 0
  start >>>= 0

  if (end <= start) {
    return ''
  }

  if (!encoding) encoding = 'utf8'

  while (true) {
    switch (encoding) {
      case 'hex':
        return hexSlice(this, start, end)

      case 'utf8':
      case 'utf-8':
        return utf8Slice(this, start, end)

      case 'ascii':
        return asciiSlice(this, start, end)

      case 'latin1':
      case 'binary':
        return latin1Slice(this, start, end)

      case 'base64':
        return base64Slice(this, start, end)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return utf16leSlice(this, start, end)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = (encoding + '').toLowerCase()
        loweredCase = true
    }
  }
}

// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
// Buffer instances.
Buffer.prototype._isBuffer = true

function swap (b, n, m) {
  var i = b[n]
  b[n] = b[m]
  b[m] = i
}

Buffer.prototype.swap16 = function swap16 () {
  var len = this.length
  if (len % 2 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 16-bits')
  }
  for (var i = 0; i < len; i += 2) {
    swap(this, i, i + 1)
  }
  return this
}

Buffer.prototype.swap32 = function swap32 () {
  var len = this.length
  if (len % 4 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 32-bits')
  }
  for (var i = 0; i < len; i += 4) {
    swap(this, i, i + 3)
    swap(this, i + 1, i + 2)
  }
  return this
}

Buffer.prototype.swap64 = function swap64 () {
  var len = this.length
  if (len % 8 !== 0) {
    throw new RangeError('Buffer size must be a multiple of 64-bits')
  }
  for (var i = 0; i < len; i += 8) {
    swap(this, i, i + 7)
    swap(this, i + 1, i + 6)
    swap(this, i + 2, i + 5)
    swap(this, i + 3, i + 4)
  }
  return this
}

Buffer.prototype.toString = function toString () {
  var length = this.length | 0
  if (length === 0) return ''
  if (arguments.length === 0) return utf8Slice(this, 0, length)
  return slowToString.apply(this, arguments)
}

Buffer.prototype.equals = function equals (b) {
  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
  if (this === b) return true
  return Buffer.compare(this, b) === 0
}

Buffer.prototype.inspect = function inspect () {
  var str = ''
  var max = exports.INSPECT_MAX_BYTES
  if (this.length > 0) {
    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
    if (this.length > max) str += ' ... '
  }
  return '<Buffer ' + str + '>'
}

Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
  if (!Buffer.isBuffer(target)) {
    throw new TypeError('Argument must be a Buffer')
  }

  if (start === undefined) {
    start = 0
  }
  if (end === undefined) {
    end = target ? target.length : 0
  }
  if (thisStart === undefined) {
    thisStart = 0
  }
  if (thisEnd === undefined) {
    thisEnd = this.length
  }

  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
    throw new RangeError('out of range index')
  }

  if (thisStart >= thisEnd && start >= end) {
    return 0
  }
  if (thisStart >= thisEnd) {
    return -1
  }
  if (start >= end) {
    return 1
  }

  start >>>= 0
  end >>>= 0
  thisStart >>>= 0
  thisEnd >>>= 0

  if (this === target) return 0

  var x = thisEnd - thisStart
  var y = end - start
  var len = Math.min(x, y)

  var thisCopy = this.slice(thisStart, thisEnd)
  var targetCopy = target.slice(start, end)

  for (var i = 0; i < len; ++i) {
    if (thisCopy[i] !== targetCopy[i]) {
      x = thisCopy[i]
      y = targetCopy[i]
      break
    }
  }

  if (x < y) return -1
  if (y < x) return 1
  return 0
}

// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
//
// Arguments:
// - buffer - a Buffer to search
// - val - a string, Buffer, or number
// - byteOffset - an index into `buffer`; will be clamped to an int32
// - encoding - an optional encoding, relevant is val is a string
// - dir - true for indexOf, false for lastIndexOf
function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
  // Empty buffer means no match
  if (buffer.length === 0) return -1

  // Normalize byteOffset
  if (typeof byteOffset === 'string') {
    encoding = byteOffset
    byteOffset = 0
  } else if (byteOffset > 0x7fffffff) {
    byteOffset = 0x7fffffff
  } else if (byteOffset < -0x80000000) {
    byteOffset = -0x80000000
  }
  byteOffset = +byteOffset  // Coerce to Number.
  if (isNaN(byteOffset)) {
    // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
    byteOffset = dir ? 0 : (buffer.length - 1)
  }

  // Normalize byteOffset: negative offsets start from the end of the buffer
  if (byteOffset < 0) byteOffset = buffer.length + byteOffset
  if (byteOffset >= buffer.length) {
    if (dir) return -1
    else byteOffset = buffer.length - 1
  } else if (byteOffset < 0) {
    if (dir) byteOffset = 0
    else return -1
  }

  // Normalize val
  if (typeof val === 'string') {
    val = Buffer.from(val, encoding)
  }

  // Finally, search either indexOf (if dir is true) or lastIndexOf
  if (Buffer.isBuffer(val)) {
    // Special case: looking for empty string/buffer always fails
    if (val.length === 0) {
      return -1
    }
    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
  } else if (typeof val === 'number') {
    val = val & 0xFF // Search for a byte value [0-255]
    if (Buffer.TYPED_ARRAY_SUPPORT &&
        typeof Uint8Array.prototype.indexOf === 'function') {
      if (dir) {
        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
      } else {
        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
      }
    }
    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
  }

  throw new TypeError('val must be string, number or Buffer')
}

function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
  var indexSize = 1
  var arrLength = arr.length
  var valLength = val.length

  if (encoding !== undefined) {
    encoding = String(encoding).toLowerCase()
    if (encoding === 'ucs2' || encoding === 'ucs-2' ||
        encoding === 'utf16le' || encoding === 'utf-16le') {
      if (arr.length < 2 || val.length < 2) {
        return -1
      }
      indexSize = 2
      arrLength /= 2
      valLength /= 2
      byteOffset /= 2
    }
  }

  function read (buf, i) {
    if (indexSize === 1) {
      return buf[i]
    } else {
      return buf.readUInt16BE(i * indexSize)
    }
  }

  var i
  if (dir) {
    var foundIndex = -1
    for (i = byteOffset; i < arrLength; i++) {
      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
        if (foundIndex === -1) foundIndex = i
        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
      } else {
        if (foundIndex !== -1) i -= i - foundIndex
        foundIndex = -1
      }
    }
  } else {
    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
    for (i = byteOffset; i >= 0; i--) {
      var found = true
      for (var j = 0; j < valLength; j++) {
        if (read(arr, i + j) !== read(val, j)) {
          found = false
          break
        }
      }
      if (found) return i
    }
  }

  return -1
}

Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
  return this.indexOf(val, byteOffset, encoding) !== -1
}

Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
}

Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
}

function hexWrite (buf, string, offset, length) {
  offset = Number(offset) || 0
  var remaining = buf.length - offset
  if (!length) {
    length = remaining
  } else {
    length = Number(length)
    if (length > remaining) {
      length = remaining
    }
  }

  // must be an even number of digits
  var strLen = string.length
  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')

  if (length > strLen / 2) {
    length = strLen / 2
  }
  for (var i = 0; i < length; ++i) {
    var parsed = parseInt(string.substr(i * 2, 2), 16)
    if (isNaN(parsed)) return i
    buf[offset + i] = parsed
  }
  return i
}

function utf8Write (buf, string, offset, length) {
  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
}

function asciiWrite (buf, string, offset, length) {
  return blitBuffer(asciiToBytes(string), buf, offset, length)
}

function latin1Write (buf, string, offset, length) {
  return asciiWrite(buf, string, offset, length)
}

function base64Write (buf, string, offset, length) {
  return blitBuffer(base64ToBytes(string), buf, offset, length)
}

function ucs2Write (buf, string, offset, length) {
  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
}

Buffer.prototype.write = function write (string, offset, length, encoding) {
  // Buffer#write(string)
  if (offset === undefined) {
    encoding = 'utf8'
    length = this.length
    offset = 0
  // Buffer#write(string, encoding)
  } else if (length === undefined && typeof offset === 'string') {
    encoding = offset
    length = this.length
    offset = 0
  // Buffer#write(string, offset[, length][, encoding])
  } else if (isFinite(offset)) {
    offset = offset | 0
    if (isFinite(length)) {
      length = length | 0
      if (encoding === undefined) encoding = 'utf8'
    } else {
      encoding = length
      length = undefined
    }
  // legacy write(string, encoding, offset, length) - remove in v0.13
  } else {
    throw new Error(
      'Buffer.write(string, encoding, offset[, length]) is no longer supported'
    )
  }

  var remaining = this.length - offset
  if (length === undefined || length > remaining) length = remaining

  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
    throw new RangeError('Attempt to write outside buffer bounds')
  }

  if (!encoding) encoding = 'utf8'

  var loweredCase = false
  for (;;) {
    switch (encoding) {
      case 'hex':
        return hexWrite(this, string, offset, length)

      case 'utf8':
      case 'utf-8':
        return utf8Write(this, string, offset, length)

      case 'ascii':
        return asciiWrite(this, string, offset, length)

      case 'latin1':
      case 'binary':
        return latin1Write(this, string, offset, length)

      case 'base64':
        // Warning: maxLength not taken into account in base64Write
        return base64Write(this, string, offset, length)

      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return ucs2Write(this, string, offset, length)

      default:
        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
        encoding = ('' + encoding).toLowerCase()
        loweredCase = true
    }
  }
}

Buffer.prototype.toJSON = function toJSON () {
  return {
    type: 'Buffer',
    data: Array.prototype.slice.call(this._arr || this, 0)
  }
}

function base64Slice (buf, start, end) {
  if (start === 0 && end === buf.length) {
    return base64.fromByteArray(buf)
  } else {
    return base64.fromByteArray(buf.slice(start, end))
  }
}

function utf8Slice (buf, start, end) {
  end = Math.min(buf.length, end)
  var res = []

  var i = start
  while (i < end) {
    var firstByte = buf[i]
    var codePoint = null
    var bytesPerSequence = (firstByte > 0xEF) ? 4
      : (firstByte > 0xDF) ? 3
      : (firstByte > 0xBF) ? 2
      : 1

    if (i + bytesPerSequence <= end) {
      var secondByte, thirdByte, fourthByte, tempCodePoint

      switch (bytesPerSequence) {
        case 1:
          if (firstByte < 0x80) {
            codePoint = firstByte
          }
          break
        case 2:
          secondByte = buf[i + 1]
          if ((secondByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
            if (tempCodePoint > 0x7F) {
              codePoint = tempCodePoint
            }
          }
          break
        case 3:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
              codePoint = tempCodePoint
            }
          }
          break
        case 4:
          secondByte = buf[i + 1]
          thirdByte = buf[i + 2]
          fourthByte = buf[i + 3]
          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
              codePoint = tempCodePoint
            }
          }
      }
    }

    if (codePoint === null) {
      // we did not generate a valid codePoint so insert a
      // replacement char (U+FFFD) and advance only 1 byte
      codePoint = 0xFFFD
      bytesPerSequence = 1
    } else if (codePoint > 0xFFFF) {
      // encode to utf16 (surrogate pair dance)
      codePoint -= 0x10000
      res.push(codePoint >>> 10 & 0x3FF | 0xD800)
      codePoint = 0xDC00 | codePoint & 0x3FF
    }

    res.push(codePoint)
    i += bytesPerSequence
  }

  return decodeCodePointsArray(res)
}

// Based on http://stackoverflow.com/a/22747272/680742, the browser with
// the lowest limit is Chrome, with 0x10000 args.
// We go 1 magnitude less, for safety
var MAX_ARGUMENTS_LENGTH = 0x1000

function decodeCodePointsArray (codePoints) {
  var len = codePoints.length
  if (len <= MAX_ARGUMENTS_LENGTH) {
    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
  }

  // Decode in chunks to avoid "call stack size exceeded".
  var res = ''
  var i = 0
  while (i < len) {
    res += String.fromCharCode.apply(
      String,
      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
    )
  }
  return res
}

function asciiSlice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i] & 0x7F)
  }
  return ret
}

function latin1Slice (buf, start, end) {
  var ret = ''
  end = Math.min(buf.length, end)

  for (var i = start; i < end; ++i) {
    ret += String.fromCharCode(buf[i])
  }
  return ret
}

function hexSlice (buf, start, end) {
  var len = buf.length

  if (!start || start < 0) start = 0
  if (!end || end < 0 || end > len) end = len

  var out = ''
  for (var i = start; i < end; ++i) {
    out += toHex(buf[i])
  }
  return out
}

function utf16leSlice (buf, start, end) {
  var bytes = buf.slice(start, end)
  var res = ''
  for (var i = 0; i < bytes.length; i += 2) {
    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
  }
  return res
}

Buffer.prototype.slice = function slice (start, end) {
  var len = this.length
  start = ~~start
  end = end === undefined ? len : ~~end

  if (start < 0) {
    start += len
    if (start < 0) start = 0
  } else if (start > len) {
    start = len
  }

  if (end < 0) {
    end += len
    if (end < 0) end = 0
  } else if (end > len) {
    end = len
  }

  if (end < start) end = start

  var newBuf
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    newBuf = this.subarray(start, end)
    newBuf.__proto__ = Buffer.prototype
  } else {
    var sliceLen = end - start
    newBuf = new Buffer(sliceLen, undefined)
    for (var i = 0; i < sliceLen; ++i) {
      newBuf[i] = this[i + start]
    }
  }

  return newBuf
}

/*
 * Need to make sure that buffer isn't trying to write out of bounds.
 */
function checkOffset (offset, ext, length) {
  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
}

Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }

  return val
}

Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    checkOffset(offset, byteLength, this.length)
  }

  var val = this[offset + --byteLength]
  var mul = 1
  while (byteLength > 0 && (mul *= 0x100)) {
    val += this[offset + --byteLength] * mul
  }

  return val
}

Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  return this[offset]
}

Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return this[offset] | (this[offset + 1] << 8)
}

Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  return (this[offset] << 8) | this[offset + 1]
}

Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return ((this[offset]) |
      (this[offset + 1] << 8) |
      (this[offset + 2] << 16)) +
      (this[offset + 3] * 0x1000000)
}

Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] * 0x1000000) +
    ((this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    this[offset + 3])
}

Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var val = this[offset]
  var mul = 1
  var i = 0
  while (++i < byteLength && (mul *= 0x100)) {
    val += this[offset + i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) checkOffset(offset, byteLength, this.length)

  var i = byteLength
  var mul = 1
  var val = this[offset + --i]
  while (i > 0 && (mul *= 0x100)) {
    val += this[offset + --i] * mul
  }
  mul *= 0x80

  if (val >= mul) val -= Math.pow(2, 8 * byteLength)

  return val
}

Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 1, this.length)
  if (!(this[offset] & 0x80)) return (this[offset])
  return ((0xff - this[offset] + 1) * -1)
}

Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset] | (this[offset + 1] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 2, this.length)
  var val = this[offset + 1] | (this[offset] << 8)
  return (val & 0x8000) ? val | 0xFFFF0000 : val
}

Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset]) |
    (this[offset + 1] << 8) |
    (this[offset + 2] << 16) |
    (this[offset + 3] << 24)
}

Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)

  return (this[offset] << 24) |
    (this[offset + 1] << 16) |
    (this[offset + 2] << 8) |
    (this[offset + 3])
}

Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, true, 23, 4)
}

Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 4, this.length)
  return ieee754.read(this, offset, false, 23, 4)
}

Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, true, 52, 8)
}

Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
  if (!noAssert) checkOffset(offset, 8, this.length)
  return ieee754.read(this, offset, false, 52, 8)
}

function checkInt (buf, value, offset, ext, max, min) {
  if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
  if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
}

Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var mul = 1
  var i = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  byteLength = byteLength | 0
  if (!noAssert) {
    var maxBytes = Math.pow(2, 8 * byteLength) - 1
    checkInt(this, value, offset, byteLength, maxBytes, 0)
  }

  var i = byteLength - 1
  var mul = 1
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    this[offset + i] = (value / mul) & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  this[offset] = (value & 0xff)
  return offset + 1
}

function objectWriteUInt16 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
      (littleEndian ? i : 1 - i) * 8
  }
}

Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

function objectWriteUInt32 (buf, value, offset, littleEndian) {
  if (value < 0) value = 0xffffffff + value + 1
  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
  }
}

Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset + 3] = (value >>> 24)
    this[offset + 2] = (value >>> 16)
    this[offset + 1] = (value >>> 8)
    this[offset] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = 0
  var mul = 1
  var sub = 0
  this[offset] = value & 0xFF
  while (++i < byteLength && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) {
    var limit = Math.pow(2, 8 * byteLength - 1)

    checkInt(this, value, offset, byteLength, limit - 1, -limit)
  }

  var i = byteLength - 1
  var mul = 1
  var sub = 0
  this[offset + i] = value & 0xFF
  while (--i >= 0 && (mul *= 0x100)) {
    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
      sub = 1
    }
    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
  }

  return offset + byteLength
}

Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
  if (value < 0) value = 0xff + value + 1
  this[offset] = (value & 0xff)
  return offset + 1
}

Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
  } else {
    objectWriteUInt16(this, value, offset, true)
  }
  return offset + 2
}

Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 8)
    this[offset + 1] = (value & 0xff)
  } else {
    objectWriteUInt16(this, value, offset, false)
  }
  return offset + 2
}

Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value & 0xff)
    this[offset + 1] = (value >>> 8)
    this[offset + 2] = (value >>> 16)
    this[offset + 3] = (value >>> 24)
  } else {
    objectWriteUInt32(this, value, offset, true)
  }
  return offset + 4
}

Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
  value = +value
  offset = offset | 0
  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
  if (value < 0) value = 0xffffffff + value + 1
  if (Buffer.TYPED_ARRAY_SUPPORT) {
    this[offset] = (value >>> 24)
    this[offset + 1] = (value >>> 16)
    this[offset + 2] = (value >>> 8)
    this[offset + 3] = (value & 0xff)
  } else {
    objectWriteUInt32(this, value, offset, false)
  }
  return offset + 4
}

function checkIEEE754 (buf, value, offset, ext, max, min) {
  if (offset + ext > buf.length) throw new RangeError('Index out of range')
  if (offset < 0) throw new RangeError('Index out of range')
}

function writeFloat (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
  }
  ieee754.write(buf, value, offset, littleEndian, 23, 4)
  return offset + 4
}

Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
  return writeFloat(this, value, offset, true, noAssert)
}

Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
  return writeFloat(this, value, offset, false, noAssert)
}

function writeDouble (buf, value, offset, littleEndian, noAssert) {
  if (!noAssert) {
    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
  }
  ieee754.write(buf, value, offset, littleEndian, 52, 8)
  return offset + 8
}

Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
  return writeDouble(this, value, offset, true, noAssert)
}

Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
  return writeDouble(this, value, offset, false, noAssert)
}

// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
Buffer.prototype.copy = function copy (target, targetStart, start, end) {
  if (!start) start = 0
  if (!end && end !== 0) end = this.length
  if (targetStart >= target.length) targetStart = target.length
  if (!targetStart) targetStart = 0
  if (end > 0 && end < start) end = start

  // Copy 0 bytes; we're done
  if (end === start) return 0
  if (target.length === 0 || this.length === 0) return 0

  // Fatal error conditions
  if (targetStart < 0) {
    throw new RangeError('targetStart out of bounds')
  }
  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
  if (end < 0) throw new RangeError('sourceEnd out of bounds')

  // Are we oob?
  if (end > this.length) end = this.length
  if (target.length - targetStart < end - start) {
    end = target.length - targetStart + start
  }

  var len = end - start
  var i

  if (this === target && start < targetStart && targetStart < end) {
    // descending copy from end
    for (i = len - 1; i >= 0; --i) {
      target[i + targetStart] = this[i + start]
    }
  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
    // ascending copy from start
    for (i = 0; i < len; ++i) {
      target[i + targetStart] = this[i + start]
    }
  } else {
    Uint8Array.prototype.set.call(
      target,
      this.subarray(start, start + len),
      targetStart
    )
  }

  return len
}

// Usage:
//    buffer.fill(number[, offset[, end]])
//    buffer.fill(buffer[, offset[, end]])
//    buffer.fill(string[, offset[, end]][, encoding])
Buffer.prototype.fill = function fill (val, start, end, encoding) {
  // Handle string cases:
  if (typeof val === 'string') {
    if (typeof start === 'string') {
      encoding = start
      start = 0
      end = this.length
    } else if (typeof end === 'string') {
      encoding = end
      end = this.length
    }
    if (val.length === 1) {
      var code = val.charCodeAt(0)
      if (code < 256) {
        val = code
      }
    }
    if (encoding !== undefined && typeof encoding !== 'string') {
      throw new TypeError('encoding must be a string')
    }
    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
      throw new TypeError('Unknown encoding: ' + encoding)
    }
  } else if (typeof val === 'number') {
    val = val & 255
  }

  // Invalid ranges are not set to a default, so can range check early.
  if (start < 0 || this.length < start || this.length < end) {
    throw new RangeError('Out of range index')
  }

  if (end <= start) {
    return this
  }

  start = start >>> 0
  end = end === undefined ? this.length : end >>> 0

  if (!val) val = 0

  var i
  if (typeof val === 'number') {
    for (i = start; i < end; ++i) {
      this[i] = val
    }
  } else {
    var bytes = Buffer.isBuffer(val)
      ? val
      : utf8ToBytes(new Buffer(val, encoding).toString())
    var len = bytes.length
    for (i = 0; i < end - start; ++i) {
      this[i + start] = bytes[i % len]
    }
  }

  return this
}

// HELPER FUNCTIONS
// ================

var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g

function base64clean (str) {
  // Node strips out invalid characters like \n and \t from the string, base64-js does not
  str = stringtrim(str).replace(INVALID_BASE64_RE, '')
  // Node converts strings with length < 2 to ''
  if (str.length < 2) return ''
  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
  while (str.length % 4 !== 0) {
    str = str + '='
  }
  return str
}

function stringtrim (str) {
  if (str.trim) return str.trim()
  return str.replace(/^\s+|\s+$/g, '')
}

function toHex (n) {
  if (n < 16) return '0' + n.toString(16)
  return n.toString(16)
}

function utf8ToBytes (string, units) {
  units = units || Infinity
  var codePoint
  var length = string.length
  var leadSurrogate = null
  var bytes = []

  for (var i = 0; i < length; ++i) {
    codePoint = string.charCodeAt(i)

    // is surrogate component
    if (codePoint > 0xD7FF && codePoint < 0xE000) {
      // last char was a lead
      if (!leadSurrogate) {
        // no lead yet
        if (codePoint > 0xDBFF) {
          // unexpected trail
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        } else if (i + 1 === length) {
          // unpaired lead
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
          continue
        }

        // valid lead
        leadSurrogate = codePoint

        continue
      }

      // 2 leads in a row
      if (codePoint < 0xDC00) {
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
        leadSurrogate = codePoint
        continue
      }

      // valid surrogate pair
      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
    } else if (leadSurrogate) {
      // valid bmp char, but last char was a lead
      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
    }

    leadSurrogate = null

    // encode utf8
    if (codePoint < 0x80) {
      if ((units -= 1) < 0) break
      bytes.push(codePoint)
    } else if (codePoint < 0x800) {
      if ((units -= 2) < 0) break
      bytes.push(
        codePoint >> 0x6 | 0xC0,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x10000) {
      if ((units -= 3) < 0) break
      bytes.push(
        codePoint >> 0xC | 0xE0,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else if (codePoint < 0x110000) {
      if ((units -= 4) < 0) break
      bytes.push(
        codePoint >> 0x12 | 0xF0,
        codePoint >> 0xC & 0x3F | 0x80,
        codePoint >> 0x6 & 0x3F | 0x80,
        codePoint & 0x3F | 0x80
      )
    } else {
      throw new Error('Invalid code point')
    }
  }

  return bytes
}

function asciiToBytes (str) {
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    // Node's code seems to be doing this and not & 0x7F..
    byteArray.push(str.charCodeAt(i) & 0xFF)
  }
  return byteArray
}

function utf16leToBytes (str, units) {
  var c, hi, lo
  var byteArray = []
  for (var i = 0; i < str.length; ++i) {
    if ((units -= 2) < 0) break

    c = str.charCodeAt(i)
    hi = c >> 8
    lo = c % 256
    byteArray.push(lo)
    byteArray.push(hi)
  }

  return byteArray
}

function base64ToBytes (str) {
  return base64.toByteArray(base64clean(str))
}

function blitBuffer (src, dst, offset, length) {
  for (var i = 0; i < length; ++i) {
    if ((i + offset >= dst.length) || (i >= src.length)) break
    dst[i + offset] = src[i]
  }
  return i
}

function isnan (val) {
  return val !== val // eslint-disable-line no-self-compare
}


/***/ }),
/* 32 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.byteLength = byteLength
exports.toByteArray = toByteArray
exports.fromByteArray = fromByteArray

var lookup = []
var revLookup = []
var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array

var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
for (var i = 0, len = code.length; i < len; ++i) {
  lookup[i] = code[i]
  revLookup[code.charCodeAt(i)] = i
}

// Support decoding URL-safe base64 strings, as Node.js does.
// See: https://en.wikipedia.org/wiki/Base64#URL_applications
revLookup['-'.charCodeAt(0)] = 62
revLookup['_'.charCodeAt(0)] = 63

function getLens (b64) {
  var len = b64.length

  if (len % 4 > 0) {
    throw new Error('Invalid string. Length must be a multiple of 4')
  }

  // Trim off extra bytes after placeholder bytes are found
  // See: https://github.com/beatgammit/base64-js/issues/42
  var validLen = b64.indexOf('=')
  if (validLen === -1) validLen = len

  var placeHoldersLen = validLen === len
    ? 0
    : 4 - (validLen % 4)

  return [validLen, placeHoldersLen]
}

// base64 is 4/3 + up to two characters of the original data
function byteLength (b64) {
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function _byteLength (b64, validLen, placeHoldersLen) {
  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
}

function toByteArray (b64) {
  var tmp
  var lens = getLens(b64)
  var validLen = lens[0]
  var placeHoldersLen = lens[1]

  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))

  var curByte = 0

  // if there are placeholders, only get up to the last complete 4 chars
  var len = placeHoldersLen > 0
    ? validLen - 4
    : validLen

  var i
  for (i = 0; i < len; i += 4) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 18) |
      (revLookup[b64.charCodeAt(i + 1)] << 12) |
      (revLookup[b64.charCodeAt(i + 2)] << 6) |
      revLookup[b64.charCodeAt(i + 3)]
    arr[curByte++] = (tmp >> 16) & 0xFF
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 2) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 2) |
      (revLookup[b64.charCodeAt(i + 1)] >> 4)
    arr[curByte++] = tmp & 0xFF
  }

  if (placeHoldersLen === 1) {
    tmp =
      (revLookup[b64.charCodeAt(i)] << 10) |
      (revLookup[b64.charCodeAt(i + 1)] << 4) |
      (revLookup[b64.charCodeAt(i + 2)] >> 2)
    arr[curByte++] = (tmp >> 8) & 0xFF
    arr[curByte++] = tmp & 0xFF
  }

  return arr
}

function tripletToBase64 (num) {
  return lookup[num >> 18 & 0x3F] +
    lookup[num >> 12 & 0x3F] +
    lookup[num >> 6 & 0x3F] +
    lookup[num & 0x3F]
}

function encodeChunk (uint8, start, end) {
  var tmp
  var output = []
  for (var i = start; i < end; i += 3) {
    tmp =
      ((uint8[i] << 16) & 0xFF0000) +
      ((uint8[i + 1] << 8) & 0xFF00) +
      (uint8[i + 2] & 0xFF)
    output.push(tripletToBase64(tmp))
  }
  return output.join('')
}

function fromByteArray (uint8) {
  var tmp
  var len = uint8.length
  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
  var parts = []
  var maxChunkLength = 16383 // must be multiple of 3

  // go through the array every three bytes, we'll deal with trailing stuff later
  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
    parts.push(encodeChunk(
      uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)
    ))
  }

  // pad the end with zeros, but make sure to not forget the extra bytes
  if (extraBytes === 1) {
    tmp = uint8[len - 1]
    parts.push(
      lookup[tmp >> 2] +
      lookup[(tmp << 4) & 0x3F] +
      '=='
    )
  } else if (extraBytes === 2) {
    tmp = (uint8[len - 2] << 8) + uint8[len - 1]
    parts.push(
      lookup[tmp >> 10] +
      lookup[(tmp >> 4) & 0x3F] +
      lookup[(tmp << 2) & 0x3F] +
      '='
    )
  }

  return parts.join('')
}


/***/ }),
/* 33 */
/***/ (function(module, exports) {

exports.read = function (buffer, offset, isLE, mLen, nBytes) {
  var e, m
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var nBits = -7
  var i = isLE ? (nBytes - 1) : 0
  var d = isLE ? -1 : 1
  var s = buffer[offset + i]

  i += d

  e = s & ((1 << (-nBits)) - 1)
  s >>= (-nBits)
  nBits += eLen
  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  m = e & ((1 << (-nBits)) - 1)
  e >>= (-nBits)
  nBits += mLen
  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}

  if (e === 0) {
    e = 1 - eBias
  } else if (e === eMax) {
    return m ? NaN : ((s ? -1 : 1) * Infinity)
  } else {
    m = m + Math.pow(2, mLen)
    e = e - eBias
  }
  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
}

exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
  var e, m, c
  var eLen = (nBytes * 8) - mLen - 1
  var eMax = (1 << eLen) - 1
  var eBias = eMax >> 1
  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
  var i = isLE ? 0 : (nBytes - 1)
  var d = isLE ? 1 : -1
  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0

  value = Math.abs(value)

  if (isNaN(value) || value === Infinity) {
    m = isNaN(value) ? 1 : 0
    e = eMax
  } else {
    e = Math.floor(Math.log(value) / Math.LN2)
    if (value * (c = Math.pow(2, -e)) < 1) {
      e--
      c *= 2
    }
    if (e + eBias >= 1) {
      value += rt / c
    } else {
      value += rt * Math.pow(2, 1 - eBias)
    }
    if (value * c >= 2) {
      e++
      c /= 2
    }

    if (e + eBias >= eMax) {
      m = 0
      e = eMax
    } else if (e + eBias >= 1) {
      m = ((value * c) - 1) * Math.pow(2, mLen)
      e = e + eBias
    } else {
      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
      e = 0
    }
  }

  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

  e = (e << mLen) | m
  eLen += mLen
  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

  buffer[offset + i - d] |= s * 128
}


/***/ }),
/* 34 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = Array.isArray || function (arr) {
  return toString.call(arr) == '[object Array]';
};


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(3);

var _hasOwnProperty = Object.prototype.hasOwnProperty;
var _toString       = Object.prototype.toString;

function resolveYamlOmap(data) {
  if (data === null) return true;

  var objectKeys = [], index, length, pair, pairKey, pairHasKey,
      object = data;

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];
    pairHasKey = false;

    if (_toString.call(pair) !== '[object Object]') return false;

    for (pairKey in pair) {
      if (_hasOwnProperty.call(pair, pairKey)) {
        if (!pairHasKey) pairHasKey = true;
        else return false;
      }
    }

    if (!pairHasKey) return false;

    if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);
    else return false;
  }

  return true;
}

function constructYamlOmap(data) {
  return data !== null ? data : [];
}

module.exports = new Type('tag:yaml.org,2002:omap', {
  kind: 'sequence',
  resolve: resolveYamlOmap,
  construct: constructYamlOmap
});


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(3);

var _toString = Object.prototype.toString;

function resolveYamlPairs(data) {
  if (data === null) return true;

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    if (_toString.call(pair) !== '[object Object]') return false;

    keys = Object.keys(pair);

    if (keys.length !== 1) return false;

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return true;
}

function constructYamlPairs(data) {
  if (data === null) return [];

  var index, length, pair, keys, result,
      object = data;

  result = new Array(object.length);

  for (index = 0, length = object.length; index < length; index += 1) {
    pair = object[index];

    keys = Object.keys(pair);

    result[index] = [ keys[0], pair[keys[0]] ];
  }

  return result;
}

module.exports = new Type('tag:yaml.org,2002:pairs', {
  kind: 'sequence',
  resolve: resolveYamlPairs,
  construct: constructYamlPairs
});


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(3);

var _hasOwnProperty = Object.prototype.hasOwnProperty;

function resolveYamlSet(data) {
  if (data === null) return true;

  var key, object = data;

  for (key in object) {
    if (_hasOwnProperty.call(object, key)) {
      if (object[key] !== null) return false;
    }
  }

  return true;
}

function constructYamlSet(data) {
  return data !== null ? data : {};
}

module.exports = new Type('tag:yaml.org,2002:set', {
  kind: 'mapping',
  resolve: resolveYamlSet,
  construct: constructYamlSet
});


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(3);

function resolveJavascriptUndefined() {
  return true;
}

function constructJavascriptUndefined() {
  /*eslint-disable no-undefined*/
  return undefined;
}

function representJavascriptUndefined() {
  return '';
}

function isUndefined(object) {
  return typeof object === 'undefined';
}

module.exports = new Type('tag:yaml.org,2002:js/undefined', {
  kind: 'scalar',
  resolve: resolveJavascriptUndefined,
  construct: constructJavascriptUndefined,
  predicate: isUndefined,
  represent: representJavascriptUndefined
});


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Type = __webpack_require__(3);

function resolveJavascriptRegExp(data) {
  if (data === null) return false;
  if (data.length === 0) return false;

  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // if regexp starts with '/' it can have modifiers and must be properly closed
  // `/foo/gim` - modifiers tail can be maximum 3 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];

    if (modifiers.length > 3) return false;
    // if expression starts with /, is should be properly terminated
    if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
  }

  return true;
}

function constructJavascriptRegExp(data) {
  var regexp = data,
      tail   = /\/([gim]*)$/.exec(data),
      modifiers = '';

  // `/foo/gim` - tail can be maximum 4 chars
  if (regexp[0] === '/') {
    if (tail) modifiers = tail[1];
    regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
  }

  return new RegExp(regexp, modifiers);
}

function representJavascriptRegExp(object /*, style*/) {
  var result = '/' + object.source + '/';

  if (object.global) result += 'g';
  if (object.multiline) result += 'm';
  if (object.ignoreCase) result += 'i';

  return result;
}

function isRegExp(object) {
  return Object.prototype.toString.call(object) === '[object RegExp]';
}

module.exports = new Type('tag:yaml.org,2002:js/regexp', {
  kind: 'scalar',
  resolve: resolveJavascriptRegExp,
  construct: constructJavascriptRegExp,
  predicate: isRegExp,
  represent: representJavascriptRegExp
});


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var require;

var esprima;

// Browserified version does not have esprima
//
// 1. For node.js just require module as deps
// 2. For browser try to require mudule via external AMD system.
//    If not found - try to fallback to window.esprima. If not
//    found too - then fail to parse.
//
try {
  // workaround to exclude package from browserify list.
  var _require = require;
  esprima = __webpack_require__(41);
} catch (_) {
  /*global window */
  if (typeof window !== 'undefined') esprima = window.esprima;
}

var Type = __webpack_require__(3);

function resolveJavascriptFunction(data) {
  if (data === null) return false;

  try {
    var source = '(' + data + ')',
        ast    = esprima.parse(source, { range: true });

    if (ast.type                    !== 'Program'             ||
        ast.body.length             !== 1                     ||
        ast.body[0].type            !== 'ExpressionStatement' ||
        (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
          ast.body[0].expression.type !== 'FunctionExpression')) {
      return false;
    }

    return true;
  } catch (err) {
    return false;
  }
}

function constructJavascriptFunction(data) {
  /*jslint evil:true*/

  var source = '(' + data + ')',
      ast    = esprima.parse(source, { range: true }),
      params = [],
      body;

  if (ast.type                    !== 'Program'             ||
      ast.body.length             !== 1                     ||
      ast.body[0].type            !== 'ExpressionStatement' ||
      (ast.body[0].expression.type !== 'ArrowFunctionExpression' &&
        ast.body[0].expression.type !== 'FunctionExpression')) {
    throw new Error('Failed to resolve function');
  }

  ast.body[0].expression.params.forEach(function (param) {
    params.push(param.name);
  });

  body = ast.body[0].expression.body.range;

  // Esprima's ranges include the first '{' and the last '}' characters on
  // function expressions. So cut them out.
  if (ast.body[0].expression.body.type === 'BlockStatement') {
    /*eslint-disable no-new-func*/
    return new Function(params, source.slice(body[0] + 1, body[1] - 1));
  }
  // ES6 arrow functions can omit the BlockStatement. In that case, just return
  // the body.
  /*eslint-disable no-new-func*/
  return new Function(params, 'return ' + source.slice(body[0], body[1]));
}

function representJavascriptFunction(object /*, style*/) {
  return object.toString();
}

function isFunction(object) {
  return Object.prototype.toString.call(object) === '[object Function]';
}

module.exports = new Type('tag:yaml.org,2002:js/function', {
  kind: 'scalar',
  resolve: resolveJavascriptFunction,
  construct: constructJavascriptFunction,
  predicate: isFunction,
  represent: representJavascriptFunction
});


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

(function webpackUniversalModuleDefinition(root, factory) {
/* istanbul ignore next */
	if(true)
		module.exports = factory();
	else {}
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};

/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {

/******/ 		// Check if module is in cache
/* istanbul ignore if */
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;

/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};

/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);

/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;

/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}


/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;

/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;

/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";

/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	/*
	  Copyright JS Foundation and other contributors, https://js.foundation/

	  Redistribution and use in source and binary forms, with or without
	  modification, are permitted provided that the following conditions are met:

	    * Redistributions of source code must retain the above copyright
	      notice, this list of conditions and the following disclaimer.
	    * Redistributions in binary form must reproduce the above copyright
	      notice, this list of conditions and the following disclaimer in the
	      documentation and/or other materials provided with the distribution.

	  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
	  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
	  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
	  ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
	  DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
	  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
	  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
	  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
	  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
	  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
	*/
	Object.defineProperty(exports, "__esModule", { value: true });
	var comment_handler_1 = __webpack_require__(1);
	var jsx_parser_1 = __webpack_require__(3);
	var parser_1 = __webpack_require__(8);
	var tokenizer_1 = __webpack_require__(15);
	function parse(code, options, delegate) {
	    var commentHandler = null;
	    var proxyDelegate = function (node, metadata) {
	        if (delegate) {
	            delegate(node, metadata);
	        }
	        if (commentHandler) {
	            commentHandler.visit(node, metadata);
	        }
	    };
	    var parserDelegate = (typeof delegate === 'function') ? proxyDelegate : null;
	    var collectComment = false;
	    if (options) {
	        collectComment = (typeof options.comment === 'boolean' && options.comment);
	        var attachComment = (typeof options.attachComment === 'boolean' && options.attachComment);
	        if (collectComment || attachComment) {
	            commentHandler = new comment_handler_1.CommentHandler();
	            commentHandler.attach = attachComment;
	            options.comment = true;
	            parserDelegate = proxyDelegate;
	        }
	    }
	    var isModule = false;
	    if (options && typeof options.sourceType === 'string') {
	        isModule = (options.sourceType === 'module');
	    }
	    var parser;
	    if (options && typeof options.jsx === 'boolean' && options.jsx) {
	        parser = new jsx_parser_1.JSXParser(code, options, parserDelegate);
	    }
	    else {
	        parser = new parser_1.Parser(code, options, parserDelegate);
	    }
	    var program = isModule ? parser.parseModule() : parser.parseScript();
	    var ast = program;
	    if (collectComment && commentHandler) {
	        ast.comments = commentHandler.comments;
	    }
	    if (parser.config.tokens) {
	        ast.tokens = parser.tokens;
	    }
	    if (parser.config.tolerant) {
	        ast.errors = parser.errorHandler.errors;
	    }
	    return ast;
	}
	exports.parse = parse;
	function parseModule(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'module';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseModule = parseModule;
	function parseScript(code, options, delegate) {
	    var parsingOptions = options || {};
	    parsingOptions.sourceType = 'script';
	    return parse(code, parsingOptions, delegate);
	}
	exports.parseScript = parseScript;
	function tokenize(code, options, delegate) {
	    var tokenizer = new tokenizer_1.Tokenizer(code, options);
	    var tokens;
	    tokens = [];
	    try {
	        while (true) {
	            var token = tokenizer.getNextToken();
	            if (!token) {
	                break;
	            }
	            if (delegate) {
	                token = delegate(token);
	            }
	            tokens.push(token);
	        }
	    }
	    catch (e) {
	        tokenizer.errorHandler.tolerate(e);
	    }
	    if (tokenizer.errorHandler.tolerant) {
	        tokens.errors = tokenizer.errors();
	    }
	    return tokens;
	}
	exports.tokenize = tokenize;
	var syntax_1 = __webpack_require__(2);
	exports.Syntax = syntax_1.Syntax;
	// Sync with *.json manifests.
	exports.version = '4.0.1';


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __webpack_require__(2);
	var CommentHandler = (function () {
	    function CommentHandler() {
	        this.attach = false;
	        this.comments = [];
	        this.stack = [];
	        this.leading = [];
	        this.trailing = [];
	    }
	    CommentHandler.prototype.insertInnerComments = function (node, metadata) {
	        //  innnerComments for properties empty block
	        //  `function a() {/** comments **\/}`
	        if (node.type === syntax_1.Syntax.BlockStatement && node.body.length === 0) {
	            var innerComments = [];
	            for (var i = this.leading.length - 1; i >= 0; --i) {
	                var entry = this.leading[i];
	                if (metadata.end.offset >= entry.start) {
	                    innerComments.unshift(entry.comment);
	                    this.leading.splice(i, 1);
	                    this.trailing.splice(i, 1);
	                }
	            }
	            if (innerComments.length) {
	                node.innerComments = innerComments;
	            }
	        }
	    };
	    CommentHandler.prototype.findTrailingComments = function (metadata) {
	        var trailingComments = [];
	        if (this.trailing.length > 0) {
	            for (var i = this.trailing.length - 1; i >= 0; --i) {
	                var entry_1 = this.trailing[i];
	                if (entry_1.start >= metadata.end.offset) {
	                    trailingComments.unshift(entry_1.comment);
	                }
	            }
	            this.trailing.length = 0;
	            return trailingComments;
	        }
	        var entry = this.stack[this.stack.length - 1];
	        if (entry && entry.node.trailingComments) {
	            var firstComment = entry.node.trailingComments[0];
	            if (firstComment && firstComment.range[0] >= metadata.end.offset) {
	                trailingComments = entry.node.trailingComments;
	                delete entry.node.trailingComments;
	            }
	        }
	        return trailingComments;
	    };
	    CommentHandler.prototype.findLeadingComments = function (metadata) {
	        var leadingComments = [];
	        var target;
	        while (this.stack.length > 0) {
	            var entry = this.stack[this.stack.length - 1];
	            if (entry && entry.start >= metadata.start.offset) {
	                target = entry.node;
	                this.stack.pop();
	            }
	            else {
	                break;
	            }
	        }
	        if (target) {
	            var count = target.leadingComments ? target.leadingComments.length : 0;
	            for (var i = count - 1; i >= 0; --i) {
	                var comment = target.leadingComments[i];
	                if (comment.range[1] <= metadata.start.offset) {
	                    leadingComments.unshift(comment);
	                    target.leadingComments.splice(i, 1);
	                }
	            }
	            if (target.leadingComments && target.leadingComments.length === 0) {
	                delete target.leadingComments;
	            }
	            return leadingComments;
	        }
	        for (var i = this.leading.length - 1; i >= 0; --i) {
	            var entry = this.leading[i];
	            if (entry.start <= metadata.start.offset) {
	                leadingComments.unshift(entry.comment);
	                this.leading.splice(i, 1);
	            }
	        }
	        return leadingComments;
	    };
	    CommentHandler.prototype.visitNode = function (node, metadata) {
	        if (node.type === syntax_1.Syntax.Program && node.body.length > 0) {
	            return;
	        }
	        this.insertInnerComments(node, metadata);
	        var trailingComments = this.findTrailingComments(metadata);
	        var leadingComments = this.findLeadingComments(metadata);
	        if (leadingComments.length > 0) {
	            node.leadingComments = leadingComments;
	        }
	        if (trailingComments.length > 0) {
	            node.trailingComments = trailingComments;
	        }
	        this.stack.push({
	            node: node,
	            start: metadata.start.offset
	        });
	    };
	    CommentHandler.prototype.visitComment = function (node, metadata) {
	        var type = (node.type[0] === 'L') ? 'Line' : 'Block';
	        var comment = {
	            type: type,
	            value: node.value
	        };
	        if (node.range) {
	            comment.range = node.range;
	        }
	        if (node.loc) {
	            comment.loc = node.loc;
	        }
	        this.comments.push(comment);
	        if (this.attach) {
	            var entry = {
	                comment: {
	                    type: type,
	                    value: node.value,
	                    range: [metadata.start.offset, metadata.end.offset]
	                },
	                start: metadata.start.offset
	            };
	            if (node.loc) {
	                entry.comment.loc = node.loc;
	            }
	            node.type = type;
	            this.leading.push(entry);
	            this.trailing.push(entry);
	        }
	    };
	    CommentHandler.prototype.visit = function (node, metadata) {
	        if (node.type === 'LineComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (node.type === 'BlockComment') {
	            this.visitComment(node, metadata);
	        }
	        else if (this.attach) {
	            this.visitNode(node, metadata);
	        }
	    };
	    return CommentHandler;
	}());
	exports.CommentHandler = CommentHandler;


/***/ },
/* 2 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.Syntax = {
	    AssignmentExpression: 'AssignmentExpression',
	    AssignmentPattern: 'AssignmentPattern',
	    ArrayExpression: 'ArrayExpression',
	    ArrayPattern: 'ArrayPattern',
	    ArrowFunctionExpression: 'ArrowFunctionExpression',
	    AwaitExpression: 'AwaitExpression',
	    BlockStatement: 'BlockStatement',
	    BinaryExpression: 'BinaryExpression',
	    BreakStatement: 'BreakStatement',
	    CallExpression: 'CallExpression',
	    CatchClause: 'CatchClause',
	    ClassBody: 'ClassBody',
	    ClassDeclaration: 'ClassDeclaration',
	    ClassExpression: 'ClassExpression',
	    ConditionalExpression: 'ConditionalExpression',
	    ContinueStatement: 'ContinueStatement',
	    DoWhileStatement: 'DoWhileStatement',
	    DebuggerStatement: 'DebuggerStatement',
	    EmptyStatement: 'EmptyStatement',
	    ExportAllDeclaration: 'ExportAllDeclaration',
	    ExportDefaultDeclaration: 'ExportDefaultDeclaration',
	    ExportNamedDeclaration: 'ExportNamedDeclaration',
	    ExportSpecifier: 'ExportSpecifier',
	    ExpressionStatement: 'ExpressionStatement',
	    ForStatement: 'ForStatement',
	    ForOfStatement: 'ForOfStatement',
	    ForInStatement: 'ForInStatement',
	    FunctionDeclaration: 'FunctionDeclaration',
	    FunctionExpression: 'FunctionExpression',
	    Identifier: 'Identifier',
	    IfStatement: 'IfStatement',
	    ImportDeclaration: 'ImportDeclaration',
	    ImportDefaultSpecifier: 'ImportDefaultSpecifier',
	    ImportNamespaceSpecifier: 'ImportNamespaceSpecifier',
	    ImportSpecifier: 'ImportSpecifier',
	    Literal: 'Literal',
	    LabeledStatement: 'LabeledStatement',
	    LogicalExpression: 'LogicalExpression',
	    MemberExpression: 'MemberExpression',
	    MetaProperty: 'MetaProperty',
	    MethodDefinition: 'MethodDefinition',
	    NewExpression: 'NewExpression',
	    ObjectExpression: 'ObjectExpression',
	    ObjectPattern: 'ObjectPattern',
	    Program: 'Program',
	    Property: 'Property',
	    RestElement: 'RestElement',
	    ReturnStatement: 'ReturnStatement',
	    SequenceExpression: 'SequenceExpression',
	    SpreadElement: 'SpreadElement',
	    Super: 'Super',
	    SwitchCase: 'SwitchCase',
	    SwitchStatement: 'SwitchStatement',
	    TaggedTemplateExpression: 'TaggedTemplateExpression',
	    TemplateElement: 'TemplateElement',
	    TemplateLiteral: 'TemplateLiteral',
	    ThisExpression: 'ThisExpression',
	    ThrowStatement: 'ThrowStatement',
	    TryStatement: 'TryStatement',
	    UnaryExpression: 'UnaryExpression',
	    UpdateExpression: 'UpdateExpression',
	    VariableDeclaration: 'VariableDeclaration',
	    VariableDeclarator: 'VariableDeclarator',
	    WhileStatement: 'WhileStatement',
	    WithStatement: 'WithStatement',
	    YieldExpression: 'YieldExpression'
	};


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
/* istanbul ignore next */
	var __extends = (this && this.__extends) || (function () {
	    var extendStatics = Object.setPrototypeOf ||
	        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
	        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
	    return function (d, b) {
	        extendStatics(d, b);
	        function __() { this.constructor = d; }
	        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	    };
	})();
	Object.defineProperty(exports, "__esModule", { value: true });
	var character_1 = __webpack_require__(4);
	var JSXNode = __webpack_require__(5);
	var jsx_syntax_1 = __webpack_require__(6);
	var Node = __webpack_require__(7);
	var parser_1 = __webpack_require__(8);
	var token_1 = __webpack_require__(13);
	var xhtml_entities_1 = __webpack_require__(14);
	token_1.TokenName[100 /* Identifier */] = 'JSXIdentifier';
	token_1.TokenName[101 /* Text */] = 'JSXText';
	// Fully qualified element name, e.g. <svg:path> returns "svg:path"
	function getQualifiedElementName(elementName) {
	    var qualifiedName;
	    switch (elementName.type) {
	        case jsx_syntax_1.JSXSyntax.JSXIdentifier:
	            var id = elementName;
	            qualifiedName = id.name;
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXNamespacedName:
	            var ns = elementName;
	            qualifiedName = getQualifiedElementName(ns.namespace) + ':' +
	                getQualifiedElementName(ns.name);
	            break;
	        case jsx_syntax_1.JSXSyntax.JSXMemberExpression:
	            var expr = elementName;
	            qualifiedName = getQualifiedElementName(expr.object) + '.' +
	                getQualifiedElementName(expr.property);
	            break;
	        /* istanbul ignore next */
	        default:
	            break;
	    }
	    return qualifiedName;
	}
	var JSXParser = (function (_super) {
	    __extends(JSXParser, _super);
	    function JSXParser(code, options, delegate) {
	        return _super.call(this, code, options, delegate) || this;
	    }
	    JSXParser.prototype.parsePrimaryExpression = function () {
	        return this.match('<') ? this.parseJSXRoot() : _super.prototype.parsePrimaryExpression.call(this);
	    };
	    JSXParser.prototype.startJSX = function () {
	        // Unwind the scanner before the lookahead token.
	        this.scanner.index = this.startMarker.index;
	        this.scanner.lineNumber = this.startMarker.line;
	        this.scanner.lineStart = this.startMarker.index - this.startMarker.column;
	    };
	    JSXParser.prototype.finishJSX = function () {
	        // Prime the next lookahead.
	        this.nextToken();
	    };
	    JSXParser.prototype.reenterJSX = function () {
	        this.startJSX();
	        this.expectJSX('}');
	        // Pop the closing '}' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	    };
	    JSXParser.prototype.createJSXNode = function () {
	        this.collectComments();
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.createJSXChildNode = function () {
	        return {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    };
	    JSXParser.prototype.scanXHTMLEntity = function (quote) {
	        var result = '&';
	        var valid = true;
	        var terminated = false;
	        var numeric = false;
	        var hex = false;
	        while (!this.scanner.eof() && valid && !terminated) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === quote) {
	                break;
	            }
	            terminated = (ch === ';');
	            result += ch;
	            ++this.scanner.index;
	            if (!terminated) {
	                switch (result.length) {
	                    case 2:
	                        // e.g. '&#123;'
	                        numeric = (ch === '#');
	                        break;
	                    case 3:
	                        if (numeric) {
	                            // e.g. '&#x41;'
	                            hex = (ch === 'x');
	                            valid = hex || character_1.Character.isDecimalDigit(ch.charCodeAt(0));
	                            numeric = numeric && !hex;
	                        }
	                        break;
	                    default:
	                        valid = valid && !(numeric && !character_1.Character.isDecimalDigit(ch.charCodeAt(0)));
	                        valid = valid && !(hex && !character_1.Character.isHexDigit(ch.charCodeAt(0)));
	                        break;
	                }
	            }
	        }
	        if (valid && terminated && result.length > 2) {
	            // e.g. '&#x41;' becomes just '#x41'
	            var str = result.substr(1, result.length - 2);
	            if (numeric && str.length > 1) {
	                result = String.fromCharCode(parseInt(str.substr(1), 10));
	            }
	            else if (hex && str.length > 2) {
	                result = String.fromCharCode(parseInt('0' + str.substr(1), 16));
	            }
	            else if (!numeric && !hex && xhtml_entities_1.XHTMLEntities[str]) {
	                result = xhtml_entities_1.XHTMLEntities[str];
	            }
	        }
	        return result;
	    };
	    // Scan the next JSX token. This replaces Scanner#lex when in JSX mode.
	    JSXParser.prototype.lexJSX = function () {
	        var cp = this.scanner.source.charCodeAt(this.scanner.index);
	        // < > / : = { }
	        if (cp === 60 || cp === 62 || cp === 47 || cp === 58 || cp === 61 || cp === 123 || cp === 125) {
	            var value = this.scanner.source[this.scanner.index++];
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index - 1,
	                end: this.scanner.index
	            };
	        }
	        // " '
	        if (cp === 34 || cp === 39) {
	            var start = this.scanner.index;
	            var quote = this.scanner.source[this.scanner.index++];
	            var str = '';
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source[this.scanner.index++];
	                if (ch === quote) {
	                    break;
	                }
	                else if (ch === '&') {
	                    str += this.scanXHTMLEntity(quote);
	                }
	                else {
	                    str += ch;
	                }
	            }
	            return {
	                type: 8 /* StringLiteral */,
	                value: str,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // ... or .
	        if (cp === 46) {
	            var n1 = this.scanner.source.charCodeAt(this.scanner.index + 1);
	            var n2 = this.scanner.source.charCodeAt(this.scanner.index + 2);
	            var value = (n1 === 46 && n2 === 46) ? '...' : '.';
	            var start = this.scanner.index;
	            this.scanner.index += value.length;
	            return {
	                type: 7 /* Punctuator */,
	                value: value,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        // `
	        if (cp === 96) {
	            // Only placeholder, since it will be rescanned as a real assignment expression.
	            return {
	                type: 10 /* Template */,
	                value: '',
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: this.scanner.index,
	                end: this.scanner.index
	            };
	        }
	        // Identifer can not contain backslash (char code 92).
	        if (character_1.Character.isIdentifierStart(cp) && (cp !== 92)) {
	            var start = this.scanner.index;
	            ++this.scanner.index;
	            while (!this.scanner.eof()) {
	                var ch = this.scanner.source.charCodeAt(this.scanner.index);
	                if (character_1.Character.isIdentifierPart(ch) && (ch !== 92)) {
	                    ++this.scanner.index;
	                }
	                else if (ch === 45) {
	                    // Hyphen (char code 45) can be part of an identifier.
	                    ++this.scanner.index;
	                }
	                else {
	                    break;
	                }
	            }
	            var id = this.scanner.source.slice(start, this.scanner.index);
	            return {
	                type: 100 /* Identifier */,
	                value: id,
	                lineNumber: this.scanner.lineNumber,
	                lineStart: this.scanner.lineStart,
	                start: start,
	                end: this.scanner.index
	            };
	        }
	        return this.scanner.lex();
	    };
	    JSXParser.prototype.nextJSXToken = function () {
	        this.collectComments();
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = this.lexJSX();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        if (this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.nextJSXText = function () {
	        this.startMarker.index = this.scanner.index;
	        this.startMarker.line = this.scanner.lineNumber;
	        this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        var start = this.scanner.index;
	        var text = '';
	        while (!this.scanner.eof()) {
	            var ch = this.scanner.source[this.scanner.index];
	            if (ch === '{' || ch === '<') {
	                break;
	            }
	            ++this.scanner.index;
	            text += ch;
	            if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.scanner.lineNumber;
	                if (ch === '\r' && this.scanner.source[this.scanner.index] === '\n') {
	                    ++this.scanner.index;
	                }
	                this.scanner.lineStart = this.scanner.index;
	            }
	        }
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        var token = {
	            type: 101 /* Text */,
	            value: text,
	            lineNumber: this.scanner.lineNumber,
	            lineStart: this.scanner.lineStart,
	            start: start,
	            end: this.scanner.index
	        };
	        if ((text.length > 0) && this.config.tokens) {
	            this.tokens.push(this.convertToken(token));
	        }
	        return token;
	    };
	    JSXParser.prototype.peekJSXToken = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.lexJSX();
	        this.scanner.restoreState(state);
	        return next;
	    };
	    // Expect the next JSX token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    JSXParser.prototype.expectJSX = function (value) {
	        var token = this.nextJSXToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next JSX token matches the specified punctuator.
	    JSXParser.prototype.matchJSX = function (value) {
	        var next = this.peekJSXToken();
	        return next.type === 7 /* Punctuator */ && next.value === value;
	    };
	    JSXParser.prototype.parseJSXIdentifier = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 100 /* Identifier */) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new JSXNode.JSXIdentifier(token.value));
	    };
	    JSXParser.prototype.parseJSXElementName = function () {
	        var node = this.createJSXNode();
	        var elementName = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = elementName;
	            this.expectJSX(':');
	            var name_1 = this.parseJSXIdentifier();
	            elementName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_1));
	        }
	        else if (this.matchJSX('.')) {
	            while (this.matchJSX('.')) {
	                var object = elementName;
	                this.expectJSX('.');
	                var property = this.parseJSXIdentifier();
	                elementName = this.finalize(node, new JSXNode.JSXMemberExpression(object, property));
	            }
	        }
	        return elementName;
	    };
	    JSXParser.prototype.parseJSXAttributeName = function () {
	        var node = this.createJSXNode();
	        var attributeName;
	        var identifier = this.parseJSXIdentifier();
	        if (this.matchJSX(':')) {
	            var namespace = identifier;
	            this.expectJSX(':');
	            var name_2 = this.parseJSXIdentifier();
	            attributeName = this.finalize(node, new JSXNode.JSXNamespacedName(namespace, name_2));
	        }
	        else {
	            attributeName = identifier;
	        }
	        return attributeName;
	    };
	    JSXParser.prototype.parseJSXStringLiteralAttribute = function () {
	        var node = this.createJSXNode();
	        var token = this.nextJSXToken();
	        if (token.type !== 8 /* StringLiteral */) {
	            this.throwUnexpectedToken(token);
	        }
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    JSXParser.prototype.parseJSXExpressionAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.finishJSX();
	        if (this.match('}')) {
	            this.tolerateError('JSX attributes must only be assigned a non-empty expression');
	        }
	        var expression = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXAttributeValue = function () {
	        return this.matchJSX('{') ? this.parseJSXExpressionAttribute() :
	            this.matchJSX('<') ? this.parseJSXElement() : this.parseJSXStringLiteralAttribute();
	    };
	    JSXParser.prototype.parseJSXNameValueAttribute = function () {
	        var node = this.createJSXNode();
	        var name = this.parseJSXAttributeName();
	        var value = null;
	        if (this.matchJSX('=')) {
	            this.expectJSX('=');
	            value = this.parseJSXAttributeValue();
	        }
	        return this.finalize(node, new JSXNode.JSXAttribute(name, value));
	    };
	    JSXParser.prototype.parseJSXSpreadAttribute = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        this.expectJSX('...');
	        this.finishJSX();
	        var argument = this.parseAssignmentExpression();
	        this.reenterJSX();
	        return this.finalize(node, new JSXNode.JSXSpreadAttribute(argument));
	    };
	    JSXParser.prototype.parseJSXAttributes = function () {
	        var attributes = [];
	        while (!this.matchJSX('/') && !this.matchJSX('>')) {
	            var attribute = this.matchJSX('{') ? this.parseJSXSpreadAttribute() :
	                this.parseJSXNameValueAttribute();
	            attributes.push(attribute);
	        }
	        return attributes;
	    };
	    JSXParser.prototype.parseJSXOpeningElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXBoundaryElement = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('<');
	        if (this.matchJSX('/')) {
	            this.expectJSX('/');
	            var name_3 = this.parseJSXElementName();
	            this.expectJSX('>');
	            return this.finalize(node, new JSXNode.JSXClosingElement(name_3));
	        }
	        var name = this.parseJSXElementName();
	        var attributes = this.parseJSXAttributes();
	        var selfClosing = this.matchJSX('/');
	        if (selfClosing) {
	            this.expectJSX('/');
	        }
	        this.expectJSX('>');
	        return this.finalize(node, new JSXNode.JSXOpeningElement(name, selfClosing, attributes));
	    };
	    JSXParser.prototype.parseJSXEmptyExpression = function () {
	        var node = this.createJSXChildNode();
	        this.collectComments();
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        return this.finalize(node, new JSXNode.JSXEmptyExpression());
	    };
	    JSXParser.prototype.parseJSXExpressionContainer = function () {
	        var node = this.createJSXNode();
	        this.expectJSX('{');
	        var expression;
	        if (this.matchJSX('}')) {
	            expression = this.parseJSXEmptyExpression();
	            this.expectJSX('}');
	        }
	        else {
	            this.finishJSX();
	            expression = this.parseAssignmentExpression();
	            this.reenterJSX();
	        }
	        return this.finalize(node, new JSXNode.JSXExpressionContainer(expression));
	    };
	    JSXParser.prototype.parseJSXChildren = function () {
	        var children = [];
	        while (!this.scanner.eof()) {
	            var node = this.createJSXChildNode();
	            var token = this.nextJSXText();
	            if (token.start < token.end) {
	                var raw = this.getTokenRaw(token);
	                var child = this.finalize(node, new JSXNode.JSXText(token.value, raw));
	                children.push(child);
	            }
	            if (this.scanner.source[this.scanner.index] === '{') {
	                var container = this.parseJSXExpressionContainer();
	                children.push(container);
	            }
	            else {
	                break;
	            }
	        }
	        return children;
	    };
	    JSXParser.prototype.parseComplexJSXElement = function (el) {
	        var stack = [];
	        while (!this.scanner.eof()) {
	            el.children = el.children.concat(this.parseJSXChildren());
	            var node = this.createJSXChildNode();
	            var element = this.parseJSXBoundaryElement();
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXOpeningElement) {
	                var opening = element;
	                if (opening.selfClosing) {
	                    var child = this.finalize(node, new JSXNode.JSXElement(opening, [], null));
	                    el.children.push(child);
	                }
	                else {
	                    stack.push(el);
	                    el = { node: node, opening: opening, closing: null, children: [] };
	                }
	            }
	            if (element.type === jsx_syntax_1.JSXSyntax.JSXClosingElement) {
	                el.closing = element;
	                var open_1 = getQualifiedElementName(el.opening.name);
	                var close_1 = getQualifiedElementName(el.closing.name);
	                if (open_1 !== close_1) {
	                    this.tolerateError('Expected corresponding JSX closing tag for %0', open_1);
	                }
	                if (stack.length > 0) {
	                    var child = this.finalize(el.node, new JSXNode.JSXElement(el.opening, el.children, el.closing));
	                    el = stack[stack.length - 1];
	                    el.children.push(child);
	                    stack.pop();
	                }
	                else {
	                    break;
	                }
	            }
	        }
	        return el;
	    };
	    JSXParser.prototype.parseJSXElement = function () {
	        var node = this.createJSXNode();
	        var opening = this.parseJSXOpeningElement();
	        var children = [];
	        var closing = null;
	        if (!opening.selfClosing) {
	            var el = this.parseComplexJSXElement({ node: node, opening: opening, closing: closing, children: children });
	            children = el.children;
	            closing = el.closing;
	        }
	        return this.finalize(node, new JSXNode.JSXElement(opening, children, closing));
	    };
	    JSXParser.prototype.parseJSXRoot = function () {
	        // Pop the opening '<' added from the lookahead.
	        if (this.config.tokens) {
	            this.tokens.pop();
	        }
	        this.startJSX();
	        var element = this.parseJSXElement();
	        this.finishJSX();
	        return element;
	    };
	    JSXParser.prototype.isStartOfExpression = function () {
	        return _super.prototype.isStartOfExpression.call(this) || this.match('<');
	    };
	    return JSXParser;
	}(parser_1.Parser));
	exports.JSXParser = JSXParser;


/***/ },
/* 4 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// See also tools/generate-unicode-regex.js.
	var Regex = {
	    // Unicode v8.0.0 NonAsciiIdentifierStart:
	    NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
	    // Unicode v8.0.0 NonAsciiIdentifierPart:
	    NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C81-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFC-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AD\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C4\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
	};
	exports.Character = {
	    /* tslint:disable:no-bitwise */
	    fromCodePoint: function (cp) {
	        return (cp < 0x10000) ? String.fromCharCode(cp) :
	            String.fromCharCode(0xD800 + ((cp - 0x10000) >> 10)) +
	                String.fromCharCode(0xDC00 + ((cp - 0x10000) & 1023));
	    },
	    // https://tc39.github.io/ecma262/#sec-white-space
	    isWhiteSpace: function (cp) {
	        return (cp === 0x20) || (cp === 0x09) || (cp === 0x0B) || (cp === 0x0C) || (cp === 0xA0) ||
	            (cp >= 0x1680 && [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF].indexOf(cp) >= 0);
	    },
	    // https://tc39.github.io/ecma262/#sec-line-terminators
	    isLineTerminator: function (cp) {
	        return (cp === 0x0A) || (cp === 0x0D) || (cp === 0x2028) || (cp === 0x2029);
	    },
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    isIdentifierStart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierStart.test(exports.Character.fromCodePoint(cp)));
	    },
	    isIdentifierPart: function (cp) {
	        return (cp === 0x24) || (cp === 0x5F) ||
	            (cp >= 0x41 && cp <= 0x5A) ||
	            (cp >= 0x61 && cp <= 0x7A) ||
	            (cp >= 0x30 && cp <= 0x39) ||
	            (cp === 0x5C) ||
	            ((cp >= 0x80) && Regex.NonAsciiIdentifierPart.test(exports.Character.fromCodePoint(cp)));
	    },
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    isDecimalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39); // 0..9
	    },
	    isHexDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x39) ||
	            (cp >= 0x41 && cp <= 0x46) ||
	            (cp >= 0x61 && cp <= 0x66); // a..f
	    },
	    isOctalDigit: function (cp) {
	        return (cp >= 0x30 && cp <= 0x37); // 0..7
	    }
	};


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var jsx_syntax_1 = __webpack_require__(6);
	/* tslint:disable:max-classes-per-file */
	var JSXClosingElement = (function () {
	    function JSXClosingElement(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXClosingElement;
	        this.name = name;
	    }
	    return JSXClosingElement;
	}());
	exports.JSXClosingElement = JSXClosingElement;
	var JSXElement = (function () {
	    function JSXElement(openingElement, children, closingElement) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXElement;
	        this.openingElement = openingElement;
	        this.children = children;
	        this.closingElement = closingElement;
	    }
	    return JSXElement;
	}());
	exports.JSXElement = JSXElement;
	var JSXEmptyExpression = (function () {
	    function JSXEmptyExpression() {
	        this.type = jsx_syntax_1.JSXSyntax.JSXEmptyExpression;
	    }
	    return JSXEmptyExpression;
	}());
	exports.JSXEmptyExpression = JSXEmptyExpression;
	var JSXExpressionContainer = (function () {
	    function JSXExpressionContainer(expression) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXExpressionContainer;
	        this.expression = expression;
	    }
	    return JSXExpressionContainer;
	}());
	exports.JSXExpressionContainer = JSXExpressionContainer;
	var JSXIdentifier = (function () {
	    function JSXIdentifier(name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXIdentifier;
	        this.name = name;
	    }
	    return JSXIdentifier;
	}());
	exports.JSXIdentifier = JSXIdentifier;
	var JSXMemberExpression = (function () {
	    function JSXMemberExpression(object, property) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXMemberExpression;
	        this.object = object;
	        this.property = property;
	    }
	    return JSXMemberExpression;
	}());
	exports.JSXMemberExpression = JSXMemberExpression;
	var JSXAttribute = (function () {
	    function JSXAttribute(name, value) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXAttribute;
	        this.name = name;
	        this.value = value;
	    }
	    return JSXAttribute;
	}());
	exports.JSXAttribute = JSXAttribute;
	var JSXNamespacedName = (function () {
	    function JSXNamespacedName(namespace, name) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXNamespacedName;
	        this.namespace = namespace;
	        this.name = name;
	    }
	    return JSXNamespacedName;
	}());
	exports.JSXNamespacedName = JSXNamespacedName;
	var JSXOpeningElement = (function () {
	    function JSXOpeningElement(name, selfClosing, attributes) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXOpeningElement;
	        this.name = name;
	        this.selfClosing = selfClosing;
	        this.attributes = attributes;
	    }
	    return JSXOpeningElement;
	}());
	exports.JSXOpeningElement = JSXOpeningElement;
	var JSXSpreadAttribute = (function () {
	    function JSXSpreadAttribute(argument) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXSpreadAttribute;
	        this.argument = argument;
	    }
	    return JSXSpreadAttribute;
	}());
	exports.JSXSpreadAttribute = JSXSpreadAttribute;
	var JSXText = (function () {
	    function JSXText(value, raw) {
	        this.type = jsx_syntax_1.JSXSyntax.JSXText;
	        this.value = value;
	        this.raw = raw;
	    }
	    return JSXText;
	}());
	exports.JSXText = JSXText;


/***/ },
/* 6 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.JSXSyntax = {
	    JSXAttribute: 'JSXAttribute',
	    JSXClosingElement: 'JSXClosingElement',
	    JSXElement: 'JSXElement',
	    JSXEmptyExpression: 'JSXEmptyExpression',
	    JSXExpressionContainer: 'JSXExpressionContainer',
	    JSXIdentifier: 'JSXIdentifier',
	    JSXMemberExpression: 'JSXMemberExpression',
	    JSXNamespacedName: 'JSXNamespacedName',
	    JSXOpeningElement: 'JSXOpeningElement',
	    JSXSpreadAttribute: 'JSXSpreadAttribute',
	    JSXText: 'JSXText'
	};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var syntax_1 = __webpack_require__(2);
	/* tslint:disable:max-classes-per-file */
	var ArrayExpression = (function () {
	    function ArrayExpression(elements) {
	        this.type = syntax_1.Syntax.ArrayExpression;
	        this.elements = elements;
	    }
	    return ArrayExpression;
	}());
	exports.ArrayExpression = ArrayExpression;
	var ArrayPattern = (function () {
	    function ArrayPattern(elements) {
	        this.type = syntax_1.Syntax.ArrayPattern;
	        this.elements = elements;
	    }
	    return ArrayPattern;
	}());
	exports.ArrayPattern = ArrayPattern;
	var ArrowFunctionExpression = (function () {
	    function ArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = false;
	    }
	    return ArrowFunctionExpression;
	}());
	exports.ArrowFunctionExpression = ArrowFunctionExpression;
	var AssignmentExpression = (function () {
	    function AssignmentExpression(operator, left, right) {
	        this.type = syntax_1.Syntax.AssignmentExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentExpression;
	}());
	exports.AssignmentExpression = AssignmentExpression;
	var AssignmentPattern = (function () {
	    function AssignmentPattern(left, right) {
	        this.type = syntax_1.Syntax.AssignmentPattern;
	        this.left = left;
	        this.right = right;
	    }
	    return AssignmentPattern;
	}());
	exports.AssignmentPattern = AssignmentPattern;
	var AsyncArrowFunctionExpression = (function () {
	    function AsyncArrowFunctionExpression(params, body, expression) {
	        this.type = syntax_1.Syntax.ArrowFunctionExpression;
	        this.id = null;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = expression;
	        this.async = true;
	    }
	    return AsyncArrowFunctionExpression;
	}());
	exports.AsyncArrowFunctionExpression = AsyncArrowFunctionExpression;
	var AsyncFunctionDeclaration = (function () {
	    function AsyncFunctionDeclaration(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionDeclaration;
	}());
	exports.AsyncFunctionDeclaration = AsyncFunctionDeclaration;
	var AsyncFunctionExpression = (function () {
	    function AsyncFunctionExpression(id, params, body) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = false;
	        this.expression = false;
	        this.async = true;
	    }
	    return AsyncFunctionExpression;
	}());
	exports.AsyncFunctionExpression = AsyncFunctionExpression;
	var AwaitExpression = (function () {
	    function AwaitExpression(argument) {
	        this.type = syntax_1.Syntax.AwaitExpression;
	        this.argument = argument;
	    }
	    return AwaitExpression;
	}());
	exports.AwaitExpression = AwaitExpression;
	var BinaryExpression = (function () {
	    function BinaryExpression(operator, left, right) {
	        var logical = (operator === '||' || operator === '&&');
	        this.type = logical ? syntax_1.Syntax.LogicalExpression : syntax_1.Syntax.BinaryExpression;
	        this.operator = operator;
	        this.left = left;
	        this.right = right;
	    }
	    return BinaryExpression;
	}());
	exports.BinaryExpression = BinaryExpression;
	var BlockStatement = (function () {
	    function BlockStatement(body) {
	        this.type = syntax_1.Syntax.BlockStatement;
	        this.body = body;
	    }
	    return BlockStatement;
	}());
	exports.BlockStatement = BlockStatement;
	var BreakStatement = (function () {
	    function BreakStatement(label) {
	        this.type = syntax_1.Syntax.BreakStatement;
	        this.label = label;
	    }
	    return BreakStatement;
	}());
	exports.BreakStatement = BreakStatement;
	var CallExpression = (function () {
	    function CallExpression(callee, args) {
	        this.type = syntax_1.Syntax.CallExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return CallExpression;
	}());
	exports.CallExpression = CallExpression;
	var CatchClause = (function () {
	    function CatchClause(param, body) {
	        this.type = syntax_1.Syntax.CatchClause;
	        this.param = param;
	        this.body = body;
	    }
	    return CatchClause;
	}());
	exports.CatchClause = CatchClause;
	var ClassBody = (function () {
	    function ClassBody(body) {
	        this.type = syntax_1.Syntax.ClassBody;
	        this.body = body;
	    }
	    return ClassBody;
	}());
	exports.ClassBody = ClassBody;
	var ClassDeclaration = (function () {
	    function ClassDeclaration(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassDeclaration;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassDeclaration;
	}());
	exports.ClassDeclaration = ClassDeclaration;
	var ClassExpression = (function () {
	    function ClassExpression(id, superClass, body) {
	        this.type = syntax_1.Syntax.ClassExpression;
	        this.id = id;
	        this.superClass = superClass;
	        this.body = body;
	    }
	    return ClassExpression;
	}());
	exports.ClassExpression = ClassExpression;
	var ComputedMemberExpression = (function () {
	    function ComputedMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = true;
	        this.object = object;
	        this.property = property;
	    }
	    return ComputedMemberExpression;
	}());
	exports.ComputedMemberExpression = ComputedMemberExpression;
	var ConditionalExpression = (function () {
	    function ConditionalExpression(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.ConditionalExpression;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return ConditionalExpression;
	}());
	exports.ConditionalExpression = ConditionalExpression;
	var ContinueStatement = (function () {
	    function ContinueStatement(label) {
	        this.type = syntax_1.Syntax.ContinueStatement;
	        this.label = label;
	    }
	    return ContinueStatement;
	}());
	exports.ContinueStatement = ContinueStatement;
	var DebuggerStatement = (function () {
	    function DebuggerStatement() {
	        this.type = syntax_1.Syntax.DebuggerStatement;
	    }
	    return DebuggerStatement;
	}());
	exports.DebuggerStatement = DebuggerStatement;
	var Directive = (function () {
	    function Directive(expression, directive) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	        this.directive = directive;
	    }
	    return Directive;
	}());
	exports.Directive = Directive;
	var DoWhileStatement = (function () {
	    function DoWhileStatement(body, test) {
	        this.type = syntax_1.Syntax.DoWhileStatement;
	        this.body = body;
	        this.test = test;
	    }
	    return DoWhileStatement;
	}());
	exports.DoWhileStatement = DoWhileStatement;
	var EmptyStatement = (function () {
	    function EmptyStatement() {
	        this.type = syntax_1.Syntax.EmptyStatement;
	    }
	    return EmptyStatement;
	}());
	exports.EmptyStatement = EmptyStatement;
	var ExportAllDeclaration = (function () {
	    function ExportAllDeclaration(source) {
	        this.type = syntax_1.Syntax.ExportAllDeclaration;
	        this.source = source;
	    }
	    return ExportAllDeclaration;
	}());
	exports.ExportAllDeclaration = ExportAllDeclaration;
	var ExportDefaultDeclaration = (function () {
	    function ExportDefaultDeclaration(declaration) {
	        this.type = syntax_1.Syntax.ExportDefaultDeclaration;
	        this.declaration = declaration;
	    }
	    return ExportDefaultDeclaration;
	}());
	exports.ExportDefaultDeclaration = ExportDefaultDeclaration;
	var ExportNamedDeclaration = (function () {
	    function ExportNamedDeclaration(declaration, specifiers, source) {
	        this.type = syntax_1.Syntax.ExportNamedDeclaration;
	        this.declaration = declaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ExportNamedDeclaration;
	}());
	exports.ExportNamedDeclaration = ExportNamedDeclaration;
	var ExportSpecifier = (function () {
	    function ExportSpecifier(local, exported) {
	        this.type = syntax_1.Syntax.ExportSpecifier;
	        this.exported = exported;
	        this.local = local;
	    }
	    return ExportSpecifier;
	}());
	exports.ExportSpecifier = ExportSpecifier;
	var ExpressionStatement = (function () {
	    function ExpressionStatement(expression) {
	        this.type = syntax_1.Syntax.ExpressionStatement;
	        this.expression = expression;
	    }
	    return ExpressionStatement;
	}());
	exports.ExpressionStatement = ExpressionStatement;
	var ForInStatement = (function () {
	    function ForInStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForInStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	        this.each = false;
	    }
	    return ForInStatement;
	}());
	exports.ForInStatement = ForInStatement;
	var ForOfStatement = (function () {
	    function ForOfStatement(left, right, body) {
	        this.type = syntax_1.Syntax.ForOfStatement;
	        this.left = left;
	        this.right = right;
	        this.body = body;
	    }
	    return ForOfStatement;
	}());
	exports.ForOfStatement = ForOfStatement;
	var ForStatement = (function () {
	    function ForStatement(init, test, update, body) {
	        this.type = syntax_1.Syntax.ForStatement;
	        this.init = init;
	        this.test = test;
	        this.update = update;
	        this.body = body;
	    }
	    return ForStatement;
	}());
	exports.ForStatement = ForStatement;
	var FunctionDeclaration = (function () {
	    function FunctionDeclaration(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionDeclaration;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionDeclaration;
	}());
	exports.FunctionDeclaration = FunctionDeclaration;
	var FunctionExpression = (function () {
	    function FunctionExpression(id, params, body, generator) {
	        this.type = syntax_1.Syntax.FunctionExpression;
	        this.id = id;
	        this.params = params;
	        this.body = body;
	        this.generator = generator;
	        this.expression = false;
	        this.async = false;
	    }
	    return FunctionExpression;
	}());
	exports.FunctionExpression = FunctionExpression;
	var Identifier = (function () {
	    function Identifier(name) {
	        this.type = syntax_1.Syntax.Identifier;
	        this.name = name;
	    }
	    return Identifier;
	}());
	exports.Identifier = Identifier;
	var IfStatement = (function () {
	    function IfStatement(test, consequent, alternate) {
	        this.type = syntax_1.Syntax.IfStatement;
	        this.test = test;
	        this.consequent = consequent;
	        this.alternate = alternate;
	    }
	    return IfStatement;
	}());
	exports.IfStatement = IfStatement;
	var ImportDeclaration = (function () {
	    function ImportDeclaration(specifiers, source) {
	        this.type = syntax_1.Syntax.ImportDeclaration;
	        this.specifiers = specifiers;
	        this.source = source;
	    }
	    return ImportDeclaration;
	}());
	exports.ImportDeclaration = ImportDeclaration;
	var ImportDefaultSpecifier = (function () {
	    function ImportDefaultSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportDefaultSpecifier;
	        this.local = local;
	    }
	    return ImportDefaultSpecifier;
	}());
	exports.ImportDefaultSpecifier = ImportDefaultSpecifier;
	var ImportNamespaceSpecifier = (function () {
	    function ImportNamespaceSpecifier(local) {
	        this.type = syntax_1.Syntax.ImportNamespaceSpecifier;
	        this.local = local;
	    }
	    return ImportNamespaceSpecifier;
	}());
	exports.ImportNamespaceSpecifier = ImportNamespaceSpecifier;
	var ImportSpecifier = (function () {
	    function ImportSpecifier(local, imported) {
	        this.type = syntax_1.Syntax.ImportSpecifier;
	        this.local = local;
	        this.imported = imported;
	    }
	    return ImportSpecifier;
	}());
	exports.ImportSpecifier = ImportSpecifier;
	var LabeledStatement = (function () {
	    function LabeledStatement(label, body) {
	        this.type = syntax_1.Syntax.LabeledStatement;
	        this.label = label;
	        this.body = body;
	    }
	    return LabeledStatement;
	}());
	exports.LabeledStatement = LabeledStatement;
	var Literal = (function () {
	    function Literal(value, raw) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	    }
	    return Literal;
	}());
	exports.Literal = Literal;
	var MetaProperty = (function () {
	    function MetaProperty(meta, property) {
	        this.type = syntax_1.Syntax.MetaProperty;
	        this.meta = meta;
	        this.property = property;
	    }
	    return MetaProperty;
	}());
	exports.MetaProperty = MetaProperty;
	var MethodDefinition = (function () {
	    function MethodDefinition(key, computed, value, kind, isStatic) {
	        this.type = syntax_1.Syntax.MethodDefinition;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.static = isStatic;
	    }
	    return MethodDefinition;
	}());
	exports.MethodDefinition = MethodDefinition;
	var Module = (function () {
	    function Module(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'module';
	    }
	    return Module;
	}());
	exports.Module = Module;
	var NewExpression = (function () {
	    function NewExpression(callee, args) {
	        this.type = syntax_1.Syntax.NewExpression;
	        this.callee = callee;
	        this.arguments = args;
	    }
	    return NewExpression;
	}());
	exports.NewExpression = NewExpression;
	var ObjectExpression = (function () {
	    function ObjectExpression(properties) {
	        this.type = syntax_1.Syntax.ObjectExpression;
	        this.properties = properties;
	    }
	    return ObjectExpression;
	}());
	exports.ObjectExpression = ObjectExpression;
	var ObjectPattern = (function () {
	    function ObjectPattern(properties) {
	        this.type = syntax_1.Syntax.ObjectPattern;
	        this.properties = properties;
	    }
	    return ObjectPattern;
	}());
	exports.ObjectPattern = ObjectPattern;
	var Property = (function () {
	    function Property(kind, key, computed, value, method, shorthand) {
	        this.type = syntax_1.Syntax.Property;
	        this.key = key;
	        this.computed = computed;
	        this.value = value;
	        this.kind = kind;
	        this.method = method;
	        this.shorthand = shorthand;
	    }
	    return Property;
	}());
	exports.Property = Property;
	var RegexLiteral = (function () {
	    function RegexLiteral(value, raw, pattern, flags) {
	        this.type = syntax_1.Syntax.Literal;
	        this.value = value;
	        this.raw = raw;
	        this.regex = { pattern: pattern, flags: flags };
	    }
	    return RegexLiteral;
	}());
	exports.RegexLiteral = RegexLiteral;
	var RestElement = (function () {
	    function RestElement(argument) {
	        this.type = syntax_1.Syntax.RestElement;
	        this.argument = argument;
	    }
	    return RestElement;
	}());
	exports.RestElement = RestElement;
	var ReturnStatement = (function () {
	    function ReturnStatement(argument) {
	        this.type = syntax_1.Syntax.ReturnStatement;
	        this.argument = argument;
	    }
	    return ReturnStatement;
	}());
	exports.ReturnStatement = ReturnStatement;
	var Script = (function () {
	    function Script(body) {
	        this.type = syntax_1.Syntax.Program;
	        this.body = body;
	        this.sourceType = 'script';
	    }
	    return Script;
	}());
	exports.Script = Script;
	var SequenceExpression = (function () {
	    function SequenceExpression(expressions) {
	        this.type = syntax_1.Syntax.SequenceExpression;
	        this.expressions = expressions;
	    }
	    return SequenceExpression;
	}());
	exports.SequenceExpression = SequenceExpression;
	var SpreadElement = (function () {
	    function SpreadElement(argument) {
	        this.type = syntax_1.Syntax.SpreadElement;
	        this.argument = argument;
	    }
	    return SpreadElement;
	}());
	exports.SpreadElement = SpreadElement;
	var StaticMemberExpression = (function () {
	    function StaticMemberExpression(object, property) {
	        this.type = syntax_1.Syntax.MemberExpression;
	        this.computed = false;
	        this.object = object;
	        this.property = property;
	    }
	    return StaticMemberExpression;
	}());
	exports.StaticMemberExpression = StaticMemberExpression;
	var Super = (function () {
	    function Super() {
	        this.type = syntax_1.Syntax.Super;
	    }
	    return Super;
	}());
	exports.Super = Super;
	var SwitchCase = (function () {
	    function SwitchCase(test, consequent) {
	        this.type = syntax_1.Syntax.SwitchCase;
	        this.test = test;
	        this.consequent = consequent;
	    }
	    return SwitchCase;
	}());
	exports.SwitchCase = SwitchCase;
	var SwitchStatement = (function () {
	    function SwitchStatement(discriminant, cases) {
	        this.type = syntax_1.Syntax.SwitchStatement;
	        this.discriminant = discriminant;
	        this.cases = cases;
	    }
	    return SwitchStatement;
	}());
	exports.SwitchStatement = SwitchStatement;
	var TaggedTemplateExpression = (function () {
	    function TaggedTemplateExpression(tag, quasi) {
	        this.type = syntax_1.Syntax.TaggedTemplateExpression;
	        this.tag = tag;
	        this.quasi = quasi;
	    }
	    return TaggedTemplateExpression;
	}());
	exports.TaggedTemplateExpression = TaggedTemplateExpression;
	var TemplateElement = (function () {
	    function TemplateElement(value, tail) {
	        this.type = syntax_1.Syntax.TemplateElement;
	        this.value = value;
	        this.tail = tail;
	    }
	    return TemplateElement;
	}());
	exports.TemplateElement = TemplateElement;
	var TemplateLiteral = (function () {
	    function TemplateLiteral(quasis, expressions) {
	        this.type = syntax_1.Syntax.TemplateLiteral;
	        this.quasis = quasis;
	        this.expressions = expressions;
	    }
	    return TemplateLiteral;
	}());
	exports.TemplateLiteral = TemplateLiteral;
	var ThisExpression = (function () {
	    function ThisExpression() {
	        this.type = syntax_1.Syntax.ThisExpression;
	    }
	    return ThisExpression;
	}());
	exports.ThisExpression = ThisExpression;
	var ThrowStatement = (function () {
	    function ThrowStatement(argument) {
	        this.type = syntax_1.Syntax.ThrowStatement;
	        this.argument = argument;
	    }
	    return ThrowStatement;
	}());
	exports.ThrowStatement = ThrowStatement;
	var TryStatement = (function () {
	    function TryStatement(block, handler, finalizer) {
	        this.type = syntax_1.Syntax.TryStatement;
	        this.block = block;
	        this.handler = handler;
	        this.finalizer = finalizer;
	    }
	    return TryStatement;
	}());
	exports.TryStatement = TryStatement;
	var UnaryExpression = (function () {
	    function UnaryExpression(operator, argument) {
	        this.type = syntax_1.Syntax.UnaryExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = true;
	    }
	    return UnaryExpression;
	}());
	exports.UnaryExpression = UnaryExpression;
	var UpdateExpression = (function () {
	    function UpdateExpression(operator, argument, prefix) {
	        this.type = syntax_1.Syntax.UpdateExpression;
	        this.operator = operator;
	        this.argument = argument;
	        this.prefix = prefix;
	    }
	    return UpdateExpression;
	}());
	exports.UpdateExpression = UpdateExpression;
	var VariableDeclaration = (function () {
	    function VariableDeclaration(declarations, kind) {
	        this.type = syntax_1.Syntax.VariableDeclaration;
	        this.declarations = declarations;
	        this.kind = kind;
	    }
	    return VariableDeclaration;
	}());
	exports.VariableDeclaration = VariableDeclaration;
	var VariableDeclarator = (function () {
	    function VariableDeclarator(id, init) {
	        this.type = syntax_1.Syntax.VariableDeclarator;
	        this.id = id;
	        this.init = init;
	    }
	    return VariableDeclarator;
	}());
	exports.VariableDeclarator = VariableDeclarator;
	var WhileStatement = (function () {
	    function WhileStatement(test, body) {
	        this.type = syntax_1.Syntax.WhileStatement;
	        this.test = test;
	        this.body = body;
	    }
	    return WhileStatement;
	}());
	exports.WhileStatement = WhileStatement;
	var WithStatement = (function () {
	    function WithStatement(object, body) {
	        this.type = syntax_1.Syntax.WithStatement;
	        this.object = object;
	        this.body = body;
	    }
	    return WithStatement;
	}());
	exports.WithStatement = WithStatement;
	var YieldExpression = (function () {
	    function YieldExpression(argument, delegate) {
	        this.type = syntax_1.Syntax.YieldExpression;
	        this.argument = argument;
	        this.delegate = delegate;
	    }
	    return YieldExpression;
	}());
	exports.YieldExpression = YieldExpression;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __webpack_require__(9);
	var error_handler_1 = __webpack_require__(10);
	var messages_1 = __webpack_require__(11);
	var Node = __webpack_require__(7);
	var scanner_1 = __webpack_require__(12);
	var syntax_1 = __webpack_require__(2);
	var token_1 = __webpack_require__(13);
	var ArrowParameterPlaceHolder = 'ArrowParameterPlaceHolder';
	var Parser = (function () {
	    function Parser(code, options, delegate) {
	        if (options === void 0) { options = {}; }
	        this.config = {
	            range: (typeof options.range === 'boolean') && options.range,
	            loc: (typeof options.loc === 'boolean') && options.loc,
	            source: null,
	            tokens: (typeof options.tokens === 'boolean') && options.tokens,
	            comment: (typeof options.comment === 'boolean') && options.comment,
	            tolerant: (typeof options.tolerant === 'boolean') && options.tolerant
	        };
	        if (this.config.loc && options.source && options.source !== null) {
	            this.config.source = String(options.source);
	        }
	        this.delegate = delegate;
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = this.config.tolerant;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = this.config.comment;
	        this.operatorPrecedence = {
	            ')': 0,
	            ';': 0,
	            ',': 0,
	            '=': 0,
	            ']': 0,
	            '||': 1,
	            '&&': 2,
	            '|': 3,
	            '^': 4,
	            '&': 5,
	            '==': 6,
	            '!=': 6,
	            '===': 6,
	            '!==': 6,
	            '<': 7,
	            '>': 7,
	            '<=': 7,
	            '>=': 7,
	            '<<': 8,
	            '>>': 8,
	            '>>>': 8,
	            '+': 9,
	            '-': 9,
	            '*': 11,
	            '/': 11,
	            '%': 11
	        };
	        this.lookahead = {
	            type: 2 /* EOF */,
	            value: '',
	            lineNumber: this.scanner.lineNumber,
	            lineStart: 0,
	            start: 0,
	            end: 0
	        };
	        this.hasLineTerminator = false;
	        this.context = {
	            isModule: false,
	            await: false,
	            allowIn: true,
	            allowStrictDirective: true,
	            allowYield: true,
	            firstCoverInitializedNameError: null,
	            isAssignmentTarget: false,
	            isBindingElement: false,
	            inFunctionBody: false,
	            inIteration: false,
	            inSwitch: false,
	            labelSet: {},
	            strict: false
	        };
	        this.tokens = [];
	        this.startMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.lastMarker = {
	            index: 0,
	            line: this.scanner.lineNumber,
	            column: 0
	        };
	        this.nextToken();
	        this.lastMarker = {
	            index: this.scanner.index,
	            line: this.scanner.lineNumber,
	            column: this.scanner.index - this.scanner.lineStart
	        };
	    }
	    Parser.prototype.throwError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.lastMarker.line;
	        var column = this.lastMarker.column + 1;
	        throw this.errorHandler.createError(index, line, column, msg);
	    };
	    Parser.prototype.tolerateError = function (messageFormat) {
	        var values = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            values[_i - 1] = arguments[_i];
	        }
	        var args = Array.prototype.slice.call(arguments, 1);
	        var msg = messageFormat.replace(/%(\d)/g, function (whole, idx) {
	            assert_1.assert(idx < args.length, 'Message reference must be in range');
	            return args[idx];
	        });
	        var index = this.lastMarker.index;
	        var line = this.scanner.lineNumber;
	        var column = this.lastMarker.column + 1;
	        this.errorHandler.tolerateError(index, line, column, msg);
	    };
	    // Throw an exception because of the token.
	    Parser.prototype.unexpectedTokenError = function (token, message) {
	        var msg = message || messages_1.Messages.UnexpectedToken;
	        var value;
	        if (token) {
	            if (!message) {
	                msg = (token.type === 2 /* EOF */) ? messages_1.Messages.UnexpectedEOS :
	                    (token.type === 3 /* Identifier */) ? messages_1.Messages.UnexpectedIdentifier :
	                        (token.type === 6 /* NumericLiteral */) ? messages_1.Messages.UnexpectedNumber :
	                            (token.type === 8 /* StringLiteral */) ? messages_1.Messages.UnexpectedString :
	                                (token.type === 10 /* Template */) ? messages_1.Messages.UnexpectedTemplate :
	                                    messages_1.Messages.UnexpectedToken;
	                if (token.type === 4 /* Keyword */) {
	                    if (this.scanner.isFutureReservedWord(token.value)) {
	                        msg = messages_1.Messages.UnexpectedReserved;
	                    }
	                    else if (this.context.strict && this.scanner.isStrictModeReservedWord(token.value)) {
	                        msg = messages_1.Messages.StrictReservedWord;
	                    }
	                }
	            }
	            value = token.value;
	        }
	        else {
	            value = 'ILLEGAL';
	        }
	        msg = msg.replace('%0', value);
	        if (token && typeof token.lineNumber === 'number') {
	            var index = token.start;
	            var line = token.lineNumber;
	            var lastMarkerLineStart = this.lastMarker.index - this.lastMarker.column;
	            var column = token.start - lastMarkerLineStart + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	        else {
	            var index = this.lastMarker.index;
	            var line = this.lastMarker.line;
	            var column = this.lastMarker.column + 1;
	            return this.errorHandler.createError(index, line, column, msg);
	        }
	    };
	    Parser.prototype.throwUnexpectedToken = function (token, message) {
	        throw this.unexpectedTokenError(token, message);
	    };
	    Parser.prototype.tolerateUnexpectedToken = function (token, message) {
	        this.errorHandler.tolerate(this.unexpectedTokenError(token, message));
	    };
	    Parser.prototype.collectComments = function () {
	        if (!this.config.comment) {
	            this.scanner.scanComments();
	        }
	        else {
	            var comments = this.scanner.scanComments();
	            if (comments.length > 0 && this.delegate) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var node = void 0;
	                    node = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: this.scanner.source.slice(e.slice[0], e.slice[1])
	                    };
	                    if (this.config.range) {
	                        node.range = e.range;
	                    }
	                    if (this.config.loc) {
	                        node.loc = e.loc;
	                    }
	                    var metadata = {
	                        start: {
	                            line: e.loc.start.line,
	                            column: e.loc.start.column,
	                            offset: e.range[0]
	                        },
	                        end: {
	                            line: e.loc.end.line,
	                            column: e.loc.end.column,
	                            offset: e.range[1]
	                        }
	                    };
	                    this.delegate(node, metadata);
	                }
	            }
	        }
	    };
	    // From internal representation to an external structure
	    Parser.prototype.getTokenRaw = function (token) {
	        return this.scanner.source.slice(token.start, token.end);
	    };
	    Parser.prototype.convertToken = function (token) {
	        var t = {
	            type: token_1.TokenName[token.type],
	            value: this.getTokenRaw(token)
	        };
	        if (this.config.range) {
	            t.range = [token.start, token.end];
	        }
	        if (this.config.loc) {
	            t.loc = {
	                start: {
	                    line: this.startMarker.line,
	                    column: this.startMarker.column
	                },
	                end: {
	                    line: this.scanner.lineNumber,
	                    column: this.scanner.index - this.scanner.lineStart
	                }
	            };
	        }
	        if (token.type === 9 /* RegularExpression */) {
	            var pattern = token.pattern;
	            var flags = token.flags;
	            t.regex = { pattern: pattern, flags: flags };
	        }
	        return t;
	    };
	    Parser.prototype.nextToken = function () {
	        var token = this.lookahead;
	        this.lastMarker.index = this.scanner.index;
	        this.lastMarker.line = this.scanner.lineNumber;
	        this.lastMarker.column = this.scanner.index - this.scanner.lineStart;
	        this.collectComments();
	        if (this.scanner.index !== this.startMarker.index) {
	            this.startMarker.index = this.scanner.index;
	            this.startMarker.line = this.scanner.lineNumber;
	            this.startMarker.column = this.scanner.index - this.scanner.lineStart;
	        }
	        var next = this.scanner.lex();
	        this.hasLineTerminator = (token.lineNumber !== next.lineNumber);
	        if (next && this.context.strict && next.type === 3 /* Identifier */) {
	            if (this.scanner.isStrictModeReservedWord(next.value)) {
	                next.type = 4 /* Keyword */;
	            }
	        }
	        this.lookahead = next;
	        if (this.config.tokens && next.type !== 2 /* EOF */) {
	            this.tokens.push(this.convertToken(next));
	        }
	        return token;
	    };
	    Parser.prototype.nextRegexToken = function () {
	        this.collectComments();
	        var token = this.scanner.scanRegExp();
	        if (this.config.tokens) {
	            // Pop the previous token, '/' or '/='
	            // This is added from the lookahead token.
	            this.tokens.pop();
	            this.tokens.push(this.convertToken(token));
	        }
	        // Prime the next lookahead.
	        this.lookahead = token;
	        this.nextToken();
	        return token;
	    };
	    Parser.prototype.createNode = function () {
	        return {
	            index: this.startMarker.index,
	            line: this.startMarker.line,
	            column: this.startMarker.column
	        };
	    };
	    Parser.prototype.startNode = function (token, lastLineStart) {
	        if (lastLineStart === void 0) { lastLineStart = 0; }
	        var column = token.start - token.lineStart;
	        var line = token.lineNumber;
	        if (column < 0) {
	            column += lastLineStart;
	            line--;
	        }
	        return {
	            index: token.start,
	            line: line,
	            column: column
	        };
	    };
	    Parser.prototype.finalize = function (marker, node) {
	        if (this.config.range) {
	            node.range = [marker.index, this.lastMarker.index];
	        }
	        if (this.config.loc) {
	            node.loc = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column
	                }
	            };
	            if (this.config.source) {
	                node.loc.source = this.config.source;
	            }
	        }
	        if (this.delegate) {
	            var metadata = {
	                start: {
	                    line: marker.line,
	                    column: marker.column,
	                    offset: marker.index
	                },
	                end: {
	                    line: this.lastMarker.line,
	                    column: this.lastMarker.column,
	                    offset: this.lastMarker.index
	                }
	            };
	            this.delegate(node, metadata);
	        }
	        return node;
	    };
	    // Expect the next token to match the specified punctuator.
	    // If not, an exception will be thrown.
	    Parser.prototype.expect = function (value) {
	        var token = this.nextToken();
	        if (token.type !== 7 /* Punctuator */ || token.value !== value) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Quietly expect a comma when in tolerant mode, otherwise delegates to expect().
	    Parser.prototype.expectCommaSeparator = function () {
	        if (this.config.tolerant) {
	            var token = this.lookahead;
	            if (token.type === 7 /* Punctuator */ && token.value === ',') {
	                this.nextToken();
	            }
	            else if (token.type === 7 /* Punctuator */ && token.value === ';') {
	                this.nextToken();
	                this.tolerateUnexpectedToken(token);
	            }
	            else {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.UnexpectedToken);
	            }
	        }
	        else {
	            this.expect(',');
	        }
	    };
	    // Expect the next token to match the specified keyword.
	    // If not, an exception will be thrown.
	    Parser.prototype.expectKeyword = function (keyword) {
	        var token = this.nextToken();
	        if (token.type !== 4 /* Keyword */ || token.value !== keyword) {
	            this.throwUnexpectedToken(token);
	        }
	    };
	    // Return true if the next token matches the specified punctuator.
	    Parser.prototype.match = function (value) {
	        return this.lookahead.type === 7 /* Punctuator */ && this.lookahead.value === value;
	    };
	    // Return true if the next token matches the specified keyword
	    Parser.prototype.matchKeyword = function (keyword) {
	        return this.lookahead.type === 4 /* Keyword */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token matches the specified contextual keyword
	    // (where an identifier is sometimes a keyword depending on the context)
	    Parser.prototype.matchContextualKeyword = function (keyword) {
	        return this.lookahead.type === 3 /* Identifier */ && this.lookahead.value === keyword;
	    };
	    // Return true if the next token is an assignment operator
	    Parser.prototype.matchAssign = function () {
	        if (this.lookahead.type !== 7 /* Punctuator */) {
	            return false;
	        }
	        var op = this.lookahead.value;
	        return op === '=' ||
	            op === '*=' ||
	            op === '**=' ||
	            op === '/=' ||
	            op === '%=' ||
	            op === '+=' ||
	            op === '-=' ||
	            op === '<<=' ||
	            op === '>>=' ||
	            op === '>>>=' ||
	            op === '&=' ||
	            op === '^=' ||
	            op === '|=';
	    };
	    // Cover grammar support.
	    //
	    // When an assignment expression position starts with an left parenthesis, the determination of the type
	    // of the syntax is to be deferred arbitrarily long until the end of the parentheses pair (plus a lookahead)
	    // or the first comma. This situation also defers the determination of all the expressions nested in the pair.
	    //
	    // There are three productions that can be parsed in a parentheses pair that needs to be determined
	    // after the outermost pair is closed. They are:
	    //
	    //   1. AssignmentExpression
	    //   2. BindingElements
	    //   3. AssignmentTargets
	    //
	    // In order to avoid exponential backtracking, we use two flags to denote if the production can be
	    // binding element or assignment target.
	    //
	    // The three productions have the relationship:
	    //
	    //   BindingElements  AssignmentTargets  AssignmentExpression
	    //
	    // with a single exception that CoverInitializedName when used directly in an Expression, generates
	    // an early error. Therefore, we need the third state, firstCoverInitializedNameError, to track the
	    // first usage of CoverInitializedName and report it when we reached the end of the parentheses pair.
	    //
	    // isolateCoverGrammar function runs the given parser function with a new cover grammar context, and it does not
	    // effect the current flags. This means the production the parser parses is only used as an expression. Therefore
	    // the CoverInitializedName check is conducted.
	    //
	    // inheritCoverGrammar function runs the given parse function with a new cover grammar context, and it propagates
	    // the flags outside of the parser. This means the production the parser parses is used as a part of a potential
	    // pattern. The CoverInitializedName check is deferred.
	    Parser.prototype.isolateCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        if (this.context.firstCoverInitializedNameError !== null) {
	            this.throwUnexpectedToken(this.context.firstCoverInitializedNameError);
	        }
	        this.context.isBindingElement = previousIsBindingElement;
	        this.context.isAssignmentTarget = previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.inheritCoverGrammar = function (parseFunction) {
	        var previousIsBindingElement = this.context.isBindingElement;
	        var previousIsAssignmentTarget = this.context.isAssignmentTarget;
	        var previousFirstCoverInitializedNameError = this.context.firstCoverInitializedNameError;
	        this.context.isBindingElement = true;
	        this.context.isAssignmentTarget = true;
	        this.context.firstCoverInitializedNameError = null;
	        var result = parseFunction.call(this);
	        this.context.isBindingElement = this.context.isBindingElement && previousIsBindingElement;
	        this.context.isAssignmentTarget = this.context.isAssignmentTarget && previousIsAssignmentTarget;
	        this.context.firstCoverInitializedNameError = previousFirstCoverInitializedNameError || this.context.firstCoverInitializedNameError;
	        return result;
	    };
	    Parser.prototype.consumeSemicolon = function () {
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else if (!this.hasLineTerminator) {
	            if (this.lookahead.type !== 2 /* EOF */ && !this.match('}')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.lastMarker.index = this.startMarker.index;
	            this.lastMarker.line = this.startMarker.line;
	            this.lastMarker.column = this.startMarker.column;
	        }
	    };
	    // https://tc39.github.io/ecma262/#sec-primary-expression
	    Parser.prototype.parsePrimaryExpression = function () {
	        var node = this.createNode();
	        var expr;
	        var token, raw;
	        switch (this.lookahead.type) {
	            case 3 /* Identifier */:
	                if ((this.context.isModule || this.context.await) && this.lookahead.value === 'await') {
	                    this.tolerateUnexpectedToken(this.lookahead);
	                }
	                expr = this.matchAsyncFunction() ? this.parseFunctionExpression() : this.finalize(node, new Node.Identifier(this.nextToken().value));
	                break;
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	                if (this.context.strict && this.lookahead.octal) {
	                    this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.StrictOctalLiteral);
	                }
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 1 /* BooleanLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(token.value === 'true', raw));
	                break;
	            case 5 /* NullLiteral */:
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                token = this.nextToken();
	                raw = this.getTokenRaw(token);
	                expr = this.finalize(node, new Node.Literal(null, raw));
	                break;
	            case 10 /* Template */:
	                expr = this.parseTemplateLiteral();
	                break;
	            case 7 /* Punctuator */:
	                switch (this.lookahead.value) {
	                    case '(':
	                        this.context.isBindingElement = false;
	                        expr = this.inheritCoverGrammar(this.parseGroupExpression);
	                        break;
	                    case '[':
	                        expr = this.inheritCoverGrammar(this.parseArrayInitializer);
	                        break;
	                    case '{':
	                        expr = this.inheritCoverGrammar(this.parseObjectInitializer);
	                        break;
	                    case '/':
	                    case '/=':
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                        this.scanner.index = this.startMarker.index;
	                        token = this.nextRegexToken();
	                        raw = this.getTokenRaw(token);
	                        expr = this.finalize(node, new Node.RegexLiteral(token.regex, raw, token.pattern, token.flags));
	                        break;
	                    default:
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                }
	                break;
	            case 4 /* Keyword */:
	                if (!this.context.strict && this.context.allowYield && this.matchKeyword('yield')) {
	                    expr = this.parseIdentifierName();
	                }
	                else if (!this.context.strict && this.matchKeyword('let')) {
	                    expr = this.finalize(node, new Node.Identifier(this.nextToken().value));
	                }
	                else {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    if (this.matchKeyword('function')) {
	                        expr = this.parseFunctionExpression();
	                    }
	                    else if (this.matchKeyword('this')) {
	                        this.nextToken();
	                        expr = this.finalize(node, new Node.ThisExpression());
	                    }
	                    else if (this.matchKeyword('class')) {
	                        expr = this.parseClassExpression();
	                    }
	                    else {
	                        expr = this.throwUnexpectedToken(this.nextToken());
	                    }
	                }
	                break;
	            default:
	                expr = this.throwUnexpectedToken(this.nextToken());
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-array-initializer
	    Parser.prototype.parseSpreadElement = function () {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.inheritCoverGrammar(this.parseAssignmentExpression);
	        return this.finalize(node, new Node.SpreadElement(arg));
	    };
	    Parser.prototype.parseArrayInitializer = function () {
	        var node = this.createNode();
	        var elements = [];
	        this.expect('[');
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else if (this.match('...')) {
	                var element = this.parseSpreadElement();
	                if (!this.match(']')) {
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    this.expect(',');
	                }
	                elements.push(element);
	            }
	            else {
	                elements.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayExpression(elements));
	    };
	    // https://tc39.github.io/ecma262/#sec-object-initializer
	    Parser.prototype.parsePropertyMethod = function (params) {
	        this.context.isAssignmentTarget = false;
	        this.context.isBindingElement = false;
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = params.simple;
	        var body = this.isolateCoverGrammar(this.parseFunctionSourceElements);
	        if (this.context.strict && params.firstRestricted) {
	            this.tolerateUnexpectedToken(params.firstRestricted, params.message);
	        }
	        if (this.context.strict && params.stricted) {
	            this.tolerateUnexpectedToken(params.stricted, params.message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        return body;
	    };
	    Parser.prototype.parsePropertyMethodFunction = function () {
	        var isGenerator = false;
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = true;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    Parser.prototype.parsePropertyMethodAsyncFunction = function () {
	        var node = this.createNode();
	        var previousAllowYield = this.context.allowYield;
	        var previousAwait = this.context.await;
	        this.context.allowYield = false;
	        this.context.await = true;
	        var params = this.parseFormalParameters();
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        this.context.await = previousAwait;
	        return this.finalize(node, new Node.AsyncFunctionExpression(null, params.params, method));
	    };
	    Parser.prototype.parseObjectPropertyKey = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        var key;
	        switch (token.type) {
	            case 8 /* StringLiteral */:
	            case 6 /* NumericLiteral */:
	                if (this.context.strict && token.octal) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictOctalLiteral);
	                }
	                var raw = this.getTokenRaw(token);
	                key = this.finalize(node, new Node.Literal(token.value, raw));
	                break;
	            case 3 /* Identifier */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 4 /* Keyword */:
	                key = this.finalize(node, new Node.Identifier(token.value));
	                break;
	            case 7 /* Punctuator */:
	                if (token.value === '[') {
	                    key = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    this.expect(']');
	                }
	                else {
	                    key = this.throwUnexpectedToken(token);
	                }
	                break;
	            default:
	                key = this.throwUnexpectedToken(token);
	        }
	        return key;
	    };
	    Parser.prototype.isPropertyKey = function (key, value) {
	        return (key.type === syntax_1.Syntax.Identifier && key.name === value) ||
	            (key.type === syntax_1.Syntax.Literal && key.value === value);
	    };
	    Parser.prototype.parseObjectProperty = function (hasProto) {
	        var node = this.createNode();
	        var token = this.lookahead;
	        var kind;
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var shorthand = false;
	        var isAsync = false;
	        if (token.type === 3 /* Identifier */) {
	            var id = token.value;
	            this.nextToken();
	            computed = this.match('[');
	            isAsync = !this.hasLineTerminator && (id === 'async') &&
	                !this.match(':') && !this.match('(') && !this.match('*') && !this.match(',');
	            key = isAsync ? this.parseObjectPropertyKey() : this.finalize(node, new Node.Identifier(id));
	        }
	        else if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'get' && lookaheadPropertyKey) {
	            kind = 'get';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.context.allowYield = false;
	            value = this.parseGetterMethod();
	        }
	        else if (token.type === 3 /* Identifier */ && !isAsync && token.value === 'set' && lookaheadPropertyKey) {
	            kind = 'set';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseSetterMethod();
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        else {
	            if (!key) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            kind = 'init';
	            if (this.match(':') && !isAsync) {
	                if (!computed && this.isPropertyKey(key, '__proto__')) {
	                    if (hasProto.value) {
	                        this.tolerateError(messages_1.Messages.DuplicateProtoProperty);
	                    }
	                    hasProto.value = true;
	                }
	                this.nextToken();
	                value = this.inheritCoverGrammar(this.parseAssignmentExpression);
	            }
	            else if (this.match('(')) {
	                value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	                method = true;
	            }
	            else if (token.type === 3 /* Identifier */) {
	                var id = this.finalize(node, new Node.Identifier(token.value));
	                if (this.match('=')) {
	                    this.context.firstCoverInitializedNameError = this.lookahead;
	                    this.nextToken();
	                    shorthand = true;
	                    var init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    value = this.finalize(node, new Node.AssignmentPattern(id, init));
	                }
	                else {
	                    shorthand = true;
	                    value = id;
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.Property(kind, key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectInitializer = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var properties = [];
	        var hasProto = { value: false };
	        while (!this.match('}')) {
	            properties.push(this.parseObjectProperty(hasProto));
	            if (!this.match('}')) {
	                this.expectCommaSeparator();
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectExpression(properties));
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literals
	    Parser.prototype.parseTemplateHead = function () {
	        assert_1.assert(this.lookahead.head, 'Template literal must start with a template head');
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateElement = function () {
	        if (this.lookahead.type !== 10 /* Template */) {
	            this.throwUnexpectedToken();
	        }
	        var node = this.createNode();
	        var token = this.nextToken();
	        var raw = token.value;
	        var cooked = token.cooked;
	        return this.finalize(node, new Node.TemplateElement({ raw: raw, cooked: cooked }, token.tail));
	    };
	    Parser.prototype.parseTemplateLiteral = function () {
	        var node = this.createNode();
	        var expressions = [];
	        var quasis = [];
	        var quasi = this.parseTemplateHead();
	        quasis.push(quasi);
	        while (!quasi.tail) {
	            expressions.push(this.parseExpression());
	            quasi = this.parseTemplateElement();
	            quasis.push(quasi);
	        }
	        return this.finalize(node, new Node.TemplateLiteral(quasis, expressions));
	    };
	    // https://tc39.github.io/ecma262/#sec-grouping-operator
	    Parser.prototype.reinterpretExpressionAsPattern = function (expr) {
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	            case syntax_1.Syntax.MemberExpression:
	            case syntax_1.Syntax.RestElement:
	            case syntax_1.Syntax.AssignmentPattern:
	                break;
	            case syntax_1.Syntax.SpreadElement:
	                expr.type = syntax_1.Syntax.RestElement;
	                this.reinterpretExpressionAsPattern(expr.argument);
	                break;
	            case syntax_1.Syntax.ArrayExpression:
	                expr.type = syntax_1.Syntax.ArrayPattern;
	                for (var i = 0; i < expr.elements.length; i++) {
	                    if (expr.elements[i] !== null) {
	                        this.reinterpretExpressionAsPattern(expr.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectExpression:
	                expr.type = syntax_1.Syntax.ObjectPattern;
	                for (var i = 0; i < expr.properties.length; i++) {
	                    this.reinterpretExpressionAsPattern(expr.properties[i].value);
	                }
	                break;
	            case syntax_1.Syntax.AssignmentExpression:
	                expr.type = syntax_1.Syntax.AssignmentPattern;
	                delete expr.operator;
	                this.reinterpretExpressionAsPattern(expr.left);
	                break;
	            default:
	                // Allow other node type for tolerant parsing.
	                break;
	        }
	    };
	    Parser.prototype.parseGroupExpression = function () {
	        var expr;
	        this.expect('(');
	        if (this.match(')')) {
	            this.nextToken();
	            if (!this.match('=>')) {
	                this.expect('=>');
	            }
	            expr = {
	                type: ArrowParameterPlaceHolder,
	                params: [],
	                async: false
	            };
	        }
	        else {
	            var startToken = this.lookahead;
	            var params = [];
	            if (this.match('...')) {
	                expr = this.parseRestElement(params);
	                this.expect(')');
	                if (!this.match('=>')) {
	                    this.expect('=>');
	                }
	                expr = {
	                    type: ArrowParameterPlaceHolder,
	                    params: [expr],
	                    async: false
	                };
	            }
	            else {
	                var arrow = false;
	                this.context.isBindingElement = true;
	                expr = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                if (this.match(',')) {
	                    var expressions = [];
	                    this.context.isAssignmentTarget = false;
	                    expressions.push(expr);
	                    while (this.lookahead.type !== 2 /* EOF */) {
	                        if (!this.match(',')) {
	                            break;
	                        }
	                        this.nextToken();
	                        if (this.match(')')) {
	                            this.nextToken();
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else if (this.match('...')) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            expressions.push(this.parseRestElement(params));
	                            this.expect(')');
	                            if (!this.match('=>')) {
	                                this.expect('=>');
	                            }
	                            this.context.isBindingElement = false;
	                            for (var i = 0; i < expressions.length; i++) {
	                                this.reinterpretExpressionAsPattern(expressions[i]);
	                            }
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: expressions,
	                                async: false
	                            };
	                        }
	                        else {
	                            expressions.push(this.inheritCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        if (arrow) {
	                            break;
	                        }
	                    }
	                    if (!arrow) {
	                        expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	                    }
	                }
	                if (!arrow) {
	                    this.expect(')');
	                    if (this.match('=>')) {
	                        if (expr.type === syntax_1.Syntax.Identifier && expr.name === 'yield') {
	                            arrow = true;
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: [expr],
	                                async: false
	                            };
	                        }
	                        if (!arrow) {
	                            if (!this.context.isBindingElement) {
	                                this.throwUnexpectedToken(this.lookahead);
	                            }
	                            if (expr.type === syntax_1.Syntax.SequenceExpression) {
	                                for (var i = 0; i < expr.expressions.length; i++) {
	                                    this.reinterpretExpressionAsPattern(expr.expressions[i]);
	                                }
	                            }
	                            else {
	                                this.reinterpretExpressionAsPattern(expr);
	                            }
	                            var parameters = (expr.type === syntax_1.Syntax.SequenceExpression ? expr.expressions : [expr]);
	                            expr = {
	                                type: ArrowParameterPlaceHolder,
	                                params: parameters,
	                                async: false
	                            };
	                        }
	                    }
	                    this.context.isBindingElement = false;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-left-hand-side-expressions
	    Parser.prototype.parseArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAssignmentExpression);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.isIdentifierName = function (token) {
	        return token.type === 3 /* Identifier */ ||
	            token.type === 4 /* Keyword */ ||
	            token.type === 1 /* BooleanLiteral */ ||
	            token.type === 5 /* NullLiteral */;
	    };
	    Parser.prototype.parseIdentifierName = function () {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (!this.isIdentifierName(token)) {
	            this.throwUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseNewExpression = function () {
	        var node = this.createNode();
	        var id = this.parseIdentifierName();
	        assert_1.assert(id.name === 'new', 'New expression must start with `new`');
	        var expr;
	        if (this.match('.')) {
	            this.nextToken();
	            if (this.lookahead.type === 3 /* Identifier */ && this.context.inFunctionBody && this.lookahead.value === 'target') {
	                var property = this.parseIdentifierName();
	                expr = new Node.MetaProperty(id, property);
	            }
	            else {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            var callee = this.isolateCoverGrammar(this.parseLeftHandSideExpression);
	            var args = this.match('(') ? this.parseArguments() : [];
	            expr = new Node.NewExpression(callee, args);
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return this.finalize(node, expr);
	    };
	    Parser.prototype.parseAsyncArgument = function () {
	        var arg = this.parseAssignmentExpression();
	        this.context.firstCoverInitializedNameError = null;
	        return arg;
	    };
	    Parser.prototype.parseAsyncArguments = function () {
	        this.expect('(');
	        var args = [];
	        if (!this.match(')')) {
	            while (true) {
	                var expr = this.match('...') ? this.parseSpreadElement() :
	                    this.isolateCoverGrammar(this.parseAsyncArgument);
	                args.push(expr);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expectCommaSeparator();
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return args;
	    };
	    Parser.prototype.parseLeftHandSideExpressionAllowCall = function () {
	        var startToken = this.lookahead;
	        var maybeAsync = this.matchContextualKeyword('async');
	        var previousAllowIn = this.context.allowIn;
	        this.context.allowIn = true;
	        var expr;
	        if (this.matchKeyword('super') && this.context.inFunctionBody) {
	            expr = this.createNode();
	            this.nextToken();
	            expr = this.finalize(expr, new Node.Super());
	            if (!this.match('(') && !this.match('.') && !this.match('[')) {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        }
	        while (true) {
	            if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(this.startNode(startToken), new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.match('(')) {
	                var asyncArrow = maybeAsync && (startToken.lineNumber === this.lookahead.lineNumber);
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = false;
	                var args = asyncArrow ? this.parseAsyncArguments() : this.parseArguments();
	                expr = this.finalize(this.startNode(startToken), new Node.CallExpression(expr, args));
	                if (asyncArrow && this.match('=>')) {
	                    for (var i = 0; i < args.length; ++i) {
	                        this.reinterpretExpressionAsPattern(args[i]);
	                    }
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: args,
	                        async: true
	                    };
	                }
	            }
	            else if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(this.startNode(startToken), new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(this.startNode(startToken), new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        this.context.allowIn = previousAllowIn;
	        return expr;
	    };
	    Parser.prototype.parseSuper = function () {
	        var node = this.createNode();
	        this.expectKeyword('super');
	        if (!this.match('[') && !this.match('.')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        return this.finalize(node, new Node.Super());
	    };
	    Parser.prototype.parseLeftHandSideExpression = function () {
	        assert_1.assert(this.context.allowIn, 'callee of new expression always allow in keyword.');
	        var node = this.startNode(this.lookahead);
	        var expr = (this.matchKeyword('super') && this.context.inFunctionBody) ? this.parseSuper() :
	            this.inheritCoverGrammar(this.matchKeyword('new') ? this.parseNewExpression : this.parsePrimaryExpression);
	        while (true) {
	            if (this.match('[')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('[');
	                var property = this.isolateCoverGrammar(this.parseExpression);
	                this.expect(']');
	                expr = this.finalize(node, new Node.ComputedMemberExpression(expr, property));
	            }
	            else if (this.match('.')) {
	                this.context.isBindingElement = false;
	                this.context.isAssignmentTarget = true;
	                this.expect('.');
	                var property = this.parseIdentifierName();
	                expr = this.finalize(node, new Node.StaticMemberExpression(expr, property));
	            }
	            else if (this.lookahead.type === 10 /* Template */ && this.lookahead.head) {
	                var quasi = this.parseTemplateLiteral();
	                expr = this.finalize(node, new Node.TaggedTemplateExpression(expr, quasi));
	            }
	            else {
	                break;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-update-expressions
	    Parser.prototype.parseUpdateExpression = function () {
	        var expr;
	        var startToken = this.lookahead;
	        if (this.match('++') || this.match('--')) {
	            var node = this.startNode(startToken);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                this.tolerateError(messages_1.Messages.StrictLHSPrefix);
	            }
	            if (!this.context.isAssignmentTarget) {
	                this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	            }
	            var prefix = true;
	            expr = this.finalize(node, new Node.UpdateExpression(token.value, expr, prefix));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else {
	            expr = this.inheritCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	            if (!this.hasLineTerminator && this.lookahead.type === 7 /* Punctuator */) {
	                if (this.match('++') || this.match('--')) {
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier && this.scanner.isRestrictedWord(expr.name)) {
	                        this.tolerateError(messages_1.Messages.StrictLHSPostfix);
	                    }
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    this.context.isAssignmentTarget = false;
	                    this.context.isBindingElement = false;
	                    var operator = this.nextToken().value;
	                    var prefix = false;
	                    expr = this.finalize(this.startNode(startToken), new Node.UpdateExpression(operator, expr, prefix));
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-unary-operators
	    Parser.prototype.parseAwaitExpression = function () {
	        var node = this.createNode();
	        this.nextToken();
	        var argument = this.parseUnaryExpression();
	        return this.finalize(node, new Node.AwaitExpression(argument));
	    };
	    Parser.prototype.parseUnaryExpression = function () {
	        var expr;
	        if (this.match('+') || this.match('-') || this.match('~') || this.match('!') ||
	            this.matchKeyword('delete') || this.matchKeyword('void') || this.matchKeyword('typeof')) {
	            var node = this.startNode(this.lookahead);
	            var token = this.nextToken();
	            expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	            expr = this.finalize(node, new Node.UnaryExpression(token.value, expr));
	            if (this.context.strict && expr.operator === 'delete' && expr.argument.type === syntax_1.Syntax.Identifier) {
	                this.tolerateError(messages_1.Messages.StrictDelete);
	            }
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        else if (this.context.await && this.matchContextualKeyword('await')) {
	            expr = this.parseAwaitExpression();
	        }
	        else {
	            expr = this.parseUpdateExpression();
	        }
	        return expr;
	    };
	    Parser.prototype.parseExponentiationExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseUnaryExpression);
	        if (expr.type !== syntax_1.Syntax.UnaryExpression && this.match('**')) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.BinaryExpression('**', left, right));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-exp-operator
	    // https://tc39.github.io/ecma262/#sec-multiplicative-operators
	    // https://tc39.github.io/ecma262/#sec-additive-operators
	    // https://tc39.github.io/ecma262/#sec-bitwise-shift-operators
	    // https://tc39.github.io/ecma262/#sec-relational-operators
	    // https://tc39.github.io/ecma262/#sec-equality-operators
	    // https://tc39.github.io/ecma262/#sec-binary-bitwise-operators
	    // https://tc39.github.io/ecma262/#sec-binary-logical-operators
	    Parser.prototype.binaryPrecedence = function (token) {
	        var op = token.value;
	        var precedence;
	        if (token.type === 7 /* Punctuator */) {
	            precedence = this.operatorPrecedence[op] || 0;
	        }
	        else if (token.type === 4 /* Keyword */) {
	            precedence = (op === 'instanceof' || (this.context.allowIn && op === 'in')) ? 7 : 0;
	        }
	        else {
	            precedence = 0;
	        }
	        return precedence;
	    };
	    Parser.prototype.parseBinaryExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseExponentiationExpression);
	        var token = this.lookahead;
	        var prec = this.binaryPrecedence(token);
	        if (prec > 0) {
	            this.nextToken();
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	            var markers = [startToken, this.lookahead];
	            var left = expr;
	            var right = this.isolateCoverGrammar(this.parseExponentiationExpression);
	            var stack = [left, token.value, right];
	            var precedences = [prec];
	            while (true) {
	                prec = this.binaryPrecedence(this.lookahead);
	                if (prec <= 0) {
	                    break;
	                }
	                // Reduce: make a binary expression from the three topmost entries.
	                while ((stack.length > 2) && (prec <= precedences[precedences.length - 1])) {
	                    right = stack.pop();
	                    var operator = stack.pop();
	                    precedences.pop();
	                    left = stack.pop();
	                    markers.pop();
	                    var node = this.startNode(markers[markers.length - 1]);
	                    stack.push(this.finalize(node, new Node.BinaryExpression(operator, left, right)));
	                }
	                // Shift.
	                stack.push(this.nextToken().value);
	                precedences.push(prec);
	                markers.push(this.lookahead);
	                stack.push(this.isolateCoverGrammar(this.parseExponentiationExpression));
	            }
	            // Final reduce to clean-up the stack.
	            var i = stack.length - 1;
	            expr = stack[i];
	            var lastMarker = markers.pop();
	            while (i > 1) {
	                var marker = markers.pop();
	                var lastLineStart = lastMarker && lastMarker.lineStart;
	                var node = this.startNode(marker, lastLineStart);
	                var operator = stack[i - 1];
	                expr = this.finalize(node, new Node.BinaryExpression(operator, stack[i - 2], expr));
	                i -= 2;
	                lastMarker = marker;
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-conditional-operator
	    Parser.prototype.parseConditionalExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.inheritCoverGrammar(this.parseBinaryExpression);
	        if (this.match('?')) {
	            this.nextToken();
	            var previousAllowIn = this.context.allowIn;
	            this.context.allowIn = true;
	            var consequent = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowIn = previousAllowIn;
	            this.expect(':');
	            var alternate = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            expr = this.finalize(this.startNode(startToken), new Node.ConditionalExpression(expr, consequent, alternate));
	            this.context.isAssignmentTarget = false;
	            this.context.isBindingElement = false;
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-assignment-operators
	    Parser.prototype.checkPatternParam = function (options, param) {
	        switch (param.type) {
	            case syntax_1.Syntax.Identifier:
	                this.validateParam(options, param, param.name);
	                break;
	            case syntax_1.Syntax.RestElement:
	                this.checkPatternParam(options, param.argument);
	                break;
	            case syntax_1.Syntax.AssignmentPattern:
	                this.checkPatternParam(options, param.left);
	                break;
	            case syntax_1.Syntax.ArrayPattern:
	                for (var i = 0; i < param.elements.length; i++) {
	                    if (param.elements[i] !== null) {
	                        this.checkPatternParam(options, param.elements[i]);
	                    }
	                }
	                break;
	            case syntax_1.Syntax.ObjectPattern:
	                for (var i = 0; i < param.properties.length; i++) {
	                    this.checkPatternParam(options, param.properties[i].value);
	                }
	                break;
	            default:
	                break;
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	    };
	    Parser.prototype.reinterpretAsCoverFormalsList = function (expr) {
	        var params = [expr];
	        var options;
	        var asyncArrow = false;
	        switch (expr.type) {
	            case syntax_1.Syntax.Identifier:
	                break;
	            case ArrowParameterPlaceHolder:
	                params = expr.params;
	                asyncArrow = expr.async;
	                break;
	            default:
	                return null;
	        }
	        options = {
	            simple: true,
	            paramSet: {}
	        };
	        for (var i = 0; i < params.length; ++i) {
	            var param = params[i];
	            if (param.type === syntax_1.Syntax.AssignmentPattern) {
	                if (param.right.type === syntax_1.Syntax.YieldExpression) {
	                    if (param.right.argument) {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                    param.right.type = syntax_1.Syntax.Identifier;
	                    param.right.name = 'yield';
	                    delete param.right.argument;
	                    delete param.right.delegate;
	                }
	            }
	            else if (asyncArrow && param.type === syntax_1.Syntax.Identifier && param.name === 'await') {
	                this.throwUnexpectedToken(this.lookahead);
	            }
	            this.checkPatternParam(options, param);
	            params[i] = param;
	        }
	        if (this.context.strict || !this.context.allowYield) {
	            for (var i = 0; i < params.length; ++i) {
	                var param = params[i];
	                if (param.type === syntax_1.Syntax.YieldExpression) {
	                    this.throwUnexpectedToken(this.lookahead);
	                }
	            }
	        }
	        if (options.message === messages_1.Messages.StrictParamDupe) {
	            var token = this.context.strict ? options.stricted : options.firstRestricted;
	            this.throwUnexpectedToken(token, options.message);
	        }
	        return {
	            simple: options.simple,
	            params: params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.parseAssignmentExpression = function () {
	        var expr;
	        if (!this.context.allowYield && this.matchKeyword('yield')) {
	            expr = this.parseYieldExpression();
	        }
	        else {
	            var startToken = this.lookahead;
	            var token = startToken;
	            expr = this.parseConditionalExpression();
	            if (token.type === 3 /* Identifier */ && (token.lineNumber === this.lookahead.lineNumber) && token.value === 'async') {
	                if (this.lookahead.type === 3 /* Identifier */ || this.matchKeyword('yield')) {
	                    var arg = this.parsePrimaryExpression();
	                    this.reinterpretExpressionAsPattern(arg);
	                    expr = {
	                        type: ArrowParameterPlaceHolder,
	                        params: [arg],
	                        async: true
	                    };
	                }
	            }
	            if (expr.type === ArrowParameterPlaceHolder || this.match('=>')) {
	                // https://tc39.github.io/ecma262/#sec-arrow-function-definitions
	                this.context.isAssignmentTarget = false;
	                this.context.isBindingElement = false;
	                var isAsync = expr.async;
	                var list = this.reinterpretAsCoverFormalsList(expr);
	                if (list) {
	                    if (this.hasLineTerminator) {
	                        this.tolerateUnexpectedToken(this.lookahead);
	                    }
	                    this.context.firstCoverInitializedNameError = null;
	                    var previousStrict = this.context.strict;
	                    var previousAllowStrictDirective = this.context.allowStrictDirective;
	                    this.context.allowStrictDirective = list.simple;
	                    var previousAllowYield = this.context.allowYield;
	                    var previousAwait = this.context.await;
	                    this.context.allowYield = true;
	                    this.context.await = isAsync;
	                    var node = this.startNode(startToken);
	                    this.expect('=>');
	                    var body = void 0;
	                    if (this.match('{')) {
	                        var previousAllowIn = this.context.allowIn;
	                        this.context.allowIn = true;
	                        body = this.parseFunctionSourceElements();
	                        this.context.allowIn = previousAllowIn;
	                    }
	                    else {
	                        body = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    }
	                    var expression = body.type !== syntax_1.Syntax.BlockStatement;
	                    if (this.context.strict && list.firstRestricted) {
	                        this.throwUnexpectedToken(list.firstRestricted, list.message);
	                    }
	                    if (this.context.strict && list.stricted) {
	                        this.tolerateUnexpectedToken(list.stricted, list.message);
	                    }
	                    expr = isAsync ? this.finalize(node, new Node.AsyncArrowFunctionExpression(list.params, body, expression)) :
	                        this.finalize(node, new Node.ArrowFunctionExpression(list.params, body, expression));
	                    this.context.strict = previousStrict;
	                    this.context.allowStrictDirective = previousAllowStrictDirective;
	                    this.context.allowYield = previousAllowYield;
	                    this.context.await = previousAwait;
	                }
	            }
	            else {
	                if (this.matchAssign()) {
	                    if (!this.context.isAssignmentTarget) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInAssignment);
	                    }
	                    if (this.context.strict && expr.type === syntax_1.Syntax.Identifier) {
	                        var id = expr;
	                        if (this.scanner.isRestrictedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictLHSAssignment);
	                        }
	                        if (this.scanner.isStrictModeReservedWord(id.name)) {
	                            this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	                        }
	                    }
	                    if (!this.match('=')) {
	                        this.context.isAssignmentTarget = false;
	                        this.context.isBindingElement = false;
	                    }
	                    else {
	                        this.reinterpretExpressionAsPattern(expr);
	                    }
	                    token = this.nextToken();
	                    var operator = token.value;
	                    var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                    expr = this.finalize(this.startNode(startToken), new Node.AssignmentExpression(operator, expr, right));
	                    this.context.firstCoverInitializedNameError = null;
	                }
	            }
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-comma-operator
	    Parser.prototype.parseExpression = function () {
	        var startToken = this.lookahead;
	        var expr = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        if (this.match(',')) {
	            var expressions = [];
	            expressions.push(expr);
	            while (this.lookahead.type !== 2 /* EOF */) {
	                if (!this.match(',')) {
	                    break;
	                }
	                this.nextToken();
	                expressions.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	            }
	            expr = this.finalize(this.startNode(startToken), new Node.SequenceExpression(expressions));
	        }
	        return expr;
	    };
	    // https://tc39.github.io/ecma262/#sec-block
	    Parser.prototype.parseStatementListItem = function () {
	        var statement;
	        this.context.isAssignmentTarget = true;
	        this.context.isBindingElement = true;
	        if (this.lookahead.type === 4 /* Keyword */) {
	            switch (this.lookahead.value) {
	                case 'export':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalExportDeclaration);
	                    }
	                    statement = this.parseExportDeclaration();
	                    break;
	                case 'import':
	                    if (!this.context.isModule) {
	                        this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.IllegalImportDeclaration);
	                    }
	                    statement = this.parseImportDeclaration();
	                    break;
	                case 'const':
	                    statement = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'function':
	                    statement = this.parseFunctionDeclaration();
	                    break;
	                case 'class':
	                    statement = this.parseClassDeclaration();
	                    break;
	                case 'let':
	                    statement = this.isLexicalDeclaration() ? this.parseLexicalDeclaration({ inFor: false }) : this.parseStatement();
	                    break;
	                default:
	                    statement = this.parseStatement();
	                    break;
	            }
	        }
	        else {
	            statement = this.parseStatement();
	        }
	        return statement;
	    };
	    Parser.prototype.parseBlock = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var block = [];
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            block.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.BlockStatement(block));
	    };
	    // https://tc39.github.io/ecma262/#sec-let-and-const-declarations
	    Parser.prototype.parseLexicalBinding = function (kind, options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, kind);
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (kind === 'const') {
	            if (!this.matchKeyword('in') && !this.matchContextualKeyword('of')) {
	                if (this.match('=')) {
	                    this.nextToken();
	                    init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	                }
	                else {
	                    this.throwError(messages_1.Messages.DeclarationMissingInitializer, 'const');
	                }
	            }
	        }
	        else if ((!options.inFor && id.type !== syntax_1.Syntax.Identifier) || this.match('=')) {
	            this.expect('=');
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseBindingList = function (kind, options) {
	        var list = [this.parseLexicalBinding(kind, options)];
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseLexicalBinding(kind, options));
	        }
	        return list;
	    };
	    Parser.prototype.isLexicalDeclaration = function () {
	        var state = this.scanner.saveState();
	        this.scanner.scanComments();
	        var next = this.scanner.lex();
	        this.scanner.restoreState(state);
	        return (next.type === 3 /* Identifier */) ||
	            (next.type === 7 /* Punctuator */ && next.value === '[') ||
	            (next.type === 7 /* Punctuator */ && next.value === '{') ||
	            (next.type === 4 /* Keyword */ && next.value === 'let') ||
	            (next.type === 4 /* Keyword */ && next.value === 'yield');
	    };
	    Parser.prototype.parseLexicalDeclaration = function (options) {
	        var node = this.createNode();
	        var kind = this.nextToken().value;
	        assert_1.assert(kind === 'let' || kind === 'const', 'Lexical declaration must be either let or const');
	        var declarations = this.parseBindingList(kind, options);
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, kind));
	    };
	    // https://tc39.github.io/ecma262/#sec-destructuring-binding-patterns
	    Parser.prototype.parseBindingRestElement = function (params, kind) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params, kind);
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseArrayPattern = function (params, kind) {
	        var node = this.createNode();
	        this.expect('[');
	        var elements = [];
	        while (!this.match(']')) {
	            if (this.match(',')) {
	                this.nextToken();
	                elements.push(null);
	            }
	            else {
	                if (this.match('...')) {
	                    elements.push(this.parseBindingRestElement(params, kind));
	                    break;
	                }
	                else {
	                    elements.push(this.parsePatternWithDefault(params, kind));
	                }
	                if (!this.match(']')) {
	                    this.expect(',');
	                }
	            }
	        }
	        this.expect(']');
	        return this.finalize(node, new Node.ArrayPattern(elements));
	    };
	    Parser.prototype.parsePropertyPattern = function (params, kind) {
	        var node = this.createNode();
	        var computed = false;
	        var shorthand = false;
	        var method = false;
	        var key;
	        var value;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            var keyToken = this.lookahead;
	            key = this.parseVariableIdentifier();
	            var init = this.finalize(node, new Node.Identifier(keyToken.value));
	            if (this.match('=')) {
	                params.push(keyToken);
	                shorthand = true;
	                this.nextToken();
	                var expr = this.parseAssignmentExpression();
	                value = this.finalize(this.startNode(keyToken), new Node.AssignmentPattern(init, expr));
	            }
	            else if (!this.match(':')) {
	                params.push(keyToken);
	                shorthand = true;
	                value = init;
	            }
	            else {
	                this.expect(':');
	                value = this.parsePatternWithDefault(params, kind);
	            }
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            this.expect(':');
	            value = this.parsePatternWithDefault(params, kind);
	        }
	        return this.finalize(node, new Node.Property('init', key, computed, value, method, shorthand));
	    };
	    Parser.prototype.parseObjectPattern = function (params, kind) {
	        var node = this.createNode();
	        var properties = [];
	        this.expect('{');
	        while (!this.match('}')) {
	            properties.push(this.parsePropertyPattern(params, kind));
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return this.finalize(node, new Node.ObjectPattern(properties));
	    };
	    Parser.prototype.parsePattern = function (params, kind) {
	        var pattern;
	        if (this.match('[')) {
	            pattern = this.parseArrayPattern(params, kind);
	        }
	        else if (this.match('{')) {
	            pattern = this.parseObjectPattern(params, kind);
	        }
	        else {
	            if (this.matchKeyword('let') && (kind === 'const' || kind === 'let')) {
	                this.tolerateUnexpectedToken(this.lookahead, messages_1.Messages.LetInLexicalBinding);
	            }
	            params.push(this.lookahead);
	            pattern = this.parseVariableIdentifier(kind);
	        }
	        return pattern;
	    };
	    Parser.prototype.parsePatternWithDefault = function (params, kind) {
	        var startToken = this.lookahead;
	        var pattern = this.parsePattern(params, kind);
	        if (this.match('=')) {
	            this.nextToken();
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = true;
	            var right = this.isolateCoverGrammar(this.parseAssignmentExpression);
	            this.context.allowYield = previousAllowYield;
	            pattern = this.finalize(this.startNode(startToken), new Node.AssignmentPattern(pattern, right));
	        }
	        return pattern;
	    };
	    // https://tc39.github.io/ecma262/#sec-variable-statement
	    Parser.prototype.parseVariableIdentifier = function (kind) {
	        var node = this.createNode();
	        var token = this.nextToken();
	        if (token.type === 4 /* Keyword */ && token.value === 'yield') {
	            if (this.context.strict) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else if (!this.context.allowYield) {
	                this.throwUnexpectedToken(token);
	            }
	        }
	        else if (token.type !== 3 /* Identifier */) {
	            if (this.context.strict && token.type === 4 /* Keyword */ && this.scanner.isStrictModeReservedWord(token.value)) {
	                this.tolerateUnexpectedToken(token, messages_1.Messages.StrictReservedWord);
	            }
	            else {
	                if (this.context.strict || token.value !== 'let' || kind !== 'var') {
	                    this.throwUnexpectedToken(token);
	                }
	            }
	        }
	        else if ((this.context.isModule || this.context.await) && token.type === 3 /* Identifier */ && token.value === 'await') {
	            this.tolerateUnexpectedToken(token);
	        }
	        return this.finalize(node, new Node.Identifier(token.value));
	    };
	    Parser.prototype.parseVariableDeclaration = function (options) {
	        var node = this.createNode();
	        var params = [];
	        var id = this.parsePattern(params, 'var');
	        if (this.context.strict && id.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(id.name)) {
	                this.tolerateError(messages_1.Messages.StrictVarName);
	            }
	        }
	        var init = null;
	        if (this.match('=')) {
	            this.nextToken();
	            init = this.isolateCoverGrammar(this.parseAssignmentExpression);
	        }
	        else if (id.type !== syntax_1.Syntax.Identifier && !options.inFor) {
	            this.expect('=');
	        }
	        return this.finalize(node, new Node.VariableDeclarator(id, init));
	    };
	    Parser.prototype.parseVariableDeclarationList = function (options) {
	        var opt = { inFor: options.inFor };
	        var list = [];
	        list.push(this.parseVariableDeclaration(opt));
	        while (this.match(',')) {
	            this.nextToken();
	            list.push(this.parseVariableDeclaration(opt));
	        }
	        return list;
	    };
	    Parser.prototype.parseVariableStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('var');
	        var declarations = this.parseVariableDeclarationList({ inFor: false });
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.VariableDeclaration(declarations, 'var'));
	    };
	    // https://tc39.github.io/ecma262/#sec-empty-statement
	    Parser.prototype.parseEmptyStatement = function () {
	        var node = this.createNode();
	        this.expect(';');
	        return this.finalize(node, new Node.EmptyStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-expression-statement
	    Parser.prototype.parseExpressionStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ExpressionStatement(expr));
	    };
	    // https://tc39.github.io/ecma262/#sec-if-statement
	    Parser.prototype.parseIfClause = function () {
	        if (this.context.strict && this.matchKeyword('function')) {
	            this.tolerateError(messages_1.Messages.StrictFunction);
	        }
	        return this.parseStatement();
	    };
	    Parser.prototype.parseIfStatement = function () {
	        var node = this.createNode();
	        var consequent;
	        var alternate = null;
	        this.expectKeyword('if');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            consequent = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            consequent = this.parseIfClause();
	            if (this.matchKeyword('else')) {
	                this.nextToken();
	                alternate = this.parseIfClause();
	            }
	        }
	        return this.finalize(node, new Node.IfStatement(test, consequent, alternate));
	    };
	    // https://tc39.github.io/ecma262/#sec-do-while-statement
	    Parser.prototype.parseDoWhileStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('do');
	        var previousInIteration = this.context.inIteration;
	        this.context.inIteration = true;
	        var body = this.parseStatement();
	        this.context.inIteration = previousInIteration;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	        }
	        else {
	            this.expect(')');
	            if (this.match(';')) {
	                this.nextToken();
	            }
	        }
	        return this.finalize(node, new Node.DoWhileStatement(body, test));
	    };
	    // https://tc39.github.io/ecma262/#sec-while-statement
	    Parser.prototype.parseWhileStatement = function () {
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('while');
	        this.expect('(');
	        var test = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.parseStatement();
	            this.context.inIteration = previousInIteration;
	        }
	        return this.finalize(node, new Node.WhileStatement(test, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-for-statement
	    // https://tc39.github.io/ecma262/#sec-for-in-and-for-of-statements
	    Parser.prototype.parseForStatement = function () {
	        var init = null;
	        var test = null;
	        var update = null;
	        var forIn = true;
	        var left, right;
	        var node = this.createNode();
	        this.expectKeyword('for');
	        this.expect('(');
	        if (this.match(';')) {
	            this.nextToken();
	        }
	        else {
	            if (this.matchKeyword('var')) {
	                init = this.createNode();
	                this.nextToken();
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                var declarations = this.parseVariableDeclarationList({ inFor: true });
	                this.context.allowIn = previousAllowIn;
	                if (declarations.length === 1 && this.matchKeyword('in')) {
	                    var decl = declarations[0];
	                    if (decl.init && (decl.id.type === syntax_1.Syntax.ArrayPattern || decl.id.type === syntax_1.Syntax.ObjectPattern || this.context.strict)) {
	                        this.tolerateError(messages_1.Messages.ForInOfLoopInitializer, 'for-in');
	                    }
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    init = this.finalize(init, new Node.VariableDeclaration(declarations, 'var'));
	                    this.expect(';');
	                }
	            }
	            else if (this.matchKeyword('const') || this.matchKeyword('let')) {
	                init = this.createNode();
	                var kind = this.nextToken().value;
	                if (!this.context.strict && this.lookahead.value === 'in') {
	                    init = this.finalize(init, new Node.Identifier(kind));
	                    this.nextToken();
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else {
	                    var previousAllowIn = this.context.allowIn;
	                    this.context.allowIn = false;
	                    var declarations = this.parseBindingList(kind, { inFor: true });
	                    this.context.allowIn = previousAllowIn;
	                    if (declarations.length === 1 && declarations[0].init === null && this.matchKeyword('in')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseExpression();
	                        init = null;
	                    }
	                    else if (declarations.length === 1 && declarations[0].init === null && this.matchContextualKeyword('of')) {
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                        this.nextToken();
	                        left = init;
	                        right = this.parseAssignmentExpression();
	                        init = null;
	                        forIn = false;
	                    }
	                    else {
	                        this.consumeSemicolon();
	                        init = this.finalize(init, new Node.VariableDeclaration(declarations, kind));
	                    }
	                }
	            }
	            else {
	                var initStartToken = this.lookahead;
	                var previousAllowIn = this.context.allowIn;
	                this.context.allowIn = false;
	                init = this.inheritCoverGrammar(this.parseAssignmentExpression);
	                this.context.allowIn = previousAllowIn;
	                if (this.matchKeyword('in')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForIn);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseExpression();
	                    init = null;
	                }
	                else if (this.matchContextualKeyword('of')) {
	                    if (!this.context.isAssignmentTarget || init.type === syntax_1.Syntax.AssignmentExpression) {
	                        this.tolerateError(messages_1.Messages.InvalidLHSInForLoop);
	                    }
	                    this.nextToken();
	                    this.reinterpretExpressionAsPattern(init);
	                    left = init;
	                    right = this.parseAssignmentExpression();
	                    init = null;
	                    forIn = false;
	                }
	                else {
	                    if (this.match(',')) {
	                        var initSeq = [init];
	                        while (this.match(',')) {
	                            this.nextToken();
	                            initSeq.push(this.isolateCoverGrammar(this.parseAssignmentExpression));
	                        }
	                        init = this.finalize(this.startNode(initStartToken), new Node.SequenceExpression(initSeq));
	                    }
	                    this.expect(';');
	                }
	            }
	        }
	        if (typeof left === 'undefined') {
	            if (!this.match(';')) {
	                test = this.parseExpression();
	            }
	            this.expect(';');
	            if (!this.match(')')) {
	                update = this.parseExpression();
	            }
	        }
	        var body;
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            var previousInIteration = this.context.inIteration;
	            this.context.inIteration = true;
	            body = this.isolateCoverGrammar(this.parseStatement);
	            this.context.inIteration = previousInIteration;
	        }
	        return (typeof left === 'undefined') ?
	            this.finalize(node, new Node.ForStatement(init, test, update, body)) :
	            forIn ? this.finalize(node, new Node.ForInStatement(left, right, body)) :
	                this.finalize(node, new Node.ForOfStatement(left, right, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-continue-statement
	    Parser.prototype.parseContinueStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('continue');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            label = id;
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration) {
	            this.throwError(messages_1.Messages.IllegalContinue);
	        }
	        return this.finalize(node, new Node.ContinueStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-break-statement
	    Parser.prototype.parseBreakStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('break');
	        var label = null;
	        if (this.lookahead.type === 3 /* Identifier */ && !this.hasLineTerminator) {
	            var id = this.parseVariableIdentifier();
	            var key = '$' + id.name;
	            if (!Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.UnknownLabel, id.name);
	            }
	            label = id;
	        }
	        this.consumeSemicolon();
	        if (label === null && !this.context.inIteration && !this.context.inSwitch) {
	            this.throwError(messages_1.Messages.IllegalBreak);
	        }
	        return this.finalize(node, new Node.BreakStatement(label));
	    };
	    // https://tc39.github.io/ecma262/#sec-return-statement
	    Parser.prototype.parseReturnStatement = function () {
	        if (!this.context.inFunctionBody) {
	            this.tolerateError(messages_1.Messages.IllegalReturn);
	        }
	        var node = this.createNode();
	        this.expectKeyword('return');
	        var hasArgument = (!this.match(';') && !this.match('}') &&
	            !this.hasLineTerminator && this.lookahead.type !== 2 /* EOF */) ||
	            this.lookahead.type === 8 /* StringLiteral */ ||
	            this.lookahead.type === 10 /* Template */;
	        var argument = hasArgument ? this.parseExpression() : null;
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ReturnStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-with-statement
	    Parser.prototype.parseWithStatement = function () {
	        if (this.context.strict) {
	            this.tolerateError(messages_1.Messages.StrictModeWith);
	        }
	        var node = this.createNode();
	        var body;
	        this.expectKeyword('with');
	        this.expect('(');
	        var object = this.parseExpression();
	        if (!this.match(')') && this.config.tolerant) {
	            this.tolerateUnexpectedToken(this.nextToken());
	            body = this.finalize(this.createNode(), new Node.EmptyStatement());
	        }
	        else {
	            this.expect(')');
	            body = this.parseStatement();
	        }
	        return this.finalize(node, new Node.WithStatement(object, body));
	    };
	    // https://tc39.github.io/ecma262/#sec-switch-statement
	    Parser.prototype.parseSwitchCase = function () {
	        var node = this.createNode();
	        var test;
	        if (this.matchKeyword('default')) {
	            this.nextToken();
	            test = null;
	        }
	        else {
	            this.expectKeyword('case');
	            test = this.parseExpression();
	        }
	        this.expect(':');
	        var consequent = [];
	        while (true) {
	            if (this.match('}') || this.matchKeyword('default') || this.matchKeyword('case')) {
	                break;
	            }
	            consequent.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.SwitchCase(test, consequent));
	    };
	    Parser.prototype.parseSwitchStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('switch');
	        this.expect('(');
	        var discriminant = this.parseExpression();
	        this.expect(')');
	        var previousInSwitch = this.context.inSwitch;
	        this.context.inSwitch = true;
	        var cases = [];
	        var defaultFound = false;
	        this.expect('{');
	        while (true) {
	            if (this.match('}')) {
	                break;
	            }
	            var clause = this.parseSwitchCase();
	            if (clause.test === null) {
	                if (defaultFound) {
	                    this.throwError(messages_1.Messages.MultipleDefaultsInSwitch);
	                }
	                defaultFound = true;
	            }
	            cases.push(clause);
	        }
	        this.expect('}');
	        this.context.inSwitch = previousInSwitch;
	        return this.finalize(node, new Node.SwitchStatement(discriminant, cases));
	    };
	    // https://tc39.github.io/ecma262/#sec-labelled-statements
	    Parser.prototype.parseLabelledStatement = function () {
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var statement;
	        if ((expr.type === syntax_1.Syntax.Identifier) && this.match(':')) {
	            this.nextToken();
	            var id = expr;
	            var key = '$' + id.name;
	            if (Object.prototype.hasOwnProperty.call(this.context.labelSet, key)) {
	                this.throwError(messages_1.Messages.Redeclaration, 'Label', id.name);
	            }
	            this.context.labelSet[key] = true;
	            var body = void 0;
	            if (this.matchKeyword('class')) {
	                this.tolerateUnexpectedToken(this.lookahead);
	                body = this.parseClassDeclaration();
	            }
	            else if (this.matchKeyword('function')) {
	                var token = this.lookahead;
	                var declaration = this.parseFunctionDeclaration();
	                if (this.context.strict) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunction);
	                }
	                else if (declaration.generator) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.GeneratorInLegacyContext);
	                }
	                body = declaration;
	            }
	            else {
	                body = this.parseStatement();
	            }
	            delete this.context.labelSet[key];
	            statement = new Node.LabeledStatement(id, body);
	        }
	        else {
	            this.consumeSemicolon();
	            statement = new Node.ExpressionStatement(expr);
	        }
	        return this.finalize(node, statement);
	    };
	    // https://tc39.github.io/ecma262/#sec-throw-statement
	    Parser.prototype.parseThrowStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('throw');
	        if (this.hasLineTerminator) {
	            this.throwError(messages_1.Messages.NewlineAfterThrow);
	        }
	        var argument = this.parseExpression();
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ThrowStatement(argument));
	    };
	    // https://tc39.github.io/ecma262/#sec-try-statement
	    Parser.prototype.parseCatchClause = function () {
	        var node = this.createNode();
	        this.expectKeyword('catch');
	        this.expect('(');
	        if (this.match(')')) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        var params = [];
	        var param = this.parsePattern(params);
	        var paramMap = {};
	        for (var i = 0; i < params.length; i++) {
	            var key = '$' + params[i].value;
	            if (Object.prototype.hasOwnProperty.call(paramMap, key)) {
	                this.tolerateError(messages_1.Messages.DuplicateBinding, params[i].value);
	            }
	            paramMap[key] = true;
	        }
	        if (this.context.strict && param.type === syntax_1.Syntax.Identifier) {
	            if (this.scanner.isRestrictedWord(param.name)) {
	                this.tolerateError(messages_1.Messages.StrictCatchVariable);
	            }
	        }
	        this.expect(')');
	        var body = this.parseBlock();
	        return this.finalize(node, new Node.CatchClause(param, body));
	    };
	    Parser.prototype.parseFinallyClause = function () {
	        this.expectKeyword('finally');
	        return this.parseBlock();
	    };
	    Parser.prototype.parseTryStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('try');
	        var block = this.parseBlock();
	        var handler = this.matchKeyword('catch') ? this.parseCatchClause() : null;
	        var finalizer = this.matchKeyword('finally') ? this.parseFinallyClause() : null;
	        if (!handler && !finalizer) {
	            this.throwError(messages_1.Messages.NoCatchOrFinally);
	        }
	        return this.finalize(node, new Node.TryStatement(block, handler, finalizer));
	    };
	    // https://tc39.github.io/ecma262/#sec-debugger-statement
	    Parser.prototype.parseDebuggerStatement = function () {
	        var node = this.createNode();
	        this.expectKeyword('debugger');
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.DebuggerStatement());
	    };
	    // https://tc39.github.io/ecma262/#sec-ecmascript-language-statements-and-declarations
	    Parser.prototype.parseStatement = function () {
	        var statement;
	        switch (this.lookahead.type) {
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 8 /* StringLiteral */:
	            case 10 /* Template */:
	            case 9 /* RegularExpression */:
	                statement = this.parseExpressionStatement();
	                break;
	            case 7 /* Punctuator */:
	                var value = this.lookahead.value;
	                if (value === '{') {
	                    statement = this.parseBlock();
	                }
	                else if (value === '(') {
	                    statement = this.parseExpressionStatement();
	                }
	                else if (value === ';') {
	                    statement = this.parseEmptyStatement();
	                }
	                else {
	                    statement = this.parseExpressionStatement();
	                }
	                break;
	            case 3 /* Identifier */:
	                statement = this.matchAsyncFunction() ? this.parseFunctionDeclaration() : this.parseLabelledStatement();
	                break;
	            case 4 /* Keyword */:
	                switch (this.lookahead.value) {
	                    case 'break':
	                        statement = this.parseBreakStatement();
	                        break;
	                    case 'continue':
	                        statement = this.parseContinueStatement();
	                        break;
	                    case 'debugger':
	                        statement = this.parseDebuggerStatement();
	                        break;
	                    case 'do':
	                        statement = this.parseDoWhileStatement();
	                        break;
	                    case 'for':
	                        statement = this.parseForStatement();
	                        break;
	                    case 'function':
	                        statement = this.parseFunctionDeclaration();
	                        break;
	                    case 'if':
	                        statement = this.parseIfStatement();
	                        break;
	                    case 'return':
	                        statement = this.parseReturnStatement();
	                        break;
	                    case 'switch':
	                        statement = this.parseSwitchStatement();
	                        break;
	                    case 'throw':
	                        statement = this.parseThrowStatement();
	                        break;
	                    case 'try':
	                        statement = this.parseTryStatement();
	                        break;
	                    case 'var':
	                        statement = this.parseVariableStatement();
	                        break;
	                    case 'while':
	                        statement = this.parseWhileStatement();
	                        break;
	                    case 'with':
	                        statement = this.parseWithStatement();
	                        break;
	                    default:
	                        statement = this.parseExpressionStatement();
	                        break;
	                }
	                break;
	            default:
	                statement = this.throwUnexpectedToken(this.lookahead);
	        }
	        return statement;
	    };
	    // https://tc39.github.io/ecma262/#sec-function-definitions
	    Parser.prototype.parseFunctionSourceElements = function () {
	        var node = this.createNode();
	        this.expect('{');
	        var body = this.parseDirectivePrologues();
	        var previousLabelSet = this.context.labelSet;
	        var previousInIteration = this.context.inIteration;
	        var previousInSwitch = this.context.inSwitch;
	        var previousInFunctionBody = this.context.inFunctionBody;
	        this.context.labelSet = {};
	        this.context.inIteration = false;
	        this.context.inSwitch = false;
	        this.context.inFunctionBody = true;
	        while (this.lookahead.type !== 2 /* EOF */) {
	            if (this.match('}')) {
	                break;
	            }
	            body.push(this.parseStatementListItem());
	        }
	        this.expect('}');
	        this.context.labelSet = previousLabelSet;
	        this.context.inIteration = previousInIteration;
	        this.context.inSwitch = previousInSwitch;
	        this.context.inFunctionBody = previousInFunctionBody;
	        return this.finalize(node, new Node.BlockStatement(body));
	    };
	    Parser.prototype.validateParam = function (options, param, name) {
	        var key = '$' + name;
	        if (this.context.strict) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        else if (!options.firstRestricted) {
	            if (this.scanner.isRestrictedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictParamName;
	            }
	            else if (this.scanner.isStrictModeReservedWord(name)) {
	                options.firstRestricted = param;
	                options.message = messages_1.Messages.StrictReservedWord;
	            }
	            else if (Object.prototype.hasOwnProperty.call(options.paramSet, key)) {
	                options.stricted = param;
	                options.message = messages_1.Messages.StrictParamDupe;
	            }
	        }
	        /* istanbul ignore next */
	        if (typeof Object.defineProperty === 'function') {
	            Object.defineProperty(options.paramSet, key, { value: true, enumerable: true, writable: true, configurable: true });
	        }
	        else {
	            options.paramSet[key] = true;
	        }
	    };
	    Parser.prototype.parseRestElement = function (params) {
	        var node = this.createNode();
	        this.expect('...');
	        var arg = this.parsePattern(params);
	        if (this.match('=')) {
	            this.throwError(messages_1.Messages.DefaultRestParameter);
	        }
	        if (!this.match(')')) {
	            this.throwError(messages_1.Messages.ParameterAfterRestParameter);
	        }
	        return this.finalize(node, new Node.RestElement(arg));
	    };
	    Parser.prototype.parseFormalParameter = function (options) {
	        var params = [];
	        var param = this.match('...') ? this.parseRestElement(params) : this.parsePatternWithDefault(params);
	        for (var i = 0; i < params.length; i++) {
	            this.validateParam(options, params[i], params[i].value);
	        }
	        options.simple = options.simple && (param instanceof Node.Identifier);
	        options.params.push(param);
	    };
	    Parser.prototype.parseFormalParameters = function (firstRestricted) {
	        var options;
	        options = {
	            simple: true,
	            params: [],
	            firstRestricted: firstRestricted
	        };
	        this.expect('(');
	        if (!this.match(')')) {
	            options.paramSet = {};
	            while (this.lookahead.type !== 2 /* EOF */) {
	                this.parseFormalParameter(options);
	                if (this.match(')')) {
	                    break;
	                }
	                this.expect(',');
	                if (this.match(')')) {
	                    break;
	                }
	            }
	        }
	        this.expect(')');
	        return {
	            simple: options.simple,
	            params: options.params,
	            stricted: options.stricted,
	            firstRestricted: options.firstRestricted,
	            message: options.message
	        };
	    };
	    Parser.prototype.matchAsyncFunction = function () {
	        var match = this.matchContextualKeyword('async');
	        if (match) {
	            var state = this.scanner.saveState();
	            this.scanner.scanComments();
	            var next = this.scanner.lex();
	            this.scanner.restoreState(state);
	            match = (state.lineNumber === next.lineNumber) && (next.type === 4 /* Keyword */) && (next.value === 'function');
	        }
	        return match;
	    };
	    Parser.prototype.parseFunctionDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted = null;
	        if (!identifierIsOptional || !this.match('(')) {
	            var token = this.lookahead;
	            id = this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionDeclaration(id, params, body)) :
	            this.finalize(node, new Node.FunctionDeclaration(id, params, body, isGenerator));
	    };
	    Parser.prototype.parseFunctionExpression = function () {
	        var node = this.createNode();
	        var isAsync = this.matchContextualKeyword('async');
	        if (isAsync) {
	            this.nextToken();
	        }
	        this.expectKeyword('function');
	        var isGenerator = isAsync ? false : this.match('*');
	        if (isGenerator) {
	            this.nextToken();
	        }
	        var message;
	        var id = null;
	        var firstRestricted;
	        var previousAllowAwait = this.context.await;
	        var previousAllowYield = this.context.allowYield;
	        this.context.await = isAsync;
	        this.context.allowYield = !isGenerator;
	        if (!this.match('(')) {
	            var token = this.lookahead;
	            id = (!this.context.strict && !isGenerator && this.matchKeyword('yield')) ? this.parseIdentifierName() : this.parseVariableIdentifier();
	            if (this.context.strict) {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.StrictFunctionName);
	                }
	            }
	            else {
	                if (this.scanner.isRestrictedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictFunctionName;
	                }
	                else if (this.scanner.isStrictModeReservedWord(token.value)) {
	                    firstRestricted = token;
	                    message = messages_1.Messages.StrictReservedWord;
	                }
	            }
	        }
	        var formalParameters = this.parseFormalParameters(firstRestricted);
	        var params = formalParameters.params;
	        var stricted = formalParameters.stricted;
	        firstRestricted = formalParameters.firstRestricted;
	        if (formalParameters.message) {
	            message = formalParameters.message;
	        }
	        var previousStrict = this.context.strict;
	        var previousAllowStrictDirective = this.context.allowStrictDirective;
	        this.context.allowStrictDirective = formalParameters.simple;
	        var body = this.parseFunctionSourceElements();
	        if (this.context.strict && firstRestricted) {
	            this.throwUnexpectedToken(firstRestricted, message);
	        }
	        if (this.context.strict && stricted) {
	            this.tolerateUnexpectedToken(stricted, message);
	        }
	        this.context.strict = previousStrict;
	        this.context.allowStrictDirective = previousAllowStrictDirective;
	        this.context.await = previousAllowAwait;
	        this.context.allowYield = previousAllowYield;
	        return isAsync ? this.finalize(node, new Node.AsyncFunctionExpression(id, params, body)) :
	            this.finalize(node, new Node.FunctionExpression(id, params, body, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-directive-prologues-and-the-use-strict-directive
	    Parser.prototype.parseDirective = function () {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var expr = this.parseExpression();
	        var directive = (expr.type === syntax_1.Syntax.Literal) ? this.getTokenRaw(token).slice(1, -1) : null;
	        this.consumeSemicolon();
	        return this.finalize(node, directive ? new Node.Directive(expr, directive) : new Node.ExpressionStatement(expr));
	    };
	    Parser.prototype.parseDirectivePrologues = function () {
	        var firstRestricted = null;
	        var body = [];
	        while (true) {
	            var token = this.lookahead;
	            if (token.type !== 8 /* StringLiteral */) {
	                break;
	            }
	            var statement = this.parseDirective();
	            body.push(statement);
	            var directive = statement.directive;
	            if (typeof directive !== 'string') {
	                break;
	            }
	            if (directive === 'use strict') {
	                this.context.strict = true;
	                if (firstRestricted) {
	                    this.tolerateUnexpectedToken(firstRestricted, messages_1.Messages.StrictOctalLiteral);
	                }
	                if (!this.context.allowStrictDirective) {
	                    this.tolerateUnexpectedToken(token, messages_1.Messages.IllegalLanguageModeDirective);
	                }
	            }
	            else {
	                if (!firstRestricted && token.octal) {
	                    firstRestricted = token;
	                }
	            }
	        }
	        return body;
	    };
	    // https://tc39.github.io/ecma262/#sec-method-definitions
	    Parser.prototype.qualifiedPropertyName = function (token) {
	        switch (token.type) {
	            case 3 /* Identifier */:
	            case 8 /* StringLiteral */:
	            case 1 /* BooleanLiteral */:
	            case 5 /* NullLiteral */:
	            case 6 /* NumericLiteral */:
	            case 4 /* Keyword */:
	                return true;
	            case 7 /* Punctuator */:
	                return token.value === '[';
	            default:
	                break;
	        }
	        return false;
	    };
	    Parser.prototype.parseGetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length > 0) {
	            this.tolerateError(messages_1.Messages.BadGetterArity);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseSetterMethod = function () {
	        var node = this.createNode();
	        var isGenerator = false;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = !isGenerator;
	        var formalParameters = this.parseFormalParameters();
	        if (formalParameters.params.length !== 1) {
	            this.tolerateError(messages_1.Messages.BadSetterArity);
	        }
	        else if (formalParameters.params[0] instanceof Node.RestElement) {
	            this.tolerateError(messages_1.Messages.BadSetterRestParameter);
	        }
	        var method = this.parsePropertyMethod(formalParameters);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, formalParameters.params, method, isGenerator));
	    };
	    Parser.prototype.parseGeneratorMethod = function () {
	        var node = this.createNode();
	        var isGenerator = true;
	        var previousAllowYield = this.context.allowYield;
	        this.context.allowYield = true;
	        var params = this.parseFormalParameters();
	        this.context.allowYield = false;
	        var method = this.parsePropertyMethod(params);
	        this.context.allowYield = previousAllowYield;
	        return this.finalize(node, new Node.FunctionExpression(null, params.params, method, isGenerator));
	    };
	    // https://tc39.github.io/ecma262/#sec-generator-function-definitions
	    Parser.prototype.isStartOfExpression = function () {
	        var start = true;
	        var value = this.lookahead.value;
	        switch (this.lookahead.type) {
	            case 7 /* Punctuator */:
	                start = (value === '[') || (value === '(') || (value === '{') ||
	                    (value === '+') || (value === '-') ||
	                    (value === '!') || (value === '~') ||
	                    (value === '++') || (value === '--') ||
	                    (value === '/') || (value === '/='); // regular expression literal
	                break;
	            case 4 /* Keyword */:
	                start = (value === 'class') || (value === 'delete') ||
	                    (value === 'function') || (value === 'let') || (value === 'new') ||
	                    (value === 'super') || (value === 'this') || (value === 'typeof') ||
	                    (value === 'void') || (value === 'yield');
	                break;
	            default:
	                break;
	        }
	        return start;
	    };
	    Parser.prototype.parseYieldExpression = function () {
	        var node = this.createNode();
	        this.expectKeyword('yield');
	        var argument = null;
	        var delegate = false;
	        if (!this.hasLineTerminator) {
	            var previousAllowYield = this.context.allowYield;
	            this.context.allowYield = false;
	            delegate = this.match('*');
	            if (delegate) {
	                this.nextToken();
	                argument = this.parseAssignmentExpression();
	            }
	            else if (this.isStartOfExpression()) {
	                argument = this.parseAssignmentExpression();
	            }
	            this.context.allowYield = previousAllowYield;
	        }
	        return this.finalize(node, new Node.YieldExpression(argument, delegate));
	    };
	    // https://tc39.github.io/ecma262/#sec-class-definitions
	    Parser.prototype.parseClassElement = function (hasConstructor) {
	        var token = this.lookahead;
	        var node = this.createNode();
	        var kind = '';
	        var key = null;
	        var value = null;
	        var computed = false;
	        var method = false;
	        var isStatic = false;
	        var isAsync = false;
	        if (this.match('*')) {
	            this.nextToken();
	        }
	        else {
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            var id = key;
	            if (id.name === 'static' && (this.qualifiedPropertyName(this.lookahead) || this.match('*'))) {
	                token = this.lookahead;
	                isStatic = true;
	                computed = this.match('[');
	                if (this.match('*')) {
	                    this.nextToken();
	                }
	                else {
	                    key = this.parseObjectPropertyKey();
	                }
	            }
	            if ((token.type === 3 /* Identifier */) && !this.hasLineTerminator && (token.value === 'async')) {
	                var punctuator = this.lookahead.value;
	                if (punctuator !== ':' && punctuator !== '(' && punctuator !== '*') {
	                    isAsync = true;
	                    token = this.lookahead;
	                    key = this.parseObjectPropertyKey();
	                    if (token.type === 3 /* Identifier */ && token.value === 'constructor') {
	                        this.tolerateUnexpectedToken(token, messages_1.Messages.ConstructorIsAsync);
	                    }
	                }
	            }
	        }
	        var lookaheadPropertyKey = this.qualifiedPropertyName(this.lookahead);
	        if (token.type === 3 /* Identifier */) {
	            if (token.value === 'get' && lookaheadPropertyKey) {
	                kind = 'get';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                this.context.allowYield = false;
	                value = this.parseGetterMethod();
	            }
	            else if (token.value === 'set' && lookaheadPropertyKey) {
	                kind = 'set';
	                computed = this.match('[');
	                key = this.parseObjectPropertyKey();
	                value = this.parseSetterMethod();
	            }
	        }
	        else if (token.type === 7 /* Punctuator */ && token.value === '*' && lookaheadPropertyKey) {
	            kind = 'init';
	            computed = this.match('[');
	            key = this.parseObjectPropertyKey();
	            value = this.parseGeneratorMethod();
	            method = true;
	        }
	        if (!kind && key && this.match('(')) {
	            kind = 'init';
	            value = isAsync ? this.parsePropertyMethodAsyncFunction() : this.parsePropertyMethodFunction();
	            method = true;
	        }
	        if (!kind) {
	            this.throwUnexpectedToken(this.lookahead);
	        }
	        if (kind === 'init') {
	            kind = 'method';
	        }
	        if (!computed) {
	            if (isStatic && this.isPropertyKey(key, 'prototype')) {
	                this.throwUnexpectedToken(token, messages_1.Messages.StaticPrototype);
	            }
	            if (!isStatic && this.isPropertyKey(key, 'constructor')) {
	                if (kind !== 'method' || !method || (value && value.generator)) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.ConstructorSpecialMethod);
	                }
	                if (hasConstructor.value) {
	                    this.throwUnexpectedToken(token, messages_1.Messages.DuplicateConstructor);
	                }
	                else {
	                    hasConstructor.value = true;
	                }
	                kind = 'constructor';
	            }
	        }
	        return this.finalize(node, new Node.MethodDefinition(key, computed, value, kind, isStatic));
	    };
	    Parser.prototype.parseClassElementList = function () {
	        var body = [];
	        var hasConstructor = { value: false };
	        this.expect('{');
	        while (!this.match('}')) {
	            if (this.match(';')) {
	                this.nextToken();
	            }
	            else {
	                body.push(this.parseClassElement(hasConstructor));
	            }
	        }
	        this.expect('}');
	        return body;
	    };
	    Parser.prototype.parseClassBody = function () {
	        var node = this.createNode();
	        var elementList = this.parseClassElementList();
	        return this.finalize(node, new Node.ClassBody(elementList));
	    };
	    Parser.prototype.parseClassDeclaration = function (identifierIsOptional) {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (identifierIsOptional && (this.lookahead.type !== 3 /* Identifier */)) ? null : this.parseVariableIdentifier();
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassDeclaration(id, superClass, classBody));
	    };
	    Parser.prototype.parseClassExpression = function () {
	        var node = this.createNode();
	        var previousStrict = this.context.strict;
	        this.context.strict = true;
	        this.expectKeyword('class');
	        var id = (this.lookahead.type === 3 /* Identifier */) ? this.parseVariableIdentifier() : null;
	        var superClass = null;
	        if (this.matchKeyword('extends')) {
	            this.nextToken();
	            superClass = this.isolateCoverGrammar(this.parseLeftHandSideExpressionAllowCall);
	        }
	        var classBody = this.parseClassBody();
	        this.context.strict = previousStrict;
	        return this.finalize(node, new Node.ClassExpression(id, superClass, classBody));
	    };
	    // https://tc39.github.io/ecma262/#sec-scripts
	    // https://tc39.github.io/ecma262/#sec-modules
	    Parser.prototype.parseModule = function () {
	        this.context.strict = true;
	        this.context.isModule = true;
	        this.scanner.isModule = true;
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Module(body));
	    };
	    Parser.prototype.parseScript = function () {
	        var node = this.createNode();
	        var body = this.parseDirectivePrologues();
	        while (this.lookahead.type !== 2 /* EOF */) {
	            body.push(this.parseStatementListItem());
	        }
	        return this.finalize(node, new Node.Script(body));
	    };
	    // https://tc39.github.io/ecma262/#sec-imports
	    Parser.prototype.parseModuleSpecifier = function () {
	        var node = this.createNode();
	        if (this.lookahead.type !== 8 /* StringLiteral */) {
	            this.throwError(messages_1.Messages.InvalidModuleSpecifier);
	        }
	        var token = this.nextToken();
	        var raw = this.getTokenRaw(token);
	        return this.finalize(node, new Node.Literal(token.value, raw));
	    };
	    // import {<foo as bar>} ...;
	    Parser.prototype.parseImportSpecifier = function () {
	        var node = this.createNode();
	        var imported;
	        var local;
	        if (this.lookahead.type === 3 /* Identifier */) {
	            imported = this.parseVariableIdentifier();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	        }
	        else {
	            imported = this.parseIdentifierName();
	            local = imported;
	            if (this.matchContextualKeyword('as')) {
	                this.nextToken();
	                local = this.parseVariableIdentifier();
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	        }
	        return this.finalize(node, new Node.ImportSpecifier(local, imported));
	    };
	    // {foo, bar as bas}
	    Parser.prototype.parseNamedImports = function () {
	        this.expect('{');
	        var specifiers = [];
	        while (!this.match('}')) {
	            specifiers.push(this.parseImportSpecifier());
	            if (!this.match('}')) {
	                this.expect(',');
	            }
	        }
	        this.expect('}');
	        return specifiers;
	    };
	    // import <foo> ...;
	    Parser.prototype.parseImportDefaultSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportDefaultSpecifier(local));
	    };
	    // import <* as foo> ...;
	    Parser.prototype.parseImportNamespaceSpecifier = function () {
	        var node = this.createNode();
	        this.expect('*');
	        if (!this.matchContextualKeyword('as')) {
	            this.throwError(messages_1.Messages.NoAsAfterImportNamespace);
	        }
	        this.nextToken();
	        var local = this.parseIdentifierName();
	        return this.finalize(node, new Node.ImportNamespaceSpecifier(local));
	    };
	    Parser.prototype.parseImportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalImportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('import');
	        var src;
	        var specifiers = [];
	        if (this.lookahead.type === 8 /* StringLiteral */) {
	            // import 'foo';
	            src = this.parseModuleSpecifier();
	        }
	        else {
	            if (this.match('{')) {
	                // import {bar}
	                specifiers = specifiers.concat(this.parseNamedImports());
	            }
	            else if (this.match('*')) {
	                // import * as foo
	                specifiers.push(this.parseImportNamespaceSpecifier());
	            }
	            else if (this.isIdentifierName(this.lookahead) && !this.matchKeyword('default')) {
	                // import foo
	                specifiers.push(this.parseImportDefaultSpecifier());
	                if (this.match(',')) {
	                    this.nextToken();
	                    if (this.match('*')) {
	                        // import foo, * as foo
	                        specifiers.push(this.parseImportNamespaceSpecifier());
	                    }
	                    else if (this.match('{')) {
	                        // import foo, {bar}
	                        specifiers = specifiers.concat(this.parseNamedImports());
	                    }
	                    else {
	                        this.throwUnexpectedToken(this.lookahead);
	                    }
	                }
	            }
	            else {
	                this.throwUnexpectedToken(this.nextToken());
	            }
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            src = this.parseModuleSpecifier();
	        }
	        this.consumeSemicolon();
	        return this.finalize(node, new Node.ImportDeclaration(specifiers, src));
	    };
	    // https://tc39.github.io/ecma262/#sec-exports
	    Parser.prototype.parseExportSpecifier = function () {
	        var node = this.createNode();
	        var local = this.parseIdentifierName();
	        var exported = local;
	        if (this.matchContextualKeyword('as')) {
	            this.nextToken();
	            exported = this.parseIdentifierName();
	        }
	        return this.finalize(node, new Node.ExportSpecifier(local, exported));
	    };
	    Parser.prototype.parseExportDeclaration = function () {
	        if (this.context.inFunctionBody) {
	            this.throwError(messages_1.Messages.IllegalExportDeclaration);
	        }
	        var node = this.createNode();
	        this.expectKeyword('export');
	        var exportDeclaration;
	        if (this.matchKeyword('default')) {
	            // export default ...
	            this.nextToken();
	            if (this.matchKeyword('function')) {
	                // export default function foo () {}
	                // export default function () {}
	                var declaration = this.parseFunctionDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchKeyword('class')) {
	                // export default class foo {}
	                var declaration = this.parseClassDeclaration(true);
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else if (this.matchContextualKeyword('async')) {
	                // export default async function f () {}
	                // export default async function () {}
	                // export default async x => x
	                var declaration = this.matchAsyncFunction() ? this.parseFunctionDeclaration(true) : this.parseAssignmentExpression();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	            else {
	                if (this.matchContextualKeyword('from')) {
	                    this.throwError(messages_1.Messages.UnexpectedToken, this.lookahead.value);
	                }
	                // export default {};
	                // export default [];
	                // export default (1 + 2);
	                var declaration = this.match('{') ? this.parseObjectInitializer() :
	                    this.match('[') ? this.parseArrayInitializer() : this.parseAssignmentExpression();
	                this.consumeSemicolon();
	                exportDeclaration = this.finalize(node, new Node.ExportDefaultDeclaration(declaration));
	            }
	        }
	        else if (this.match('*')) {
	            // export * from 'foo';
	            this.nextToken();
	            if (!this.matchContextualKeyword('from')) {
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            this.nextToken();
	            var src = this.parseModuleSpecifier();
	            this.consumeSemicolon();
	            exportDeclaration = this.finalize(node, new Node.ExportAllDeclaration(src));
	        }
	        else if (this.lookahead.type === 4 /* Keyword */) {
	            // export var f = 1;
	            var declaration = void 0;
	            switch (this.lookahead.value) {
	                case 'let':
	                case 'const':
	                    declaration = this.parseLexicalDeclaration({ inFor: false });
	                    break;
	                case 'var':
	                case 'class':
	                case 'function':
	                    declaration = this.parseStatementListItem();
	                    break;
	                default:
	                    this.throwUnexpectedToken(this.lookahead);
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else if (this.matchAsyncFunction()) {
	            var declaration = this.parseFunctionDeclaration();
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(declaration, [], null));
	        }
	        else {
	            var specifiers = [];
	            var source = null;
	            var isExportFromIdentifier = false;
	            this.expect('{');
	            while (!this.match('}')) {
	                isExportFromIdentifier = isExportFromIdentifier || this.matchKeyword('default');
	                specifiers.push(this.parseExportSpecifier());
	                if (!this.match('}')) {
	                    this.expect(',');
	                }
	            }
	            this.expect('}');
	            if (this.matchContextualKeyword('from')) {
	                // export {default} from 'foo';
	                // export {foo} from 'foo';
	                this.nextToken();
	                source = this.parseModuleSpecifier();
	                this.consumeSemicolon();
	            }
	            else if (isExportFromIdentifier) {
	                // export {default}; // missing fromClause
	                var message = this.lookahead.value ? messages_1.Messages.UnexpectedToken : messages_1.Messages.MissingFromClause;
	                this.throwError(message, this.lookahead.value);
	            }
	            else {
	                // export {foo};
	                this.consumeSemicolon();
	            }
	            exportDeclaration = this.finalize(node, new Node.ExportNamedDeclaration(null, specifiers, source));
	        }
	        return exportDeclaration;
	    };
	    return Parser;
	}());
	exports.Parser = Parser;


/***/ },
/* 9 */
/***/ function(module, exports) {

	"use strict";
	// Ensure the condition is true, otherwise throw an error.
	// This is only to have a better contract semantic, i.e. another safety net
	// to catch a logic error. The condition shall be fulfilled in normal case.
	// Do NOT use this to enforce a certain condition on any user input.
	Object.defineProperty(exports, "__esModule", { value: true });
	function assert(condition, message) {
	    /* istanbul ignore if */
	    if (!condition) {
	        throw new Error('ASSERT: ' + message);
	    }
	}
	exports.assert = assert;


/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";
	/* tslint:disable:max-classes-per-file */
	Object.defineProperty(exports, "__esModule", { value: true });
	var ErrorHandler = (function () {
	    function ErrorHandler() {
	        this.errors = [];
	        this.tolerant = false;
	    }
	    ErrorHandler.prototype.recordError = function (error) {
	        this.errors.push(error);
	    };
	    ErrorHandler.prototype.tolerate = function (error) {
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    ErrorHandler.prototype.constructError = function (msg, column) {
	        var error = new Error(msg);
	        try {
	            throw error;
	        }
	        catch (base) {
	            /* istanbul ignore else */
	            if (Object.create && Object.defineProperty) {
	                error = Object.create(base);
	                Object.defineProperty(error, 'column', { value: column });
	            }
	        }
	        /* istanbul ignore next */
	        return error;
	    };
	    ErrorHandler.prototype.createError = function (index, line, col, description) {
	        var msg = 'Line ' + line + ': ' + description;
	        var error = this.constructError(msg, col);
	        error.index = index;
	        error.lineNumber = line;
	        error.description = description;
	        return error;
	    };
	    ErrorHandler.prototype.throwError = function (index, line, col, description) {
	        throw this.createError(index, line, col, description);
	    };
	    ErrorHandler.prototype.tolerateError = function (index, line, col, description) {
	        var error = this.createError(index, line, col, description);
	        if (this.tolerant) {
	            this.recordError(error);
	        }
	        else {
	            throw error;
	        }
	    };
	    return ErrorHandler;
	}());
	exports.ErrorHandler = ErrorHandler;


/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	// Error messages should be identical to V8.
	exports.Messages = {
	    BadGetterArity: 'Getter must not have any formal parameters',
	    BadSetterArity: 'Setter must have exactly one formal parameter',
	    BadSetterRestParameter: 'Setter function argument must not be a rest parameter',
	    ConstructorIsAsync: 'Class constructor may not be an async method',
	    ConstructorSpecialMethod: 'Class constructor may not be an accessor',
	    DeclarationMissingInitializer: 'Missing initializer in %0 declaration',
	    DefaultRestParameter: 'Unexpected token =',
	    DuplicateBinding: 'Duplicate binding %0',
	    DuplicateConstructor: 'A class may only have one constructor',
	    DuplicateProtoProperty: 'Duplicate __proto__ fields are not allowed in object literals',
	    ForInOfLoopInitializer: '%0 loop variable declaration may not have an initializer',
	    GeneratorInLegacyContext: 'Generator declarations are not allowed in legacy contexts',
	    IllegalBreak: 'Illegal break statement',
	    IllegalContinue: 'Illegal continue statement',
	    IllegalExportDeclaration: 'Unexpected token',
	    IllegalImportDeclaration: 'Unexpected token',
	    IllegalLanguageModeDirective: 'Illegal \'use strict\' directive in function with non-simple parameter list',
	    IllegalReturn: 'Illegal return statement',
	    InvalidEscapedReservedWord: 'Keyword must not contain escaped characters',
	    InvalidHexEscapeSequence: 'Invalid hexadecimal escape sequence',
	    InvalidLHSInAssignment: 'Invalid left-hand side in assignment',
	    InvalidLHSInForIn: 'Invalid left-hand side in for-in',
	    InvalidLHSInForLoop: 'Invalid left-hand side in for-loop',
	    InvalidModuleSpecifier: 'Unexpected token',
	    InvalidRegExp: 'Invalid regular expression',
	    LetInLexicalBinding: 'let is disallowed as a lexically bound name',
	    MissingFromClause: 'Unexpected token',
	    MultipleDefaultsInSwitch: 'More than one default clause in switch statement',
	    NewlineAfterThrow: 'Illegal newline after throw',
	    NoAsAfterImportNamespace: 'Unexpected token',
	    NoCatchOrFinally: 'Missing catch or finally after try',
	    ParameterAfterRestParameter: 'Rest parameter must be last formal parameter',
	    Redeclaration: '%0 \'%1\' has already been declared',
	    StaticPrototype: 'Classes may not have static property named prototype',
	    StrictCatchVariable: 'Catch variable may not be eval or arguments in strict mode',
	    StrictDelete: 'Delete of an unqualified identifier in strict mode.',
	    StrictFunction: 'In strict mode code, functions can only be declared at top level or inside a block',
	    StrictFunctionName: 'Function name may not be eval or arguments in strict mode',
	    StrictLHSAssignment: 'Assignment to eval or arguments is not allowed in strict mode',
	    StrictLHSPostfix: 'Postfix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictLHSPrefix: 'Prefix increment/decrement may not have eval or arguments operand in strict mode',
	    StrictModeWith: 'Strict mode code may not include a with statement',
	    StrictOctalLiteral: 'Octal literals are not allowed in strict mode.',
	    StrictParamDupe: 'Strict mode function may not have duplicate parameter names',
	    StrictParamName: 'Parameter name eval or arguments is not allowed in strict mode',
	    StrictReservedWord: 'Use of future reserved word in strict mode',
	    StrictVarName: 'Variable name may not be eval or arguments in strict mode',
	    TemplateOctalLiteral: 'Octal literals are not allowed in template strings.',
	    UnexpectedEOS: 'Unexpected end of input',
	    UnexpectedIdentifier: 'Unexpected identifier',
	    UnexpectedNumber: 'Unexpected number',
	    UnexpectedReserved: 'Unexpected reserved word',
	    UnexpectedString: 'Unexpected string',
	    UnexpectedTemplate: 'Unexpected quasi %0',
	    UnexpectedToken: 'Unexpected token %0',
	    UnexpectedTokenIllegal: 'Unexpected token ILLEGAL',
	    UnknownLabel: 'Undefined label \'%0\'',
	    UnterminatedRegExp: 'Invalid regular expression: missing /'
	};


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var assert_1 = __webpack_require__(9);
	var character_1 = __webpack_require__(4);
	var messages_1 = __webpack_require__(11);
	function hexValue(ch) {
	    return '0123456789abcdef'.indexOf(ch.toLowerCase());
	}
	function octalValue(ch) {
	    return '01234567'.indexOf(ch);
	}
	var Scanner = (function () {
	    function Scanner(code, handler) {
	        this.source = code;
	        this.errorHandler = handler;
	        this.trackComment = false;
	        this.isModule = false;
	        this.length = code.length;
	        this.index = 0;
	        this.lineNumber = (code.length > 0) ? 1 : 0;
	        this.lineStart = 0;
	        this.curlyStack = [];
	    }
	    Scanner.prototype.saveState = function () {
	        return {
	            index: this.index,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart
	        };
	    };
	    Scanner.prototype.restoreState = function (state) {
	        this.index = state.index;
	        this.lineNumber = state.lineNumber;
	        this.lineStart = state.lineStart;
	    };
	    Scanner.prototype.eof = function () {
	        return this.index >= this.length;
	    };
	    Scanner.prototype.throwUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        return this.errorHandler.throwError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    Scanner.prototype.tolerateUnexpectedToken = function (message) {
	        if (message === void 0) { message = messages_1.Messages.UnexpectedTokenIllegal; }
	        this.errorHandler.tolerateError(this.index, this.lineNumber, this.index - this.lineStart + 1, message);
	    };
	    // https://tc39.github.io/ecma262/#sec-comments
	    Scanner.prototype.skipSingleLineComment = function (offset) {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - offset;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - offset
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            ++this.index;
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (this.trackComment) {
	                    loc.end = {
	                        line: this.lineNumber,
	                        column: this.index - this.lineStart - 1
	                    };
	                    var entry = {
	                        multiLine: false,
	                        slice: [start + offset, this.index - 1],
	                        range: [start, this.index - 1],
	                        loc: loc
	                    };
	                    comments.push(entry);
	                }
	                if (ch === 13 && this.source.charCodeAt(this.index) === 10) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                return comments;
	            }
	        }
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: false,
	                slice: [start + offset, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        return comments;
	    };
	    Scanner.prototype.skipMultiLineComment = function () {
	        var comments = [];
	        var start, loc;
	        if (this.trackComment) {
	            comments = [];
	            start = this.index - 2;
	            loc = {
	                start: {
	                    line: this.lineNumber,
	                    column: this.index - this.lineStart - 2
	                },
	                end: {}
	            };
	        }
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isLineTerminator(ch)) {
	                if (ch === 0x0D && this.source.charCodeAt(this.index + 1) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                ++this.index;
	                this.lineStart = this.index;
	            }
	            else if (ch === 0x2A) {
	                // Block comment ends with '*/'.
	                if (this.source.charCodeAt(this.index + 1) === 0x2F) {
	                    this.index += 2;
	                    if (this.trackComment) {
	                        loc.end = {
	                            line: this.lineNumber,
	                            column: this.index - this.lineStart
	                        };
	                        var entry = {
	                            multiLine: true,
	                            slice: [start + 2, this.index - 2],
	                            range: [start, this.index],
	                            loc: loc
	                        };
	                        comments.push(entry);
	                    }
	                    return comments;
	                }
	                ++this.index;
	            }
	            else {
	                ++this.index;
	            }
	        }
	        // Ran off the end of the file - the whole thing is a comment
	        if (this.trackComment) {
	            loc.end = {
	                line: this.lineNumber,
	                column: this.index - this.lineStart
	            };
	            var entry = {
	                multiLine: true,
	                slice: [start + 2, this.index],
	                range: [start, this.index],
	                loc: loc
	            };
	            comments.push(entry);
	        }
	        this.tolerateUnexpectedToken();
	        return comments;
	    };
	    Scanner.prototype.scanComments = function () {
	        var comments;
	        if (this.trackComment) {
	            comments = [];
	        }
	        var start = (this.index === 0);
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (character_1.Character.isWhiteSpace(ch)) {
	                ++this.index;
	            }
	            else if (character_1.Character.isLineTerminator(ch)) {
	                ++this.index;
	                if (ch === 0x0D && this.source.charCodeAt(this.index) === 0x0A) {
	                    ++this.index;
	                }
	                ++this.lineNumber;
	                this.lineStart = this.index;
	                start = true;
	            }
	            else if (ch === 0x2F) {
	                ch = this.source.charCodeAt(this.index + 1);
	                if (ch === 0x2F) {
	                    this.index += 2;
	                    var comment = this.skipSingleLineComment(2);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                    start = true;
	                }
	                else if (ch === 0x2A) {
	                    this.index += 2;
	                    var comment = this.skipMultiLineComment();
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (start && ch === 0x2D) {
	                // U+003E is '>'
	                if ((this.source.charCodeAt(this.index + 1) === 0x2D) && (this.source.charCodeAt(this.index + 2) === 0x3E)) {
	                    // '-->' is a single-line comment
	                    this.index += 3;
	                    var comment = this.skipSingleLineComment(3);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else if (ch === 0x3C && !this.isModule) {
	                if (this.source.slice(this.index + 1, this.index + 4) === '!--') {
	                    this.index += 4; // `<!--`
	                    var comment = this.skipSingleLineComment(4);
	                    if (this.trackComment) {
	                        comments = comments.concat(comment);
	                    }
	                }
	                else {
	                    break;
	                }
	            }
	            else {
	                break;
	            }
	        }
	        return comments;
	    };
	    // https://tc39.github.io/ecma262/#sec-future-reserved-words
	    Scanner.prototype.isFutureReservedWord = function (id) {
	        switch (id) {
	            case 'enum':
	            case 'export':
	            case 'import':
	            case 'super':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isStrictModeReservedWord = function (id) {
	        switch (id) {
	            case 'implements':
	            case 'interface':
	            case 'package':
	            case 'private':
	            case 'protected':
	            case 'public':
	            case 'static':
	            case 'yield':
	            case 'let':
	                return true;
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.isRestrictedWord = function (id) {
	        return id === 'eval' || id === 'arguments';
	    };
	    // https://tc39.github.io/ecma262/#sec-keywords
	    Scanner.prototype.isKeyword = function (id) {
	        switch (id.length) {
	            case 2:
	                return (id === 'if') || (id === 'in') || (id === 'do');
	            case 3:
	                return (id === 'var') || (id === 'for') || (id === 'new') ||
	                    (id === 'try') || (id === 'let');
	            case 4:
	                return (id === 'this') || (id === 'else') || (id === 'case') ||
	                    (id === 'void') || (id === 'with') || (id === 'enum');
	            case 5:
	                return (id === 'while') || (id === 'break') || (id === 'catch') ||
	                    (id === 'throw') || (id === 'const') || (id === 'yield') ||
	                    (id === 'class') || (id === 'super');
	            case 6:
	                return (id === 'return') || (id === 'typeof') || (id === 'delete') ||
	                    (id === 'switch') || (id === 'export') || (id === 'import');
	            case 7:
	                return (id === 'default') || (id === 'finally') || (id === 'extends');
	            case 8:
	                return (id === 'function') || (id === 'continue') || (id === 'debugger');
	            case 10:
	                return (id === 'instanceof');
	            default:
	                return false;
	        }
	    };
	    Scanner.prototype.codePointAt = function (i) {
	        var cp = this.source.charCodeAt(i);
	        if (cp >= 0xD800 && cp <= 0xDBFF) {
	            var second = this.source.charCodeAt(i + 1);
	            if (second >= 0xDC00 && second <= 0xDFFF) {
	                var first = cp;
	                cp = (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;
	            }
	        }
	        return cp;
	    };
	    Scanner.prototype.scanHexEscape = function (prefix) {
	        var len = (prefix === 'u') ? 4 : 2;
	        var code = 0;
	        for (var i = 0; i < len; ++i) {
	            if (!this.eof() && character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                code = code * 16 + hexValue(this.source[this.index++]);
	            }
	            else {
	                return null;
	            }
	        }
	        return String.fromCharCode(code);
	    };
	    Scanner.prototype.scanUnicodeCodePointEscape = function () {
	        var ch = this.source[this.index];
	        var code = 0;
	        // At least, one hex digit is required.
	        if (ch === '}') {
	            this.throwUnexpectedToken();
	        }
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            if (!character_1.Character.isHexDigit(ch.charCodeAt(0))) {
	                break;
	            }
	            code = code * 16 + hexValue(ch);
	        }
	        if (code > 0x10FFFF || ch !== '}') {
	            this.throwUnexpectedToken();
	        }
	        return character_1.Character.fromCodePoint(code);
	    };
	    Scanner.prototype.getIdentifier = function () {
	        var start = this.index++;
	        while (!this.eof()) {
	            var ch = this.source.charCodeAt(this.index);
	            if (ch === 0x5C) {
	                // Blackslash (U+005C) marks Unicode escape sequence.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            else if (ch >= 0xD800 && ch < 0xDFFF) {
	                // Need to handle surrogate pairs.
	                this.index = start;
	                return this.getComplexIdentifier();
	            }
	            if (character_1.Character.isIdentifierPart(ch)) {
	                ++this.index;
	            }
	            else {
	                break;
	            }
	        }
	        return this.source.slice(start, this.index);
	    };
	    Scanner.prototype.getComplexIdentifier = function () {
	        var cp = this.codePointAt(this.index);
	        var id = character_1.Character.fromCodePoint(cp);
	        this.index += id.length;
	        // '\u' (U+005C, U+0075) denotes an escaped character.
	        var ch;
	        if (cp === 0x5C) {
	            if (this.source.charCodeAt(this.index) !== 0x75) {
	                this.throwUnexpectedToken();
	            }
	            ++this.index;
	            if (this.source[this.index] === '{') {
	                ++this.index;
	                ch = this.scanUnicodeCodePointEscape();
	            }
	            else {
	                ch = this.scanHexEscape('u');
	                if (ch === null || ch === '\\' || !character_1.Character.isIdentifierStart(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken();
	                }
	            }
	            id = ch;
	        }
	        while (!this.eof()) {
	            cp = this.codePointAt(this.index);
	            if (!character_1.Character.isIdentifierPart(cp)) {
	                break;
	            }
	            ch = character_1.Character.fromCodePoint(cp);
	            id += ch;
	            this.index += ch.length;
	            // '\u' (U+005C, U+0075) denotes an escaped character.
	            if (cp === 0x5C) {
	                id = id.substr(0, id.length - 1);
	                if (this.source.charCodeAt(this.index) !== 0x75) {
	                    this.throwUnexpectedToken();
	                }
	                ++this.index;
	                if (this.source[this.index] === '{') {
	                    ++this.index;
	                    ch = this.scanUnicodeCodePointEscape();
	                }
	                else {
	                    ch = this.scanHexEscape('u');
	                    if (ch === null || ch === '\\' || !character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                        this.throwUnexpectedToken();
	                    }
	                }
	                id += ch;
	            }
	        }
	        return id;
	    };
	    Scanner.prototype.octalToDecimal = function (ch) {
	        // \0 is not octal escape sequence
	        var octal = (ch !== '0');
	        var code = octalValue(ch);
	        if (!this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	            octal = true;
	            code = code * 8 + octalValue(this.source[this.index++]);
	            // 3 digits are only allowed when string starts
	            // with 0, 1, 2, 3
	            if ('0123'.indexOf(ch) >= 0 && !this.eof() && character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                code = code * 8 + octalValue(this.source[this.index++]);
	            }
	        }
	        return {
	            code: code,
	            octal: octal
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-names-and-keywords
	    Scanner.prototype.scanIdentifier = function () {
	        var type;
	        var start = this.index;
	        // Backslash (U+005C) starts an escaped character.
	        var id = (this.source.charCodeAt(start) === 0x5C) ? this.getComplexIdentifier() : this.getIdentifier();
	        // There is no keyword or literal with only one character.
	        // Thus, it must be an identifier.
	        if (id.length === 1) {
	            type = 3 /* Identifier */;
	        }
	        else if (this.isKeyword(id)) {
	            type = 4 /* Keyword */;
	        }
	        else if (id === 'null') {
	            type = 5 /* NullLiteral */;
	        }
	        else if (id === 'true' || id === 'false') {
	            type = 1 /* BooleanLiteral */;
	        }
	        else {
	            type = 3 /* Identifier */;
	        }
	        if (type !== 3 /* Identifier */ && (start + id.length !== this.index)) {
	            var restore = this.index;
	            this.index = start;
	            this.tolerateUnexpectedToken(messages_1.Messages.InvalidEscapedReservedWord);
	            this.index = restore;
	        }
	        return {
	            type: type,
	            value: id,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-punctuators
	    Scanner.prototype.scanPunctuator = function () {
	        var start = this.index;
	        // Check for most common single-character punctuators.
	        var str = this.source[this.index];
	        switch (str) {
	            case '(':
	            case '{':
	                if (str === '{') {
	                    this.curlyStack.push('{');
	                }
	                ++this.index;
	                break;
	            case '.':
	                ++this.index;
	                if (this.source[this.index] === '.' && this.source[this.index + 1] === '.') {
	                    // Spread operator: ...
	                    this.index += 2;
	                    str = '...';
	                }
	                break;
	            case '}':
	                ++this.index;
	                this.curlyStack.pop();
	                break;
	            case ')':
	            case ';':
	            case ',':
	            case '[':
	            case ']':
	            case ':':
	            case '?':
	            case '~':
	                ++this.index;
	                break;
	            default:
	                // 4-character punctuator.
	                str = this.source.substr(this.index, 4);
	                if (str === '>>>=') {
	                    this.index += 4;
	                }
	                else {
	                    // 3-character punctuators.
	                    str = str.substr(0, 3);
	                    if (str === '===' || str === '!==' || str === '>>>' ||
	                        str === '<<=' || str === '>>=' || str === '**=') {
	                        this.index += 3;
	                    }
	                    else {
	                        // 2-character punctuators.
	                        str = str.substr(0, 2);
	                        if (str === '&&' || str === '||' || str === '==' || str === '!=' ||
	                            str === '+=' || str === '-=' || str === '*=' || str === '/=' ||
	                            str === '++' || str === '--' || str === '<<' || str === '>>' ||
	                            str === '&=' || str === '|=' || str === '^=' || str === '%=' ||
	                            str === '<=' || str === '>=' || str === '=>' || str === '**') {
	                            this.index += 2;
	                        }
	                        else {
	                            // 1-character punctuators.
	                            str = this.source[this.index];
	                            if ('<>=!+-*%&|^/'.indexOf(str) >= 0) {
	                                ++this.index;
	                            }
	                        }
	                    }
	                }
	        }
	        if (this.index === start) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 7 /* Punctuator */,
	            value: str,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-numeric-literals
	    Scanner.prototype.scanHexLiteral = function (start) {
	        var num = '';
	        while (!this.eof()) {
	            if (!character_1.Character.isHexDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt('0x' + num, 16),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanBinaryLiteral = function (start) {
	        var num = '';
	        var ch;
	        while (!this.eof()) {
	            ch = this.source[this.index];
	            if (ch !== '0' && ch !== '1') {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (num.length === 0) {
	            // only 0b or 0B
	            this.throwUnexpectedToken();
	        }
	        if (!this.eof()) {
	            ch = this.source.charCodeAt(this.index);
	            /* istanbul ignore else */
	            if (character_1.Character.isIdentifierStart(ch) || character_1.Character.isDecimalDigit(ch)) {
	                this.throwUnexpectedToken();
	            }
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 2),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.scanOctalLiteral = function (prefix, start) {
	        var num = '';
	        var octal = false;
	        if (character_1.Character.isOctalDigit(prefix.charCodeAt(0))) {
	            octal = true;
	            num = '0' + this.source[this.index++];
	        }
	        else {
	            ++this.index;
	        }
	        while (!this.eof()) {
	            if (!character_1.Character.isOctalDigit(this.source.charCodeAt(this.index))) {
	                break;
	            }
	            num += this.source[this.index++];
	        }
	        if (!octal && num.length === 0) {
	            // only 0o or 0O
	            this.throwUnexpectedToken();
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index)) || character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseInt(num, 8),
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.isImplicitOctalLiteral = function () {
	        // Implicit octal, unless there is a non-octal digit.
	        // (Annex B.1.1 on Numeric Literals)
	        for (var i = this.index + 1; i < this.length; ++i) {
	            var ch = this.source[i];
	            if (ch === '8' || ch === '9') {
	                return false;
	            }
	            if (!character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                return true;
	            }
	        }
	        return true;
	    };
	    Scanner.prototype.scanNumericLiteral = function () {
	        var start = this.index;
	        var ch = this.source[start];
	        assert_1.assert(character_1.Character.isDecimalDigit(ch.charCodeAt(0)) || (ch === '.'), 'Numeric literal must start with a decimal digit or a decimal point');
	        var num = '';
	        if (ch !== '.') {
	            num = this.source[this.index++];
	            ch = this.source[this.index];
	            // Hex number starts with '0x'.
	            // Octal number starts with '0'.
	            // Octal number in ES6 starts with '0o'.
	            // Binary number in ES6 starts with '0b'.
	            if (num === '0') {
	                if (ch === 'x' || ch === 'X') {
	                    ++this.index;
	                    return this.scanHexLiteral(start);
	                }
	                if (ch === 'b' || ch === 'B') {
	                    ++this.index;
	                    return this.scanBinaryLiteral(start);
	                }
	                if (ch === 'o' || ch === 'O') {
	                    return this.scanOctalLiteral(ch, start);
	                }
	                if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                    if (this.isImplicitOctalLiteral()) {
	                        return this.scanOctalLiteral(ch, start);
	                    }
	                }
	            }
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === '.') {
	            num += this.source[this.index++];
	            while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                num += this.source[this.index++];
	            }
	            ch = this.source[this.index];
	        }
	        if (ch === 'e' || ch === 'E') {
	            num += this.source[this.index++];
	            ch = this.source[this.index];
	            if (ch === '+' || ch === '-') {
	                num += this.source[this.index++];
	            }
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                while (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                    num += this.source[this.index++];
	                }
	            }
	            else {
	                this.throwUnexpectedToken();
	            }
	        }
	        if (character_1.Character.isIdentifierStart(this.source.charCodeAt(this.index))) {
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 6 /* NumericLiteral */,
	            value: parseFloat(num),
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-string-literals
	    Scanner.prototype.scanStringLiteral = function () {
	        var start = this.index;
	        var quote = this.source[start];
	        assert_1.assert((quote === '\'' || quote === '"'), 'String literal must starts with a quote');
	        ++this.index;
	        var octal = false;
	        var str = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === quote) {
	                quote = '';
	                break;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!ch || !character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                str += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var unescaped_1 = this.scanHexEscape(ch);
	                                if (unescaped_1 === null) {
	                                    this.throwUnexpectedToken();
	                                }
	                                str += unescaped_1;
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            str += unescaped;
	                            break;
	                        case 'n':
	                            str += '\n';
	                            break;
	                        case 'r':
	                            str += '\r';
	                            break;
	                        case 't':
	                            str += '\t';
	                            break;
	                        case 'b':
	                            str += '\b';
	                            break;
	                        case 'f':
	                            str += '\f';
	                            break;
	                        case 'v':
	                            str += '\x0B';
	                            break;
	                        case '8':
	                        case '9':
	                            str += ch;
	                            this.tolerateUnexpectedToken();
	                            break;
	                        default:
	                            if (ch && character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                var octToDec = this.octalToDecimal(ch);
	                                octal = octToDec.octal || octal;
	                                str += String.fromCharCode(octToDec.code);
	                            }
	                            else {
	                                str += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                break;
	            }
	            else {
	                str += ch;
	            }
	        }
	        if (quote !== '') {
	            this.index = start;
	            this.throwUnexpectedToken();
	        }
	        return {
	            type: 8 /* StringLiteral */,
	            value: str,
	            octal: octal,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-template-literal-lexical-components
	    Scanner.prototype.scanTemplate = function () {
	        var cooked = '';
	        var terminated = false;
	        var start = this.index;
	        var head = (this.source[start] === '`');
	        var tail = false;
	        var rawOffset = 2;
	        ++this.index;
	        while (!this.eof()) {
	            var ch = this.source[this.index++];
	            if (ch === '`') {
	                rawOffset = 1;
	                tail = true;
	                terminated = true;
	                break;
	            }
	            else if (ch === '$') {
	                if (this.source[this.index] === '{') {
	                    this.curlyStack.push('${');
	                    ++this.index;
	                    terminated = true;
	                    break;
	                }
	                cooked += ch;
	            }
	            else if (ch === '\\') {
	                ch = this.source[this.index++];
	                if (!character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    switch (ch) {
	                        case 'n':
	                            cooked += '\n';
	                            break;
	                        case 'r':
	                            cooked += '\r';
	                            break;
	                        case 't':
	                            cooked += '\t';
	                            break;
	                        case 'u':
	                            if (this.source[this.index] === '{') {
	                                ++this.index;
	                                cooked += this.scanUnicodeCodePointEscape();
	                            }
	                            else {
	                                var restore = this.index;
	                                var unescaped_2 = this.scanHexEscape(ch);
	                                if (unescaped_2 !== null) {
	                                    cooked += unescaped_2;
	                                }
	                                else {
	                                    this.index = restore;
	                                    cooked += ch;
	                                }
	                            }
	                            break;
	                        case 'x':
	                            var unescaped = this.scanHexEscape(ch);
	                            if (unescaped === null) {
	                                this.throwUnexpectedToken(messages_1.Messages.InvalidHexEscapeSequence);
	                            }
	                            cooked += unescaped;
	                            break;
	                        case 'b':
	                            cooked += '\b';
	                            break;
	                        case 'f':
	                            cooked += '\f';
	                            break;
	                        case 'v':
	                            cooked += '\v';
	                            break;
	                        default:
	                            if (ch === '0') {
	                                if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index))) {
	                                    // Illegal: \01 \02 and so on
	                                    this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                                }
	                                cooked += '\0';
	                            }
	                            else if (character_1.Character.isOctalDigit(ch.charCodeAt(0))) {
	                                // Illegal: \1 \2
	                                this.throwUnexpectedToken(messages_1.Messages.TemplateOctalLiteral);
	                            }
	                            else {
	                                cooked += ch;
	                            }
	                            break;
	                    }
	                }
	                else {
	                    ++this.lineNumber;
	                    if (ch === '\r' && this.source[this.index] === '\n') {
	                        ++this.index;
	                    }
	                    this.lineStart = this.index;
	                }
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                ++this.lineNumber;
	                if (ch === '\r' && this.source[this.index] === '\n') {
	                    ++this.index;
	                }
	                this.lineStart = this.index;
	                cooked += '\n';
	            }
	            else {
	                cooked += ch;
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken();
	        }
	        if (!head) {
	            this.curlyStack.pop();
	        }
	        return {
	            type: 10 /* Template */,
	            value: this.source.slice(start + 1, this.index - rawOffset),
	            cooked: cooked,
	            head: head,
	            tail: tail,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	    Scanner.prototype.testRegExp = function (pattern, flags) {
	        // The BMP character to use as a replacement for astral symbols when
	        // translating an ES6 "u"-flagged pattern to an ES5-compatible
	        // approximation.
	        // Note: replacing with '\uFFFF' enables false positives in unlikely
	        // scenarios. For example, `[\u{1044f}-\u{10440}]` is an invalid
	        // pattern that would not be detected by this substitution.
	        var astralSubstitute = '\uFFFF';
	        var tmp = pattern;
	        var self = this;
	        if (flags.indexOf('u') >= 0) {
	            tmp = tmp
	                .replace(/\\u\{([0-9a-fA-F]+)\}|\\u([a-fA-F0-9]{4})/g, function ($0, $1, $2) {
	                var codePoint = parseInt($1 || $2, 16);
	                if (codePoint > 0x10FFFF) {
	                    self.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	                }
	                if (codePoint <= 0xFFFF) {
	                    return String.fromCharCode(codePoint);
	                }
	                return astralSubstitute;
	            })
	                .replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, astralSubstitute);
	        }
	        // First, detect invalid regular expressions.
	        try {
	            RegExp(tmp);
	        }
	        catch (e) {
	            this.throwUnexpectedToken(messages_1.Messages.InvalidRegExp);
	        }
	        // Return a regular expression object for this pattern-flag pair, or
	        // `null` in case the current environment doesn't support the flags it
	        // uses.
	        try {
	            return new RegExp(pattern, flags);
	        }
	        catch (exception) {
	            /* istanbul ignore next */
	            return null;
	        }
	    };
	    Scanner.prototype.scanRegExpBody = function () {
	        var ch = this.source[this.index];
	        assert_1.assert(ch === '/', 'Regular expression literal must start with a slash');
	        var str = this.source[this.index++];
	        var classMarker = false;
	        var terminated = false;
	        while (!this.eof()) {
	            ch = this.source[this.index++];
	            str += ch;
	            if (ch === '\\') {
	                ch = this.source[this.index++];
	                // https://tc39.github.io/ecma262/#sec-literals-regular-expression-literals
	                if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                    this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	                }
	                str += ch;
	            }
	            else if (character_1.Character.isLineTerminator(ch.charCodeAt(0))) {
	                this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	            }
	            else if (classMarker) {
	                if (ch === ']') {
	                    classMarker = false;
	                }
	            }
	            else {
	                if (ch === '/') {
	                    terminated = true;
	                    break;
	                }
	                else if (ch === '[') {
	                    classMarker = true;
	                }
	            }
	        }
	        if (!terminated) {
	            this.throwUnexpectedToken(messages_1.Messages.UnterminatedRegExp);
	        }
	        // Exclude leading and trailing slash.
	        return str.substr(1, str.length - 2);
	    };
	    Scanner.prototype.scanRegExpFlags = function () {
	        var str = '';
	        var flags = '';
	        while (!this.eof()) {
	            var ch = this.source[this.index];
	            if (!character_1.Character.isIdentifierPart(ch.charCodeAt(0))) {
	                break;
	            }
	            ++this.index;
	            if (ch === '\\' && !this.eof()) {
	                ch = this.source[this.index];
	                if (ch === 'u') {
	                    ++this.index;
	                    var restore = this.index;
	                    var char = this.scanHexEscape('u');
	                    if (char !== null) {
	                        flags += char;
	                        for (str += '\\u'; restore < this.index; ++restore) {
	                            str += this.source[restore];
	                        }
	                    }
	                    else {
	                        this.index = restore;
	                        flags += 'u';
	                        str += '\\u';
	                    }
	                    this.tolerateUnexpectedToken();
	                }
	                else {
	                    str += '\\';
	                    this.tolerateUnexpectedToken();
	                }
	            }
	            else {
	                flags += ch;
	                str += ch;
	            }
	        }
	        return flags;
	    };
	    Scanner.prototype.scanRegExp = function () {
	        var start = this.index;
	        var pattern = this.scanRegExpBody();
	        var flags = this.scanRegExpFlags();
	        var value = this.testRegExp(pattern, flags);
	        return {
	            type: 9 /* RegularExpression */,
	            value: '',
	            pattern: pattern,
	            flags: flags,
	            regex: value,
	            lineNumber: this.lineNumber,
	            lineStart: this.lineStart,
	            start: start,
	            end: this.index
	        };
	    };
	    Scanner.prototype.lex = function () {
	        if (this.eof()) {
	            return {
	                type: 2 /* EOF */,
	                value: '',
	                lineNumber: this.lineNumber,
	                lineStart: this.lineStart,
	                start: this.index,
	                end: this.index
	            };
	        }
	        var cp = this.source.charCodeAt(this.index);
	        if (character_1.Character.isIdentifierStart(cp)) {
	            return this.scanIdentifier();
	        }
	        // Very common: ( and ) and ;
	        if (cp === 0x28 || cp === 0x29 || cp === 0x3B) {
	            return this.scanPunctuator();
	        }
	        // String literal starts with single quote (U+0027) or double quote (U+0022).
	        if (cp === 0x27 || cp === 0x22) {
	            return this.scanStringLiteral();
	        }
	        // Dot (.) U+002E can also start a floating-point number, hence the need
	        // to check the next character.
	        if (cp === 0x2E) {
	            if (character_1.Character.isDecimalDigit(this.source.charCodeAt(this.index + 1))) {
	                return this.scanNumericLiteral();
	            }
	            return this.scanPunctuator();
	        }
	        if (character_1.Character.isDecimalDigit(cp)) {
	            return this.scanNumericLiteral();
	        }
	        // Template literals start with ` (U+0060) for template head
	        // or } (U+007D) for template middle or template tail.
	        if (cp === 0x60 || (cp === 0x7D && this.curlyStack[this.curlyStack.length - 1] === '${')) {
	            return this.scanTemplate();
	        }
	        // Possible identifier start in a surrogate pair.
	        if (cp >= 0xD800 && cp < 0xDFFF) {
	            if (character_1.Character.isIdentifierStart(this.codePointAt(this.index))) {
	                return this.scanIdentifier();
	            }
	        }
	        return this.scanPunctuator();
	    };
	    return Scanner;
	}());
	exports.Scanner = Scanner;


/***/ },
/* 13 */
/***/ function(module, exports) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.TokenName = {};
	exports.TokenName[1 /* BooleanLiteral */] = 'Boolean';
	exports.TokenName[2 /* EOF */] = '<end>';
	exports.TokenName[3 /* Identifier */] = 'Identifier';
	exports.TokenName[4 /* Keyword */] = 'Keyword';
	exports.TokenName[5 /* NullLiteral */] = 'Null';
	exports.TokenName[6 /* NumericLiteral */] = 'Numeric';
	exports.TokenName[7 /* Punctuator */] = 'Punctuator';
	exports.TokenName[8 /* StringLiteral */] = 'String';
	exports.TokenName[9 /* RegularExpression */] = 'RegularExpression';
	exports.TokenName[10 /* Template */] = 'Template';


/***/ },
/* 14 */
/***/ function(module, exports) {

	"use strict";
	// Generated by generate-xhtml-entities.js. DO NOT MODIFY!
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.XHTMLEntities = {
	    quot: '\u0022',
	    amp: '\u0026',
	    apos: '\u0027',
	    gt: '\u003E',
	    nbsp: '\u00A0',
	    iexcl: '\u00A1',
	    cent: '\u00A2',
	    pound: '\u00A3',
	    curren: '\u00A4',
	    yen: '\u00A5',
	    brvbar: '\u00A6',
	    sect: '\u00A7',
	    uml: '\u00A8',
	    copy: '\u00A9',
	    ordf: '\u00AA',
	    laquo: '\u00AB',
	    not: '\u00AC',
	    shy: '\u00AD',
	    reg: '\u00AE',
	    macr: '\u00AF',
	    deg: '\u00B0',
	    plusmn: '\u00B1',
	    sup2: '\u00B2',
	    sup3: '\u00B3',
	    acute: '\u00B4',
	    micro: '\u00B5',
	    para: '\u00B6',
	    middot: '\u00B7',
	    cedil: '\u00B8',
	    sup1: '\u00B9',
	    ordm: '\u00BA',
	    raquo: '\u00BB',
	    frac14: '\u00BC',
	    frac12: '\u00BD',
	    frac34: '\u00BE',
	    iquest: '\u00BF',
	    Agrave: '\u00C0',
	    Aacute: '\u00C1',
	    Acirc: '\u00C2',
	    Atilde: '\u00C3',
	    Auml: '\u00C4',
	    Aring: '\u00C5',
	    AElig: '\u00C6',
	    Ccedil: '\u00C7',
	    Egrave: '\u00C8',
	    Eacute: '\u00C9',
	    Ecirc: '\u00CA',
	    Euml: '\u00CB',
	    Igrave: '\u00CC',
	    Iacute: '\u00CD',
	    Icirc: '\u00CE',
	    Iuml: '\u00CF',
	    ETH: '\u00D0',
	    Ntilde: '\u00D1',
	    Ograve: '\u00D2',
	    Oacute: '\u00D3',
	    Ocirc: '\u00D4',
	    Otilde: '\u00D5',
	    Ouml: '\u00D6',
	    times: '\u00D7',
	    Oslash: '\u00D8',
	    Ugrave: '\u00D9',
	    Uacute: '\u00DA',
	    Ucirc: '\u00DB',
	    Uuml: '\u00DC',
	    Yacute: '\u00DD',
	    THORN: '\u00DE',
	    szlig: '\u00DF',
	    agrave: '\u00E0',
	    aacute: '\u00E1',
	    acirc: '\u00E2',
	    atilde: '\u00E3',
	    auml: '\u00E4',
	    aring: '\u00E5',
	    aelig: '\u00E6',
	    ccedil: '\u00E7',
	    egrave: '\u00E8',
	    eacute: '\u00E9',
	    ecirc: '\u00EA',
	    euml: '\u00EB',
	    igrave: '\u00EC',
	    iacute: '\u00ED',
	    icirc: '\u00EE',
	    iuml: '\u00EF',
	    eth: '\u00F0',
	    ntilde: '\u00F1',
	    ograve: '\u00F2',
	    oacute: '\u00F3',
	    ocirc: '\u00F4',
	    otilde: '\u00F5',
	    ouml: '\u00F6',
	    divide: '\u00F7',
	    oslash: '\u00F8',
	    ugrave: '\u00F9',
	    uacute: '\u00FA',
	    ucirc: '\u00FB',
	    uuml: '\u00FC',
	    yacute: '\u00FD',
	    thorn: '\u00FE',
	    yuml: '\u00FF',
	    OElig: '\u0152',
	    oelig: '\u0153',
	    Scaron: '\u0160',
	    scaron: '\u0161',
	    Yuml: '\u0178',
	    fnof: '\u0192',
	    circ: '\u02C6',
	    tilde: '\u02DC',
	    Alpha: '\u0391',
	    Beta: '\u0392',
	    Gamma: '\u0393',
	    Delta: '\u0394',
	    Epsilon: '\u0395',
	    Zeta: '\u0396',
	    Eta: '\u0397',
	    Theta: '\u0398',
	    Iota: '\u0399',
	    Kappa: '\u039A',
	    Lambda: '\u039B',
	    Mu: '\u039C',
	    Nu: '\u039D',
	    Xi: '\u039E',
	    Omicron: '\u039F',
	    Pi: '\u03A0',
	    Rho: '\u03A1',
	    Sigma: '\u03A3',
	    Tau: '\u03A4',
	    Upsilon: '\u03A5',
	    Phi: '\u03A6',
	    Chi: '\u03A7',
	    Psi: '\u03A8',
	    Omega: '\u03A9',
	    alpha: '\u03B1',
	    beta: '\u03B2',
	    gamma: '\u03B3',
	    delta: '\u03B4',
	    epsilon: '\u03B5',
	    zeta: '\u03B6',
	    eta: '\u03B7',
	    theta: '\u03B8',
	    iota: '\u03B9',
	    kappa: '\u03BA',
	    lambda: '\u03BB',
	    mu: '\u03BC',
	    nu: '\u03BD',
	    xi: '\u03BE',
	    omicron: '\u03BF',
	    pi: '\u03C0',
	    rho: '\u03C1',
	    sigmaf: '\u03C2',
	    sigma: '\u03C3',
	    tau: '\u03C4',
	    upsilon: '\u03C5',
	    phi: '\u03C6',
	    chi: '\u03C7',
	    psi: '\u03C8',
	    omega: '\u03C9',
	    thetasym: '\u03D1',
	    upsih: '\u03D2',
	    piv: '\u03D6',
	    ensp: '\u2002',
	    emsp: '\u2003',
	    thinsp: '\u2009',
	    zwnj: '\u200C',
	    zwj: '\u200D',
	    lrm: '\u200E',
	    rlm: '\u200F',
	    ndash: '\u2013',
	    mdash: '\u2014',
	    lsquo: '\u2018',
	    rsquo: '\u2019',
	    sbquo: '\u201A',
	    ldquo: '\u201C',
	    rdquo: '\u201D',
	    bdquo: '\u201E',
	    dagger: '\u2020',
	    Dagger: '\u2021',
	    bull: '\u2022',
	    hellip: '\u2026',
	    permil: '\u2030',
	    prime: '\u2032',
	    Prime: '\u2033',
	    lsaquo: '\u2039',
	    rsaquo: '\u203A',
	    oline: '\u203E',
	    frasl: '\u2044',
	    euro: '\u20AC',
	    image: '\u2111',
	    weierp: '\u2118',
	    real: '\u211C',
	    trade: '\u2122',
	    alefsym: '\u2135',
	    larr: '\u2190',
	    uarr: '\u2191',
	    rarr: '\u2192',
	    darr: '\u2193',
	    harr: '\u2194',
	    crarr: '\u21B5',
	    lArr: '\u21D0',
	    uArr: '\u21D1',
	    rArr: '\u21D2',
	    dArr: '\u21D3',
	    hArr: '\u21D4',
	    forall: '\u2200',
	    part: '\u2202',
	    exist: '\u2203',
	    empty: '\u2205',
	    nabla: '\u2207',
	    isin: '\u2208',
	    notin: '\u2209',
	    ni: '\u220B',
	    prod: '\u220F',
	    sum: '\u2211',
	    minus: '\u2212',
	    lowast: '\u2217',
	    radic: '\u221A',
	    prop: '\u221D',
	    infin: '\u221E',
	    ang: '\u2220',
	    and: '\u2227',
	    or: '\u2228',
	    cap: '\u2229',
	    cup: '\u222A',
	    int: '\u222B',
	    there4: '\u2234',
	    sim: '\u223C',
	    cong: '\u2245',
	    asymp: '\u2248',
	    ne: '\u2260',
	    equiv: '\u2261',
	    le: '\u2264',
	    ge: '\u2265',
	    sub: '\u2282',
	    sup: '\u2283',
	    nsub: '\u2284',
	    sube: '\u2286',
	    supe: '\u2287',
	    oplus: '\u2295',
	    otimes: '\u2297',
	    perp: '\u22A5',
	    sdot: '\u22C5',
	    lceil: '\u2308',
	    rceil: '\u2309',
	    lfloor: '\u230A',
	    rfloor: '\u230B',
	    loz: '\u25CA',
	    spades: '\u2660',
	    clubs: '\u2663',
	    hearts: '\u2665',
	    diams: '\u2666',
	    lang: '\u27E8',
	    rang: '\u27E9'
	};


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	Object.defineProperty(exports, "__esModule", { value: true });
	var error_handler_1 = __webpack_require__(10);
	var scanner_1 = __webpack_require__(12);
	var token_1 = __webpack_require__(13);
	var Reader = (function () {
	    function Reader() {
	        this.values = [];
	        this.curly = this.paren = -1;
	    }
	    // A function following one of those tokens is an expression.
	    Reader.prototype.beforeFunctionExpression = function (t) {
	        return ['(', '{', '[', 'in', 'typeof', 'instanceof', 'new',
	            'return', 'case', 'delete', 'throw', 'void',
	            // assignment operators
	            '=', '+=', '-=', '*=', '**=', '/=', '%=', '<<=', '>>=', '>>>=',
	            '&=', '|=', '^=', ',',
	            // binary/unary operators
	            '+', '-', '*', '**', '/', '%', '++', '--', '<<', '>>', '>>>', '&',
	            '|', '^', '!', '~', '&&', '||', '?', ':', '===', '==', '>=',
	            '<=', '<', '>', '!=', '!=='].indexOf(t) >= 0;
	    };
	    // Determine if forward slash (/) is an operator or part of a regular expression
	    // https://github.com/mozilla/sweet.js/wiki/design
	    Reader.prototype.isRegexStart = function () {
	        var previous = this.values[this.values.length - 1];
	        var regex = (previous !== null);
	        switch (previous) {
	            case 'this':
	            case ']':
	                regex = false;
	                break;
	            case ')':
	                var keyword = this.values[this.paren - 1];
	                regex = (keyword === 'if' || keyword === 'while' || keyword === 'for' || keyword === 'with');
	                break;
	            case '}':
	                // Dividing a function by anything makes little sense,
	                // but we have to check for that.
	                regex = false;
	                if (this.values[this.curly - 3] === 'function') {
	                    // Anonymous function, e.g. function(){} /42
	                    var check = this.values[this.curly - 4];
	                    regex = check ? !this.beforeFunctionExpression(check) : false;
	                }
	                else if (this.values[this.curly - 4] === 'function') {
	                    // Named function, e.g. function f(){} /42/
	                    var check = this.values[this.curly - 5];
	                    regex = check ? !this.beforeFunctionExpression(check) : true;
	                }
	                break;
	            default:
	                break;
	        }
	        return regex;
	    };
	    Reader.prototype.push = function (token) {
	        if (token.type === 7 /* Punctuator */ || token.type === 4 /* Keyword */) {
	            if (token.value === '{') {
	                this.curly = this.values.length;
	            }
	            else if (token.value === '(') {
	                this.paren = this.values.length;
	            }
	            this.values.push(token.value);
	        }
	        else {
	            this.values.push(null);
	        }
	    };
	    return Reader;
	}());
	var Tokenizer = (function () {
	    function Tokenizer(code, config) {
	        this.errorHandler = new error_handler_1.ErrorHandler();
	        this.errorHandler.tolerant = config ? (typeof config.tolerant === 'boolean' && config.tolerant) : false;
	        this.scanner = new scanner_1.Scanner(code, this.errorHandler);
	        this.scanner.trackComment = config ? (typeof config.comment === 'boolean' && config.comment) : false;
	        this.trackRange = config ? (typeof config.range === 'boolean' && config.range) : false;
	        this.trackLoc = config ? (typeof config.loc === 'boolean' && config.loc) : false;
	        this.buffer = [];
	        this.reader = new Reader();
	    }
	    Tokenizer.prototype.errors = function () {
	        return this.errorHandler.errors;
	    };
	    Tokenizer.prototype.getNextToken = function () {
	        if (this.buffer.length === 0) {
	            var comments = this.scanner.scanComments();
	            if (this.scanner.trackComment) {
	                for (var i = 0; i < comments.length; ++i) {
	                    var e = comments[i];
	                    var value = this.scanner.source.slice(e.slice[0], e.slice[1]);
	                    var comment = {
	                        type: e.multiLine ? 'BlockComment' : 'LineComment',
	                        value: value
	                    };
	                    if (this.trackRange) {
	                        comment.range = e.range;
	                    }
	                    if (this.trackLoc) {
	                        comment.loc = e.loc;
	                    }
	                    this.buffer.push(comment);
	                }
	            }
	            if (!this.scanner.eof()) {
	                var loc = void 0;
	                if (this.trackLoc) {
	                    loc = {
	                        start: {
	                            line: this.scanner.lineNumber,
	                            column: this.scanner.index - this.scanner.lineStart
	                        },
	                        end: {}
	                    };
	                }
	                var startRegex = (this.scanner.source[this.scanner.index] === '/') && this.reader.isRegexStart();
	                var token = startRegex ? this.scanner.scanRegExp() : this.scanner.lex();
	                this.reader.push(token);
	                var entry = {
	                    type: token_1.TokenName[token.type],
	                    value: this.scanner.source.slice(token.start, token.end)
	                };
	                if (this.trackRange) {
	                    entry.range = [token.start, token.end];
	                }
	                if (this.trackLoc) {
	                    loc.end = {
	                        line: this.scanner.lineNumber,
	                        column: this.scanner.index - this.scanner.lineStart
	                    };
	                    entry.loc = loc;
	                }
	                if (token.type === 9 /* RegularExpression */) {
	                    var pattern = token.pattern;
	                    var flags = token.flags;
	                    entry.regex = { pattern: pattern, flags: flags };
	                }
	                this.buffer.push(entry);
	            }
	        }
	        return this.buffer.shift();
	    };
	    return Tokenizer;
	}());
	exports.Tokenizer = Tokenizer;


/***/ }
/******/ ])
});
;

/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*eslint-disable no-use-before-define*/

var common              = __webpack_require__(7);
var YAMLException       = __webpack_require__(10);
var DEFAULT_FULL_SCHEMA = __webpack_require__(12);
var DEFAULT_SAFE_SCHEMA = __webpack_require__(11);

var _toString       = Object.prototype.toString;
var _hasOwnProperty = Object.prototype.hasOwnProperty;

var CHAR_TAB                  = 0x09; /* Tab */
var CHAR_LINE_FEED            = 0x0A; /* LF */
var CHAR_SPACE                = 0x20; /* Space */
var CHAR_EXCLAMATION          = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE         = 0x22; /* " */
var CHAR_SHARP                = 0x23; /* # */
var CHAR_PERCENT              = 0x25; /* % */
var CHAR_AMPERSAND            = 0x26; /* & */
var CHAR_SINGLE_QUOTE         = 0x27; /* ' */
var CHAR_ASTERISK             = 0x2A; /* * */
var CHAR_COMMA                = 0x2C; /* , */
var CHAR_MINUS                = 0x2D; /* - */
var CHAR_COLON                = 0x3A; /* : */
var CHAR_GREATER_THAN         = 0x3E; /* > */
var CHAR_QUESTION             = 0x3F; /* ? */
var CHAR_COMMERCIAL_AT        = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */
var CHAR_GRAVE_ACCENT         = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */
var CHAR_VERTICAL_LINE        = 0x7C; /* | */
var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */

var ESCAPE_SEQUENCES = {};

ESCAPE_SEQUENCES[0x00]   = '\\0';
ESCAPE_SEQUENCES[0x07]   = '\\a';
ESCAPE_SEQUENCES[0x08]   = '\\b';
ESCAPE_SEQUENCES[0x09]   = '\\t';
ESCAPE_SEQUENCES[0x0A]   = '\\n';
ESCAPE_SEQUENCES[0x0B]   = '\\v';
ESCAPE_SEQUENCES[0x0C]   = '\\f';
ESCAPE_SEQUENCES[0x0D]   = '\\r';
ESCAPE_SEQUENCES[0x1B]   = '\\e';
ESCAPE_SEQUENCES[0x22]   = '\\"';
ESCAPE_SEQUENCES[0x5C]   = '\\\\';
ESCAPE_SEQUENCES[0x85]   = '\\N';
ESCAPE_SEQUENCES[0xA0]   = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';

var DEPRECATED_BOOLEANS_SYNTAX = [
  'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',
  'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'
];

function compileStyleMap(schema, map) {
  var result, keys, index, length, tag, style, type;

  if (map === null) return {};

  result = {};
  keys = Object.keys(map);

  for (index = 0, length = keys.length; index < length; index += 1) {
    tag = keys[index];
    style = String(map[tag]);

    if (tag.slice(0, 2) === '!!') {
      tag = 'tag:yaml.org,2002:' + tag.slice(2);
    }
    type = schema.compiledTypeMap['fallback'][tag];

    if (type && _hasOwnProperty.call(type.styleAliases, style)) {
      style = type.styleAliases[style];
    }

    result[tag] = style;
  }

  return result;
}

function encodeHex(character) {
  var string, handle, length;

  string = character.toString(16).toUpperCase();

  if (character <= 0xFF) {
    handle = 'x';
    length = 2;
  } else if (character <= 0xFFFF) {
    handle = 'u';
    length = 4;
  } else if (character <= 0xFFFFFFFF) {
    handle = 'U';
    length = 8;
  } else {
    throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
  }

  return '\\' + handle + common.repeat('0', length - string.length) + string;
}

function State(options) {
  this.schema        = options['schema'] || DEFAULT_FULL_SCHEMA;
  this.indent        = Math.max(1, (options['indent'] || 2));
  this.noArrayIndent = options['noArrayIndent'] || false;
  this.skipInvalid   = options['skipInvalid'] || false;
  this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);
  this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);
  this.sortKeys      = options['sortKeys'] || false;
  this.lineWidth     = options['lineWidth'] || 80;
  this.noRefs        = options['noRefs'] || false;
  this.noCompatMode  = options['noCompatMode'] || false;
  this.condenseFlow  = options['condenseFlow'] || false;

  this.implicitTypes = this.schema.compiledImplicit;
  this.explicitTypes = this.schema.compiledExplicit;

  this.tag = null;
  this.result = '';

  this.duplicates = [];
  this.usedDuplicates = null;
}

// Indents every line in a string. Empty lines (\n only) are not indented.
function indentString(string, spaces) {
  var ind = common.repeat(' ', spaces),
      position = 0,
      next = -1,
      result = '',
      line,
      length = string.length;

  while (position < length) {
    next = string.indexOf('\n', position);
    if (next === -1) {
      line = string.slice(position);
      position = length;
    } else {
      line = string.slice(position, next + 1);
      position = next + 1;
    }

    if (line.length && line !== '\n') result += ind;

    result += line;
  }

  return result;
}

function generateNextLine(state, level) {
  return '\n' + common.repeat(' ', state.indent * level);
}

function testImplicitResolving(state, str) {
  var index, length, type;

  for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
    type = state.implicitTypes[index];

    if (type.resolve(str)) {
      return true;
    }
  }

  return false;
}

// [33] s-white ::= s-space | s-tab
function isWhitespace(c) {
  return c === CHAR_SPACE || c === CHAR_TAB;
}

// Returns true if the character can be printed without escaping.
// From YAML 1.2: "any allowed characters known to be non-printable
// should also be escaped. [However,] This isnt mandatory"
// Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.
function isPrintable(c) {
  return  (0x00020 <= c && c <= 0x00007E)
      || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)
      || ((0x0E000 <= c && c <= 0x00FFFD) && c !== 0xFEFF /* BOM */)
      ||  (0x10000 <= c && c <= 0x10FFFF);
}

// Simplified test for values allowed after the first character in plain style.
function isPlainSafe(c) {
  // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
  // where nb-char ::= c-printable - b-char - c-byte-order-mark.
  return isPrintable(c) && c !== 0xFEFF
    // - c-flow-indicator
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // - ":" - "#"
    && c !== CHAR_COLON
    && c !== CHAR_SHARP;
}

// Simplified test for values allowed as the first character in plain style.
function isPlainSafeFirst(c) {
  // Uses a subset of ns-char - c-indicator
  // where ns-char = nb-char - s-white.
  return isPrintable(c) && c !== 0xFEFF
    && !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // - | ? | : | , | [ | ] | { | }
    && c !== CHAR_MINUS
    && c !== CHAR_QUESTION
    && c !== CHAR_COLON
    && c !== CHAR_COMMA
    && c !== CHAR_LEFT_SQUARE_BRACKET
    && c !== CHAR_RIGHT_SQUARE_BRACKET
    && c !== CHAR_LEFT_CURLY_BRACKET
    && c !== CHAR_RIGHT_CURLY_BRACKET
    // | # | & | * | ! | | | > | ' | "
    && c !== CHAR_SHARP
    && c !== CHAR_AMPERSAND
    && c !== CHAR_ASTERISK
    && c !== CHAR_EXCLAMATION
    && c !== CHAR_VERTICAL_LINE
    && c !== CHAR_GREATER_THAN
    && c !== CHAR_SINGLE_QUOTE
    && c !== CHAR_DOUBLE_QUOTE
    // | % | @ | `)
    && c !== CHAR_PERCENT
    && c !== CHAR_COMMERCIAL_AT
    && c !== CHAR_GRAVE_ACCENT;
}

// Determines whether block indentation indicator is required.
function needIndentIndicator(string) {
  var leadingSpaceRe = /^\n* /;
  return leadingSpaceRe.test(string);
}

var STYLE_PLAIN   = 1,
    STYLE_SINGLE  = 2,
    STYLE_LITERAL = 3,
    STYLE_FOLDED  = 4,
    STYLE_DOUBLE  = 5;

// Determines which scalar styles are possible and returns the preferred style.
// lineWidth = -1 => no limit.
// Pre-conditions: str.length > 0.
// Post-conditions:
//    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
//    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
//    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).
function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
  var i;
  var char;
  var hasLineBreak = false;
  var hasFoldableLine = false; // only checked if shouldTrackWidth
  var shouldTrackWidth = lineWidth !== -1;
  var previousLineBreak = -1; // count the first line correctly
  var plain = isPlainSafeFirst(string.charCodeAt(0))
          && !isWhitespace(string.charCodeAt(string.length - 1));

  if (singleLineOnly) {
    // Case: no block styles.
    // Check for disallowed characters to rule out plain and single.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char);
    }
  } else {
    // Case: block styles permitted.
    for (i = 0; i < string.length; i++) {
      char = string.charCodeAt(i);
      if (char === CHAR_LINE_FEED) {
        hasLineBreak = true;
        // Check if any line can be folded.
        if (shouldTrackWidth) {
          hasFoldableLine = hasFoldableLine ||
            // Foldable line = too long, and not more-indented.
            (i - previousLineBreak - 1 > lineWidth &&
             string[previousLineBreak + 1] !== ' ');
          previousLineBreak = i;
        }
      } else if (!isPrintable(char)) {
        return STYLE_DOUBLE;
      }
      plain = plain && isPlainSafe(char);
    }
    // in case the end is missing a \n
    hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&
      (i - previousLineBreak - 1 > lineWidth &&
       string[previousLineBreak + 1] !== ' '));
  }
  // Although every style can represent \n without escaping, prefer block styles
  // for multiline, since they're more readable and they don't add empty lines.
  // Also prefer folding a super-long line.
  if (!hasLineBreak && !hasFoldableLine) {
    // Strings interpretable as another type have to be quoted;
    // e.g. the string 'true' vs. the boolean true.
    return plain && !testAmbiguousType(string)
      ? STYLE_PLAIN : STYLE_SINGLE;
  }
  // Edge case: block indentation indicator can only have one digit.
  if (indentPerLevel > 9 && needIndentIndicator(string)) {
    return STYLE_DOUBLE;
  }
  // At this point we know block styles are valid.
  // Prefer literal style unless we want to fold.
  return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
}

// Note: line breaking/folding is implemented for only the folded style.
// NB. We drop the last trailing newline (if any) of a returned block scalar
//  since the dumper adds its own newline. This always works:
//     No ending newline => unaffected; already using strip "-" chomping.
//     Ending newline    => removed then restored.
//  Importantly, this keeps the "+" chomp indicator from gaining an extra line.
function writeScalar(state, string, level, iskey) {
  state.dump = (function () {
    if (string.length === 0) {
      return "''";
    }
    if (!state.noCompatMode &&
        DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
      return "'" + string + "'";
    }

    var indent = state.indent * Math.max(1, level); // no 0-indent scalars
    // As indentation gets deeper, let the width decrease monotonically
    // to the lower bound min(state.lineWidth, 40).
    // Note that this implies
    //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.
    //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
    // This behaves better than a constant minimum width which disallows narrower options,
    // or an indent threshold which causes the width to suddenly increase.
    var lineWidth = state.lineWidth === -1
      ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);

    // Without knowing if keys are implicit/explicit, assume implicit for safety.
    var singleLineOnly = iskey
      // No block styles in flow mode.
      || (state.flowLevel > -1 && level >= state.flowLevel);
    function testAmbiguity(string) {
      return testImplicitResolving(state, string);
    }

    switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
      case STYLE_PLAIN:
        return string;
      case STYLE_SINGLE:
        return "'" + string.replace(/'/g, "''") + "'";
      case STYLE_LITERAL:
        return '|' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(string, indent));
      case STYLE_FOLDED:
        return '>' + blockHeader(string, state.indent)
          + dropEndingNewline(indentString(foldString(string, lineWidth), indent));
      case STYLE_DOUBLE:
        return '"' + escapeString(string, lineWidth) + '"';
      default:
        throw new YAMLException('impossible error: invalid scalar style');
    }
  }());
}

// Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.
function blockHeader(string, indentPerLevel) {
  var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';

  // note the special case: the string '\n' counts as a "trailing" empty line.
  var clip =          string[string.length - 1] === '\n';
  var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
  var chomp = keep ? '+' : (clip ? '' : '-');

  return indentIndicator + chomp + '\n';
}

// (See the note for writeScalar.)
function dropEndingNewline(string) {
  return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
}

// Note: a long line without a suitable break point will exceed the width limit.
// Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.
function foldString(string, width) {
  // In folded style, $k$ consecutive newlines output as $k+1$ newlines
  // unless they're before or after a more-indented line, or at the very
  // beginning or end, in which case $k$ maps to $k$.
  // Therefore, parse each chunk as newline(s) followed by a content line.
  var lineRe = /(\n+)([^\n]*)/g;

  // first line (possibly an empty line)
  var result = (function () {
    var nextLF = string.indexOf('\n');
    nextLF = nextLF !== -1 ? nextLF : string.length;
    lineRe.lastIndex = nextLF;
    return foldLine(string.slice(0, nextLF), width);
  }());
  // If we haven't reached the first content line yet, don't add an extra \n.
  var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
  var moreIndented;

  // rest of the lines
  var match;
  while ((match = lineRe.exec(string))) {
    var prefix = match[1], line = match[2];
    moreIndented = (line[0] === ' ');
    result += prefix
      + (!prevMoreIndented && !moreIndented && line !== ''
        ? '\n' : '')
      + foldLine(line, width);
    prevMoreIndented = moreIndented;
  }

  return result;
}

// Greedy line breaking.
// Picks the longest line under the limit each time,
// otherwise settles for the shortest line over the limit.
// NB. More-indented lines *cannot* be folded, as that would add an extra \n.
function foldLine(line, width) {
  if (line === '' || line[0] === ' ') return line;

  // Since a more-indented line adds a \n, breaks can't be followed by a space.
  var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.
  var match;
  // start is an inclusive index. end, curr, and next are exclusive.
  var start = 0, end, curr = 0, next = 0;
  var result = '';

  // Invariants: 0 <= start <= length-1.
  //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
  // Inside the loop:
  //   A match implies length >= 2, so curr and next are <= length-2.
  while ((match = breakRe.exec(line))) {
    next = match.index;
    // maintain invariant: curr - start <= width
    if (next - start > width) {
      end = (curr > start) ? curr : next; // derive end <= length-2
      result += '\n' + line.slice(start, end);
      // skip the space that was output as \n
      start = end + 1;                    // derive start <= length-1
    }
    curr = next;
  }

  // By the invariants, start <= length-1, so there is something left over.
  // It is either the whole string or a part starting from non-whitespace.
  result += '\n';
  // Insert a break if the remainder is too long and there is a break available.
  if (line.length - start > width && curr > start) {
    result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
  } else {
    result += line.slice(start);
  }

  return result.slice(1); // drop extra \n joiner
}

// Escapes a double-quoted string.
function escapeString(string) {
  var result = '';
  var char, nextChar;
  var escapeSeq;

  for (var i = 0; i < string.length; i++) {
    char = string.charCodeAt(i);
    // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").
    if (char >= 0xD800 && char <= 0xDBFF/* high surrogate */) {
      nextChar = string.charCodeAt(i + 1);
      if (nextChar >= 0xDC00 && nextChar <= 0xDFFF/* low surrogate */) {
        // Combine the surrogate pair and store it escaped.
        result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000);
        // Advance index one extra since we already used that char here.
        i++; continue;
      }
    }
    escapeSeq = ESCAPE_SEQUENCES[char];
    result += !escapeSeq && isPrintable(char)
      ? string[i]
      : escapeSeq || encodeHex(char);
  }

  return result;
}

function writeFlowSequence(state, level, object) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level, object[index], false, false)) {
      if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = '[' + _result + ']';
}

function writeBlockSequence(state, level, object, compact) {
  var _result = '',
      _tag    = state.tag,
      index,
      length;

  for (index = 0, length = object.length; index < length; index += 1) {
    // Write only valid elements.
    if (writeNode(state, level + 1, object[index], true, true)) {
      if (!compact || index !== 0) {
        _result += generateNextLine(state, level);
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        _result += '-';
      } else {
        _result += '- ';
      }

      _result += state.dump;
    }
  }

  state.tag = _tag;
  state.dump = _result || '[]'; // Empty sequence if no valid values.
}

function writeFlowMapping(state, level, object) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      pairBuffer;

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = state.condenseFlow ? '"' : '';

    if (index !== 0) pairBuffer += ', ';

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level, objectKey, false, false)) {
      continue; // Skip this pair because of invalid key;
    }

    if (state.dump.length > 1024) pairBuffer += '? ';

    pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

    if (!writeNode(state, level, objectValue, false, false)) {
      continue; // Skip this pair because of invalid value.
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = '{' + _result + '}';
}

function writeBlockMapping(state, level, object, compact) {
  var _result       = '',
      _tag          = state.tag,
      objectKeyList = Object.keys(object),
      index,
      length,
      objectKey,
      objectValue,
      explicitPair,
      pairBuffer;

  // Allow sorting keys so that the output file is deterministic
  if (state.sortKeys === true) {
    // Default sorting
    objectKeyList.sort();
  } else if (typeof state.sortKeys === 'function') {
    // Custom sort function
    objectKeyList.sort(state.sortKeys);
  } else if (state.sortKeys) {
    // Something is wrong
    throw new YAMLException('sortKeys must be a boolean or a function');
  }

  for (index = 0, length = objectKeyList.length; index < length; index += 1) {
    pairBuffer = '';

    if (!compact || index !== 0) {
      pairBuffer += generateNextLine(state, level);
    }

    objectKey = objectKeyList[index];
    objectValue = object[objectKey];

    if (!writeNode(state, level + 1, objectKey, true, true, true)) {
      continue; // Skip this pair because of invalid key.
    }

    explicitPair = (state.tag !== null && state.tag !== '?') ||
                   (state.dump && state.dump.length > 1024);

    if (explicitPair) {
      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += '?';
      } else {
        pairBuffer += '? ';
      }
    }

    pairBuffer += state.dump;

    if (explicitPair) {
      pairBuffer += generateNextLine(state, level);
    }

    if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
      continue; // Skip this pair because of invalid value.
    }

    if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
      pairBuffer += ':';
    } else {
      pairBuffer += ': ';
    }

    pairBuffer += state.dump;

    // Both key and value are valid.
    _result += pairBuffer;
  }

  state.tag = _tag;
  state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}

function detectType(state, object, explicit) {
  var _result, typeList, index, length, type, style;

  typeList = explicit ? state.explicitTypes : state.implicitTypes;

  for (index = 0, length = typeList.length; index < length; index += 1) {
    type = typeList[index];

    if ((type.instanceOf  || type.predicate) &&
        (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&
        (!type.predicate  || type.predicate(object))) {

      state.tag = explicit ? type.tag : '?';

      if (type.represent) {
        style = state.styleMap[type.tag] || type.defaultStyle;

        if (_toString.call(type.represent) === '[object Function]') {
          _result = type.represent(object, style);
        } else if (_hasOwnProperty.call(type.represent, style)) {
          _result = type.represent[style](object, style);
        } else {
          throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
        }

        state.dump = _result;
      }

      return true;
    }
  }

  return false;
}

// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact, iskey) {
  state.tag = null;
  state.dump = object;

  if (!detectType(state, object, false)) {
    detectType(state, object, true);
  }

  var type = _toString.call(state.dump);

  if (block) {
    block = (state.flowLevel < 0 || state.flowLevel > level);
  }

  var objectOrArray = type === '[object Object]' || type === '[object Array]',
      duplicateIndex,
      duplicate;

  if (objectOrArray) {
    duplicateIndex = state.duplicates.indexOf(object);
    duplicate = duplicateIndex !== -1;
  }

  if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {
    compact = false;
  }

  if (duplicate && state.usedDuplicates[duplicateIndex]) {
    state.dump = '*ref_' + duplicateIndex;
  } else {
    if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
      state.usedDuplicates[duplicateIndex] = true;
    }
    if (type === '[object Object]') {
      if (block && (Object.keys(state.dump).length !== 0)) {
        writeBlockMapping(state, level, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowMapping(state, level, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object Array]') {
      var arrayLevel = (state.noArrayIndent && (level > 0)) ? level - 1 : level;
      if (block && (state.dump.length !== 0)) {
        writeBlockSequence(state, arrayLevel, state.dump, compact);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + state.dump;
        }
      } else {
        writeFlowSequence(state, arrayLevel, state.dump);
        if (duplicate) {
          state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
        }
      }
    } else if (type === '[object String]') {
      if (state.tag !== '?') {
        writeScalar(state, state.dump, level, iskey);
      }
    } else {
      if (state.skipInvalid) return false;
      throw new YAMLException('unacceptable kind of an object to dump ' + type);
    }

    if (state.tag !== null && state.tag !== '?') {
      state.dump = '!<' + state.tag + '> ' + state.dump;
    }
  }

  return true;
}

function getDuplicateReferences(object, state) {
  var objects = [],
      duplicatesIndexes = [],
      index,
      length;

  inspectNode(object, objects, duplicatesIndexes);

  for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
    state.duplicates.push(objects[duplicatesIndexes[index]]);
  }
  state.usedDuplicates = new Array(length);
}

function inspectNode(object, objects, duplicatesIndexes) {
  var objectKeyList,
      index,
      length;

  if (object !== null && typeof object === 'object') {
    index = objects.indexOf(object);
    if (index !== -1) {
      if (duplicatesIndexes.indexOf(index) === -1) {
        duplicatesIndexes.push(index);
      }
    } else {
      objects.push(object);

      if (Array.isArray(object)) {
        for (index = 0, length = object.length; index < length; index += 1) {
          inspectNode(object[index], objects, duplicatesIndexes);
        }
      } else {
        objectKeyList = Object.keys(object);

        for (index = 0, length = objectKeyList.length; index < length; index += 1) {
          inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
        }
      }
    }
  }
}

function dump(input, options) {
  options = options || {};

  var state = new State(options);

  if (!state.noRefs) getDuplicateReferences(input, state);

  if (writeNode(state, 0, input, true, true)) return state.dump + '\n';

  return '';
}

function safeDump(input, options) {
  return dump(input, common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

module.exports.dump     = dump;
module.exports.safeDump = safeDump;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
   true ? module.exports = factory() :
  undefined;
}(this, (function () { 'use strict';

  var name = "prettier";
  var version = "1.19.1";
  var description = "Prettier is an opinionated code formatter";
  var bin = {
  	prettier: "./bin/prettier.js"
  };
  var repository = "prettier/prettier";
  var homepage = "https://prettier.io";
  var author = "James Long";
  var license = "MIT";
  var main = "./index.js";
  var engines = {
  	node: ">=8"
  };
  var dependencies = {
  	"@angular/compiler": "8.2.13",
  	"@babel/code-frame": "7.5.5",
  	"@babel/parser": "7.7.3",
  	"@glimmer/syntax": "0.41.0",
  	"@iarna/toml": "2.2.3",
  	"@typescript-eslint/typescript-estree": "2.6.1",
  	"angular-estree-parser": "1.1.5",
  	"angular-html-parser": "1.3.0",
  	camelcase: "5.3.1",
  	chalk: "2.4.2",
  	"cjk-regex": "2.0.0",
  	cosmiconfig: "5.2.1",
  	dashify: "2.0.0",
  	dedent: "0.7.0",
  	diff: "4.0.1",
  	editorconfig: "0.15.3",
  	"editorconfig-to-prettier": "0.1.1",
  	"escape-string-regexp": "1.0.5",
  	esutils: "2.0.3",
  	"find-parent-dir": "0.3.0",
  	"find-project-root": "1.1.1",
  	"flow-parser": "0.111.3",
  	"get-stream": "4.1.0",
  	globby: "6.1.0",
  	graphql: "14.5.8",
  	"html-element-attributes": "2.2.0",
  	"html-styles": "1.0.0",
  	"html-tag-names": "1.1.4",
  	ignore: "4.0.6",
  	"is-ci": "2.0.0",
  	"jest-docblock": "24.9.0",
  	"json-stable-stringify": "1.0.1",
  	leven: "3.1.0",
  	"lines-and-columns": "1.1.6",
  	"linguist-languages": "7.6.0",
  	"lodash.uniqby": "4.7.0",
  	mem: "5.1.1",
  	minimatch: "3.0.4",
  	minimist: "1.2.0",
  	"n-readlines": "1.0.0",
  	"normalize-path": "3.0.0",
  	"parse-srcset": "ikatyang/parse-srcset#54eb9c1cb21db5c62b4d0e275d7249516df6f0ee",
  	"postcss-less": "2.0.0",
  	"postcss-media-query-parser": "0.2.3",
  	"postcss-scss": "2.0.0",
  	"postcss-selector-parser": "2.2.3",
  	"postcss-values-parser": "1.5.0",
  	"regexp-util": "1.2.2",
  	"remark-math": "1.0.6",
  	"remark-parse": "5.0.0",
  	resolve: "1.12.0",
  	semver: "6.3.0",
  	"string-width": "4.1.0",
  	typescript: "3.7.2",
  	"unicode-regex": "3.0.0",
  	unified: "8.4.1",
  	vnopts: "1.0.2",
  	"yaml-unist-parser": "1.1.1"
  };
  var devDependencies = {
  	"@babel/core": "7.7.2",
  	"@babel/preset-env": "7.7.1",
  	"@rollup/plugin-alias": "2.2.0",
  	"@rollup/plugin-replace": "2.2.1",
  	"babel-loader": "8.0.6",
  	benchmark: "2.1.4",
  	"builtin-modules": "3.1.0",
  	codecov: "3.6.1",
  	"cross-env": "6.0.3",
  	eslint: "6.6.0",
  	"eslint-config-prettier": "6.5.0",
  	"eslint-formatter-friendly": "7.0.0",
  	"eslint-plugin-import": "2.18.2",
  	"eslint-plugin-prettier": "3.1.1",
  	"eslint-plugin-react": "7.16.0",
  	execa: "3.2.0",
  	jest: "23.3.0",
  	"jest-junit": "9.0.0",
  	"jest-snapshot-serializer-ansi": "1.0.0",
  	"jest-snapshot-serializer-raw": "1.1.0",
  	"jest-watch-typeahead": "0.4.0",
  	mkdirp: "0.5.1",
  	prettier: "1.19.0",
  	prettylint: "1.0.0",
  	rimraf: "3.0.0",
  	rollup: "1.26.3",
  	"rollup-plugin-babel": "4.3.3",
  	"rollup-plugin-commonjs": "10.1.0",
  	"rollup-plugin-json": "4.0.0",
  	"rollup-plugin-node-globals": "1.4.0",
  	"rollup-plugin-node-resolve": "5.2.0",
  	"rollup-plugin-terser": "5.1.2",
  	shelljs: "0.8.3",
  	"snapshot-diff": "0.4.0",
  	"strip-ansi": "5.2.0",
  	"synchronous-promise": "2.0.10",
  	tempy: "0.2.1",
  	"terser-webpack-plugin": "2.2.1",
  	webpack: "4.41.2"
  };
  var scripts = {
  	prepublishOnly: "echo \"Error: must publish from dist/\" && exit 1",
  	"prepare-release": "yarn && yarn build && yarn test:dist",
  	test: "jest",
  	"test:dist": "node ./scripts/test-dist.js",
  	"test-integration": "jest tests_integration",
  	"perf-repeat": "yarn && yarn build && cross-env NODE_ENV=production node ./dist/bin-prettier.js --debug-repeat ${PERF_REPEAT:-1000} --loglevel debug ${PERF_FILE:-./index.js} > /dev/null",
  	"perf-repeat-inspect": "yarn && yarn build && cross-env NODE_ENV=production node --inspect-brk ./dist/bin-prettier.js --debug-repeat ${PERF_REPEAT:-1000} --loglevel debug ${PERF_FILE:-./index.js} > /dev/null",
  	"perf-benchmark": "yarn && yarn build && cross-env NODE_ENV=production node ./dist/bin-prettier.js --debug-benchmark --loglevel debug ${PERF_FILE:-./index.js} > /dev/null",
  	"check-types": "tsc",
  	lint: "cross-env EFF_NO_LINK_RULES=true eslint . --format friendly",
  	"lint-docs": "prettylint {.,docs,website,website/blog}/*.md",
  	"lint-dist": "eslint --no-eslintrc --no-ignore --env=browser \"dist/!(bin-prettier|index|third-party).js\"",
  	build: "node --max-old-space-size=3072 ./scripts/build/build.js",
  	"build-docs": "node ./scripts/build-docs.js",
  	"check-deps": "node ./scripts/check-deps.js",
  	spellcheck: "npx -p cspell@4.0.31 cspell {bin,scripts,src}/**/*.js {docs,website/blog,changelog_unreleased}/**/*.md"
  };
  var _package = {
  	name: name,
  	version: version,
  	description: description,
  	bin: bin,
  	repository: repository,
  	homepage: homepage,
  	author: author,
  	license: license,
  	main: main,
  	engines: engines,
  	dependencies: dependencies,
  	devDependencies: devDependencies,
  	scripts: scripts
  };

  var _package$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name,
    version: version,
    description: description,
    bin: bin,
    repository: repository,
    homepage: homepage,
    author: author,
    license: license,
    main: main,
    engines: engines,
    dependencies: dependencies,
    devDependencies: devDependencies,
    scripts: scripts,
    'default': _package
  });

  function _typeof(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof(obj);
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function");
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        writable: true,
        configurable: true
      }
    });
    if (superClass) _setPrototypeOf(subClass, superClass);
  }

  function _getPrototypeOf(o) {
    _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {
      return o.__proto__ || Object.getPrototypeOf(o);
    };
    return _getPrototypeOf(o);
  }

  function _setPrototypeOf(o, p) {
    _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {
      o.__proto__ = p;
      return o;
    };

    return _setPrototypeOf(o, p);
  }

  function isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;

    try {
      Date.prototype.toString.call(Reflect.construct(Date, [], function () {}));
      return true;
    } catch (e) {
      return false;
    }
  }

  function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
      _construct = Reflect.construct;
    } else {
      _construct = function _construct(Parent, args, Class) {
        var a = [null];
        a.push.apply(a, args);
        var Constructor = Function.bind.apply(Parent, a);
        var instance = new Constructor();
        if (Class) _setPrototypeOf(instance, Class.prototype);
        return instance;
      };
    }

    return _construct.apply(null, arguments);
  }

  function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
  }

  function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;

    _wrapNativeSuper = function _wrapNativeSuper(Class) {
      if (Class === null || !_isNativeFunction(Class)) return Class;

      if (typeof Class !== "function") {
        throw new TypeError("Super expression must either be null or a function");
      }

      if (typeof _cache !== "undefined") {
        if (_cache.has(Class)) return _cache.get(Class);

        _cache.set(Class, Wrapper);
      }

      function Wrapper() {
        return _construct(Class, arguments, _getPrototypeOf(this).constructor);
      }

      Wrapper.prototype = Object.create(Class.prototype, {
        constructor: {
          value: Wrapper,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
      return _setPrototypeOf(Wrapper, Class);
    };

    return _wrapNativeSuper(Class);
  }

  function _assertThisInitialized(self) {
    if (self === void 0) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return self;
  }

  function _possibleConstructorReturn(self, call) {
    if (call && (typeof call === "object" || typeof call === "function")) {
      return call;
    }

    return _assertThisInitialized(self);
  }

  function _superPropBase(object, property) {
    while (!Object.prototype.hasOwnProperty.call(object, property)) {
      object = _getPrototypeOf(object);
      if (object === null) break;
    }

    return object;
  }

  function _get(target, property, receiver) {
    if (typeof Reflect !== "undefined" && Reflect.get) {
      _get = Reflect.get;
    } else {
      _get = function _get(target, property, receiver) {
        var base = _superPropBase(target, property);

        if (!base) return;
        var desc = Object.getOwnPropertyDescriptor(base, property);

        if (desc.get) {
          return desc.get.call(receiver);
        }

        return desc.value;
      };
    }

    return _get(target, property, receiver || target);
  }

  function _taggedTemplateLiteral(strings, raw) {
    if (!raw) {
      raw = strings.slice(0);
    }

    return Object.freeze(Object.defineProperties(strings, {
      raw: {
        value: Object.freeze(raw)
      }
    }));
  }

  function _slicedToArray(arr, i) {
    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
  }

  function _toConsumableArray(arr) {
    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread();
  }

  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    }
  }

  function _arrayWithHoles(arr) {
    if (Array.isArray(arr)) return arr;
  }

  function _iterableToArray(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _iterableToArrayLimit(arr, i) {
    if (!(Symbol.iterator in Object(arr) || Object.prototype.toString.call(arr) === "[object Arguments]")) {
      return;
    }

    var _arr = [];
    var _n = true;
    var _d = false;
    var _e = undefined;

    try {
      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
        _arr.push(_s.value);

        if (i && _arr.length === i) break;
      }
    } catch (err) {
      _d = true;
      _e = err;
    } finally {
      try {
        if (!_n && _i["return"] != null) _i["return"]();
      } finally {
        if (_d) throw _e;
      }
    }

    return _arr;
  }

  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  function _nonIterableRest() {
    throw new TypeError("Invalid attempt to destructure non-iterable instance");
  }

  function Diff() {}

  Diff.prototype = {
    diff: function diff(oldString, newString) {
      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var callback = options.callback;

      if (typeof options === 'function') {
        callback = options;
        options = {};
      }

      this.options = options;
      var self = this;

      function done(value) {
        if (callback) {
          setTimeout(function () {
            callback(undefined, value);
          }, 0);
          return true;
        } else {
          return value;
        }
      } // Allow subclasses to massage the input prior to running


      oldString = this.castInput(oldString);
      newString = this.castInput(newString);
      oldString = this.removeEmpty(this.tokenize(oldString));
      newString = this.removeEmpty(this.tokenize(newString));
      var newLen = newString.length,
          oldLen = oldString.length;
      var editLength = 1;
      var maxEditLength = newLen + oldLen;
      var bestPath = [{
        newPos: -1,
        components: []
      }]; // Seed editLength = 0, i.e. the content starts with the same values

      var oldPos = this.extractCommon(bestPath[0], newString, oldString, 0);

      if (bestPath[0].newPos + 1 >= newLen && oldPos + 1 >= oldLen) {
        // Identity per the equality and tokenizer
        return done([{
          value: this.join(newString),
          count: newString.length
        }]);
      } // Main worker method. checks all permutations of a given edit length for acceptance.


      function execEditLength() {
        for (var diagonalPath = -1 * editLength; diagonalPath <= editLength; diagonalPath += 2) {
          var basePath = void 0;

          var addPath = bestPath[diagonalPath - 1],
              removePath = bestPath[diagonalPath + 1],
              _oldPos = (removePath ? removePath.newPos : 0) - diagonalPath;

          if (addPath) {
            // No one else is going to attempt to use this value, clear it
            bestPath[diagonalPath - 1] = undefined;
          }

          var canAdd = addPath && addPath.newPos + 1 < newLen,
              canRemove = removePath && 0 <= _oldPos && _oldPos < oldLen;

          if (!canAdd && !canRemove) {
            // If this path is a terminal then prune
            bestPath[diagonalPath] = undefined;
            continue;
          } // Select the diagonal that we want to branch from. We select the prior
          // path whose position in the new string is the farthest from the origin
          // and does not pass the bounds of the diff graph


          if (!canAdd || canRemove && addPath.newPos < removePath.newPos) {
            basePath = clonePath(removePath);
            self.pushComponent(basePath.components, undefined, true);
          } else {
            basePath = addPath; // No need to clone, we've pulled it from the list

            basePath.newPos++;
            self.pushComponent(basePath.components, true, undefined);
          }

          _oldPos = self.extractCommon(basePath, newString, oldString, diagonalPath); // If we have hit the end of both strings, then we are done

          if (basePath.newPos + 1 >= newLen && _oldPos + 1 >= oldLen) {
            return done(buildValues(self, basePath.components, newString, oldString, self.useLongestToken));
          } else {
            // Otherwise track this path as a potential candidate and continue.
            bestPath[diagonalPath] = basePath;
          }
        }

        editLength++;
      } // Performs the length of edit iteration. Is a bit fugly as this has to support the
      // sync and async mode which is never fun. Loops over execEditLength until a value
      // is produced.


      if (callback) {
        (function exec() {
          setTimeout(function () {
            // This should not happen, but we want to be safe.

            /* istanbul ignore next */
            if (editLength > maxEditLength) {
              return callback();
            }

            if (!execEditLength()) {
              exec();
            }
          }, 0);
        })();
      } else {
        while (editLength <= maxEditLength) {
          var ret = execEditLength();

          if (ret) {
            return ret;
          }
        }
      }
    },
    pushComponent: function pushComponent(components, added, removed) {
      var last = components[components.length - 1];

      if (last && last.added === added && last.removed === removed) {
        // We need to clone here as the component clone operation is just
        // as shallow array clone
        components[components.length - 1] = {
          count: last.count + 1,
          added: added,
          removed: removed
        };
      } else {
        components.push({
          count: 1,
          added: added,
          removed: removed
        });
      }
    },
    extractCommon: function extractCommon(basePath, newString, oldString, diagonalPath) {
      var newLen = newString.length,
          oldLen = oldString.length,
          newPos = basePath.newPos,
          oldPos = newPos - diagonalPath,
          commonCount = 0;

      while (newPos + 1 < newLen && oldPos + 1 < oldLen && this.equals(newString[newPos + 1], oldString[oldPos + 1])) {
        newPos++;
        oldPos++;
        commonCount++;
      }

      if (commonCount) {
        basePath.components.push({
          count: commonCount
        });
      }

      basePath.newPos = newPos;
      return oldPos;
    },
    equals: function equals(left, right) {
      if (this.options.comparator) {
        return this.options.comparator(left, right);
      } else {
        return left === right || this.options.ignoreCase && left.toLowerCase() === right.toLowerCase();
      }
    },
    removeEmpty: function removeEmpty(array) {
      var ret = [];

      for (var i = 0; i < array.length; i++) {
        if (array[i]) {
          ret.push(array[i]);
        }
      }

      return ret;
    },
    castInput: function castInput(value) {
      return value;
    },
    tokenize: function tokenize(value) {
      return value.split('');
    },
    join: function join(chars) {
      return chars.join('');
    }
  };

  function buildValues(diff, components, newString, oldString, useLongestToken) {
    var componentPos = 0,
        componentLen = components.length,
        newPos = 0,
        oldPos = 0;

    for (; componentPos < componentLen; componentPos++) {
      var component = components[componentPos];

      if (!component.removed) {
        if (!component.added && useLongestToken) {
          var value = newString.slice(newPos, newPos + component.count);
          value = value.map(function (value, i) {
            var oldValue = oldString[oldPos + i];
            return oldValue.length > value.length ? oldValue : value;
          });
          component.value = diff.join(value);
        } else {
          component.value = diff.join(newString.slice(newPos, newPos + component.count));
        }

        newPos += component.count; // Common case

        if (!component.added) {
          oldPos += component.count;
        }
      } else {
        component.value = diff.join(oldString.slice(oldPos, oldPos + component.count));
        oldPos += component.count; // Reverse add and remove so removes are output first to match common convention
        // The diffing algorithm is tied to add then remove output and this is the simplest
        // route to get the desired output with minimal overhead.

        if (componentPos && components[componentPos - 1].added) {
          var tmp = components[componentPos - 1];
          components[componentPos - 1] = components[componentPos];
          components[componentPos] = tmp;
        }
      }
    } // Special case handle for when one terminal is ignored (i.e. whitespace).
    // For this case we merge the terminal into the prior string and drop the change.
    // This is only available for string mode.


    var lastComponent = components[componentLen - 1];

    if (componentLen > 1 && typeof lastComponent.value === 'string' && (lastComponent.added || lastComponent.removed) && diff.equals('', lastComponent.value)) {
      components[componentLen - 2].value += lastComponent.value;
      components.pop();
    }

    return components;
  }

  function clonePath(path) {
    return {
      newPos: path.newPos,
      components: path.components.slice(0)
    };
  }

  var characterDiff = new Diff();

  function diffChars(oldStr, newStr, options) {
    return characterDiff.diff(oldStr, newStr, options);
  }

  function generateOptions(options, defaults) {
    if (typeof options === 'function') {
      defaults.callback = options;
    } else if (options) {
      for (var name in options) {
        /* istanbul ignore else */
        if (options.hasOwnProperty(name)) {
          defaults[name] = options[name];
        }
      }
    }

    return defaults;
  } //
  // Ranges and exceptions:
  // Latin-1 Supplement, 008000FF
  //  - U+00D7   Multiplication sign
  //  - U+00F7   Division sign
  // Latin Extended-A, 0100017F
  // Latin Extended-B, 0180024F
  // IPA Extensions, 025002AF
  // Spacing Modifier Letters, 02B002FF
  //  - U+02C7   &#711;  Caron
  //  - U+02D8   &#728;  Breve
  //  - U+02D9   &#729;  Dot Above
  //  - U+02DA   &#730;  Ring Above
  //  - U+02DB   &#731;  Ogonek
  //  - U+02DC   &#732;  Small Tilde
  //  - U+02DD   &#733;  Double Acute Accent
  // Latin Extended Additional, 1E001EFF


  var extendedWordChars = /^[A-Za-z\xC0-\u02C6\u02C8-\u02D7\u02DE-\u02FF\u1E00-\u1EFF]+$/;
  var reWhitespace = /\S/;
  var wordDiff = new Diff();

  wordDiff.equals = function (left, right) {
    if (this.options.ignoreCase) {
      left = left.toLowerCase();
      right = right.toLowerCase();
    }

    return left === right || this.options.ignoreWhitespace && !reWhitespace.test(left) && !reWhitespace.test(right);
  };

  wordDiff.tokenize = function (value) {
    var tokens = value.split(/(\s+|[()[\]{}'"]|\b)/); // Join the boundary splits that we do not consider to be boundaries. This is primarily the extended Latin character set.

    for (var i = 0; i < tokens.length - 1; i++) {
      // If we have an empty string in the next field and we have only word chars before and after, merge
      if (!tokens[i + 1] && tokens[i + 2] && extendedWordChars.test(tokens[i]) && extendedWordChars.test(tokens[i + 2])) {
        tokens[i] += tokens[i + 2];
        tokens.splice(i + 1, 2);
        i--;
      }
    }

    return tokens;
  };

  function diffWords(oldStr, newStr, options) {
    options = generateOptions(options, {
      ignoreWhitespace: true
    });
    return wordDiff.diff(oldStr, newStr, options);
  }

  function diffWordsWithSpace(oldStr, newStr, options) {
    return wordDiff.diff(oldStr, newStr, options);
  }

  var lineDiff = new Diff();

  lineDiff.tokenize = function (value) {
    var retLines = [],
        linesAndNewlines = value.split(/(\n|\r\n)/); // Ignore the final empty token that occurs if the string ends with a new line

    if (!linesAndNewlines[linesAndNewlines.length - 1]) {
      linesAndNewlines.pop();
    } // Merge the content and line separators into single tokens


    for (var i = 0; i < linesAndNewlines.length; i++) {
      var line = linesAndNewlines[i];

      if (i % 2 && !this.options.newlineIsToken) {
        retLines[retLines.length - 1] += line;
      } else {
        if (this.options.ignoreWhitespace) {
          line = line.trim();
        }

        retLines.push(line);
      }
    }

    return retLines;
  };

  function diffLines(oldStr, newStr, callback) {
    return lineDiff.diff(oldStr, newStr, callback);
  }

  function diffTrimmedLines(oldStr, newStr, callback) {
    var options = generateOptions(callback, {
      ignoreWhitespace: true
    });
    return lineDiff.diff(oldStr, newStr, options);
  }

  var sentenceDiff = new Diff();

  sentenceDiff.tokenize = function (value) {
    return value.split(/(\S.+?[.!?])(?=\s+|$)/);
  };

  function diffSentences(oldStr, newStr, callback) {
    return sentenceDiff.diff(oldStr, newStr, callback);
  }

  var cssDiff = new Diff();

  cssDiff.tokenize = function (value) {
    return value.split(/([{}:;,]|\s+)/);
  };

  function diffCss(oldStr, newStr, callback) {
    return cssDiff.diff(oldStr, newStr, callback);
  }

  function _typeof$1(obj) {
    if (typeof Symbol === "function" && _typeof(Symbol.iterator) === "symbol") {
      _typeof$1 = function _typeof$1(obj) {
        return _typeof(obj);
      };
    } else {
      _typeof$1 = function _typeof$1(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : _typeof(obj);
      };
    }

    return _typeof$1(obj);
  }

  function _toConsumableArray$1(arr) {
    return _arrayWithoutHoles$1(arr) || _iterableToArray$1(arr) || _nonIterableSpread$1();
  }

  function _arrayWithoutHoles$1(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    }
  }

  function _iterableToArray$1(iter) {
    if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === "[object Arguments]") return Array.from(iter);
  }

  function _nonIterableSpread$1() {
    throw new TypeError("Invalid attempt to spread non-iterable instance");
  }

  var objectPrototypeToString = Object.prototype.toString;
  var jsonDiff = new Diff(); // Discriminate between two lines of pretty-printed, serialized JSON where one of them has a
  // dangling comma and the other doesn't. Turns out including the dangling comma yields the nicest output:

  jsonDiff.useLongestToken = true;
  jsonDiff.tokenize = lineDiff.tokenize;

  jsonDiff.castInput = function (value) {
    var _this$options = this.options,
        undefinedReplacement = _this$options.undefinedReplacement,
        _this$options$stringi = _this$options.stringifyReplacer,
        stringifyReplacer = _this$options$stringi === void 0 ? function (k, v) {
      return typeof v === 'undefined' ? undefinedReplacement : v;
    } : _this$options$stringi;
    return typeof value === 'string' ? value : JSON.stringify(canonicalize(value, null, null, stringifyReplacer), stringifyReplacer, '  ');
  };

  jsonDiff.equals = function (left, right) {
    return Diff.prototype.equals.call(jsonDiff, left.replace(/,([\r\n])/g, '$1'), right.replace(/,([\r\n])/g, '$1'));
  };

  function diffJson(oldObj, newObj, options) {
    return jsonDiff.diff(oldObj, newObj, options);
  } // This function handles the presence of circular references by bailing out when encountering an
  // object that is already on the "stack" of items being processed. Accepts an optional replacer


  function canonicalize(obj, stack, replacementStack, replacer, key) {
    stack = stack || [];
    replacementStack = replacementStack || [];

    if (replacer) {
      obj = replacer(key, obj);
    }

    var i;

    for (i = 0; i < stack.length; i += 1) {
      if (stack[i] === obj) {
        return replacementStack[i];
      }
    }

    var canonicalizedObj;

    if ('[object Array]' === objectPrototypeToString.call(obj)) {
      stack.push(obj);
      canonicalizedObj = new Array(obj.length);
      replacementStack.push(canonicalizedObj);

      for (i = 0; i < obj.length; i += 1) {
        canonicalizedObj[i] = canonicalize(obj[i], stack, replacementStack, replacer, key);
      }

      stack.pop();
      replacementStack.pop();
      return canonicalizedObj;
    }

    if (obj && obj.toJSON) {
      obj = obj.toJSON();
    }

    if (_typeof$1(obj) === 'object' && obj !== null) {
      stack.push(obj);
      canonicalizedObj = {};
      replacementStack.push(canonicalizedObj);

      var sortedKeys = [],
          _key;

      for (_key in obj) {
        /* istanbul ignore else */
        if (obj.hasOwnProperty(_key)) {
          sortedKeys.push(_key);
        }
      }

      sortedKeys.sort();

      for (i = 0; i < sortedKeys.length; i += 1) {
        _key = sortedKeys[i];
        canonicalizedObj[_key] = canonicalize(obj[_key], stack, replacementStack, replacer, _key);
      }

      stack.pop();
      replacementStack.pop();
    } else {
      canonicalizedObj = obj;
    }

    return canonicalizedObj;
  }

  var arrayDiff = new Diff();

  arrayDiff.tokenize = function (value) {
    return value.slice();
  };

  arrayDiff.join = arrayDiff.removeEmpty = function (value) {
    return value;
  };

  function diffArrays(oldArr, newArr, callback) {
    return arrayDiff.diff(oldArr, newArr, callback);
  }

  function parsePatch(uniDiff) {
    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
    var diffstr = uniDiff.split(/\r\n|[\n\v\f\r\x85]/),
        delimiters = uniDiff.match(/\r\n|[\n\v\f\r\x85]/g) || [],
        list = [],
        i = 0;

    function parseIndex() {
      var index = {};
      list.push(index); // Parse diff metadata

      while (i < diffstr.length) {
        var line = diffstr[i]; // File header found, end parsing diff metadata

        if (/^(\-\-\-|\+\+\+|@@)\s/.test(line)) {
          break;
        } // Diff index


        var header = /^(?:Index:|diff(?: -r \w+)+)\s+(.+?)\s*$/.exec(line);

        if (header) {
          index.index = header[1];
        }

        i++;
      } // Parse file headers if they are defined. Unified diff requires them, but
      // there's no technical issues to have an isolated hunk without file header


      parseFileHeader(index);
      parseFileHeader(index); // Parse hunks

      index.hunks = [];

      while (i < diffstr.length) {
        var _line = diffstr[i];

        if (/^(Index:|diff|\-\-\-|\+\+\+)\s/.test(_line)) {
          break;
        } else if (/^@@/.test(_line)) {
          index.hunks.push(parseHunk());
        } else if (_line && options.strict) {
          // Ignore unexpected content unless in strict mode
          throw new Error('Unknown line ' + (i + 1) + ' ' + JSON.stringify(_line));
        } else {
          i++;
        }
      }
    } // Parses the --- and +++ headers, if none are found, no lines
    // are consumed.


    function parseFileHeader(index) {
      var fileHeader = /^(---|\+\+\+)\s+(.*)$/.exec(diffstr[i]);

      if (fileHeader) {
        var keyPrefix = fileHeader[1] === '---' ? 'old' : 'new';
        var data = fileHeader[2].split('\t', 2);
        var fileName = data[0].replace(/\\\\/g, '\\');

        if (/^".*"$/.test(fileName)) {
          fileName = fileName.substr(1, fileName.length - 2);
        }

        index[keyPrefix + 'FileName'] = fileName;
        index[keyPrefix + 'Header'] = (data[1] || '').trim();
        i++;
      }
    } // Parses a hunk
    // This assumes that we are at the start of a hunk.


    function parseHunk() {
      var chunkHeaderIndex = i,
          chunkHeaderLine = diffstr[i++],
          chunkHeader = chunkHeaderLine.split(/@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@/);
      var hunk = {
        oldStart: +chunkHeader[1],
        oldLines: +chunkHeader[2] || 1,
        newStart: +chunkHeader[3],
        newLines: +chunkHeader[4] || 1,
        lines: [],
        linedelimiters: []
      };
      var addCount = 0,
          removeCount = 0;

      for (; i < diffstr.length; i++) {
        // Lines starting with '---' could be mistaken for the "remove line" operation
        // But they could be the header for the next file. Therefore prune such cases out.
        if (diffstr[i].indexOf('--- ') === 0 && i + 2 < diffstr.length && diffstr[i + 1].indexOf('+++ ') === 0 && diffstr[i + 2].indexOf('@@') === 0) {
          break;
        }

        var operation = diffstr[i].length == 0 && i != diffstr.length - 1 ? ' ' : diffstr[i][0];

        if (operation === '+' || operation === '-' || operation === ' ' || operation === '\\') {
          hunk.lines.push(diffstr[i]);
          hunk.linedelimiters.push(delimiters[i] || '\n');

          if (operation === '+') {
            addCount++;
          } else if (operation === '-') {
            removeCount++;
          } else if (operation === ' ') {
            addCount++;
            removeCount++;
          }
        } else {
          break;
        }
      } // Handle the empty block count case


      if (!addCount && hunk.newLines === 1) {
        hunk.newLines = 0;
      }

      if (!removeCount && hunk.oldLines === 1) {
        hunk.oldLines = 0;
      } // Perform optional sanity checking


      if (options.strict) {
        if (addCount !== hunk.newLines) {
          throw new Error('Added line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
        }

        if (removeCount !== hunk.oldLines) {
          throw new Error('Removed line count did not match for hunk at line ' + (chunkHeaderIndex + 1));
        }
      }

      return hunk;
    }

    while (i < diffstr.length) {
      parseIndex();
    }

    return list;
  } // Iterator that traverses in the range of [min, max], stepping
  // by distance from a given start position. I.e. for [0, 4], with
  // start of 2, this will iterate 2, 3, 1, 4, 0.


  function distanceIterator(start, minLine, maxLine) {
    var wantForward = true,
        backwardExhausted = false,
        forwardExhausted = false,
        localOffset = 1;
    return function iterator() {
      if (wantForward && !forwardExhausted) {
        if (backwardExhausted) {
          localOffset++;
        } else {
          wantForward = false;
        } // Check if trying to fit beyond text length, and if not, check it fits
        // after offset location (or desired location on first iteration)


        if (start + localOffset <= maxLine) {
          return localOffset;
        }

        forwardExhausted = true;
      }

      if (!backwardExhausted) {
        if (!forwardExhausted) {
          wantForward = true;
        } // Check if trying to fit before text beginning, and if not, check it fits
        // before offset location


        if (minLine <= start - localOffset) {
          return -localOffset++;
        }

        backwardExhausted = true;
        return iterator();
      } // We tried to fit hunk before text beginning and beyond text length, then
      // hunk can't fit on the text. Return undefined

    };
  }

  function applyPatch(source, uniDiff) {
    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

    if (typeof uniDiff === 'string') {
      uniDiff = parsePatch(uniDiff);
    }

    if (Array.isArray(uniDiff)) {
      if (uniDiff.length > 1) {
        throw new Error('applyPatch only works with a single input.');
      }

      uniDiff = uniDiff[0];
    } // Apply the diff to the input


    var lines = source.split(/\r\n|[\n\v\f\r\x85]/),
        delimiters = source.match(/\r\n|[\n\v\f\r\x85]/g) || [],
        hunks = uniDiff.hunks,
        compareLine = options.compareLine || function (lineNumber, line, operation, patchContent) {
      return line === patchContent;
    },
        errorCount = 0,
        fuzzFactor = options.fuzzFactor || 0,
        minLine = 0,
        offset = 0,
        removeEOFNL,
        addEOFNL;
    /**
     * Checks if the hunk exactly fits on the provided location
     */


    function hunkFits(hunk, toPos) {
      for (var j = 0; j < hunk.lines.length; j++) {
        var line = hunk.lines[j],
            operation = line.length > 0 ? line[0] : ' ',
            content = line.length > 0 ? line.substr(1) : line;

        if (operation === ' ' || operation === '-') {
          // Context sanity check
          if (!compareLine(toPos + 1, lines[toPos], operation, content)) {
            errorCount++;

            if (errorCount > fuzzFactor) {
              return false;
            }
          }

          toPos++;
        }
      }

      return true;
    } // Search best fit offsets for each hunk based on the previous ones


    for (var i = 0; i < hunks.length; i++) {
      var hunk = hunks[i],
          maxLine = lines.length - hunk.oldLines,
          localOffset = 0,
          toPos = offset + hunk.oldStart - 1;
      var iterator = distanceIterator(toPos, minLine, maxLine);

      for (; localOffset !== undefined; localOffset = iterator()) {
        if (hunkFits(hunk, toPos + localOffset)) {
          hunk.offset = offset += localOffset;
          break;
        }
      }

      if (localOffset === undefined) {
        return false;
      } // Set lower text limit to end of the current hunk, so next ones don't try
      // to fit over already patched text


      minLine = hunk.offset + hunk.oldStart + hunk.oldLines;
    } // Apply patch hunks


    var diffOffset = 0;

    for (var _i = 0; _i < hunks.length; _i++) {
      var _hunk = hunks[_i],
          _toPos = _hunk.oldStart + _hunk.offset + diffOffset - 1;

      diffOffset += _hunk.newLines - _hunk.oldLines;

      if (_toPos < 0) {
        // Creating a new file
        _toPos = 0;
      }

      for (var j = 0; j < _hunk.lines.length; j++) {
        var line = _hunk.lines[j],
            operation = line.length > 0 ? line[0] : ' ',
            content = line.length > 0 ? line.substr(1) : line,
            delimiter = _hunk.linedelimiters[j];

        if (operation === ' ') {
          _toPos++;
        } else if (operation === '-') {
          lines.splice(_toPos, 1);
          delimiters.splice(_toPos, 1);
          /* istanbul ignore else */
        } else if (operation === '+') {
          lines.splice(_toPos, 0, content);
          delimiters.splice(_toPos, 0, delimiter);
          _toPos++;
        } else if (operation === '\\') {
          var previousOperation = _hunk.lines[j - 1] ? _hunk.lines[j - 1][0] : null;

          if (previousOperation === '+') {
            removeEOFNL = true;
          } else if (previousOperation === '-') {
            addEOFNL = true;
          }
        }
      }
    } // Handle EOFNL insertion/removal


    if (removeEOFNL) {
      while (!lines[lines.length - 1]) {
        lines.pop();
        delimiters.pop();
      }
    } else if (addEOFNL) {
      lines.push('');
      delimiters.push('\n');
    }

    for (var _k = 0; _k < lines.length - 1; _k++) {
      lines[_k] = lines[_k] + delimiters[_k];
    }

    return lines.join('');
  } // Wrapper that supports multiple file patches via callbacks.


  function applyPatches(uniDiff, options) {
    if (typeof uniDiff === 'string') {
      uniDiff = parsePatch(uniDiff);
    }

    var currentIndex = 0;

    function processIndex() {
      var index = uniDiff[currentIndex++];

      if (!index) {
        return options.complete();
      }

      options.loadFile(index, function (err, data) {
        if (err) {
          return options.complete(err);
        }

        var updatedContent = applyPatch(data, index, options);
        options.patched(index, updatedContent, function (err) {
          if (err) {
            return options.complete(err);
          }

          processIndex();
        });
      });
    }

    processIndex();
  }

  function structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
    if (!options) {
      options = {};
    }

    if (typeof options.context === 'undefined') {
      options.context = 4;
    }

    var diff = diffLines(oldStr, newStr, options);
    diff.push({
      value: '',
      lines: []
    }); // Append an empty value to make cleanup easier

    function contextLines(lines) {
      return lines.map(function (entry) {
        return ' ' + entry;
      });
    }

    var hunks = [];
    var oldRangeStart = 0,
        newRangeStart = 0,
        curRange = [],
        oldLine = 1,
        newLine = 1;

    var _loop = function _loop(i) {
      var current = diff[i],
          lines = current.lines || current.value.replace(/\n$/, '').split('\n');
      current.lines = lines;

      if (current.added || current.removed) {
        var _curRange; // If we have previous context, start with that


        if (!oldRangeStart) {
          var prev = diff[i - 1];
          oldRangeStart = oldLine;
          newRangeStart = newLine;

          if (prev) {
            curRange = options.context > 0 ? contextLines(prev.lines.slice(-options.context)) : [];
            oldRangeStart -= curRange.length;
            newRangeStart -= curRange.length;
          }
        } // Output our changes


        (_curRange = curRange).push.apply(_curRange, _toConsumableArray$1(lines.map(function (entry) {
          return (current.added ? '+' : '-') + entry;
        }))); // Track the updated file position


        if (current.added) {
          newLine += lines.length;
        } else {
          oldLine += lines.length;
        }
      } else {
        // Identical context lines. Track line changes
        if (oldRangeStart) {
          // Close out any changes that have been output (or join overlapping)
          if (lines.length <= options.context * 2 && i < diff.length - 2) {
            var _curRange2; // Overlapping


            (_curRange2 = curRange).push.apply(_curRange2, _toConsumableArray$1(contextLines(lines)));
          } else {
            var _curRange3; // end the range and output


            var contextSize = Math.min(lines.length, options.context);

            (_curRange3 = curRange).push.apply(_curRange3, _toConsumableArray$1(contextLines(lines.slice(0, contextSize))));

            var hunk = {
              oldStart: oldRangeStart,
              oldLines: oldLine - oldRangeStart + contextSize,
              newStart: newRangeStart,
              newLines: newLine - newRangeStart + contextSize,
              lines: curRange
            };

            if (i >= diff.length - 2 && lines.length <= options.context) {
              // EOF is inside this hunk
              var oldEOFNewline = /\n$/.test(oldStr);
              var newEOFNewline = /\n$/.test(newStr);
              var noNlBeforeAdds = lines.length == 0 && curRange.length > hunk.oldLines;

              if (!oldEOFNewline && noNlBeforeAdds) {
                // special case: old has no eol and no trailing context; no-nl can end up before adds
                curRange.splice(hunk.oldLines, 0, '\\ No newline at end of file');
              }

              if (!oldEOFNewline && !noNlBeforeAdds || !newEOFNewline) {
                curRange.push('\\ No newline at end of file');
              }
            }

            hunks.push(hunk);
            oldRangeStart = 0;
            newRangeStart = 0;
            curRange = [];
          }
        }

        oldLine += lines.length;
        newLine += lines.length;
      }
    };

    for (var i = 0; i < diff.length; i++) {
      _loop(i);
    }

    return {
      oldFileName: oldFileName,
      newFileName: newFileName,
      oldHeader: oldHeader,
      newHeader: newHeader,
      hunks: hunks
    };
  }

  function createTwoFilesPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options) {
    var diff = structuredPatch(oldFileName, newFileName, oldStr, newStr, oldHeader, newHeader, options);
    var ret = [];

    if (oldFileName == newFileName) {
      ret.push('Index: ' + oldFileName);
    }

    ret.push('===================================================================');
    ret.push('--- ' + diff.oldFileName + (typeof diff.oldHeader === 'undefined' ? '' : '\t' + diff.oldHeader));
    ret.push('+++ ' + diff.newFileName + (typeof diff.newHeader === 'undefined' ? '' : '\t' + diff.newHeader));

    for (var i = 0; i < diff.hunks.length; i++) {
      var hunk = diff.hunks[i];
      ret.push('@@ -' + hunk.oldStart + ',' + hunk.oldLines + ' +' + hunk.newStart + ',' + hunk.newLines + ' @@');
      ret.push.apply(ret, hunk.lines);
    }

    return ret.join('\n') + '\n';
  }

  function createPatch(fileName, oldStr, newStr, oldHeader, newHeader, options) {
    return createTwoFilesPatch(fileName, fileName, oldStr, newStr, oldHeader, newHeader, options);
  }

  function arrayEqual(a, b) {
    if (a.length !== b.length) {
      return false;
    }

    return arrayStartsWith(a, b);
  }

  function arrayStartsWith(array, start) {
    if (start.length > array.length) {
      return false;
    }

    for (var i = 0; i < start.length; i++) {
      if (start[i] !== array[i]) {
        return false;
      }
    }

    return true;
  }

  function calcLineCount(hunk) {
    var _calcOldNewLineCount = calcOldNewLineCount(hunk.lines),
        oldLines = _calcOldNewLineCount.oldLines,
        newLines = _calcOldNewLineCount.newLines;

    if (oldLines !== undefined) {
      hunk.oldLines = oldLines;
    } else {
      delete hunk.oldLines;
    }

    if (newLines !== undefined) {
      hunk.newLines = newLines;
    } else {
      delete hunk.newLines;
    }
  }

  function merge(mine, theirs, base) {
    mine = loadPatch(mine, base);
    theirs = loadPatch(theirs, base);
    var ret = {}; // For index we just let it pass through as it doesn't have any necessary meaning.
    // Leaving sanity checks on this to the API consumer that may know more about the
    // meaning in their own context.

    if (mine.index || theirs.index) {
      ret.index = mine.index || theirs.index;
    }

    if (mine.newFileName || theirs.newFileName) {
      if (!fileNameChanged(mine)) {
        // No header or no change in ours, use theirs (and ours if theirs does not exist)
        ret.oldFileName = theirs.oldFileName || mine.oldFileName;
        ret.newFileName = theirs.newFileName || mine.newFileName;
        ret.oldHeader = theirs.oldHeader || mine.oldHeader;
        ret.newHeader = theirs.newHeader || mine.newHeader;
      } else if (!fileNameChanged(theirs)) {
        // No header or no change in theirs, use ours
        ret.oldFileName = mine.oldFileName;
        ret.newFileName = mine.newFileName;
        ret.oldHeader = mine.oldHeader;
        ret.newHeader = mine.newHeader;
      } else {
        // Both changed... figure it out
        ret.oldFileName = selectField(ret, mine.oldFileName, theirs.oldFileName);
        ret.newFileName = selectField(ret, mine.newFileName, theirs.newFileName);
        ret.oldHeader = selectField(ret, mine.oldHeader, theirs.oldHeader);
        ret.newHeader = selectField(ret, mine.newHeader, theirs.newHeader);
      }
    }

    ret.hunks = [];
    var mineIndex = 0,
        theirsIndex = 0,
        mineOffset = 0,
        theirsOffset = 0;

    while (mineIndex < mine.hunks.length || theirsIndex < theirs.hunks.length) {
      var mineCurrent = mine.hunks[mineIndex] || {
        oldStart: Infinity
      },
          theirsCurrent = theirs.hunks[theirsIndex] || {
        oldStart: Infinity
      };

      if (hunkBefore(mineCurrent, theirsCurrent)) {
        // This patch does not overlap with any of the others, yay.
        ret.hunks.push(cloneHunk(mineCurrent, mineOffset));
        mineIndex++;
        theirsOffset += mineCurrent.newLines - mineCurrent.oldLines;
      } else if (hunkBefore(theirsCurrent, mineCurrent)) {
        // This patch does not overlap with any of the others, yay.
        ret.hunks.push(cloneHunk(theirsCurrent, theirsOffset));
        theirsIndex++;
        mineOffset += theirsCurrent.newLines - theirsCurrent.oldLines;
      } else {
        // Overlap, merge as best we can
        var mergedHunk = {
          oldStart: Math.min(mineCurrent.oldStart, theirsCurrent.oldStart),
          oldLines: 0,
          newStart: Math.min(mineCurrent.newStart + mineOffset, theirsCurrent.oldStart + theirsOffset),
          newLines: 0,
          lines: []
        };
        mergeLines(mergedHunk, mineCurrent.oldStart, mineCurrent.lines, theirsCurrent.oldStart, theirsCurrent.lines);
        theirsIndex++;
        mineIndex++;
        ret.hunks.push(mergedHunk);
      }
    }

    return ret;
  }

  function loadPatch(param, base) {
    if (typeof param === 'string') {
      if (/^@@/m.test(param) || /^Index:/m.test(param)) {
        return parsePatch(param)[0];
      }

      if (!base) {
        throw new Error('Must provide a base reference or pass in a patch');
      }

      return structuredPatch(undefined, undefined, base, param);
    }

    return param;
  }

  function fileNameChanged(patch) {
    return patch.newFileName && patch.newFileName !== patch.oldFileName;
  }

  function selectField(index, mine, theirs) {
    if (mine === theirs) {
      return mine;
    } else {
      index.conflict = true;
      return {
        mine: mine,
        theirs: theirs
      };
    }
  }

  function hunkBefore(test, check) {
    return test.oldStart < check.oldStart && test.oldStart + test.oldLines < check.oldStart;
  }

  function cloneHunk(hunk, offset) {
    return {
      oldStart: hunk.oldStart,
      oldLines: hunk.oldLines,
      newStart: hunk.newStart + offset,
      newLines: hunk.newLines,
      lines: hunk.lines
    };
  }

  function mergeLines(hunk, mineOffset, mineLines, theirOffset, theirLines) {
    // This will generally result in a conflicted hunk, but there are cases where the context
    // is the only overlap where we can successfully merge the content here.
    var mine = {
      offset: mineOffset,
      lines: mineLines,
      index: 0
    },
        their = {
      offset: theirOffset,
      lines: theirLines,
      index: 0
    }; // Handle any leading content

    insertLeading(hunk, mine, their);
    insertLeading(hunk, their, mine); // Now in the overlap content. Scan through and select the best changes from each.

    while (mine.index < mine.lines.length && their.index < their.lines.length) {
      var mineCurrent = mine.lines[mine.index],
          theirCurrent = their.lines[their.index];

      if ((mineCurrent[0] === '-' || mineCurrent[0] === '+') && (theirCurrent[0] === '-' || theirCurrent[0] === '+')) {
        // Both modified ...
        mutualChange(hunk, mine, their);
      } else if (mineCurrent[0] === '+' && theirCurrent[0] === ' ') {
        var _hunk$lines; // Mine inserted


        (_hunk$lines = hunk.lines).push.apply(_hunk$lines, _toConsumableArray$1(collectChange(mine)));
      } else if (theirCurrent[0] === '+' && mineCurrent[0] === ' ') {
        var _hunk$lines2; // Theirs inserted


        (_hunk$lines2 = hunk.lines).push.apply(_hunk$lines2, _toConsumableArray$1(collectChange(their)));
      } else if (mineCurrent[0] === '-' && theirCurrent[0] === ' ') {
        // Mine removed or edited
        removal(hunk, mine, their);
      } else if (theirCurrent[0] === '-' && mineCurrent[0] === ' ') {
        // Their removed or edited
        removal(hunk, their, mine, true);
      } else if (mineCurrent === theirCurrent) {
        // Context identity
        hunk.lines.push(mineCurrent);
        mine.index++;
        their.index++;
      } else {
        // Context mismatch
        conflict(hunk, collectChange(mine), collectChange(their));
      }
    } // Now push anything that may be remaining


    insertTrailing(hunk, mine);
    insertTrailing(hunk, their);
    calcLineCount(hunk);
  }

  function mutualChange(hunk, mine, their) {
    var myChanges = collectChange(mine),
        theirChanges = collectChange(their);

    if (allRemoves(myChanges) && allRemoves(theirChanges)) {
      // Special case for remove changes that are supersets of one another
      if (arrayStartsWith(myChanges, theirChanges) && skipRemoveSuperset(their, myChanges, myChanges.length - theirChanges.length)) {
        var _hunk$lines3;

        (_hunk$lines3 = hunk.lines).push.apply(_hunk$lines3, _toConsumableArray$1(myChanges));

        return;
      } else if (arrayStartsWith(theirChanges, myChanges) && skipRemoveSuperset(mine, theirChanges, theirChanges.length - myChanges.length)) {
        var _hunk$lines4;

        (_hunk$lines4 = hunk.lines).push.apply(_hunk$lines4, _toConsumableArray$1(theirChanges));

        return;
      }
    } else if (arrayEqual(myChanges, theirChanges)) {
      var _hunk$lines5;

      (_hunk$lines5 = hunk.lines).push.apply(_hunk$lines5, _toConsumableArray$1(myChanges));

      return;
    }

    conflict(hunk, myChanges, theirChanges);
  }

  function removal(hunk, mine, their, swap) {
    var myChanges = collectChange(mine),
        theirChanges = collectContext(their, myChanges);

    if (theirChanges.merged) {
      var _hunk$lines6;

      (_hunk$lines6 = hunk.lines).push.apply(_hunk$lines6, _toConsumableArray$1(theirChanges.merged));
    } else {
      conflict(hunk, swap ? theirChanges : myChanges, swap ? myChanges : theirChanges);
    }
  }

  function conflict(hunk, mine, their) {
    hunk.conflict = true;
    hunk.lines.push({
      conflict: true,
      mine: mine,
      theirs: their
    });
  }

  function insertLeading(hunk, insert, their) {
    while (insert.offset < their.offset && insert.index < insert.lines.length) {
      var line = insert.lines[insert.index++];
      hunk.lines.push(line);
      insert.offset++;
    }
  }

  function insertTrailing(hunk, insert) {
    while (insert.index < insert.lines.length) {
      var line = insert.lines[insert.index++];
      hunk.lines.push(line);
    }
  }

  function collectChange(state) {
    var ret = [],
        operation = state.lines[state.index][0];

    while (state.index < state.lines.length) {
      var line = state.lines[state.index]; // Group additions that are immediately after subtractions and treat them as one "atomic" modify change.

      if (operation === '-' && line[0] === '+') {
        operation = '+';
      }

      if (operation === line[0]) {
        ret.push(line);
        state.index++;
      } else {
        break;
      }
    }

    return ret;
  }

  function collectContext(state, matchChanges) {
    var changes = [],
        merged = [],
        matchIndex = 0,
        contextChanges = false,
        conflicted = false;

    while (matchIndex < matchChanges.length && state.index < state.lines.length) {
      var change = state.lines[state.index],
          match = matchChanges[matchIndex]; // Once we've hit our add, then we are done

      if (match[0] === '+') {
        break;
      }

      contextChanges = contextChanges || change[0] !== ' ';
      merged.push(match);
      matchIndex++; // Consume any additions in the other block as a conflict to attempt
      // to pull in the remaining context after this

      if (change[0] === '+') {
        conflicted = true;

        while (change[0] === '+') {
          changes.push(change);
          change = state.lines[++state.index];
        }
      }

      if (match.substr(1) === change.substr(1)) {
        changes.push(change);
        state.index++;
      } else {
        conflicted = true;
      }
    }

    if ((matchChanges[matchIndex] || '')[0] === '+' && contextChanges) {
      conflicted = true;
    }

    if (conflicted) {
      return changes;
    }

    while (matchIndex < matchChanges.length) {
      merged.push(matchChanges[matchIndex++]);
    }

    return {
      merged: merged,
      changes: changes
    };
  }

  function allRemoves(changes) {
    return changes.reduce(function (prev, change) {
      return prev && change[0] === '-';
    }, true);
  }

  function skipRemoveSuperset(state, removeChanges, delta) {
    for (var i = 0; i < delta; i++) {
      var changeContent = removeChanges[removeChanges.length - delta + i].substr(1);

      if (state.lines[state.index + i] !== ' ' + changeContent) {
        return false;
      }
    }

    state.index += delta;
    return true;
  }

  function calcOldNewLineCount(lines) {
    var oldLines = 0;
    var newLines = 0;
    lines.forEach(function (line) {
      if (typeof line !== 'string') {
        var myCount = calcOldNewLineCount(line.mine);
        var theirCount = calcOldNewLineCount(line.theirs);

        if (oldLines !== undefined) {
          if (myCount.oldLines === theirCount.oldLines) {
            oldLines += myCount.oldLines;
          } else {
            oldLines = undefined;
          }
        }

        if (newLines !== undefined) {
          if (myCount.newLines === theirCount.newLines) {
            newLines += myCount.newLines;
          } else {
            newLines = undefined;
          }
        }
      } else {
        if (newLines !== undefined && (line[0] === '+' || line[0] === ' ')) {
          newLines++;
        }

        if (oldLines !== undefined && (line[0] === '-' || line[0] === ' ')) {
          oldLines++;
        }
      }
    });
    return {
      oldLines: oldLines,
      newLines: newLines
    };
  } // See: http://code.google.com/p/google-diff-match-patch/wiki/API


  function convertChangesToDMP(changes) {
    var ret = [],
        change,
        operation;

    for (var i = 0; i < changes.length; i++) {
      change = changes[i];

      if (change.added) {
        operation = 1;
      } else if (change.removed) {
        operation = -1;
      } else {
        operation = 0;
      }

      ret.push([operation, change.value]);
    }

    return ret;
  }

  function convertChangesToXML(changes) {
    var ret = [];

    for (var i = 0; i < changes.length; i++) {
      var change = changes[i];

      if (change.added) {
        ret.push('<ins>');
      } else if (change.removed) {
        ret.push('<del>');
      }

      ret.push(escapeHTML(change.value));

      if (change.added) {
        ret.push('</ins>');
      } else if (change.removed) {
        ret.push('</del>');
      }
    }

    return ret.join('');
  }

  function escapeHTML(s) {
    var n = s;
    n = n.replace(/&/g, '&amp;');
    n = n.replace(/</g, '&lt;');
    n = n.replace(/>/g, '&gt;');
    n = n.replace(/"/g, '&quot;');
    return n;
  }

  var index_es6 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    Diff: Diff,
    diffChars: diffChars,
    diffWords: diffWords,
    diffWordsWithSpace: diffWordsWithSpace,
    diffLines: diffLines,
    diffTrimmedLines: diffTrimmedLines,
    diffSentences: diffSentences,
    diffCss: diffCss,
    diffJson: diffJson,
    diffArrays: diffArrays,
    structuredPatch: structuredPatch,
    createTwoFilesPatch: createTwoFilesPatch,
    createPatch: createPatch,
    applyPatch: applyPatch,
    applyPatches: applyPatches,
    parsePatch: parsePatch,
    merge: merge,
    convertChangesToDMP: convertChangesToDMP,
    convertChangesToXML: convertChangesToXML,
    canonicalize: canonicalize
  });

  var _shim_fs = {};

  var _shim_fs$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': _shim_fs
  });

  /*!
   * normalize-path <https://github.com/jonschlinkert/normalize-path>
   *
   * Copyright (c) 2014-2018, Jon Schlinkert.
   * Released under the MIT License.
   */
  var normalizePath = function normalizePath(path, stripTrailing) {
    if (typeof path !== 'string') {
      throw new TypeError('expected path to be a string');
    }

    if (path === '\\' || path === '/') return '/';
    var len = path.length;
    if (len <= 1) return path; // ensure that win32 namespaces has two leading slashes, so that the path is
    // handled properly by the win32 version of path.parse() after being normalized
    // https://msdn.microsoft.com/library/windows/desktop/aa365247(v=vs.85).aspx#namespaces

    var prefix = '';

    if (len > 4 && path[3] === '\\') {
      var ch = path[2];

      if ((ch === '?' || ch === '.') && path.slice(0, 2) === '\\\\') {
        path = path.slice(2);
        prefix = '//';
      }
    }

    var segs = path.split(/[/\\]+/);

    if (stripTrailing !== false && segs[segs.length - 1] === '') {
      segs.pop();
    }

    return prefix + segs.join('/');
  };

  var global$1 = typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {};

  var lookup = [];
  var revLookup = [];
  var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array;
  var inited = false;

  function init() {
    inited = true;
    var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';

    for (var i = 0, len = code.length; i < len; ++i) {
      lookup[i] = code[i];
      revLookup[code.charCodeAt(i)] = i;
    }

    revLookup['-'.charCodeAt(0)] = 62;
    revLookup['_'.charCodeAt(0)] = 63;
  }

  function toByteArray(b64) {
    if (!inited) {
      init();
    }

    var i, j, l, tmp, placeHolders, arr;
    var len = b64.length;

    if (len % 4 > 0) {
      throw new Error('Invalid string. Length must be a multiple of 4');
    } // the number of equal signs (place holders)
    // if there are two placeholders, than the two characters before it
    // represent one byte
    // if there is only one, then the three characters before it represent 2 bytes
    // this is just a cheap hack to not do indexOf twice


    placeHolders = b64[len - 2] === '=' ? 2 : b64[len - 1] === '=' ? 1 : 0; // base64 is 4/3 + up to two characters of the original data

    arr = new Arr(len * 3 / 4 - placeHolders); // if there are placeholders, only get up to the last complete 4 chars

    l = placeHolders > 0 ? len - 4 : len;
    var L = 0;

    for (i = 0, j = 0; i < l; i += 4, j += 3) {
      tmp = revLookup[b64.charCodeAt(i)] << 18 | revLookup[b64.charCodeAt(i + 1)] << 12 | revLookup[b64.charCodeAt(i + 2)] << 6 | revLookup[b64.charCodeAt(i + 3)];
      arr[L++] = tmp >> 16 & 0xFF;
      arr[L++] = tmp >> 8 & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    if (placeHolders === 2) {
      tmp = revLookup[b64.charCodeAt(i)] << 2 | revLookup[b64.charCodeAt(i + 1)] >> 4;
      arr[L++] = tmp & 0xFF;
    } else if (placeHolders === 1) {
      tmp = revLookup[b64.charCodeAt(i)] << 10 | revLookup[b64.charCodeAt(i + 1)] << 4 | revLookup[b64.charCodeAt(i + 2)] >> 2;
      arr[L++] = tmp >> 8 & 0xFF;
      arr[L++] = tmp & 0xFF;
    }

    return arr;
  }

  function tripletToBase64(num) {
    return lookup[num >> 18 & 0x3F] + lookup[num >> 12 & 0x3F] + lookup[num >> 6 & 0x3F] + lookup[num & 0x3F];
  }

  function encodeChunk(uint8, start, end) {
    var tmp;
    var output = [];

    for (var i = start; i < end; i += 3) {
      tmp = (uint8[i] << 16) + (uint8[i + 1] << 8) + uint8[i + 2];
      output.push(tripletToBase64(tmp));
    }

    return output.join('');
  }

  function fromByteArray(uint8) {
    if (!inited) {
      init();
    }

    var tmp;
    var len = uint8.length;
    var extraBytes = len % 3; // if we have 1 byte left, pad 2 bytes

    var output = '';
    var parts = [];
    var maxChunkLength = 16383; // must be multiple of 3
    // go through the array every three bytes, we'll deal with trailing stuff later

    for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
      parts.push(encodeChunk(uint8, i, i + maxChunkLength > len2 ? len2 : i + maxChunkLength));
    } // pad the end with zeros, but make sure to not forget the extra bytes


    if (extraBytes === 1) {
      tmp = uint8[len - 1];
      output += lookup[tmp >> 2];
      output += lookup[tmp << 4 & 0x3F];
      output += '==';
    } else if (extraBytes === 2) {
      tmp = (uint8[len - 2] << 8) + uint8[len - 1];
      output += lookup[tmp >> 10];
      output += lookup[tmp >> 4 & 0x3F];
      output += lookup[tmp << 2 & 0x3F];
      output += '=';
    }

    parts.push(output);
    return parts.join('');
  }

  function read(buffer, offset, isLE, mLen, nBytes) {
    var e, m;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var nBits = -7;
    var i = isLE ? nBytes - 1 : 0;
    var d = isLE ? -1 : 1;
    var s = buffer[offset + i];
    i += d;
    e = s & (1 << -nBits) - 1;
    s >>= -nBits;
    nBits += eLen;

    for (; nBits > 0; e = e * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    m = e & (1 << -nBits) - 1;
    e >>= -nBits;
    nBits += mLen;

    for (; nBits > 0; m = m * 256 + buffer[offset + i], i += d, nBits -= 8) {}

    if (e === 0) {
      e = 1 - eBias;
    } else if (e === eMax) {
      return m ? NaN : (s ? -1 : 1) * Infinity;
    } else {
      m = m + Math.pow(2, mLen);
      e = e - eBias;
    }

    return (s ? -1 : 1) * m * Math.pow(2, e - mLen);
  }
  function write(buffer, value, offset, isLE, mLen, nBytes) {
    var e, m, c;
    var eLen = nBytes * 8 - mLen - 1;
    var eMax = (1 << eLen) - 1;
    var eBias = eMax >> 1;
    var rt = mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0;
    var i = isLE ? 0 : nBytes - 1;
    var d = isLE ? 1 : -1;
    var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;
    value = Math.abs(value);

    if (isNaN(value) || value === Infinity) {
      m = isNaN(value) ? 1 : 0;
      e = eMax;
    } else {
      e = Math.floor(Math.log(value) / Math.LN2);

      if (value * (c = Math.pow(2, -e)) < 1) {
        e--;
        c *= 2;
      }

      if (e + eBias >= 1) {
        value += rt / c;
      } else {
        value += rt * Math.pow(2, 1 - eBias);
      }

      if (value * c >= 2) {
        e++;
        c /= 2;
      }

      if (e + eBias >= eMax) {
        m = 0;
        e = eMax;
      } else if (e + eBias >= 1) {
        m = (value * c - 1) * Math.pow(2, mLen);
        e = e + eBias;
      } else {
        m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen);
        e = 0;
      }
    }

    for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}

    e = e << mLen | m;
    eLen += mLen;

    for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}

    buffer[offset + i - d] |= s * 128;
  }

  var toString = {}.toString;
  var isArray = Array.isArray || function (arr) {
    return toString.call(arr) == '[object Array]';
  };

  var INSPECT_MAX_BYTES = 50;
  /**
   * If `Buffer.TYPED_ARRAY_SUPPORT`:
   *   === true    Use Uint8Array implementation (fastest)
   *   === false   Use Object implementation (most compatible, even IE6)
   *
   * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
   * Opera 11.6+, iOS 4.2+.
   *
   * Due to various browser bugs, sometimes the Object implementation will be used even
   * when the browser supports typed arrays.
   *
   * Note:
   *
   *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
   *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
   *
   *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
   *
   *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
   *     incorrect length in some situations.

   * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
   * get the Object implementation, which is slower but behaves correctly.
   */

  Buffer.TYPED_ARRAY_SUPPORT = global$1.TYPED_ARRAY_SUPPORT !== undefined ? global$1.TYPED_ARRAY_SUPPORT : true;

  function kMaxLength() {
    return Buffer.TYPED_ARRAY_SUPPORT ? 0x7fffffff : 0x3fffffff;
  }

  function createBuffer(that, length) {
    if (kMaxLength() < length) {
      throw new RangeError('Invalid typed array length');
    }

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = new Uint8Array(length);
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      if (that === null) {
        that = new Buffer(length);
      }

      that.length = length;
    }

    return that;
  }
  /**
   * The Buffer constructor returns instances of `Uint8Array` that have their
   * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
   * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
   * and the `Uint8Array` methods. Square bracket notation works as expected -- it
   * returns a single octet.
   *
   * The `Uint8Array` prototype remains unmodified.
   */


  function Buffer(arg, encodingOrOffset, length) {
    if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
      return new Buffer(arg, encodingOrOffset, length);
    } // Common case.


    if (typeof arg === 'number') {
      if (typeof encodingOrOffset === 'string') {
        throw new Error('If encoding is specified then the first argument must be a string');
      }

      return allocUnsafe(this, arg);
    }

    return from(this, arg, encodingOrOffset, length);
  }
  Buffer.poolSize = 8192; // not used by this implementation
  // TODO: Legacy, not needed anymore. Remove in next major version.

  Buffer._augment = function (arr) {
    arr.__proto__ = Buffer.prototype;
    return arr;
  };

  function from(that, value, encodingOrOffset, length) {
    if (typeof value === 'number') {
      throw new TypeError('"value" argument must not be a number');
    }

    if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
      return fromArrayBuffer(that, value, encodingOrOffset, length);
    }

    if (typeof value === 'string') {
      return fromString(that, value, encodingOrOffset);
    }

    return fromObject(that, value);
  }
  /**
   * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
   * if value is a number.
   * Buffer.from(str[, encoding])
   * Buffer.from(array)
   * Buffer.from(buffer)
   * Buffer.from(arrayBuffer[, byteOffset[, length]])
   **/


  Buffer.from = function (value, encodingOrOffset, length) {
    return from(null, value, encodingOrOffset, length);
  };

  if (Buffer.TYPED_ARRAY_SUPPORT) {
    Buffer.prototype.__proto__ = Uint8Array.prototype;
    Buffer.__proto__ = Uint8Array;
  }

  function assertSize(size) {
    if (typeof size !== 'number') {
      throw new TypeError('"size" argument must be a number');
    } else if (size < 0) {
      throw new RangeError('"size" argument must not be negative');
    }
  }

  function alloc(that, size, fill, encoding) {
    assertSize(size);

    if (size <= 0) {
      return createBuffer(that, size);
    }

    if (fill !== undefined) {
      // Only pay attention to encoding if it's a string. This
      // prevents accidentally sending in a number that would
      // be interpretted as a start offset.
      return typeof encoding === 'string' ? createBuffer(that, size).fill(fill, encoding) : createBuffer(that, size).fill(fill);
    }

    return createBuffer(that, size);
  }
  /**
   * Creates a new filled Buffer instance.
   * alloc(size[, fill[, encoding]])
   **/


  Buffer.alloc = function (size, fill, encoding) {
    return alloc(null, size, fill, encoding);
  };

  function allocUnsafe(that, size) {
    assertSize(size);
    that = createBuffer(that, size < 0 ? 0 : checked(size) | 0);

    if (!Buffer.TYPED_ARRAY_SUPPORT) {
      for (var i = 0; i < size; ++i) {
        that[i] = 0;
      }
    }

    return that;
  }
  /**
   * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
   * */


  Buffer.allocUnsafe = function (size) {
    return allocUnsafe(null, size);
  };
  /**
   * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
   */


  Buffer.allocUnsafeSlow = function (size) {
    return allocUnsafe(null, size);
  };

  function fromString(that, string, encoding) {
    if (typeof encoding !== 'string' || encoding === '') {
      encoding = 'utf8';
    }

    if (!Buffer.isEncoding(encoding)) {
      throw new TypeError('"encoding" must be a valid string encoding');
    }

    var length = byteLength(string, encoding) | 0;
    that = createBuffer(that, length);
    var actual = that.write(string, encoding);

    if (actual !== length) {
      // Writing a hex string, for example, that contains invalid characters will
      // cause everything after the first invalid character to be ignored. (e.g.
      // 'abxxcd' will be treated as 'ab')
      that = that.slice(0, actual);
    }

    return that;
  }

  function fromArrayLike(that, array) {
    var length = array.length < 0 ? 0 : checked(array.length) | 0;
    that = createBuffer(that, length);

    for (var i = 0; i < length; i += 1) {
      that[i] = array[i] & 255;
    }

    return that;
  }

  function fromArrayBuffer(that, array, byteOffset, length) {
    array.byteLength; // this throws if `array` is not a valid ArrayBuffer

    if (byteOffset < 0 || array.byteLength < byteOffset) {
      throw new RangeError('\'offset\' is out of bounds');
    }

    if (array.byteLength < byteOffset + (length || 0)) {
      throw new RangeError('\'length\' is out of bounds');
    }

    if (byteOffset === undefined && length === undefined) {
      array = new Uint8Array(array);
    } else if (length === undefined) {
      array = new Uint8Array(array, byteOffset);
    } else {
      array = new Uint8Array(array, byteOffset, length);
    }

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      // Return an augmented `Uint8Array` instance, for best performance
      that = array;
      that.__proto__ = Buffer.prototype;
    } else {
      // Fallback: Return an object instance of the Buffer class
      that = fromArrayLike(that, array);
    }

    return that;
  }

  function fromObject(that, obj) {
    if (internalIsBuffer(obj)) {
      var len = checked(obj.length) | 0;
      that = createBuffer(that, len);

      if (that.length === 0) {
        return that;
      }

      obj.copy(that, 0, 0, len);
      return that;
    }

    if (obj) {
      if (typeof ArrayBuffer !== 'undefined' && obj.buffer instanceof ArrayBuffer || 'length' in obj) {
        if (typeof obj.length !== 'number' || isnan(obj.length)) {
          return createBuffer(that, 0);
        }

        return fromArrayLike(that, obj);
      }

      if (obj.type === 'Buffer' && isArray(obj.data)) {
        return fromArrayLike(that, obj.data);
      }
    }

    throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.');
  }

  function checked(length) {
    // Note: cannot use `length < kMaxLength()` here because that fails when
    // length is NaN (which is otherwise coerced to zero.)
    if (length >= kMaxLength()) {
      throw new RangeError('Attempt to allocate Buffer larger than maximum ' + 'size: 0x' + kMaxLength().toString(16) + ' bytes');
    }

    return length | 0;
  }
  Buffer.isBuffer = isBuffer;

  function internalIsBuffer(b) {
    return !!(b != null && b._isBuffer);
  }

  Buffer.compare = function compare(a, b) {
    if (!internalIsBuffer(a) || !internalIsBuffer(b)) {
      throw new TypeError('Arguments must be Buffers');
    }

    if (a === b) return 0;
    var x = a.length;
    var y = b.length;

    for (var i = 0, len = Math.min(x, y); i < len; ++i) {
      if (a[i] !== b[i]) {
        x = a[i];
        y = b[i];
        break;
      }
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  };

  Buffer.isEncoding = function isEncoding(encoding) {
    switch (String(encoding).toLowerCase()) {
      case 'hex':
      case 'utf8':
      case 'utf-8':
      case 'ascii':
      case 'latin1':
      case 'binary':
      case 'base64':
      case 'ucs2':
      case 'ucs-2':
      case 'utf16le':
      case 'utf-16le':
        return true;

      default:
        return false;
    }
  };

  Buffer.concat = function concat(list, length) {
    if (!isArray(list)) {
      throw new TypeError('"list" argument must be an Array of Buffers');
    }

    if (list.length === 0) {
      return Buffer.alloc(0);
    }

    var i;

    if (length === undefined) {
      length = 0;

      for (i = 0; i < list.length; ++i) {
        length += list[i].length;
      }
    }

    var buffer = Buffer.allocUnsafe(length);
    var pos = 0;

    for (i = 0; i < list.length; ++i) {
      var buf = list[i];

      if (!internalIsBuffer(buf)) {
        throw new TypeError('"list" argument must be an Array of Buffers');
      }

      buf.copy(buffer, pos);
      pos += buf.length;
    }

    return buffer;
  };

  function byteLength(string, encoding) {
    if (internalIsBuffer(string)) {
      return string.length;
    }

    if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' && (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
      return string.byteLength;
    }

    if (typeof string !== 'string') {
      string = '' + string;
    }

    var len = string.length;
    if (len === 0) return 0; // Use a for loop to avoid recursion

    var loweredCase = false;

    for (;;) {
      switch (encoding) {
        case 'ascii':
        case 'latin1':
        case 'binary':
          return len;

        case 'utf8':
        case 'utf-8':
        case undefined:
          return utf8ToBytes(string).length;

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return len * 2;

        case 'hex':
          return len >>> 1;

        case 'base64':
          return base64ToBytes(string).length;

        default:
          if (loweredCase) return utf8ToBytes(string).length; // assume utf8

          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  }

  Buffer.byteLength = byteLength;

  function slowToString(encoding, start, end) {
    var loweredCase = false; // No need to verify that "this.length <= MAX_UINT32" since it's a read-only
    // property of a typed array.
    // This behaves neither like String nor Uint8Array in that we set start/end
    // to their upper/lower bounds if the value passed is out of range.
    // undefined is handled specially as per ECMA-262 6th Edition,
    // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.

    if (start === undefined || start < 0) {
      start = 0;
    } // Return early if start > this.length. Done here to prevent potential uint32
    // coercion fail below.


    if (start > this.length) {
      return '';
    }

    if (end === undefined || end > this.length) {
      end = this.length;
    }

    if (end <= 0) {
      return '';
    } // Force coersion to uint32. This will also coerce falsey/NaN values to 0.


    end >>>= 0;
    start >>>= 0;

    if (end <= start) {
      return '';
    }

    if (!encoding) encoding = 'utf8';

    while (true) {
      switch (encoding) {
        case 'hex':
          return hexSlice(this, start, end);

        case 'utf8':
        case 'utf-8':
          return utf8Slice(this, start, end);

        case 'ascii':
          return asciiSlice(this, start, end);

        case 'latin1':
        case 'binary':
          return latin1Slice(this, start, end);

        case 'base64':
          return base64Slice(this, start, end);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return utf16leSlice(this, start, end);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = (encoding + '').toLowerCase();
          loweredCase = true;
      }
    }
  } // The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
  // Buffer instances.


  Buffer.prototype._isBuffer = true;

  function swap(b, n, m) {
    var i = b[n];
    b[n] = b[m];
    b[m] = i;
  }

  Buffer.prototype.swap16 = function swap16() {
    var len = this.length;

    if (len % 2 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 16-bits');
    }

    for (var i = 0; i < len; i += 2) {
      swap(this, i, i + 1);
    }

    return this;
  };

  Buffer.prototype.swap32 = function swap32() {
    var len = this.length;

    if (len % 4 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 32-bits');
    }

    for (var i = 0; i < len; i += 4) {
      swap(this, i, i + 3);
      swap(this, i + 1, i + 2);
    }

    return this;
  };

  Buffer.prototype.swap64 = function swap64() {
    var len = this.length;

    if (len % 8 !== 0) {
      throw new RangeError('Buffer size must be a multiple of 64-bits');
    }

    for (var i = 0; i < len; i += 8) {
      swap(this, i, i + 7);
      swap(this, i + 1, i + 6);
      swap(this, i + 2, i + 5);
      swap(this, i + 3, i + 4);
    }

    return this;
  };

  Buffer.prototype.toString = function toString() {
    var length = this.length | 0;
    if (length === 0) return '';
    if (arguments.length === 0) return utf8Slice(this, 0, length);
    return slowToString.apply(this, arguments);
  };

  Buffer.prototype.equals = function equals(b) {
    if (!internalIsBuffer(b)) throw new TypeError('Argument must be a Buffer');
    if (this === b) return true;
    return Buffer.compare(this, b) === 0;
  };

  Buffer.prototype.inspect = function inspect() {
    var str = '';
    var max = INSPECT_MAX_BYTES;

    if (this.length > 0) {
      str = this.toString('hex', 0, max).match(/.{2}/g).join(' ');
      if (this.length > max) str += ' ... ';
    }

    return '<Buffer ' + str + '>';
  };

  Buffer.prototype.compare = function compare(target, start, end, thisStart, thisEnd) {
    if (!internalIsBuffer(target)) {
      throw new TypeError('Argument must be a Buffer');
    }

    if (start === undefined) {
      start = 0;
    }

    if (end === undefined) {
      end = target ? target.length : 0;
    }

    if (thisStart === undefined) {
      thisStart = 0;
    }

    if (thisEnd === undefined) {
      thisEnd = this.length;
    }

    if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
      throw new RangeError('out of range index');
    }

    if (thisStart >= thisEnd && start >= end) {
      return 0;
    }

    if (thisStart >= thisEnd) {
      return -1;
    }

    if (start >= end) {
      return 1;
    }

    start >>>= 0;
    end >>>= 0;
    thisStart >>>= 0;
    thisEnd >>>= 0;
    if (this === target) return 0;
    var x = thisEnd - thisStart;
    var y = end - start;
    var len = Math.min(x, y);
    var thisCopy = this.slice(thisStart, thisEnd);
    var targetCopy = target.slice(start, end);

    for (var i = 0; i < len; ++i) {
      if (thisCopy[i] !== targetCopy[i]) {
        x = thisCopy[i];
        y = targetCopy[i];
        break;
      }
    }

    if (x < y) return -1;
    if (y < x) return 1;
    return 0;
  }; // Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
  // OR the last index of `val` in `buffer` at offset <= `byteOffset`.
  //
  // Arguments:
  // - buffer - a Buffer to search
  // - val - a string, Buffer, or number
  // - byteOffset - an index into `buffer`; will be clamped to an int32
  // - encoding - an optional encoding, relevant is val is a string
  // - dir - true for indexOf, false for lastIndexOf


  function bidirectionalIndexOf(buffer, val, byteOffset, encoding, dir) {
    // Empty buffer means no match
    if (buffer.length === 0) return -1; // Normalize byteOffset

    if (typeof byteOffset === 'string') {
      encoding = byteOffset;
      byteOffset = 0;
    } else if (byteOffset > 0x7fffffff) {
      byteOffset = 0x7fffffff;
    } else if (byteOffset < -0x80000000) {
      byteOffset = -0x80000000;
    }

    byteOffset = +byteOffset; // Coerce to Number.

    if (isNaN(byteOffset)) {
      // byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
      byteOffset = dir ? 0 : buffer.length - 1;
    } // Normalize byteOffset: negative offsets start from the end of the buffer


    if (byteOffset < 0) byteOffset = buffer.length + byteOffset;

    if (byteOffset >= buffer.length) {
      if (dir) return -1;else byteOffset = buffer.length - 1;
    } else if (byteOffset < 0) {
      if (dir) byteOffset = 0;else return -1;
    } // Normalize val


    if (typeof val === 'string') {
      val = Buffer.from(val, encoding);
    } // Finally, search either indexOf (if dir is true) or lastIndexOf


    if (internalIsBuffer(val)) {
      // Special case: looking for empty string/buffer always fails
      if (val.length === 0) {
        return -1;
      }

      return arrayIndexOf(buffer, val, byteOffset, encoding, dir);
    } else if (typeof val === 'number') {
      val = val & 0xFF; // Search for a byte value [0-255]

      if (Buffer.TYPED_ARRAY_SUPPORT && typeof Uint8Array.prototype.indexOf === 'function') {
        if (dir) {
          return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset);
        } else {
          return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset);
        }
      }

      return arrayIndexOf(buffer, [val], byteOffset, encoding, dir);
    }

    throw new TypeError('val must be string, number or Buffer');
  }

  function arrayIndexOf(arr, val, byteOffset, encoding, dir) {
    var indexSize = 1;
    var arrLength = arr.length;
    var valLength = val.length;

    if (encoding !== undefined) {
      encoding = String(encoding).toLowerCase();

      if (encoding === 'ucs2' || encoding === 'ucs-2' || encoding === 'utf16le' || encoding === 'utf-16le') {
        if (arr.length < 2 || val.length < 2) {
          return -1;
        }

        indexSize = 2;
        arrLength /= 2;
        valLength /= 2;
        byteOffset /= 2;
      }
    }

    function read(buf, i) {
      if (indexSize === 1) {
        return buf[i];
      } else {
        return buf.readUInt16BE(i * indexSize);
      }
    }

    var i;

    if (dir) {
      var foundIndex = -1;

      for (i = byteOffset; i < arrLength; i++) {
        if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
          if (foundIndex === -1) foundIndex = i;
          if (i - foundIndex + 1 === valLength) return foundIndex * indexSize;
        } else {
          if (foundIndex !== -1) i -= i - foundIndex;
          foundIndex = -1;
        }
      }
    } else {
      if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength;

      for (i = byteOffset; i >= 0; i--) {
        var found = true;

        for (var j = 0; j < valLength; j++) {
          if (read(arr, i + j) !== read(val, j)) {
            found = false;
            break;
          }
        }

        if (found) return i;
      }
    }

    return -1;
  }

  Buffer.prototype.includes = function includes(val, byteOffset, encoding) {
    return this.indexOf(val, byteOffset, encoding) !== -1;
  };

  Buffer.prototype.indexOf = function indexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, true);
  };

  Buffer.prototype.lastIndexOf = function lastIndexOf(val, byteOffset, encoding) {
    return bidirectionalIndexOf(this, val, byteOffset, encoding, false);
  };

  function hexWrite(buf, string, offset, length) {
    offset = Number(offset) || 0;
    var remaining = buf.length - offset;

    if (!length) {
      length = remaining;
    } else {
      length = Number(length);

      if (length > remaining) {
        length = remaining;
      }
    } // must be an even number of digits


    var strLen = string.length;
    if (strLen % 2 !== 0) throw new TypeError('Invalid hex string');

    if (length > strLen / 2) {
      length = strLen / 2;
    }

    for (var i = 0; i < length; ++i) {
      var parsed = parseInt(string.substr(i * 2, 2), 16);
      if (isNaN(parsed)) return i;
      buf[offset + i] = parsed;
    }

    return i;
  }

  function utf8Write(buf, string, offset, length) {
    return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length);
  }

  function asciiWrite(buf, string, offset, length) {
    return blitBuffer(asciiToBytes(string), buf, offset, length);
  }

  function latin1Write(buf, string, offset, length) {
    return asciiWrite(buf, string, offset, length);
  }

  function base64Write(buf, string, offset, length) {
    return blitBuffer(base64ToBytes(string), buf, offset, length);
  }

  function ucs2Write(buf, string, offset, length) {
    return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length);
  }

  Buffer.prototype.write = function write(string, offset, length, encoding) {
    // Buffer#write(string)
    if (offset === undefined) {
      encoding = 'utf8';
      length = this.length;
      offset = 0; // Buffer#write(string, encoding)
    } else if (length === undefined && typeof offset === 'string') {
      encoding = offset;
      length = this.length;
      offset = 0; // Buffer#write(string, offset[, length][, encoding])
    } else if (isFinite(offset)) {
      offset = offset | 0;

      if (isFinite(length)) {
        length = length | 0;
        if (encoding === undefined) encoding = 'utf8';
      } else {
        encoding = length;
        length = undefined;
      } // legacy write(string, encoding, offset, length) - remove in v0.13

    } else {
      throw new Error('Buffer.write(string, encoding, offset[, length]) is no longer supported');
    }

    var remaining = this.length - offset;
    if (length === undefined || length > remaining) length = remaining;

    if (string.length > 0 && (length < 0 || offset < 0) || offset > this.length) {
      throw new RangeError('Attempt to write outside buffer bounds');
    }

    if (!encoding) encoding = 'utf8';
    var loweredCase = false;

    for (;;) {
      switch (encoding) {
        case 'hex':
          return hexWrite(this, string, offset, length);

        case 'utf8':
        case 'utf-8':
          return utf8Write(this, string, offset, length);

        case 'ascii':
          return asciiWrite(this, string, offset, length);

        case 'latin1':
        case 'binary':
          return latin1Write(this, string, offset, length);

        case 'base64':
          // Warning: maxLength not taken into account in base64Write
          return base64Write(this, string, offset, length);

        case 'ucs2':
        case 'ucs-2':
        case 'utf16le':
        case 'utf-16le':
          return ucs2Write(this, string, offset, length);

        default:
          if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding);
          encoding = ('' + encoding).toLowerCase();
          loweredCase = true;
      }
    }
  };

  Buffer.prototype.toJSON = function toJSON() {
    return {
      type: 'Buffer',
      data: Array.prototype.slice.call(this._arr || this, 0)
    };
  };

  function base64Slice(buf, start, end) {
    if (start === 0 && end === buf.length) {
      return fromByteArray(buf);
    } else {
      return fromByteArray(buf.slice(start, end));
    }
  }

  function utf8Slice(buf, start, end) {
    end = Math.min(buf.length, end);
    var res = [];
    var i = start;

    while (i < end) {
      var firstByte = buf[i];
      var codePoint = null;
      var bytesPerSequence = firstByte > 0xEF ? 4 : firstByte > 0xDF ? 3 : firstByte > 0xBF ? 2 : 1;

      if (i + bytesPerSequence <= end) {
        var secondByte, thirdByte, fourthByte, tempCodePoint;

        switch (bytesPerSequence) {
          case 1:
            if (firstByte < 0x80) {
              codePoint = firstByte;
            }

            break;

          case 2:
            secondByte = buf[i + 1];

            if ((secondByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0x1F) << 0x6 | secondByte & 0x3F;

              if (tempCodePoint > 0x7F) {
                codePoint = tempCodePoint;
              }
            }

            break;

          case 3:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];

            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | thirdByte & 0x3F;

              if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
                codePoint = tempCodePoint;
              }
            }

            break;

          case 4:
            secondByte = buf[i + 1];
            thirdByte = buf[i + 2];
            fourthByte = buf[i + 3];

            if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
              tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | fourthByte & 0x3F;

              if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
                codePoint = tempCodePoint;
              }
            }

        }
      }

      if (codePoint === null) {
        // we did not generate a valid codePoint so insert a
        // replacement char (U+FFFD) and advance only 1 byte
        codePoint = 0xFFFD;
        bytesPerSequence = 1;
      } else if (codePoint > 0xFFFF) {
        // encode to utf16 (surrogate pair dance)
        codePoint -= 0x10000;
        res.push(codePoint >>> 10 & 0x3FF | 0xD800);
        codePoint = 0xDC00 | codePoint & 0x3FF;
      }

      res.push(codePoint);
      i += bytesPerSequence;
    }

    return decodeCodePointsArray(res);
  } // Based on http://stackoverflow.com/a/22747272/680742, the browser with
  // the lowest limit is Chrome, with 0x10000 args.
  // We go 1 magnitude less, for safety


  var MAX_ARGUMENTS_LENGTH = 0x1000;

  function decodeCodePointsArray(codePoints) {
    var len = codePoints.length;

    if (len <= MAX_ARGUMENTS_LENGTH) {
      return String.fromCharCode.apply(String, codePoints); // avoid extra slice()
    } // Decode in chunks to avoid "call stack size exceeded".


    var res = '';
    var i = 0;

    while (i < len) {
      res += String.fromCharCode.apply(String, codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH));
    }

    return res;
  }

  function asciiSlice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i] & 0x7F);
    }

    return ret;
  }

  function latin1Slice(buf, start, end) {
    var ret = '';
    end = Math.min(buf.length, end);

    for (var i = start; i < end; ++i) {
      ret += String.fromCharCode(buf[i]);
    }

    return ret;
  }

  function hexSlice(buf, start, end) {
    var len = buf.length;
    if (!start || start < 0) start = 0;
    if (!end || end < 0 || end > len) end = len;
    var out = '';

    for (var i = start; i < end; ++i) {
      out += toHex(buf[i]);
    }

    return out;
  }

  function utf16leSlice(buf, start, end) {
    var bytes = buf.slice(start, end);
    var res = '';

    for (var i = 0; i < bytes.length; i += 2) {
      res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256);
    }

    return res;
  }

  Buffer.prototype.slice = function slice(start, end) {
    var len = this.length;
    start = ~~start;
    end = end === undefined ? len : ~~end;

    if (start < 0) {
      start += len;
      if (start < 0) start = 0;
    } else if (start > len) {
      start = len;
    }

    if (end < 0) {
      end += len;
      if (end < 0) end = 0;
    } else if (end > len) {
      end = len;
    }

    if (end < start) end = start;
    var newBuf;

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      newBuf = this.subarray(start, end);
      newBuf.__proto__ = Buffer.prototype;
    } else {
      var sliceLen = end - start;
      newBuf = new Buffer(sliceLen, undefined);

      for (var i = 0; i < sliceLen; ++i) {
        newBuf[i] = this[i + start];
      }
    }

    return newBuf;
  };
  /*
   * Need to make sure that buffer isn't trying to write out of bounds.
   */


  function checkOffset(offset, ext, length) {
    if (offset % 1 !== 0 || offset < 0) throw new RangeError('offset is not uint');
    if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length');
  }

  Buffer.prototype.readUIntLE = function readUIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;

    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    return val;
  };

  Buffer.prototype.readUIntBE = function readUIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;

    if (!noAssert) {
      checkOffset(offset, byteLength, this.length);
    }

    var val = this[offset + --byteLength];
    var mul = 1;

    while (byteLength > 0 && (mul *= 0x100)) {
      val += this[offset + --byteLength] * mul;
    }

    return val;
  };

  Buffer.prototype.readUInt8 = function readUInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    return this[offset];
  };

  Buffer.prototype.readUInt16LE = function readUInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] | this[offset + 1] << 8;
  };

  Buffer.prototype.readUInt16BE = function readUInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    return this[offset] << 8 | this[offset + 1];
  };

  Buffer.prototype.readUInt32LE = function readUInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return (this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16) + this[offset + 3] * 0x1000000;
  };

  Buffer.prototype.readUInt32BE = function readUInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] * 0x1000000 + (this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3]);
  };

  Buffer.prototype.readIntLE = function readIntLE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var val = this[offset];
    var mul = 1;
    var i = 0;

    while (++i < byteLength && (mul *= 0x100)) {
      val += this[offset + i] * mul;
    }

    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  };

  Buffer.prototype.readIntBE = function readIntBE(offset, byteLength, noAssert) {
    offset = offset | 0;
    byteLength = byteLength | 0;
    if (!noAssert) checkOffset(offset, byteLength, this.length);
    var i = byteLength;
    var mul = 1;
    var val = this[offset + --i];

    while (i > 0 && (mul *= 0x100)) {
      val += this[offset + --i] * mul;
    }

    mul *= 0x80;
    if (val >= mul) val -= Math.pow(2, 8 * byteLength);
    return val;
  };

  Buffer.prototype.readInt8 = function readInt8(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 1, this.length);
    if (!(this[offset] & 0x80)) return this[offset];
    return (0xff - this[offset] + 1) * -1;
  };

  Buffer.prototype.readInt16LE = function readInt16LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset] | this[offset + 1] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer.prototype.readInt16BE = function readInt16BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 2, this.length);
    var val = this[offset + 1] | this[offset] << 8;
    return val & 0x8000 ? val | 0xFFFF0000 : val;
  };

  Buffer.prototype.readInt32LE = function readInt32LE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] | this[offset + 1] << 8 | this[offset + 2] << 16 | this[offset + 3] << 24;
  };

  Buffer.prototype.readInt32BE = function readInt32BE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return this[offset] << 24 | this[offset + 1] << 16 | this[offset + 2] << 8 | this[offset + 3];
  };

  Buffer.prototype.readFloatLE = function readFloatLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, true, 23, 4);
  };

  Buffer.prototype.readFloatBE = function readFloatBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 4, this.length);
    return read(this, offset, false, 23, 4);
  };

  Buffer.prototype.readDoubleLE = function readDoubleLE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, true, 52, 8);
  };

  Buffer.prototype.readDoubleBE = function readDoubleBE(offset, noAssert) {
    if (!noAssert) checkOffset(offset, 8, this.length);
    return read(this, offset, false, 52, 8);
  };

  function checkInt(buf, value, offset, ext, max, min) {
    if (!internalIsBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance');
    if (value > max || value < min) throw new RangeError('"value" argument is out of bounds');
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
  }

  Buffer.prototype.writeUIntLE = function writeUIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;

    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var mul = 1;
    var i = 0;
    this[offset] = value & 0xFF;

    while (++i < byteLength && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeUIntBE = function writeUIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;
    byteLength = byteLength | 0;

    if (!noAssert) {
      var maxBytes = Math.pow(2, 8 * byteLength) - 1;
      checkInt(this, value, offset, byteLength, maxBytes, 0);
    }

    var i = byteLength - 1;
    var mul = 1;
    this[offset + i] = value & 0xFF;

    while (--i >= 0 && (mul *= 0x100)) {
      this[offset + i] = value / mul & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeUInt8 = function writeUInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    this[offset] = value & 0xff;
    return offset + 1;
  };

  function objectWriteUInt16(buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffff + value + 1;

    for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
      buf[offset + i] = (value & 0xff << 8 * (littleEndian ? i : 1 - i)) >>> (littleEndian ? i : 1 - i) * 8;
    }
  }

  Buffer.prototype.writeUInt16LE = function writeUInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }

    return offset + 2;
  };

  Buffer.prototype.writeUInt16BE = function writeUInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }

    return offset + 2;
  };

  function objectWriteUInt32(buf, value, offset, littleEndian) {
    if (value < 0) value = 0xffffffff + value + 1;

    for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
      buf[offset + i] = value >>> (littleEndian ? i : 3 - i) * 8 & 0xff;
    }
  }

  Buffer.prototype.writeUInt32LE = function writeUInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset + 3] = value >>> 24;
      this[offset + 2] = value >>> 16;
      this[offset + 1] = value >>> 8;
      this[offset] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }

    return offset + 4;
  };

  Buffer.prototype.writeUInt32BE = function writeUInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }

    return offset + 4;
  };

  Buffer.prototype.writeIntLE = function writeIntLE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;

    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = 0;
    var mul = 1;
    var sub = 0;
    this[offset] = value & 0xFF;

    while (++i < byteLength && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
        sub = 1;
      }

      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeIntBE = function writeIntBE(value, offset, byteLength, noAssert) {
    value = +value;
    offset = offset | 0;

    if (!noAssert) {
      var limit = Math.pow(2, 8 * byteLength - 1);
      checkInt(this, value, offset, byteLength, limit - 1, -limit);
    }

    var i = byteLength - 1;
    var mul = 1;
    var sub = 0;
    this[offset + i] = value & 0xFF;

    while (--i >= 0 && (mul *= 0x100)) {
      if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
        sub = 1;
      }

      this[offset + i] = (value / mul >> 0) - sub & 0xFF;
    }

    return offset + byteLength;
  };

  Buffer.prototype.writeInt8 = function writeInt8(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80);
    if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value);
    if (value < 0) value = 0xff + value + 1;
    this[offset] = value & 0xff;
    return offset + 1;
  };

  Buffer.prototype.writeInt16LE = function writeInt16LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
    } else {
      objectWriteUInt16(this, value, offset, true);
    }

    return offset + 2;
  };

  Buffer.prototype.writeInt16BE = function writeInt16BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 8;
      this[offset + 1] = value & 0xff;
    } else {
      objectWriteUInt16(this, value, offset, false);
    }

    return offset + 2;
  };

  Buffer.prototype.writeInt32LE = function writeInt32LE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value & 0xff;
      this[offset + 1] = value >>> 8;
      this[offset + 2] = value >>> 16;
      this[offset + 3] = value >>> 24;
    } else {
      objectWriteUInt32(this, value, offset, true);
    }

    return offset + 4;
  };

  Buffer.prototype.writeInt32BE = function writeInt32BE(value, offset, noAssert) {
    value = +value;
    offset = offset | 0;
    if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000);
    if (value < 0) value = 0xffffffff + value + 1;

    if (Buffer.TYPED_ARRAY_SUPPORT) {
      this[offset] = value >>> 24;
      this[offset + 1] = value >>> 16;
      this[offset + 2] = value >>> 8;
      this[offset + 3] = value & 0xff;
    } else {
      objectWriteUInt32(this, value, offset, false);
    }

    return offset + 4;
  };

  function checkIEEE754(buf, value, offset, ext, max, min) {
    if (offset + ext > buf.length) throw new RangeError('Index out of range');
    if (offset < 0) throw new RangeError('Index out of range');
  }

  function writeFloat(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 4);
    }

    write(buf, value, offset, littleEndian, 23, 4);
    return offset + 4;
  }

  Buffer.prototype.writeFloatLE = function writeFloatLE(value, offset, noAssert) {
    return writeFloat(this, value, offset, true, noAssert);
  };

  Buffer.prototype.writeFloatBE = function writeFloatBE(value, offset, noAssert) {
    return writeFloat(this, value, offset, false, noAssert);
  };

  function writeDouble(buf, value, offset, littleEndian, noAssert) {
    if (!noAssert) {
      checkIEEE754(buf, value, offset, 8);
    }

    write(buf, value, offset, littleEndian, 52, 8);
    return offset + 8;
  }

  Buffer.prototype.writeDoubleLE = function writeDoubleLE(value, offset, noAssert) {
    return writeDouble(this, value, offset, true, noAssert);
  };

  Buffer.prototype.writeDoubleBE = function writeDoubleBE(value, offset, noAssert) {
    return writeDouble(this, value, offset, false, noAssert);
  }; // copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)


  Buffer.prototype.copy = function copy(target, targetStart, start, end) {
    if (!start) start = 0;
    if (!end && end !== 0) end = this.length;
    if (targetStart >= target.length) targetStart = target.length;
    if (!targetStart) targetStart = 0;
    if (end > 0 && end < start) end = start; // Copy 0 bytes; we're done

    if (end === start) return 0;
    if (target.length === 0 || this.length === 0) return 0; // Fatal error conditions

    if (targetStart < 0) {
      throw new RangeError('targetStart out of bounds');
    }

    if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds');
    if (end < 0) throw new RangeError('sourceEnd out of bounds'); // Are we oob?

    if (end > this.length) end = this.length;

    if (target.length - targetStart < end - start) {
      end = target.length - targetStart + start;
    }

    var len = end - start;
    var i;

    if (this === target && start < targetStart && targetStart < end) {
      // descending copy from end
      for (i = len - 1; i >= 0; --i) {
        target[i + targetStart] = this[i + start];
      }
    } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
      // ascending copy from start
      for (i = 0; i < len; ++i) {
        target[i + targetStart] = this[i + start];
      }
    } else {
      Uint8Array.prototype.set.call(target, this.subarray(start, start + len), targetStart);
    }

    return len;
  }; // Usage:
  //    buffer.fill(number[, offset[, end]])
  //    buffer.fill(buffer[, offset[, end]])
  //    buffer.fill(string[, offset[, end]][, encoding])


  Buffer.prototype.fill = function fill(val, start, end, encoding) {
    // Handle string cases:
    if (typeof val === 'string') {
      if (typeof start === 'string') {
        encoding = start;
        start = 0;
        end = this.length;
      } else if (typeof end === 'string') {
        encoding = end;
        end = this.length;
      }

      if (val.length === 1) {
        var code = val.charCodeAt(0);

        if (code < 256) {
          val = code;
        }
      }

      if (encoding !== undefined && typeof encoding !== 'string') {
        throw new TypeError('encoding must be a string');
      }

      if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
        throw new TypeError('Unknown encoding: ' + encoding);
      }
    } else if (typeof val === 'number') {
      val = val & 255;
    } // Invalid ranges are not set to a default, so can range check early.


    if (start < 0 || this.length < start || this.length < end) {
      throw new RangeError('Out of range index');
    }

    if (end <= start) {
      return this;
    }

    start = start >>> 0;
    end = end === undefined ? this.length : end >>> 0;
    if (!val) val = 0;
    var i;

    if (typeof val === 'number') {
      for (i = start; i < end; ++i) {
        this[i] = val;
      }
    } else {
      var bytes = internalIsBuffer(val) ? val : utf8ToBytes(new Buffer(val, encoding).toString());
      var len = bytes.length;

      for (i = 0; i < end - start; ++i) {
        this[i + start] = bytes[i % len];
      }
    }

    return this;
  }; // HELPER FUNCTIONS
  // ================


  var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g;

  function base64clean(str) {
    // Node strips out invalid characters like \n and \t from the string, base64-js does not
    str = stringtrim(str).replace(INVALID_BASE64_RE, ''); // Node converts strings with length < 2 to ''

    if (str.length < 2) return ''; // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not

    while (str.length % 4 !== 0) {
      str = str + '=';
    }

    return str;
  }

  function stringtrim(str) {
    if (str.trim) return str.trim();
    return str.replace(/^\s+|\s+$/g, '');
  }

  function toHex(n) {
    if (n < 16) return '0' + n.toString(16);
    return n.toString(16);
  }

  function utf8ToBytes(string, units) {
    units = units || Infinity;
    var codePoint;
    var length = string.length;
    var leadSurrogate = null;
    var bytes = [];

    for (var i = 0; i < length; ++i) {
      codePoint = string.charCodeAt(i); // is surrogate component

      if (codePoint > 0xD7FF && codePoint < 0xE000) {
        // last char was a lead
        if (!leadSurrogate) {
          // no lead yet
          if (codePoint > 0xDBFF) {
            // unexpected trail
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } else if (i + 1 === length) {
            // unpaired lead
            if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
            continue;
          } // valid lead


          leadSurrogate = codePoint;
          continue;
        } // 2 leads in a row


        if (codePoint < 0xDC00) {
          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
          leadSurrogate = codePoint;
          continue;
        } // valid surrogate pair


        codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000;
      } else if (leadSurrogate) {
        // valid bmp char, but last char was a lead
        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD);
      }

      leadSurrogate = null; // encode utf8

      if (codePoint < 0x80) {
        if ((units -= 1) < 0) break;
        bytes.push(codePoint);
      } else if (codePoint < 0x800) {
        if ((units -= 2) < 0) break;
        bytes.push(codePoint >> 0x6 | 0xC0, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x10000) {
        if ((units -= 3) < 0) break;
        bytes.push(codePoint >> 0xC | 0xE0, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else if (codePoint < 0x110000) {
        if ((units -= 4) < 0) break;
        bytes.push(codePoint >> 0x12 | 0xF0, codePoint >> 0xC & 0x3F | 0x80, codePoint >> 0x6 & 0x3F | 0x80, codePoint & 0x3F | 0x80);
      } else {
        throw new Error('Invalid code point');
      }
    }

    return bytes;
  }

  function asciiToBytes(str) {
    var byteArray = [];

    for (var i = 0; i < str.length; ++i) {
      // Node's code seems to be doing this and not & 0x7F..
      byteArray.push(str.charCodeAt(i) & 0xFF);
    }

    return byteArray;
  }

  function utf16leToBytes(str, units) {
    var c, hi, lo;
    var byteArray = [];

    for (var i = 0; i < str.length; ++i) {
      if ((units -= 2) < 0) break;
      c = str.charCodeAt(i);
      hi = c >> 8;
      lo = c % 256;
      byteArray.push(lo);
      byteArray.push(hi);
    }

    return byteArray;
  }

  function base64ToBytes(str) {
    return toByteArray(base64clean(str));
  }

  function blitBuffer(src, dst, offset, length) {
    for (var i = 0; i < length; ++i) {
      if (i + offset >= dst.length || i >= src.length) break;
      dst[i + offset] = src[i];
    }

    return i;
  }

  function isnan(val) {
    return val !== val; // eslint-disable-line no-self-compare
  } // the following is from is-buffer, also by Feross Aboukhadijeh and with same lisence
  // The _isBuffer check is for Safari 5-7 support, because it's missing
  // Object.prototype.constructor. Remove this eventually


  function isBuffer(obj) {
    return obj != null && (!!obj._isBuffer || isFastBuffer(obj) || isSlowBuffer(obj));
  }

  function isFastBuffer(obj) {
    return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
  } // For Node v0.10 support. Remove this eventually.


  function isSlowBuffer(obj) {
    return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isFastBuffer(obj.slice(0, 0));
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  function unwrapExports (x) {
  	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
  }

  function createCommonjsModule(fn, module) {
  	return module = { exports: {} }, fn(module, module.exports), module.exports;
  }

  function getCjsExportFromNamespace (n) {
  	return n && n['default'] || n;
  }

  var fs = getCjsExportFromNamespace(_shim_fs$1);

  /**
   * @class
   */


  var LineByLine =
  /*#__PURE__*/
  function () {
    function LineByLine(file, options) {
      _classCallCheck(this, LineByLine);

      options = options || {};
      if (!options.readChunk) options.readChunk = 1024;

      if (!options.newLineCharacter) {
        options.newLineCharacter = 0x0a; //linux line ending
      } else {
        options.newLineCharacter = options.newLineCharacter.charCodeAt(0);
      }

      if (typeof file === 'number') {
        this.fd = file;
      } else {
        this.fd = fs.openSync(file, 'r');
      }

      this.options = options;
      this.newLineCharacter = options.newLineCharacter;
      this.reset();
    }

    _createClass(LineByLine, [{
      key: "_searchInBuffer",
      value: function _searchInBuffer(buffer, hexNeedle) {
        var found = -1;

        for (var i = 0; i <= buffer.length; i++) {
          var b_byte = buffer[i];

          if (b_byte === hexNeedle) {
            found = i;
            break;
          }
        }

        return found;
      }
    }, {
      key: "reset",
      value: function reset() {
        this.eofReached = false;
        this.linesCache = [];
        this.fdPosition = 0;
      }
    }, {
      key: "close",
      value: function close() {
        fs.closeSync(this.fd);
        this.fd = null;
      }
    }, {
      key: "_extractLines",
      value: function _extractLines(buffer) {
        var line;
        var lines = [];
        var bufferPosition = 0;
        var lastNewLineBufferPosition = 0;

        while (true) {
          var bufferPositionValue = buffer[bufferPosition++];

          if (bufferPositionValue === this.newLineCharacter) {
            line = buffer.slice(lastNewLineBufferPosition, bufferPosition);
            lines.push(line);
            lastNewLineBufferPosition = bufferPosition;
          } else if (!bufferPositionValue) {
            break;
          }
        }

        var leftovers = buffer.slice(lastNewLineBufferPosition, bufferPosition);

        if (leftovers.length) {
          lines.push(leftovers);
        }

        return lines;
      }
    }, {
      key: "_readChunk",
      value: function _readChunk(lineLeftovers) {
        var totalBytesRead = 0;
        var bytesRead;
        var buffers = [];

        do {
          var readBuffer = new Buffer(this.options.readChunk);
          bytesRead = fs.readSync(this.fd, readBuffer, 0, this.options.readChunk, this.fdPosition);
          totalBytesRead = totalBytesRead + bytesRead;
          this.fdPosition = this.fdPosition + bytesRead;
          buffers.push(readBuffer);
        } while (bytesRead && this._searchInBuffer(buffers[buffers.length - 1], this.options.newLineCharacter) === -1);

        var bufferData = Buffer.concat(buffers);

        if (bytesRead < this.options.readChunk) {
          this.eofReached = true;
          bufferData = bufferData.slice(0, totalBytesRead);
        }

        if (totalBytesRead) {
          this.linesCache = this._extractLines(bufferData);

          if (lineLeftovers) {
            this.linesCache[0] = Buffer.concat([lineLeftovers, this.linesCache[0]]);
          }
        }

        return totalBytesRead;
      }
    }, {
      key: "next",
      value: function next() {
        if (!this.fd) return false;
        var line = false;

        if (this.eofReached && this.linesCache.length === 0) {
          return line;
        }

        var bytesRead;

        if (!this.linesCache.length) {
          bytesRead = this._readChunk();
        }

        if (this.linesCache.length) {
          line = this.linesCache.shift();
          var lastLineCharacter = line[line.length - 1];

          if (lastLineCharacter !== 0x0a) {
            bytesRead = this._readChunk(line);

            if (bytesRead) {
              line = this.linesCache.shift();
            }
          }
        }

        if (this.eofReached && this.linesCache.length === 0) {
          this.close();
        }

        if (line && line[line.length - 1] === this.newLineCharacter) {
          line = line.slice(0, line.length - 1);
        }

        return line;
      }
    }]);

    return LineByLine;
  }();

  var readlines = LineByLine;

  var ConfigError =
  /*#__PURE__*/
  function (_Error) {
    _inherits(ConfigError, _Error);

    function ConfigError() {
      _classCallCheck(this, ConfigError);

      return _possibleConstructorReturn(this, _getPrototypeOf(ConfigError).apply(this, arguments));
    }

    return ConfigError;
  }(_wrapNativeSuper(Error));

  var DebugError =
  /*#__PURE__*/
  function (_Error2) {
    _inherits(DebugError, _Error2);

    function DebugError() {
      _classCallCheck(this, DebugError);

      return _possibleConstructorReturn(this, _getPrototypeOf(DebugError).apply(this, arguments));
    }

    return DebugError;
  }(_wrapNativeSuper(Error));

  var UndefinedParserError =
  /*#__PURE__*/
  function (_Error3) {
    _inherits(UndefinedParserError, _Error3);

    function UndefinedParserError() {
      _classCallCheck(this, UndefinedParserError);

      return _possibleConstructorReturn(this, _getPrototypeOf(UndefinedParserError).apply(this, arguments));
    }

    return UndefinedParserError;
  }(_wrapNativeSuper(Error));

  var errors = {
    ConfigError: ConfigError,
    DebugError: DebugError,
    UndefinedParserError: UndefinedParserError
  };

  // based off https://github.com/defunctzombie/node-process/blob/master/browser.js

  function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
  }

  function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
  }

  var cachedSetTimeout = defaultSetTimout;
  var cachedClearTimeout = defaultClearTimeout;

  if (typeof global$1.setTimeout === 'function') {
    cachedSetTimeout = setTimeout;
  }

  if (typeof global$1.clearTimeout === 'function') {
    cachedClearTimeout = clearTimeout;
  }

  function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
      //normal enviroments in sane situations
      return setTimeout(fun, 0);
    } // if setTimeout wasn't available but was latter defined


    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
      cachedSetTimeout = setTimeout;
      return setTimeout(fun, 0);
    }

    try {
      // when when somebody has screwed with setTimeout but no I.E. maddness
      return cachedSetTimeout(fun, 0);
    } catch (e) {
      try {
        // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
        return cachedSetTimeout.call(null, fun, 0);
      } catch (e) {
        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
        return cachedSetTimeout.call(this, fun, 0);
      }
    }
  }

  function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
      //normal enviroments in sane situations
      return clearTimeout(marker);
    } // if clearTimeout wasn't available but was latter defined


    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
      cachedClearTimeout = clearTimeout;
      return clearTimeout(marker);
    }

    try {
      // when when somebody has screwed with setTimeout but no I.E. maddness
      return cachedClearTimeout(marker);
    } catch (e) {
      try {
        // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
        return cachedClearTimeout.call(null, marker);
      } catch (e) {
        // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
        // Some versions of I.E. have different rules for clearTimeout vs setTimeout
        return cachedClearTimeout.call(this, marker);
      }
    }
  }

  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;

  function cleanUpNextTick() {
    if (!draining || !currentQueue) {
      return;
    }

    draining = false;

    if (currentQueue.length) {
      queue = currentQueue.concat(queue);
    } else {
      queueIndex = -1;
    }

    if (queue.length) {
      drainQueue();
    }
  }

  function drainQueue() {
    if (draining) {
      return;
    }

    var timeout = runTimeout(cleanUpNextTick);
    draining = true;
    var len = queue.length;

    while (len) {
      currentQueue = queue;
      queue = [];

      while (++queueIndex < len) {
        if (currentQueue) {
          currentQueue[queueIndex].run();
        }
      }

      queueIndex = -1;
      len = queue.length;
    }

    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
  }

  function nextTick(fun) {
    var args = new Array(arguments.length - 1);

    if (arguments.length > 1) {
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
    }

    queue.push(new Item(fun, args));

    if (queue.length === 1 && !draining) {
      runTimeout(drainQueue);
    }
  } // v8 likes predictible objects

  function Item(fun, array) {
    this.fun = fun;
    this.array = array;
  }

  Item.prototype.run = function () {
    this.fun.apply(null, this.array);
  };

  var title = 'browser';
  var platform = 'browser';
  var browser = true;
  var env = {};
  var argv = [];
  var version$1 = ''; // empty string to avoid regexp issues

  var versions = {};
  var release = {};
  var config = {};

  function noop() {}

  var on = noop;
  var addListener = noop;
  var once = noop;
  var off = noop;
  var removeListener = noop;
  var removeAllListeners = noop;
  var emit = noop;
  function binding(name) {
    throw new Error('process.binding is not supported');
  }
  function cwd() {
    return '/';
  }
  function chdir(dir) {
    throw new Error('process.chdir is not supported');
  }
  function umask() {
    return 0;
  } // from https://github.com/kumavis/browser-process-hrtime/blob/master/index.js

  var performance = global$1.performance || {};

  var performanceNow = performance.now || performance.mozNow || performance.msNow || performance.oNow || performance.webkitNow || function () {
    return new Date().getTime();
  }; // generate timestamp or delta
  // see http://nodejs.org/api/process.html#process_process_hrtime


  function hrtime(previousTimestamp) {
    var clocktime = performanceNow.call(performance) * 1e-3;
    var seconds = Math.floor(clocktime);
    var nanoseconds = Math.floor(clocktime % 1 * 1e9);

    if (previousTimestamp) {
      seconds = seconds - previousTimestamp[0];
      nanoseconds = nanoseconds - previousTimestamp[1];

      if (nanoseconds < 0) {
        seconds--;
        nanoseconds += 1e9;
      }
    }

    return [seconds, nanoseconds];
  }
  var startTime = new Date();
  function uptime() {
    var currentTime = new Date();
    var dif = currentTime - startTime;
    return dif / 1000;
  }
  var process = {
    nextTick: nextTick,
    title: title,
    browser: browser,
    env: env,
    argv: argv,
    version: version$1,
    versions: versions,
    on: on,
    addListener: addListener,
    once: once,
    off: off,
    removeListener: removeListener,
    removeAllListeners: removeAllListeners,
    emit: emit,
    binding: binding,
    cwd: cwd,
    chdir: chdir,
    umask: umask,
    hrtime: hrtime,
    platform: platform,
    release: release,
    config: config,
    uptime: uptime
  };

  var semver = createCommonjsModule(function (module, exports) {
    exports = module.exports = SemVer;
    var debug;
    /* istanbul ignore next */

    if (_typeof(process) === 'object' && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
      debug = function debug() {
        var args = Array.prototype.slice.call(arguments, 0);
        args.unshift('SEMVER');
        console.log.apply(console, args);
      };
    } else {
      debug = function debug() {};
    } // Note: this is the semver.org version of the spec that it implements
    // Not necessarily the package version of this code.


    exports.SEMVER_SPEC_VERSION = '2.0.0';
    var MAX_LENGTH = 256;
    var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
    /* istanbul ignore next */
    9007199254740991; // Max safe segment length for coercion.

    var MAX_SAFE_COMPONENT_LENGTH = 16; // The actual regexps go on exports.re

    var re = exports.re = [];
    var src = exports.src = [];
    var t = exports.tokens = {};
    var R = 0;

    function tok(n) {
      t[n] = R++;
    } // The following Regular Expressions can be used for tokenizing,
    // validating, and parsing SemVer version strings.
    // ## Numeric Identifier
    // A single `0`, or a non-zero digit followed by zero or more digits.


    tok('NUMERICIDENTIFIER');
    src[t.NUMERICIDENTIFIER] = '0|[1-9]\\d*';
    tok('NUMERICIDENTIFIERLOOSE');
    src[t.NUMERICIDENTIFIERLOOSE] = '[0-9]+'; // ## Non-numeric Identifier
    // Zero or more digits, followed by a letter or hyphen, and then zero or
    // more letters, digits, or hyphens.

    tok('NONNUMERICIDENTIFIER');
    src[t.NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'; // ## Main Version
    // Three dot-separated numeric identifiers.

    tok('MAINVERSION');
    src[t.MAINVERSION] = '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')\\.' + '(' + src[t.NUMERICIDENTIFIER] + ')';
    tok('MAINVERSIONLOOSE');
    src[t.MAINVERSIONLOOSE] = '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')\\.' + '(' + src[t.NUMERICIDENTIFIERLOOSE] + ')'; // ## Pre-release Version Identifier
    // A numeric identifier, or a non-numeric identifier.

    tok('PRERELEASEIDENTIFIER');
    src[t.PRERELEASEIDENTIFIER] = '(?:' + src[t.NUMERICIDENTIFIER] + '|' + src[t.NONNUMERICIDENTIFIER] + ')';
    tok('PRERELEASEIDENTIFIERLOOSE');
    src[t.PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[t.NUMERICIDENTIFIERLOOSE] + '|' + src[t.NONNUMERICIDENTIFIER] + ')'; // ## Pre-release Version
    // Hyphen, followed by one or more dot-separated pre-release version
    // identifiers.

    tok('PRERELEASE');
    src[t.PRERELEASE] = '(?:-(' + src[t.PRERELEASEIDENTIFIER] + '(?:\\.' + src[t.PRERELEASEIDENTIFIER] + ')*))';
    tok('PRERELEASELOOSE');
    src[t.PRERELEASELOOSE] = '(?:-?(' + src[t.PRERELEASEIDENTIFIERLOOSE] + '(?:\\.' + src[t.PRERELEASEIDENTIFIERLOOSE] + ')*))'; // ## Build Metadata Identifier
    // Any combination of digits, letters, or hyphens.

    tok('BUILDIDENTIFIER');
    src[t.BUILDIDENTIFIER] = '[0-9A-Za-z-]+'; // ## Build Metadata
    // Plus sign, followed by one or more period-separated build metadata
    // identifiers.

    tok('BUILD');
    src[t.BUILD] = '(?:\\+(' + src[t.BUILDIDENTIFIER] + '(?:\\.' + src[t.BUILDIDENTIFIER] + ')*))'; // ## Full Version String
    // A main version, followed optionally by a pre-release version and
    // build metadata.
    // Note that the only major, minor, patch, and pre-release sections of
    // the version string are capturing groups.  The build metadata is not a
    // capturing group, because it should not ever be used in version
    // comparison.

    tok('FULL');
    tok('FULLPLAIN');
    src[t.FULLPLAIN] = 'v?' + src[t.MAINVERSION] + src[t.PRERELEASE] + '?' + src[t.BUILD] + '?';
    src[t.FULL] = '^' + src[t.FULLPLAIN] + '$'; // like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
    // also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
    // common in the npm registry.

    tok('LOOSEPLAIN');
    src[t.LOOSEPLAIN] = '[v=\\s]*' + src[t.MAINVERSIONLOOSE] + src[t.PRERELEASELOOSE] + '?' + src[t.BUILD] + '?';
    tok('LOOSE');
    src[t.LOOSE] = '^' + src[t.LOOSEPLAIN] + '$';
    tok('GTLT');
    src[t.GTLT] = '((?:<|>)?=?)'; // Something like "2.*" or "1.2.x".
    // Note that "x.x" is a valid xRange identifer, meaning "any version"
    // Only the first item is strictly required.

    tok('XRANGEIDENTIFIERLOOSE');
    src[t.XRANGEIDENTIFIERLOOSE] = src[t.NUMERICIDENTIFIERLOOSE] + '|x|X|\\*';
    tok('XRANGEIDENTIFIER');
    src[t.XRANGEIDENTIFIER] = src[t.NUMERICIDENTIFIER] + '|x|X|\\*';
    tok('XRANGEPLAIN');
    src[t.XRANGEPLAIN] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIER] + ')' + '(?:' + src[t.PRERELEASE] + ')?' + src[t.BUILD] + '?' + ')?)?';
    tok('XRANGEPLAINLOOSE');
    src[t.XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:\\.(' + src[t.XRANGEIDENTIFIERLOOSE] + ')' + '(?:' + src[t.PRERELEASELOOSE] + ')?' + src[t.BUILD] + '?' + ')?)?';
    tok('XRANGE');
    src[t.XRANGE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAIN] + '$';
    tok('XRANGELOOSE');
    src[t.XRANGELOOSE] = '^' + src[t.GTLT] + '\\s*' + src[t.XRANGEPLAINLOOSE] + '$'; // Coercion.
    // Extract anything that could conceivably be a part of a valid semver

    tok('COERCE');
    src[t.COERCE] = '(^|[^\\d])' + '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' + '(?:$|[^\\d])';
    tok('COERCERTL');
    re[t.COERCERTL] = new RegExp(src[t.COERCE], 'g'); // Tilde ranges.
    // Meaning is "reasonably at or greater than"

    tok('LONETILDE');
    src[t.LONETILDE] = '(?:~>?)';
    tok('TILDETRIM');
    src[t.TILDETRIM] = '(\\s*)' + src[t.LONETILDE] + '\\s+';
    re[t.TILDETRIM] = new RegExp(src[t.TILDETRIM], 'g');
    var tildeTrimReplace = '$1~';
    tok('TILDE');
    src[t.TILDE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAIN] + '$';
    tok('TILDELOOSE');
    src[t.TILDELOOSE] = '^' + src[t.LONETILDE] + src[t.XRANGEPLAINLOOSE] + '$'; // Caret ranges.
    // Meaning is "at least and backwards compatible with"

    tok('LONECARET');
    src[t.LONECARET] = '(?:\\^)';
    tok('CARETTRIM');
    src[t.CARETTRIM] = '(\\s*)' + src[t.LONECARET] + '\\s+';
    re[t.CARETTRIM] = new RegExp(src[t.CARETTRIM], 'g');
    var caretTrimReplace = '$1^';
    tok('CARET');
    src[t.CARET] = '^' + src[t.LONECARET] + src[t.XRANGEPLAIN] + '$';
    tok('CARETLOOSE');
    src[t.CARETLOOSE] = '^' + src[t.LONECARET] + src[t.XRANGEPLAINLOOSE] + '$'; // A simple gt/lt/eq thing, or just "" to indicate "any version"

    tok('COMPARATORLOOSE');
    src[t.COMPARATORLOOSE] = '^' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + ')$|^$';
    tok('COMPARATOR');
    src[t.COMPARATOR] = '^' + src[t.GTLT] + '\\s*(' + src[t.FULLPLAIN] + ')$|^$'; // An expression to strip any whitespace between the gtlt and the thing
    // it modifies, so that `> 1.2.3` ==> `>1.2.3`

    tok('COMPARATORTRIM');
    src[t.COMPARATORTRIM] = '(\\s*)' + src[t.GTLT] + '\\s*(' + src[t.LOOSEPLAIN] + '|' + src[t.XRANGEPLAIN] + ')'; // this one has to use the /g flag

    re[t.COMPARATORTRIM] = new RegExp(src[t.COMPARATORTRIM], 'g');
    var comparatorTrimReplace = '$1$2$3'; // Something like `1.2.3 - 1.2.4`
    // Note that these all use the loose form, because they'll be
    // checked against either the strict or loose comparator form
    // later.

    tok('HYPHENRANGE');
    src[t.HYPHENRANGE] = '^\\s*(' + src[t.XRANGEPLAIN] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAIN] + ')' + '\\s*$';
    tok('HYPHENRANGELOOSE');
    src[t.HYPHENRANGELOOSE] = '^\\s*(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s+-\\s+' + '(' + src[t.XRANGEPLAINLOOSE] + ')' + '\\s*$'; // Star ranges basically just allow anything at all.

    tok('STAR');
    src[t.STAR] = '(<|>)?=?\\s*\\*'; // Compile to actual regexp objects.
    // All are flag-free, unless they were created above with a flag.

    for (var i = 0; i < R; i++) {
      debug(i, src[i]);

      if (!re[i]) {
        re[i] = new RegExp(src[i]);
      }
    }

    exports.parse = parse;

    function parse(version, options) {
      if (!options || _typeof(options) !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (version instanceof SemVer) {
        return version;
      }

      if (typeof version !== 'string') {
        return null;
      }

      if (version.length > MAX_LENGTH) {
        return null;
      }

      var r = options.loose ? re[t.LOOSE] : re[t.FULL];

      if (!r.test(version)) {
        return null;
      }

      try {
        return new SemVer(version, options);
      } catch (er) {
        return null;
      }
    }

    exports.valid = valid;

    function valid(version, options) {
      var v = parse(version, options);
      return v ? v.version : null;
    }

    exports.clean = clean;

    function clean(version, options) {
      var s = parse(version.trim().replace(/^[=v]+/, ''), options);
      return s ? s.version : null;
    }

    exports.SemVer = SemVer;

    function SemVer(version, options) {
      if (!options || _typeof(options) !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (version instanceof SemVer) {
        if (version.loose === options.loose) {
          return version;
        } else {
          version = version.version;
        }
      } else if (typeof version !== 'string') {
        throw new TypeError('Invalid Version: ' + version);
      }

      if (version.length > MAX_LENGTH) {
        throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters');
      }

      if (!(this instanceof SemVer)) {
        return new SemVer(version, options);
      }

      debug('SemVer', version, options);
      this.options = options;
      this.loose = !!options.loose;
      var m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);

      if (!m) {
        throw new TypeError('Invalid Version: ' + version);
      }

      this.raw = version; // these are actually numbers

      this.major = +m[1];
      this.minor = +m[2];
      this.patch = +m[3];

      if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
        throw new TypeError('Invalid major version');
      }

      if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
        throw new TypeError('Invalid minor version');
      }

      if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
        throw new TypeError('Invalid patch version');
      } // numberify any prerelease numeric ids


      if (!m[4]) {
        this.prerelease = [];
      } else {
        this.prerelease = m[4].split('.').map(function (id) {
          if (/^[0-9]+$/.test(id)) {
            var num = +id;

            if (num >= 0 && num < MAX_SAFE_INTEGER) {
              return num;
            }
          }

          return id;
        });
      }

      this.build = m[5] ? m[5].split('.') : [];
      this.format();
    }

    SemVer.prototype.format = function () {
      this.version = this.major + '.' + this.minor + '.' + this.patch;

      if (this.prerelease.length) {
        this.version += '-' + this.prerelease.join('.');
      }

      return this.version;
    };

    SemVer.prototype.toString = function () {
      return this.version;
    };

    SemVer.prototype.compare = function (other) {
      debug('SemVer.compare', this.version, this.options, other);

      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      return this.compareMain(other) || this.comparePre(other);
    };

    SemVer.prototype.compareMain = function (other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    };

    SemVer.prototype.comparePre = function (other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      } // NOT having a prerelease is > having one


      if (this.prerelease.length && !other.prerelease.length) {
        return -1;
      } else if (!this.prerelease.length && other.prerelease.length) {
        return 1;
      } else if (!this.prerelease.length && !other.prerelease.length) {
        return 0;
      }

      var i = 0;

      do {
        var a = this.prerelease[i];
        var b = other.prerelease[i];
        debug('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    };

    SemVer.prototype.compareBuild = function (other) {
      if (!(other instanceof SemVer)) {
        other = new SemVer(other, this.options);
      }

      var i = 0;

      do {
        var a = this.build[i];
        var b = other.build[i];
        debug('prerelease compare', i, a, b);

        if (a === undefined && b === undefined) {
          return 0;
        } else if (b === undefined) {
          return 1;
        } else if (a === undefined) {
          return -1;
        } else if (a === b) {
          continue;
        } else {
          return compareIdentifiers(a, b);
        }
      } while (++i);
    }; // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.


    SemVer.prototype.inc = function (release, identifier) {
      switch (release) {
        case 'premajor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor = 0;
          this.major++;
          this.inc('pre', identifier);
          break;

        case 'preminor':
          this.prerelease.length = 0;
          this.patch = 0;
          this.minor++;
          this.inc('pre', identifier);
          break;

        case 'prepatch':
          // If this is already a prerelease, it will bump to the next version
          // drop any prereleases that might already exist, since they are not
          // relevant at this point.
          this.prerelease.length = 0;
          this.inc('patch', identifier);
          this.inc('pre', identifier);
          break;
        // If the input is a non-prerelease version, this acts the same as
        // prepatch.

        case 'prerelease':
          if (this.prerelease.length === 0) {
            this.inc('patch', identifier);
          }

          this.inc('pre', identifier);
          break;

        case 'major':
          // If this is a pre-major version, bump up to the same major version.
          // Otherwise increment major.
          // 1.0.0-5 bumps to 1.0.0
          // 1.1.0 bumps to 2.0.0
          if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
            this.major++;
          }

          this.minor = 0;
          this.patch = 0;
          this.prerelease = [];
          break;

        case 'minor':
          // If this is a pre-minor version, bump up to the same minor version.
          // Otherwise increment minor.
          // 1.2.0-5 bumps to 1.2.0
          // 1.2.1 bumps to 1.3.0
          if (this.patch !== 0 || this.prerelease.length === 0) {
            this.minor++;
          }

          this.patch = 0;
          this.prerelease = [];
          break;

        case 'patch':
          // If this is not a pre-release version, it will increment the patch.
          // If it is a pre-release it will bump up to the same patch version.
          // 1.2.0-5 patches to 1.2.0
          // 1.2.0 patches to 1.2.1
          if (this.prerelease.length === 0) {
            this.patch++;
          }

          this.prerelease = [];
          break;
        // This probably shouldn't be used publicly.
        // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.

        case 'pre':
          if (this.prerelease.length === 0) {
            this.prerelease = [0];
          } else {
            var i = this.prerelease.length;

            while (--i >= 0) {
              if (typeof this.prerelease[i] === 'number') {
                this.prerelease[i]++;
                i = -2;
              }
            }

            if (i === -1) {
              // didn't increment anything
              this.prerelease.push(0);
            }
          }

          if (identifier) {
            // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
            // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
            if (this.prerelease[0] === identifier) {
              if (isNaN(this.prerelease[1])) {
                this.prerelease = [identifier, 0];
              }
            } else {
              this.prerelease = [identifier, 0];
            }
          }

          break;

        default:
          throw new Error('invalid increment argument: ' + release);
      }

      this.format();
      this.raw = this.version;
      return this;
    };

    exports.inc = inc;

    function inc(version, release, loose, identifier) {
      if (typeof loose === 'string') {
        identifier = loose;
        loose = undefined;
      }

      try {
        return new SemVer(version, loose).inc(release, identifier).version;
      } catch (er) {
        return null;
      }
    }

    exports.diff = diff;

    function diff(version1, version2) {
      if (eq(version1, version2)) {
        return null;
      } else {
        var v1 = parse(version1);
        var v2 = parse(version2);
        var prefix = '';

        if (v1.prerelease.length || v2.prerelease.length) {
          prefix = 'pre';
          var defaultResult = 'prerelease';
        }

        for (var key in v1) {
          if (key === 'major' || key === 'minor' || key === 'patch') {
            if (v1[key] !== v2[key]) {
              return prefix + key;
            }
          }
        }

        return defaultResult; // may be undefined
      }
    }

    exports.compareIdentifiers = compareIdentifiers;
    var numeric = /^[0-9]+$/;

    function compareIdentifiers(a, b) {
      var anum = numeric.test(a);
      var bnum = numeric.test(b);

      if (anum && bnum) {
        a = +a;
        b = +b;
      }

      return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
    }

    exports.rcompareIdentifiers = rcompareIdentifiers;

    function rcompareIdentifiers(a, b) {
      return compareIdentifiers(b, a);
    }

    exports.major = major;

    function major(a, loose) {
      return new SemVer(a, loose).major;
    }

    exports.minor = minor;

    function minor(a, loose) {
      return new SemVer(a, loose).minor;
    }

    exports.patch = patch;

    function patch(a, loose) {
      return new SemVer(a, loose).patch;
    }

    exports.compare = compare;

    function compare(a, b, loose) {
      return new SemVer(a, loose).compare(new SemVer(b, loose));
    }

    exports.compareLoose = compareLoose;

    function compareLoose(a, b) {
      return compare(a, b, true);
    }

    exports.compareBuild = compareBuild;

    function compareBuild(a, b, loose) {
      var versionA = new SemVer(a, loose);
      var versionB = new SemVer(b, loose);
      return versionA.compare(versionB) || versionA.compareBuild(versionB);
    }

    exports.rcompare = rcompare;

    function rcompare(a, b, loose) {
      return compare(b, a, loose);
    }

    exports.sort = sort;

    function sort(list, loose) {
      return list.sort(function (a, b) {
        return exports.compareBuild(a, b, loose);
      });
    }

    exports.rsort = rsort;

    function rsort(list, loose) {
      return list.sort(function (a, b) {
        return exports.compareBuild(b, a, loose);
      });
    }

    exports.gt = gt;

    function gt(a, b, loose) {
      return compare(a, b, loose) > 0;
    }

    exports.lt = lt;

    function lt(a, b, loose) {
      return compare(a, b, loose) < 0;
    }

    exports.eq = eq;

    function eq(a, b, loose) {
      return compare(a, b, loose) === 0;
    }

    exports.neq = neq;

    function neq(a, b, loose) {
      return compare(a, b, loose) !== 0;
    }

    exports.gte = gte;

    function gte(a, b, loose) {
      return compare(a, b, loose) >= 0;
    }

    exports.lte = lte;

    function lte(a, b, loose) {
      return compare(a, b, loose) <= 0;
    }

    exports.cmp = cmp;

    function cmp(a, op, b, loose) {
      switch (op) {
        case '===':
          if (_typeof(a) === 'object') a = a.version;
          if (_typeof(b) === 'object') b = b.version;
          return a === b;

        case '!==':
          if (_typeof(a) === 'object') a = a.version;
          if (_typeof(b) === 'object') b = b.version;
          return a !== b;

        case '':
        case '=':
        case '==':
          return eq(a, b, loose);

        case '!=':
          return neq(a, b, loose);

        case '>':
          return gt(a, b, loose);

        case '>=':
          return gte(a, b, loose);

        case '<':
          return lt(a, b, loose);

        case '<=':
          return lte(a, b, loose);

        default:
          throw new TypeError('Invalid operator: ' + op);
      }
    }

    exports.Comparator = Comparator;

    function Comparator(comp, options) {
      if (!options || _typeof(options) !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (comp instanceof Comparator) {
        if (comp.loose === !!options.loose) {
          return comp;
        } else {
          comp = comp.value;
        }
      }

      if (!(this instanceof Comparator)) {
        return new Comparator(comp, options);
      }

      debug('comparator', comp, options);
      this.options = options;
      this.loose = !!options.loose;
      this.parse(comp);

      if (this.semver === ANY) {
        this.value = '';
      } else {
        this.value = this.operator + this.semver.version;
      }

      debug('comp', this);
    }

    var ANY = {};

    Comparator.prototype.parse = function (comp) {
      var r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var m = comp.match(r);

      if (!m) {
        throw new TypeError('Invalid comparator: ' + comp);
      }

      this.operator = m[1] !== undefined ? m[1] : '';

      if (this.operator === '=') {
        this.operator = '';
      } // if it literally is just '>' or '' then allow anything.


      if (!m[2]) {
        this.semver = ANY;
      } else {
        this.semver = new SemVer(m[2], this.options.loose);
      }
    };

    Comparator.prototype.toString = function () {
      return this.value;
    };

    Comparator.prototype.test = function (version) {
      debug('Comparator.test', version, this.options.loose);

      if (this.semver === ANY || version === ANY) {
        return true;
      }

      if (typeof version === 'string') {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }

      return cmp(version, this.operator, this.semver, this.options);
    };

    Comparator.prototype.intersects = function (comp, options) {
      if (!(comp instanceof Comparator)) {
        throw new TypeError('a Comparator is required');
      }

      if (!options || _typeof(options) !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      var rangeTmp;

      if (this.operator === '') {
        if (this.value === '') {
          return true;
        }

        rangeTmp = new Range(comp.value, options);
        return satisfies(this.value, rangeTmp, options);
      } else if (comp.operator === '') {
        if (comp.value === '') {
          return true;
        }

        rangeTmp = new Range(this.value, options);
        return satisfies(comp.semver, rangeTmp, options);
      }

      var sameDirectionIncreasing = (this.operator === '>=' || this.operator === '>') && (comp.operator === '>=' || comp.operator === '>');
      var sameDirectionDecreasing = (this.operator === '<=' || this.operator === '<') && (comp.operator === '<=' || comp.operator === '<');
      var sameSemVer = this.semver.version === comp.semver.version;
      var differentDirectionsInclusive = (this.operator === '>=' || this.operator === '<=') && (comp.operator === '>=' || comp.operator === '<=');
      var oppositeDirectionsLessThan = cmp(this.semver, '<', comp.semver, options) && (this.operator === '>=' || this.operator === '>') && (comp.operator === '<=' || comp.operator === '<');
      var oppositeDirectionsGreaterThan = cmp(this.semver, '>', comp.semver, options) && (this.operator === '<=' || this.operator === '<') && (comp.operator === '>=' || comp.operator === '>');
      return sameDirectionIncreasing || sameDirectionDecreasing || sameSemVer && differentDirectionsInclusive || oppositeDirectionsLessThan || oppositeDirectionsGreaterThan;
    };

    exports.Range = Range;

    function Range(range, options) {
      if (!options || _typeof(options) !== 'object') {
        options = {
          loose: !!options,
          includePrerelease: false
        };
      }

      if (range instanceof Range) {
        if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
          return range;
        } else {
          return new Range(range.raw, options);
        }
      }

      if (range instanceof Comparator) {
        return new Range(range.value, options);
      }

      if (!(this instanceof Range)) {
        return new Range(range, options);
      }

      this.options = options;
      this.loose = !!options.loose;
      this.includePrerelease = !!options.includePrerelease; // First, split based on boolean or ||

      this.raw = range;
      this.set = range.split(/\s*\|\|\s*/).map(function (range) {
        return this.parseRange(range.trim());
      }, this).filter(function (c) {
        // throw out any that are not relevant for whatever reason
        return c.length;
      });

      if (!this.set.length) {
        throw new TypeError('Invalid SemVer Range: ' + range);
      }

      this.format();
    }

    Range.prototype.format = function () {
      this.range = this.set.map(function (comps) {
        return comps.join(' ').trim();
      }).join('||').trim();
      return this.range;
    };

    Range.prototype.toString = function () {
      return this.range;
    };

    Range.prototype.parseRange = function (range) {
      var loose = this.options.loose;
      range = range.trim(); // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`

      var hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
      range = range.replace(hr, hyphenReplace);
      debug('hyphen replace', range); // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`

      range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
      debug('comparator trim', range, re[t.COMPARATORTRIM]); // `~ 1.2.3` => `~1.2.3`

      range = range.replace(re[t.TILDETRIM], tildeTrimReplace); // `^ 1.2.3` => `^1.2.3`

      range = range.replace(re[t.CARETTRIM], caretTrimReplace); // normalize spaces

      range = range.split(/\s+/).join(' '); // At this point, the range is completely trimmed and
      // ready to be split into comparators.

      var compRe = loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
      var set = range.split(' ').map(function (comp) {
        return parseComparator(comp, this.options);
      }, this).join(' ').split(/\s+/);

      if (this.options.loose) {
        // in loose mode, throw out any that are not valid comparators
        set = set.filter(function (comp) {
          return !!comp.match(compRe);
        });
      }

      set = set.map(function (comp) {
        return new Comparator(comp, this.options);
      }, this);
      return set;
    };

    Range.prototype.intersects = function (range, options) {
      if (!(range instanceof Range)) {
        throw new TypeError('a Range is required');
      }

      return this.set.some(function (thisComparators) {
        return isSatisfiable(thisComparators, options) && range.set.some(function (rangeComparators) {
          return isSatisfiable(rangeComparators, options) && thisComparators.every(function (thisComparator) {
            return rangeComparators.every(function (rangeComparator) {
              return thisComparator.intersects(rangeComparator, options);
            });
          });
        });
      });
    }; // take a set of comparators and determine whether there
    // exists a version which can satisfy it


    function isSatisfiable(comparators, options) {
      var result = true;
      var remainingComparators = comparators.slice();
      var testComparator = remainingComparators.pop();

      while (result && remainingComparators.length) {
        result = remainingComparators.every(function (otherComparator) {
          return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
      }

      return result;
    } // Mostly just for testing and legacy API reasons


    exports.toComparators = toComparators;

    function toComparators(range, options) {
      return new Range(range, options).set.map(function (comp) {
        return comp.map(function (c) {
          return c.value;
        }).join(' ').trim().split(' ');
      });
    } // comprised of xranges, tildes, stars, and gtlt's at this point.
    // already replaced the hyphen ranges
    // turn into a set of JUST comparators.


    function parseComparator(comp, options) {
      debug('comp', comp, options);
      comp = replaceCarets(comp, options);
      debug('caret', comp);
      comp = replaceTildes(comp, options);
      debug('tildes', comp);
      comp = replaceXRanges(comp, options);
      debug('xrange', comp);
      comp = replaceStars(comp, options);
      debug('stars', comp);
      return comp;
    }

    function isX(id) {
      return !id || id.toLowerCase() === 'x' || id === '*';
    } // ~, ~> --> * (any, kinda silly)
    // ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
    // ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
    // ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
    // ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
    // ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0


    function replaceTildes(comp, options) {
      return comp.trim().split(/\s+/).map(function (comp) {
        return replaceTilde(comp, options);
      }).join(' ');
    }

    function replaceTilde(comp, options) {
      var r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
      return comp.replace(r, function (_, M, m, p, pr) {
        debug('tilde', comp, _, M, m, p, pr);
        var ret;

        if (isX(M)) {
          ret = '';
        } else if (isX(m)) {
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        } else if (isX(p)) {
          // ~1.2 == >=1.2.0 <1.3.0
          ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
        } else if (pr) {
          debug('replaceTilde pr', pr);
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
        } else {
          // ~1.2.3 == >=1.2.3 <1.3.0
          ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
        }

        debug('tilde return', ret);
        return ret;
      });
    } // ^ --> * (any, kinda silly)
    // ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
    // ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
    // ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
    // ^1.2.3 --> >=1.2.3 <2.0.0
    // ^1.2.0 --> >=1.2.0 <2.0.0


    function replaceCarets(comp, options) {
      return comp.trim().split(/\s+/).map(function (comp) {
        return replaceCaret(comp, options);
      }).join(' ');
    }

    function replaceCaret(comp, options) {
      debug('caret', comp, options);
      var r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
      return comp.replace(r, function (_, M, m, p, pr) {
        debug('caret', comp, _, M, m, p, pr);
        var ret;

        if (isX(M)) {
          ret = '';
        } else if (isX(m)) {
          ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0';
        } else if (isX(p)) {
          if (M === '0') {
            ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0';
          } else {
            ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0';
          }
        } else if (pr) {
          debug('replaceCaret pr', pr);

          if (M === '0') {
            if (m === '0') {
              ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + m + '.' + (+p + 1);
            } else {
              ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + M + '.' + (+m + 1) + '.0';
            }
          } else {
            ret = '>=' + M + '.' + m + '.' + p + '-' + pr + ' <' + (+M + 1) + '.0.0';
          }
        } else {
          debug('no pr');

          if (M === '0') {
            if (m === '0') {
              ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + m + '.' + (+p + 1);
            } else {
              ret = '>=' + M + '.' + m + '.' + p + ' <' + M + '.' + (+m + 1) + '.0';
            }
          } else {
            ret = '>=' + M + '.' + m + '.' + p + ' <' + (+M + 1) + '.0.0';
          }
        }

        debug('caret return', ret);
        return ret;
      });
    }

    function replaceXRanges(comp, options) {
      debug('replaceXRanges', comp, options);
      return comp.split(/\s+/).map(function (comp) {
        return replaceXRange(comp, options);
      }).join(' ');
    }

    function replaceXRange(comp, options) {
      comp = comp.trim();
      var r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
      return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
        debug('xRange', comp, ret, gtlt, M, m, p, pr);
        var xM = isX(M);
        var xm = xM || isX(m);
        var xp = xm || isX(p);
        var anyX = xp;

        if (gtlt === '=' && anyX) {
          gtlt = '';
        } // if we're including prereleases in the match, then we need
        // to fix this to -0, the lowest possible prerelease value


        pr = options.includePrerelease ? '-0' : '';

        if (xM) {
          if (gtlt === '>' || gtlt === '<') {
            // nothing is allowed
            ret = '<0.0.0-0';
          } else {
            // nothing is forbidden
            ret = '*';
          }
        } else if (gtlt && anyX) {
          // we know patch is an x, because we have any x at all.
          // replace X with 0
          if (xm) {
            m = 0;
          }

          p = 0;

          if (gtlt === '>') {
            // >1 => >=2.0.0
            // >1.2 => >=1.3.0
            // >1.2.3 => >= 1.2.4
            gtlt = '>=';

            if (xm) {
              M = +M + 1;
              m = 0;
              p = 0;
            } else {
              m = +m + 1;
              p = 0;
            }
          } else if (gtlt === '<=') {
            // <=0.7.x is actually <0.8.0, since any 0.7.x should
            // pass.  Similarly, <=7.x is actually <8.0.0, etc.
            gtlt = '<';

            if (xm) {
              M = +M + 1;
            } else {
              m = +m + 1;
            }
          }

          ret = gtlt + M + '.' + m + '.' + p + pr;
        } else if (xm) {
          ret = '>=' + M + '.0.0' + pr + ' <' + (+M + 1) + '.0.0' + pr;
        } else if (xp) {
          ret = '>=' + M + '.' + m + '.0' + pr + ' <' + M + '.' + (+m + 1) + '.0' + pr;
        }

        debug('xRange return', ret);
        return ret;
      });
    } // Because * is AND-ed with everything else in the comparator,
    // and '' means "any version", just remove the *s entirely.


    function replaceStars(comp, options) {
      debug('replaceStars', comp, options); // Looseness is ignored here.  star is always as loose as it gets!

      return comp.trim().replace(re[t.STAR], '');
    } // This function is passed to string.replace(re[t.HYPHENRANGE])
    // M, m, patch, prerelease, build
    // 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
    // 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
    // 1.2 - 3.4 => >=1.2.0 <3.5.0


    function hyphenReplace($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb) {
      if (isX(fM)) {
        from = '';
      } else if (isX(fm)) {
        from = '>=' + fM + '.0.0';
      } else if (isX(fp)) {
        from = '>=' + fM + '.' + fm + '.0';
      } else {
        from = '>=' + from;
      }

      if (isX(tM)) {
        to = '';
      } else if (isX(tm)) {
        to = '<' + (+tM + 1) + '.0.0';
      } else if (isX(tp)) {
        to = '<' + tM + '.' + (+tm + 1) + '.0';
      } else if (tpr) {
        to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr;
      } else {
        to = '<=' + to;
      }

      return (from + ' ' + to).trim();
    } // if ANY of the sets match ALL of its comparators, then pass


    Range.prototype.test = function (version) {
      if (!version) {
        return false;
      }

      if (typeof version === 'string') {
        try {
          version = new SemVer(version, this.options);
        } catch (er) {
          return false;
        }
      }

      for (var i = 0; i < this.set.length; i++) {
        if (testSet(this.set[i], version, this.options)) {
          return true;
        }
      }

      return false;
    };

    function testSet(set, version, options) {
      for (var i = 0; i < set.length; i++) {
        if (!set[i].test(version)) {
          return false;
        }
      }

      if (version.prerelease.length && !options.includePrerelease) {
        // Find the set of versions that are allowed to have prereleases
        // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
        // That should allow `1.2.3-pr.2` to pass.
        // However, `1.2.4-alpha.notready` should NOT be allowed,
        // even though it's within the range set by the comparators.
        for (i = 0; i < set.length; i++) {
          debug(set[i].semver);

          if (set[i].semver === ANY) {
            continue;
          }

          if (set[i].semver.prerelease.length > 0) {
            var allowed = set[i].semver;

            if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
              return true;
            }
          }
        } // Version has a -pre, but it's not one of the ones we like.


        return false;
      }

      return true;
    }

    exports.satisfies = satisfies;

    function satisfies(version, range, options) {
      try {
        range = new Range(range, options);
      } catch (er) {
        return false;
      }

      return range.test(version);
    }

    exports.maxSatisfying = maxSatisfying;

    function maxSatisfying(versions, range, options) {
      var max = null;
      var maxSV = null;

      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }

      versions.forEach(function (v) {
        if (rangeObj.test(v)) {
          // satisfies(v, range, options)
          if (!max || maxSV.compare(v) === -1) {
            // compare(max, v, true)
            max = v;
            maxSV = new SemVer(max, options);
          }
        }
      });
      return max;
    }

    exports.minSatisfying = minSatisfying;

    function minSatisfying(versions, range, options) {
      var min = null;
      var minSV = null;

      try {
        var rangeObj = new Range(range, options);
      } catch (er) {
        return null;
      }

      versions.forEach(function (v) {
        if (rangeObj.test(v)) {
          // satisfies(v, range, options)
          if (!min || minSV.compare(v) === 1) {
            // compare(min, v, true)
            min = v;
            minSV = new SemVer(min, options);
          }
        }
      });
      return min;
    }

    exports.minVersion = minVersion;

    function minVersion(range, loose) {
      range = new Range(range, loose);
      var minver = new SemVer('0.0.0');

      if (range.test(minver)) {
        return minver;
      }

      minver = new SemVer('0.0.0-0');

      if (range.test(minver)) {
        return minver;
      }

      minver = null;

      for (var i = 0; i < range.set.length; ++i) {
        var comparators = range.set[i];
        comparators.forEach(function (comparator) {
          // Clone to avoid manipulating the comparator's semver object.
          var compver = new SemVer(comparator.semver.version);

          switch (comparator.operator) {
            case '>':
              if (compver.prerelease.length === 0) {
                compver.patch++;
              } else {
                compver.prerelease.push(0);
              }

              compver.raw = compver.format();

            /* fallthrough */

            case '':
            case '>=':
              if (!minver || gt(minver, compver)) {
                minver = compver;
              }

              break;

            case '<':
            case '<=':
              /* Ignore maximum versions */
              break;

            /* istanbul ignore next */

            default:
              throw new Error('Unexpected operation: ' + comparator.operator);
          }
        });
      }

      if (minver && range.test(minver)) {
        return minver;
      }

      return null;
    }

    exports.validRange = validRange;

    function validRange(range, options) {
      try {
        // Return '*' instead of '' so that truthiness works.
        // This will throw if it's invalid anyway
        return new Range(range, options).range || '*';
      } catch (er) {
        return null;
      }
    } // Determine if version is less than all the versions possible in the range


    exports.ltr = ltr;

    function ltr(version, range, options) {
      return outside(version, range, '<', options);
    } // Determine if version is greater than all the versions possible in the range.


    exports.gtr = gtr;

    function gtr(version, range, options) {
      return outside(version, range, '>', options);
    }

    exports.outside = outside;

    function outside(version, range, hilo, options) {
      version = new SemVer(version, options);
      range = new Range(range, options);
      var gtfn, ltefn, ltfn, comp, ecomp;

      switch (hilo) {
        case '>':
          gtfn = gt;
          ltefn = lte;
          ltfn = lt;
          comp = '>';
          ecomp = '>=';
          break;

        case '<':
          gtfn = lt;
          ltefn = gte;
          ltfn = gt;
          comp = '<';
          ecomp = '<=';
          break;

        default:
          throw new TypeError('Must provide a hilo val of "<" or ">"');
      } // If it satisifes the range it is not outside


      if (satisfies(version, range, options)) {
        return false;
      } // From now on, variable terms are as if we're in "gtr" mode.
      // but note that everything is flipped for the "ltr" function.


      for (var i = 0; i < range.set.length; ++i) {
        var comparators = range.set[i];
        var high = null;
        var low = null;
        comparators.forEach(function (comparator) {
          if (comparator.semver === ANY) {
            comparator = new Comparator('>=0.0.0');
          }

          high = high || comparator;
          low = low || comparator;

          if (gtfn(comparator.semver, high.semver, options)) {
            high = comparator;
          } else if (ltfn(comparator.semver, low.semver, options)) {
            low = comparator;
          }
        }); // If the edge version comparator has a operator then our version
        // isn't outside it

        if (high.operator === comp || high.operator === ecomp) {
          return false;
        } // If the lowest version comparator has an operator and our version
        // is less than it then it isn't higher than the range


        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
          return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
          return false;
        }
      }

      return true;
    }

    exports.prerelease = prerelease;

    function prerelease(version, options) {
      var parsed = parse(version, options);
      return parsed && parsed.prerelease.length ? parsed.prerelease : null;
    }

    exports.intersects = intersects;

    function intersects(r1, r2, options) {
      r1 = new Range(r1, options);
      r2 = new Range(r2, options);
      return r1.intersects(r2);
    }

    exports.coerce = coerce;

    function coerce(version, options) {
      if (version instanceof SemVer) {
        return version;
      }

      if (typeof version === 'number') {
        version = String(version);
      }

      if (typeof version !== 'string') {
        return null;
      }

      options = options || {};
      var match = null;

      if (!options.rtl) {
        match = version.match(re[t.COERCE]);
      } else {
        // Find the right-most coercible string that does not share
        // a terminus with a more left-ward coercible string.
        // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
        //
        // Walk through the string checking with a /g regexp
        // Manually set the index so as to pick up overlapping matches.
        // Stop when we get a match that ends at the string end, since no
        // coercible string can be more right-ward without the same terminus.
        var next;

        while ((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)) {
          if (!match || next.index + next[0].length !== match.index + match[0].length) {
            match = next;
          }

          re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        } // leave it in a clean state


        re[t.COERCERTL].lastIndex = -1;
      }

      if (match === null) {
        return null;
      }

      return parse(match[2] + '.' + (match[3] || '0') + '.' + (match[4] || '0'), options);
    }
  });
  var semver_1 = semver.SEMVER_SPEC_VERSION;
  var semver_2 = semver.re;
  var semver_3 = semver.src;
  var semver_4 = semver.tokens;
  var semver_5 = semver.parse;
  var semver_6 = semver.valid;
  var semver_7 = semver.clean;
  var semver_8 = semver.SemVer;
  var semver_9 = semver.inc;
  var semver_10 = semver.diff;
  var semver_11 = semver.compareIdentifiers;
  var semver_12 = semver.rcompareIdentifiers;
  var semver_13 = semver.major;
  var semver_14 = semver.minor;
  var semver_15 = semver.patch;
  var semver_16 = semver.compare;
  var semver_17 = semver.compareLoose;
  var semver_18 = semver.compareBuild;
  var semver_19 = semver.rcompare;
  var semver_20 = semver.sort;
  var semver_21 = semver.rsort;
  var semver_22 = semver.gt;
  var semver_23 = semver.lt;
  var semver_24 = semver.eq;
  var semver_25 = semver.neq;
  var semver_26 = semver.gte;
  var semver_27 = semver.lte;
  var semver_28 = semver.cmp;
  var semver_29 = semver.Comparator;
  var semver_30 = semver.Range;
  var semver_31 = semver.toComparators;
  var semver_32 = semver.satisfies;
  var semver_33 = semver.maxSatisfying;
  var semver_34 = semver.minSatisfying;
  var semver_35 = semver.minVersion;
  var semver_36 = semver.validRange;
  var semver_37 = semver.ltr;
  var semver_38 = semver.gtr;
  var semver_39 = semver.outside;
  var semver_40 = semver.prerelease;
  var semver_41 = semver.intersects;
  var semver_42 = semver.coerce;

  var arrayify = function arrayify(object, keyName) {
    return Object.keys(object).reduce(function (array, key) {
      return array.concat(Object.assign(_defineProperty({}, keyName, key), object[key]));
    }, []);
  };

  var dedent_1 = createCommonjsModule(function (module) {

    function dedent(strings) {
      var raw = void 0;

      if (typeof strings === "string") {
        // dedent can be used as a plain function
        raw = [strings];
      } else {
        raw = strings.raw;
      } // first, perform interpolation


      var result = "";

      for (var i = 0; i < raw.length; i++) {
        result += raw[i]. // join lines when there is a suppressed newline
        replace(/\\\n[ \t]*/g, ""). // handle escaped backticks
        replace(/\\`/g, "`");

        if (i < (arguments.length <= 1 ? 0 : arguments.length - 1)) {
          result += arguments.length <= i + 1 ? undefined : arguments[i + 1];
        }
      } // now strip indentation


      var lines = result.split("\n");
      var mindent = null;
      lines.forEach(function (l) {
        var m = l.match(/^(\s+)\S+/);

        if (m) {
          var indent = m[1].length;

          if (!mindent) {
            // this is the first indented line
            mindent = indent;
          } else {
            mindent = Math.min(mindent, indent);
          }
        }
      });

      if (mindent !== null) {
        result = lines.map(function (l) {
          return l[0] === " " ? l.slice(mindent) : l;
        }).join("\n");
      } // dedent eats leading and trailing whitespace too


      result = result.trim(); // handle escaped newlines at the end to ensure they don't get stripped too

      return result.replace(/\\n/g, "\n");
    }

    {
      module.exports = dedent;
    }
  });

  function _templateObject6() {
    var data = _taggedTemplateLiteral(["\n      Require either '@prettier' or '@format' to be present in the file's first docblock comment\n      in order for it to be formatted.\n    "]);

    _templateObject6 = function _templateObject6() {
      return data;
    };

    return data;
  }

  function _templateObject5() {
    var data = _taggedTemplateLiteral(["\n      Format code starting at a given character offset.\n      The range will extend backwards to the start of the first line containing the selected statement.\n      This option cannot be used with --cursor-offset.\n    "]);

    _templateObject5 = function _templateObject5() {
      return data;
    };

    return data;
  }

  function _templateObject4() {
    var data = _taggedTemplateLiteral(["\n      Format code ending at a given character offset (exclusive).\n      The range will extend forwards to the end of the selected statement.\n      This option cannot be used with --cursor-offset.\n    "]);

    _templateObject4 = function _templateObject4() {
      return data;
    };

    return data;
  }

  function _templateObject3() {
    var data = _taggedTemplateLiteral(["\n      Custom directory that contains prettier plugins in node_modules subdirectory.\n      Overrides default behavior when plugins are searched relatively to the location of Prettier.\n      Multiple values are accepted.\n    "]);

    _templateObject3 = function _templateObject3() {
      return data;
    };

    return data;
  }

  function _templateObject2() {
    var data = _taggedTemplateLiteral(["\n          Maintain existing\n          (mixed values within one file are normalised by looking at what's used after the first line)\n        "]);

    _templateObject2 = function _templateObject2() {
      return data;
    };

    return data;
  }

  function _templateObject() {
    var data = _taggedTemplateLiteral(["\n      Print (to stderr) where a cursor at the given position would move to after formatting.\n      This option cannot be used with --range-start and --range-end.\n    "]);

    _templateObject = function _templateObject() {
      return data;
    };

    return data;
  }

  var CATEGORY_CONFIG = "Config";
  var CATEGORY_EDITOR = "Editor";
  var CATEGORY_FORMAT = "Format";
  var CATEGORY_OTHER = "Other";
  var CATEGORY_OUTPUT = "Output";
  var CATEGORY_GLOBAL = "Global";
  var CATEGORY_SPECIAL = "Special";
  /**
   * @typedef {Object} OptionInfo
   * @property {string} [since] - available since version
   * @property {string} category
   * @property {'int' | 'boolean' | 'choice' | 'path'} type
   * @property {boolean} [array] - indicate it's an array of the specified type
   * @property {OptionValueInfo} [default]
   * @property {OptionRangeInfo} [range] - for type int
   * @property {string} description
   * @property {string} [deprecated] - deprecated since version
   * @property {OptionRedirectInfo} [redirect] - redirect deprecated option
   * @property {(value: any) => boolean} [exception]
   * @property {OptionChoiceInfo[]} [choices] - for type choice
   * @property {string} [cliName]
   * @property {string} [cliCategory]
   * @property {string} [cliDescription]
   *
   * @typedef {number | boolean | string} OptionValue
   * @typedef {OptionValue | [{ value: OptionValue[] }] | Array<{ since: string, value: OptionValue}>} OptionValueInfo
   *
   * @typedef {Object} OptionRedirectInfo
   * @property {string} option
   * @property {OptionValue} value
   *
   * @typedef {Object} OptionRangeInfo
   * @property {number} start - recommended range start
   * @property {number} end - recommended range end
   * @property {number} step - recommended range step
   *
   * @typedef {Object} OptionChoiceInfo
   * @property {boolean | string} value - boolean for the option that is originally boolean type
   * @property {string} description
   * @property {string} [since] - undefined if available since the first version of the option
   * @property {string} [deprecated] - deprecated since version
   * @property {OptionValueInfo} [redirect] - redirect deprecated value
   */

  /** @type {{ [name: string]: OptionInfo }} */

  var options = {
    cursorOffset: {
      since: "1.4.0",
      category: CATEGORY_SPECIAL,
      type: "int",
      default: -1,
      range: {
        start: -1,
        end: Infinity,
        step: 1
      },
      description: dedent_1(_templateObject()),
      cliCategory: CATEGORY_EDITOR
    },
    endOfLine: {
      since: "1.15.0",
      category: CATEGORY_GLOBAL,
      type: "choice",
      default: "auto",
      description: "Which end of line characters to apply.",
      choices: [{
        value: "auto",
        description: dedent_1(_templateObject2())
      }, {
        value: "lf",
        description: "Line Feed only (\\n), common on Linux and macOS as well as inside git repos"
      }, {
        value: "crlf",
        description: "Carriage Return + Line Feed characters (\\r\\n), common on Windows"
      }, {
        value: "cr",
        description: "Carriage Return character only (\\r), used very rarely"
      }]
    },
    filepath: {
      since: "1.4.0",
      category: CATEGORY_SPECIAL,
      type: "path",
      description: "Specify the input filepath. This will be used to do parser inference.",
      cliName: "stdin-filepath",
      cliCategory: CATEGORY_OTHER,
      cliDescription: "Path to the file to pretend that stdin comes from."
    },
    insertPragma: {
      since: "1.8.0",
      category: CATEGORY_SPECIAL,
      type: "boolean",
      default: false,
      description: "Insert @format pragma into file's first docblock comment.",
      cliCategory: CATEGORY_OTHER
    },
    parser: {
      since: "0.0.10",
      category: CATEGORY_GLOBAL,
      type: "choice",
      default: [{
        since: "0.0.10",
        value: "babylon"
      }, {
        since: "1.13.0",
        value: undefined
      }],
      description: "Which parser to use.",
      exception: function exception(value) {
        return typeof value === "string" || typeof value === "function";
      },
      choices: [{
        value: "flow",
        description: "Flow"
      }, {
        value: "babylon",
        description: "JavaScript",
        deprecated: "1.16.0",
        redirect: "babel"
      }, {
        value: "babel",
        since: "1.16.0",
        description: "JavaScript"
      }, {
        value: "babel-flow",
        since: "1.16.0",
        description: "Flow"
      }, {
        value: "typescript",
        since: "1.4.0",
        description: "TypeScript"
      }, {
        value: "css",
        since: "1.7.1",
        description: "CSS"
      }, {
        value: "postcss",
        since: "1.4.0",
        description: "CSS/Less/SCSS",
        deprecated: "1.7.1",
        redirect: "css"
      }, {
        value: "less",
        since: "1.7.1",
        description: "Less"
      }, {
        value: "scss",
        since: "1.7.1",
        description: "SCSS"
      }, {
        value: "json",
        since: "1.5.0",
        description: "JSON"
      }, {
        value: "json5",
        since: "1.13.0",
        description: "JSON5"
      }, {
        value: "json-stringify",
        since: "1.13.0",
        description: "JSON.stringify"
      }, {
        value: "graphql",
        since: "1.5.0",
        description: "GraphQL"
      }, {
        value: "markdown",
        since: "1.8.0",
        description: "Markdown"
      }, {
        value: "mdx",
        since: "1.15.0",
        description: "MDX"
      }, {
        value: "vue",
        since: "1.10.0",
        description: "Vue"
      }, {
        value: "yaml",
        since: "1.14.0",
        description: "YAML"
      }, {
        value: "glimmer",
        since: null,
        description: "Handlebars"
      }, {
        value: "html",
        since: "1.15.0",
        description: "HTML"
      }, {
        value: "angular",
        since: "1.15.0",
        description: "Angular"
      }, {
        value: "lwc",
        since: "1.17.0",
        description: "Lightning Web Components"
      }]
    },
    plugins: {
      since: "1.10.0",
      type: "path",
      array: true,
      default: [{
        value: []
      }],
      category: CATEGORY_GLOBAL,
      description: "Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",
      exception: function exception(value) {
        return typeof value === "string" || _typeof(value) === "object";
      },
      cliName: "plugin",
      cliCategory: CATEGORY_CONFIG
    },
    pluginSearchDirs: {
      since: "1.13.0",
      type: "path",
      array: true,
      default: [{
        value: []
      }],
      category: CATEGORY_GLOBAL,
      description: dedent_1(_templateObject3()),
      exception: function exception(value) {
        return typeof value === "string" || _typeof(value) === "object";
      },
      cliName: "plugin-search-dir",
      cliCategory: CATEGORY_CONFIG
    },
    printWidth: {
      since: "0.0.0",
      category: CATEGORY_GLOBAL,
      type: "int",
      default: 80,
      description: "The line length where Prettier will try wrap.",
      range: {
        start: 0,
        end: Infinity,
        step: 1
      }
    },
    rangeEnd: {
      since: "1.4.0",
      category: CATEGORY_SPECIAL,
      type: "int",
      default: Infinity,
      range: {
        start: 0,
        end: Infinity,
        step: 1
      },
      description: dedent_1(_templateObject4()),
      cliCategory: CATEGORY_EDITOR
    },
    rangeStart: {
      since: "1.4.0",
      category: CATEGORY_SPECIAL,
      type: "int",
      default: 0,
      range: {
        start: 0,
        end: Infinity,
        step: 1
      },
      description: dedent_1(_templateObject5()),
      cliCategory: CATEGORY_EDITOR
    },
    requirePragma: {
      since: "1.7.0",
      category: CATEGORY_SPECIAL,
      type: "boolean",
      default: false,
      description: dedent_1(_templateObject6()),
      cliCategory: CATEGORY_OTHER
    },
    tabWidth: {
      type: "int",
      category: CATEGORY_GLOBAL,
      default: 2,
      description: "Number of spaces per indentation level.",
      range: {
        start: 0,
        end: Infinity,
        step: 1
      }
    },
    useFlowParser: {
      since: "0.0.0",
      category: CATEGORY_GLOBAL,
      type: "boolean",
      default: [{
        since: "0.0.0",
        value: false
      }, {
        since: "1.15.0",
        value: undefined
      }],
      deprecated: "0.0.10",
      description: "Use flow parser.",
      redirect: {
        option: "parser",
        value: "flow"
      },
      cliName: "flow-parser"
    },
    useTabs: {
      since: "1.0.0",
      category: CATEGORY_GLOBAL,
      type: "boolean",
      default: false,
      description: "Indent with tabs instead of spaces."
    }
  };
  var coreOptions = {
    CATEGORY_CONFIG: CATEGORY_CONFIG,
    CATEGORY_EDITOR: CATEGORY_EDITOR,
    CATEGORY_FORMAT: CATEGORY_FORMAT,
    CATEGORY_OTHER: CATEGORY_OTHER,
    CATEGORY_OUTPUT: CATEGORY_OUTPUT,
    CATEGORY_GLOBAL: CATEGORY_GLOBAL,
    CATEGORY_SPECIAL: CATEGORY_SPECIAL,
    options: options
  };

  var require$$0 = getCjsExportFromNamespace(_package$1);

  var currentVersion = require$$0.version;
  var coreOptions$1 = coreOptions.options;

  function getSupportInfo(version, opts) {
    opts = Object.assign({
      plugins: [],
      showUnreleased: false,
      showDeprecated: false,
      showInternal: false
    }, opts);

    if (!version) {
      // pre-release version is smaller than the normal version in semver,
      // we need to treat it as the normal one so as to test new features.
      version = currentVersion.split("-", 1)[0];
    }

    var plugins = opts.plugins;
    var options = arrayify(Object.assign(plugins.reduce(function (currentOptions, plugin) {
      return Object.assign(currentOptions, plugin.options);
    }, {}), coreOptions$1), "name").sort(function (a, b) {
      return a.name === b.name ? 0 : a.name < b.name ? -1 : 1;
    }).filter(filterSince).filter(filterDeprecated).map(mapDeprecated).map(mapInternal).map(function (option) {
      var newOption = Object.assign({}, option);

      if (Array.isArray(newOption.default)) {
        newOption.default = newOption.default.length === 1 ? newOption.default[0].value : newOption.default.filter(filterSince).sort(function (info1, info2) {
          return semver.compare(info2.since, info1.since);
        })[0].value;
      }

      if (Array.isArray(newOption.choices)) {
        newOption.choices = newOption.choices.filter(filterSince).filter(filterDeprecated).map(mapDeprecated);
      }

      return newOption;
    }).map(function (option) {
      var filteredPlugins = plugins.filter(function (plugin) {
        return plugin.defaultOptions && plugin.defaultOptions[option.name] !== undefined;
      });
      var pluginDefaults = filteredPlugins.reduce(function (reduced, plugin) {
        reduced[plugin.name] = plugin.defaultOptions[option.name];
        return reduced;
      }, {});
      return Object.assign(option, {
        pluginDefaults: pluginDefaults
      });
    });
    var usePostCssParser = semver.lt(version, "1.7.1");
    var useBabylonParser = semver.lt(version, "1.16.0");
    var languages = plugins.reduce(function (all, plugin) {
      return all.concat(plugin.languages || []);
    }, []).filter(filterSince).map(function (language) {
      // Prevent breaking changes
      if (language.name === "Markdown") {
        return Object.assign({}, language, {
          parsers: ["markdown"]
        });
      }

      if (language.name === "TypeScript") {
        return Object.assign({}, language, {
          parsers: ["typescript"]
        });
      } // "babylon" was renamed to "babel" in 1.16.0


      if (useBabylonParser && language.parsers.indexOf("babel") !== -1) {
        return Object.assign({}, language, {
          parsers: language.parsers.map(function (parser) {
            return parser === "babel" ? "babylon" : parser;
          })
        });
      }

      if (usePostCssParser && (language.name === "CSS" || language.group === "CSS")) {
        return Object.assign({}, language, {
          parsers: ["postcss"]
        });
      }

      return language;
    });
    return {
      languages: languages,
      options: options
    };

    function filterSince(object) {
      return opts.showUnreleased || !("since" in object) || object.since && semver.gte(version, object.since);
    }

    function filterDeprecated(object) {
      return opts.showDeprecated || !("deprecated" in object) || object.deprecated && semver.lt(version, object.deprecated);
    }

    function mapDeprecated(object) {
      if (!object.deprecated || opts.showDeprecated) {
        return object;
      }

      var newObject = Object.assign({}, object);
      delete newObject.deprecated;
      delete newObject.redirect;
      return newObject;
    }

    function mapInternal(object) {
      if (opts.showInternal) {
        return object;
      }

      var newObject = Object.assign({}, object);
      delete newObject.cliName;
      delete newObject.cliCategory;
      delete newObject.cliDescription;
      return newObject;
    }
  }

  var support = {
    getSupportInfo: getSupportInfo
  };

  /*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */

  /* global Reflect, Promise */
  var _extendStatics = function extendStatics(d, b) {
    _extendStatics = Object.setPrototypeOf || {
      __proto__: []
    } instanceof Array && function (d, b) {
      d.__proto__ = b;
    } || function (d, b) {
      for (var p in b) {
        if (b.hasOwnProperty(p)) d[p] = b[p];
      }
    };

    return _extendStatics(d, b);
  };

  function __extends(d, b) {
    _extendStatics(d, b);

    function __() {
      this.constructor = d;
    }

    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
  }

  var _assign = function __assign() {
    _assign = Object.assign || function __assign(t) {
      for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];

        for (var p in s) {
          if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
      }

      return t;
    };

    return _assign.apply(this, arguments);
  };
  function __rest(s, e) {
    var t = {};

    for (var p in s) {
      if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];
    }

    if (s != null && typeof Object.getOwnPropertySymbols === "function") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];
    }
    return t;
  }
  function __decorate(decorators, target, key, desc) {
    var c = arguments.length,
        r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,
        d;
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {
      if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    }
    return c > 3 && r && Object.defineProperty(target, key, r), r;
  }
  function __param(paramIndex, decorator) {
    return function (target, key) {
      decorator(target, key, paramIndex);
    };
  }
  function __metadata(metadataKey, metadataValue) {
    if ((typeof Reflect === "undefined" ? "undefined" : _typeof(Reflect)) === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
  }
  function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
      function fulfilled(value) {
        try {
          step(generator.next(value));
        } catch (e) {
          reject(e);
        }
      }

      function rejected(value) {
        try {
          step(generator["throw"](value));
        } catch (e) {
          reject(e);
        }
      }

      function step(result) {
        result.done ? resolve(result.value) : new P(function (resolve) {
          resolve(result.value);
        }).then(fulfilled, rejected);
      }

      step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
  }
  function __generator(thisArg, body) {
    var _ = {
      label: 0,
      sent: function sent() {
        if (t[0] & 1) throw t[1];
        return t[1];
      },
      trys: [],
      ops: []
    },
        f,
        y,
        t,
        g;
    return g = {
      next: verb(0),
      "throw": verb(1),
      "return": verb(2)
    }, typeof Symbol === "function" && (g[Symbol.iterator] = function () {
      return this;
    }), g;

    function verb(n) {
      return function (v) {
        return step([n, v]);
      };
    }

    function step(op) {
      if (f) throw new TypeError("Generator is already executing.");

      while (_) {
        try {
          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
          if (y = 0, t) op = [op[0] & 2, t.value];

          switch (op[0]) {
            case 0:
            case 1:
              t = op;
              break;

            case 4:
              _.label++;
              return {
                value: op[1],
                done: false
              };

            case 5:
              _.label++;
              y = op[1];
              op = [0];
              continue;

            case 7:
              op = _.ops.pop();

              _.trys.pop();

              continue;

            default:
              if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
                _ = 0;
                continue;
              }

              if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
                _.label = op[1];
                break;
              }

              if (op[0] === 6 && _.label < t[1]) {
                _.label = t[1];
                t = op;
                break;
              }

              if (t && _.label < t[2]) {
                _.label = t[2];

                _.ops.push(op);

                break;
              }

              if (t[2]) _.ops.pop();

              _.trys.pop();

              continue;
          }

          op = body.call(thisArg, _);
        } catch (e) {
          op = [6, e];
          y = 0;
        } finally {
          f = t = 0;
        }
      }

      if (op[0] & 5) throw op[1];
      return {
        value: op[0] ? op[1] : void 0,
        done: true
      };
    }
  }
  function __exportStar(m, exports) {
    for (var p in m) {
      if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    }
  }
  function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator],
        i = 0;
    if (m) return m.call(o);
    return {
      next: function next() {
        if (o && i >= o.length) o = void 0;
        return {
          value: o && o[i++],
          done: !o
        };
      }
    };
  }
  function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o),
        r,
        ar = [],
        e;

    try {
      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) {
        ar.push(r.value);
      }
    } catch (error) {
      e = {
        error: error
      };
    } finally {
      try {
        if (r && !r.done && (m = i["return"])) m.call(i);
      } finally {
        if (e) throw e.error;
      }
    }

    return ar;
  }
  function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++) {
      ar = ar.concat(__read(arguments[i]));
    }

    return ar;
  }
  function __spreadArrays() {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) {
      s += arguments[i].length;
    }

    for (var r = Array(s), k = 0, i = 0; i < il; i++) {
      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++) {
        r[k] = a[j];
      }
    }

    return r;
  }
  function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
  }
  function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []),
        i,
        q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
      return this;
    }, i;

    function verb(n) {
      if (g[n]) i[n] = function (v) {
        return new Promise(function (a, b) {
          q.push([n, v, a, b]) > 1 || resume(n, v);
        });
      };
    }

    function resume(n, v) {
      try {
        step(g[n](v));
      } catch (e) {
        settle(q[0][3], e);
      }
    }

    function step(r) {
      r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);
    }

    function fulfill(value) {
      resume("next", value);
    }

    function reject(value) {
      resume("throw", value);
    }

    function settle(f, v) {
      if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]);
    }
  }
  function __asyncDelegator(o) {
    var i, p;
    return i = {}, verb("next"), verb("throw", function (e) {
      throw e;
    }), verb("return"), i[Symbol.iterator] = function () {
      return this;
    }, i;

    function verb(n, f) {
      i[n] = o[n] ? function (v) {
        return (p = !p) ? {
          value: __await(o[n](v)),
          done: n === "return"
        } : f ? f(v) : v;
      } : f;
    }
  }
  function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator],
        i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () {
      return this;
    }, i);

    function verb(n) {
      i[n] = o[n] && function (v) {
        return new Promise(function (resolve, reject) {
          v = o[n](v), settle(resolve, reject, v.done, v.value);
        });
      };
    }

    function settle(resolve, reject, d, v) {
      Promise.resolve(v).then(function (v) {
        resolve({
          value: v,
          done: d
        });
      }, reject);
    }
  }
  function __makeTemplateObject(cooked, raw) {
    if (Object.defineProperty) {
      Object.defineProperty(cooked, "raw", {
        value: raw
      });
    } else {
      cooked.raw = raw;
    }

    return cooked;
  }
  function __importStar(mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) {
      if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    }
    result.default = mod;
    return result;
  }
  function __importDefault(mod) {
    return mod && mod.__esModule ? mod : {
      default: mod
    };
  }

  var tslib_es6 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    __extends: __extends,
    get __assign () { return _assign; },
    __rest: __rest,
    __decorate: __decorate,
    __param: __param,
    __metadata: __metadata,
    __awaiter: __awaiter,
    __generator: __generator,
    __exportStar: __exportStar,
    __values: __values,
    __read: __read,
    __spread: __spread,
    __spreadArrays: __spreadArrays,
    __await: __await,
    __asyncGenerator: __asyncGenerator,
    __asyncDelegator: __asyncDelegator,
    __asyncValues: __asyncValues,
    __makeTemplateObject: __makeTemplateObject,
    __importStar: __importStar,
    __importDefault: __importDefault
  });

  var api = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.apiDescriptor = {
      key: function key(_key) {
        return /^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(_key) ? _key : JSON.stringify(_key);
      },
      value: function value(_value) {
        if (_value === null || _typeof(_value) !== 'object') {
          return JSON.stringify(_value);
        }

        if (Array.isArray(_value)) {
          return "[".concat(_value.map(function (subValue) {
            return exports.apiDescriptor.value(subValue);
          }).join(', '), "]");
        }

        var keys = Object.keys(_value);
        return keys.length === 0 ? '{}' : "{ ".concat(keys.map(function (key) {
          return "".concat(exports.apiDescriptor.key(key), ": ").concat(exports.apiDescriptor.value(_value[key]));
        }).join(', '), " }");
      },
      pair: function pair(_ref) {
        var key = _ref.key,
            value = _ref.value;
        return exports.apiDescriptor.value(_defineProperty({}, key, value));
      }
    };
  });
  unwrapExports(api);
  var api_1 = api.apiDescriptor;

  var tslib_1 = getCjsExportFromNamespace(tslib_es6);

  var descriptors = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    tslib_1.__exportStar(api, exports);
  });
  unwrapExports(descriptors);

  var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;

  var escapeStringRegexp = function escapeStringRegexp(str) {
    if (typeof str !== 'string') {
      throw new TypeError('Expected a string');
    }

    return str.replace(matchOperatorsRe, '\\$&');
  };

  var colorName = {
    "aliceblue": [240, 248, 255],
    "antiquewhite": [250, 235, 215],
    "aqua": [0, 255, 255],
    "aquamarine": [127, 255, 212],
    "azure": [240, 255, 255],
    "beige": [245, 245, 220],
    "bisque": [255, 228, 196],
    "black": [0, 0, 0],
    "blanchedalmond": [255, 235, 205],
    "blue": [0, 0, 255],
    "blueviolet": [138, 43, 226],
    "brown": [165, 42, 42],
    "burlywood": [222, 184, 135],
    "cadetblue": [95, 158, 160],
    "chartreuse": [127, 255, 0],
    "chocolate": [210, 105, 30],
    "coral": [255, 127, 80],
    "cornflowerblue": [100, 149, 237],
    "cornsilk": [255, 248, 220],
    "crimson": [220, 20, 60],
    "cyan": [0, 255, 255],
    "darkblue": [0, 0, 139],
    "darkcyan": [0, 139, 139],
    "darkgoldenrod": [184, 134, 11],
    "darkgray": [169, 169, 169],
    "darkgreen": [0, 100, 0],
    "darkgrey": [169, 169, 169],
    "darkkhaki": [189, 183, 107],
    "darkmagenta": [139, 0, 139],
    "darkolivegreen": [85, 107, 47],
    "darkorange": [255, 140, 0],
    "darkorchid": [153, 50, 204],
    "darkred": [139, 0, 0],
    "darksalmon": [233, 150, 122],
    "darkseagreen": [143, 188, 143],
    "darkslateblue": [72, 61, 139],
    "darkslategray": [47, 79, 79],
    "darkslategrey": [47, 79, 79],
    "darkturquoise": [0, 206, 209],
    "darkviolet": [148, 0, 211],
    "deeppink": [255, 20, 147],
    "deepskyblue": [0, 191, 255],
    "dimgray": [105, 105, 105],
    "dimgrey": [105, 105, 105],
    "dodgerblue": [30, 144, 255],
    "firebrick": [178, 34, 34],
    "floralwhite": [255, 250, 240],
    "forestgreen": [34, 139, 34],
    "fuchsia": [255, 0, 255],
    "gainsboro": [220, 220, 220],
    "ghostwhite": [248, 248, 255],
    "gold": [255, 215, 0],
    "goldenrod": [218, 165, 32],
    "gray": [128, 128, 128],
    "green": [0, 128, 0],
    "greenyellow": [173, 255, 47],
    "grey": [128, 128, 128],
    "honeydew": [240, 255, 240],
    "hotpink": [255, 105, 180],
    "indianred": [205, 92, 92],
    "indigo": [75, 0, 130],
    "ivory": [255, 255, 240],
    "khaki": [240, 230, 140],
    "lavender": [230, 230, 250],
    "lavenderblush": [255, 240, 245],
    "lawngreen": [124, 252, 0],
    "lemonchiffon": [255, 250, 205],
    "lightblue": [173, 216, 230],
    "lightcoral": [240, 128, 128],
    "lightcyan": [224, 255, 255],
    "lightgoldenrodyellow": [250, 250, 210],
    "lightgray": [211, 211, 211],
    "lightgreen": [144, 238, 144],
    "lightgrey": [211, 211, 211],
    "lightpink": [255, 182, 193],
    "lightsalmon": [255, 160, 122],
    "lightseagreen": [32, 178, 170],
    "lightskyblue": [135, 206, 250],
    "lightslategray": [119, 136, 153],
    "lightslategrey": [119, 136, 153],
    "lightsteelblue": [176, 196, 222],
    "lightyellow": [255, 255, 224],
    "lime": [0, 255, 0],
    "limegreen": [50, 205, 50],
    "linen": [250, 240, 230],
    "magenta": [255, 0, 255],
    "maroon": [128, 0, 0],
    "mediumaquamarine": [102, 205, 170],
    "mediumblue": [0, 0, 205],
    "mediumorchid": [186, 85, 211],
    "mediumpurple": [147, 112, 219],
    "mediumseagreen": [60, 179, 113],
    "mediumslateblue": [123, 104, 238],
    "mediumspringgreen": [0, 250, 154],
    "mediumturquoise": [72, 209, 204],
    "mediumvioletred": [199, 21, 133],
    "midnightblue": [25, 25, 112],
    "mintcream": [245, 255, 250],
    "mistyrose": [255, 228, 225],
    "moccasin": [255, 228, 181],
    "navajowhite": [255, 222, 173],
    "navy": [0, 0, 128],
    "oldlace": [253, 245, 230],
    "olive": [128, 128, 0],
    "olivedrab": [107, 142, 35],
    "orange": [255, 165, 0],
    "orangered": [255, 69, 0],
    "orchid": [218, 112, 214],
    "palegoldenrod": [238, 232, 170],
    "palegreen": [152, 251, 152],
    "paleturquoise": [175, 238, 238],
    "palevioletred": [219, 112, 147],
    "papayawhip": [255, 239, 213],
    "peachpuff": [255, 218, 185],
    "peru": [205, 133, 63],
    "pink": [255, 192, 203],
    "plum": [221, 160, 221],
    "powderblue": [176, 224, 230],
    "purple": [128, 0, 128],
    "rebeccapurple": [102, 51, 153],
    "red": [255, 0, 0],
    "rosybrown": [188, 143, 143],
    "royalblue": [65, 105, 225],
    "saddlebrown": [139, 69, 19],
    "salmon": [250, 128, 114],
    "sandybrown": [244, 164, 96],
    "seagreen": [46, 139, 87],
    "seashell": [255, 245, 238],
    "sienna": [160, 82, 45],
    "silver": [192, 192, 192],
    "skyblue": [135, 206, 235],
    "slateblue": [106, 90, 205],
    "slategray": [112, 128, 144],
    "slategrey": [112, 128, 144],
    "snow": [255, 250, 250],
    "springgreen": [0, 255, 127],
    "steelblue": [70, 130, 180],
    "tan": [210, 180, 140],
    "teal": [0, 128, 128],
    "thistle": [216, 191, 216],
    "tomato": [255, 99, 71],
    "turquoise": [64, 224, 208],
    "violet": [238, 130, 238],
    "wheat": [245, 222, 179],
    "white": [255, 255, 255],
    "whitesmoke": [245, 245, 245],
    "yellow": [255, 255, 0],
    "yellowgreen": [154, 205, 50]
  };

  var conversions = createCommonjsModule(function (module) {
    /* MIT license */
    // NOTE: conversions should only return primitive values (i.e. arrays, or
    //       values that give correct `typeof` results).
    //       do not use box values types (i.e. Number(), String(), etc.)
    var reverseKeywords = {};

    for (var key in colorName) {
      if (colorName.hasOwnProperty(key)) {
        reverseKeywords[colorName[key]] = key;
      }
    }

    var convert = module.exports = {
      rgb: {
        channels: 3,
        labels: 'rgb'
      },
      hsl: {
        channels: 3,
        labels: 'hsl'
      },
      hsv: {
        channels: 3,
        labels: 'hsv'
      },
      hwb: {
        channels: 3,
        labels: 'hwb'
      },
      cmyk: {
        channels: 4,
        labels: 'cmyk'
      },
      xyz: {
        channels: 3,
        labels: 'xyz'
      },
      lab: {
        channels: 3,
        labels: 'lab'
      },
      lch: {
        channels: 3,
        labels: 'lch'
      },
      hex: {
        channels: 1,
        labels: ['hex']
      },
      keyword: {
        channels: 1,
        labels: ['keyword']
      },
      ansi16: {
        channels: 1,
        labels: ['ansi16']
      },
      ansi256: {
        channels: 1,
        labels: ['ansi256']
      },
      hcg: {
        channels: 3,
        labels: ['h', 'c', 'g']
      },
      apple: {
        channels: 3,
        labels: ['r16', 'g16', 'b16']
      },
      gray: {
        channels: 1,
        labels: ['gray']
      }
    }; // hide .channels and .labels properties

    for (var model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!('channels' in convert[model])) {
          throw new Error('missing channels property: ' + model);
        }

        if (!('labels' in convert[model])) {
          throw new Error('missing channel labels property: ' + model);
        }

        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error('channel and label counts mismatch: ' + model);
        }

        var channels = convert[model].channels;
        var labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], 'channels', {
          value: channels
        });
        Object.defineProperty(convert[model], 'labels', {
          value: labels
        });
      }
    }

    convert.rgb.hsl = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;

      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }

      h = Math.min(h * 60, 360);

      if (h < 0) {
        h += 360;
      }

      l = (min + max) / 2;

      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }

      return [h, s * 100, l * 100];
    };

    convert.rgb.hsv = function (rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var v;

      if (max === 0) {
        s = 0;
      } else {
        s = delta / max * 1000 / 10;
      }

      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }

      h = Math.min(h * 60, 360);

      if (h < 0) {
        h += 360;
      }

      v = max / 255 * 1000 / 10;
      return [h, s, v];
    };

    convert.rgb.hwb = function (rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [h, w * 100, b * 100];
    };

    convert.rgb.cmyk = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [c * 100, m * 100, y * 100, k * 100];
    };
    /**
     * See https://en.m.wikipedia.org/wiki/Euclidean_distance#Squared_Euclidean_distance
     * */


    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }

    convert.rgb.keyword = function (rgb) {
      var reversed = reverseKeywords[rgb];

      if (reversed) {
        return reversed;
      }

      var currentClosestDistance = Infinity;
      var currentClosestKeyword;

      for (var keyword in colorName) {
        if (colorName.hasOwnProperty(keyword)) {
          var value = colorName[keyword]; // Compute comparative distance

          var distance = comparativeDistance(rgb, value); // Check if its less, if so set as closest

          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }

      return currentClosestKeyword;
    };

    convert.keyword.rgb = function (keyword) {
      return colorName[keyword];
    };

    convert.rgb.xyz = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255; // assume sRGB

      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [x * 100, y * 100, z * 100];
    };

    convert.rgb.lab = function (rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };

    convert.hsl.rgb = function (hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;

      if (s === 0) {
        val = l * 255;
        return [val, val, val];
      }

      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }

      t1 = 2 * l - t2;
      rgb = [0, 0, 0];

      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);

        if (t3 < 0) {
          t3++;
        }

        if (t3 > 1) {
          t3--;
        }

        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }

        rgb[i] = val * 255;
      }

      return rgb;
    };

    convert.hsl.hsv = function (hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [h, sv * 100, v * 100];
    };

    convert.hsv.rgb = function (hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;

      switch (hi) {
        case 0:
          return [v, t, p];

        case 1:
          return [q, v, p];

        case 2:
          return [p, v, t];

        case 3:
          return [p, q, v];

        case 4:
          return [t, p, v];

        case 5:
          return [v, p, q];
      }
    };

    convert.hsv.hsl = function (hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [h, sl * 100, l * 100];
    }; // http://dev.w3.org/csswg/css-color/#hwb-to-rgb


    convert.hwb.rgb = function (hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n; // wh + bl cant be > 1

      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }

      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;

      if ((i & 0x01) !== 0) {
        f = 1 - f;
      }

      n = wh + f * (v - wh); // linear interpolation

      var r;
      var g;
      var b;

      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;

        case 1:
          r = n;
          g = v;
          b = wh;
          break;

        case 2:
          r = wh;
          g = v;
          b = n;
          break;

        case 3:
          r = wh;
          g = n;
          b = v;
          break;

        case 4:
          r = n;
          g = wh;
          b = v;
          break;

        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }

      return [r * 255, g * 255, b * 255];
    };

    convert.cmyk.rgb = function (cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [r * 255, g * 255, b * 255];
    };

    convert.xyz.rgb = function (xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z * 0.0415;
      b = x * 0.0557 + y * -0.2040 + z * 1.0570; // assume sRGB

      r = r > 0.0031308 ? 1.055 * Math.pow(r, 1.0 / 2.4) - 0.055 : r * 12.92;
      g = g > 0.0031308 ? 1.055 * Math.pow(g, 1.0 / 2.4) - 0.055 : g * 12.92;
      b = b > 0.0031308 ? 1.055 * Math.pow(b, 1.0 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [r * 255, g * 255, b * 255];
    };

    convert.xyz.lab = function (xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z /= 108.883;
      x = x > 0.008856 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 0.008856 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z = z > 0.008856 ? Math.pow(z, 1 / 3) : 7.787 * z + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z);
      return [l, a, b];
    };

    convert.lab.xyz = function (lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z2 = Math.pow(z, 3);
      y = y2 > 0.008856 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 0.008856 ? x2 : (x - 16 / 116) / 7.787;
      z = z2 > 0.008856 ? z2 : (z - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z *= 108.883;
      return [x, y, z];
    };

    convert.lab.lch = function (lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;

      if (h < 0) {
        h += 360;
      }

      c = Math.sqrt(a * a + b * b);
      return [l, c, h];
    };

    convert.lch.lab = function (lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [l, a, b];
    };

    convert.rgb.ansi16 = function (args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2]; // hsv -> ansi16 optimization

      value = Math.round(value / 50);

      if (value === 0) {
        return 30;
      }

      var ansi = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));

      if (value === 2) {
        ansi += 60;
      }

      return ansi;
    };

    convert.hsv.ansi16 = function (args) {
      // optimization here; we already know the value and don't need to get
      // it converted for us.
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };

    convert.rgb.ansi256 = function (args) {
      var r = args[0];
      var g = args[1];
      var b = args[2]; // we use the extended greyscale palette here, with the exception of
      // black and white. normal palette only has 4 greyscale shades.

      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }

        if (r > 248) {
          return 231;
        }

        return Math.round((r - 8) / 247 * 24) + 232;
      }

      var ansi = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi;
    };

    convert.ansi16.rgb = function (args) {
      var color = args % 10; // handle greyscale

      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }

        color = color / 10.5 * 255;
        return [color, color, color];
      }

      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [r, g, b];
    };

    convert.ansi256.rgb = function (args) {
      // handle greyscale
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [c, c, c];
      }

      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [r, g, b];
    };

    convert.rgb.hex = function (args) {
      var integer = ((Math.round(args[0]) & 0xFF) << 16) + ((Math.round(args[1]) & 0xFF) << 8) + (Math.round(args[2]) & 0xFF);
      var string = integer.toString(16).toUpperCase();
      return '000000'.substring(string.length) + string;
    };

    convert.hex.rgb = function (args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);

      if (!match) {
        return [0, 0, 0];
      }

      var colorString = match[0];

      if (match[0].length === 3) {
        colorString = colorString.split('').map(function (char) {
          return char + char;
        }).join('');
      }

      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 0xFF;
      var g = integer >> 8 & 0xFF;
      var b = integer & 0xFF;
      return [r, g, b];
    };

    convert.rgb.hcg = function (rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;

      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }

      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }

      hue /= 6;
      hue %= 1;
      return [hue * 360, chroma * 100, grayscale * 100];
    };

    convert.hsl.hcg = function (hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;

      if (l < 0.5) {
        c = 2.0 * s * l;
      } else {
        c = 2.0 * s * (1.0 - l);
      }

      if (c < 1.0) {
        f = (l - 0.5 * c) / (1.0 - c);
      }

      return [hsl[0], c * 100, f * 100];
    };

    convert.hsv.hcg = function (hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;

      if (c < 1.0) {
        f = (v - c) / (1 - c);
      }

      return [hsv[0], c * 100, f * 100];
    };

    convert.hcg.rgb = function (hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;

      if (c === 0.0) {
        return [g * 255, g * 255, g * 255];
      }

      var pure = [0, 0, 0];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;

      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;

        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;

        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;

        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;

        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;

        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }

      mg = (1.0 - c) * g;
      return [(c * pure[0] + mg) * 255, (c * pure[1] + mg) * 255, (c * pure[2] + mg) * 255];
    };

    convert.hcg.hsv = function (hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1.0 - c);
      var f = 0;

      if (v > 0.0) {
        f = c / v;
      }

      return [hcg[0], f * 100, v * 100];
    };

    convert.hcg.hsl = function (hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1.0 - c) + 0.5 * c;
      var s = 0;

      if (l > 0.0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1.0) {
        s = c / (2 * (1 - l));
      }

      return [hcg[0], s * 100, l * 100];
    };

    convert.hcg.hwb = function (hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1.0 - c);
      return [hcg[0], (v - c) * 100, (1 - v) * 100];
    };

    convert.hwb.hcg = function (hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;

      if (c < 1) {
        g = (v - c) / (1 - c);
      }

      return [hwb[0], c * 100, g * 100];
    };

    convert.apple.rgb = function (apple) {
      return [apple[0] / 65535 * 255, apple[1] / 65535 * 255, apple[2] / 65535 * 255];
    };

    convert.rgb.apple = function (rgb) {
      return [rgb[0] / 255 * 65535, rgb[1] / 255 * 65535, rgb[2] / 255 * 65535];
    };

    convert.gray.rgb = function (args) {
      return [args[0] / 100 * 255, args[0] / 100 * 255, args[0] / 100 * 255];
    };

    convert.gray.hsl = convert.gray.hsv = function (args) {
      return [0, 0, args[0]];
    };

    convert.gray.hwb = function (gray) {
      return [0, 100, gray[0]];
    };

    convert.gray.cmyk = function (gray) {
      return [0, 0, 0, gray[0]];
    };

    convert.gray.lab = function (gray) {
      return [gray[0], 0, 0];
    };

    convert.gray.hex = function (gray) {
      var val = Math.round(gray[0] / 100 * 255) & 0xFF;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return '000000'.substring(string.length) + string;
    };

    convert.rgb.gray = function (rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [val / 255 * 100];
    };
  });
  var conversions_1 = conversions.rgb;
  var conversions_2 = conversions.hsl;
  var conversions_3 = conversions.hsv;
  var conversions_4 = conversions.hwb;
  var conversions_5 = conversions.cmyk;
  var conversions_6 = conversions.xyz;
  var conversions_7 = conversions.lab;
  var conversions_8 = conversions.lch;
  var conversions_9 = conversions.hex;
  var conversions_10 = conversions.keyword;
  var conversions_11 = conversions.ansi16;
  var conversions_12 = conversions.ansi256;
  var conversions_13 = conversions.hcg;
  var conversions_14 = conversions.apple;
  var conversions_15 = conversions.gray;

  /*
  	this function routes a model to all other models.

  	all functions that are routed have a property `.conversion` attached
  	to the returned synthetic function. This property is an array
  	of strings, each with the steps in between the 'from' and 'to'
  	color models (inclusive).

  	conversions that are not possible simply are not included.
  */
  // https://jsperf.com/object-keys-vs-for-in-with-closure/3

  var models = Object.keys(conversions);

  function buildGraph() {
    var graph = {};

    for (var len = models.length, i = 0; i < len; i++) {
      graph[models[i]] = {
        // http://jsperf.com/1-vs-infinity
        // micro-opt, but this is simple.
        distance: -1,
        parent: null
      };
    }

    return graph;
  } // https://en.wikipedia.org/wiki/Breadth-first_search


  function deriveBFS(fromModel) {
    var graph = buildGraph();
    var queue = [fromModel]; // unshift -> queue -> pop

    graph[fromModel].distance = 0;

    while (queue.length) {
      var current = queue.pop();
      var adjacents = Object.keys(conversions[current]);

      for (var len = adjacents.length, i = 0; i < len; i++) {
        var adjacent = adjacents[i];
        var node = graph[adjacent];

        if (node.distance === -1) {
          node.distance = graph[current].distance + 1;
          node.parent = current;
          queue.unshift(adjacent);
        }
      }
    }

    return graph;
  }

  function link(from, to) {
    return function (args) {
      return to(from(args));
    };
  }

  function wrapConversion(toModel, graph) {
    var path = [graph[toModel].parent, toModel];
    var fn = conversions[graph[toModel].parent][toModel];
    var cur = graph[toModel].parent;

    while (graph[cur].parent) {
      path.unshift(graph[cur].parent);
      fn = link(conversions[graph[cur].parent][cur], fn);
      cur = graph[cur].parent;
    }

    fn.conversion = path;
    return fn;
  }

  var route = function route(fromModel) {
    var graph = deriveBFS(fromModel);
    var conversion = {};
    var models = Object.keys(graph);

    for (var len = models.length, i = 0; i < len; i++) {
      var toModel = models[i];
      var node = graph[toModel];

      if (node.parent === null) {
        // no possible conversion, or this node is the source model.
        continue;
      }

      conversion[toModel] = wrapConversion(toModel, graph);
    }

    return conversion;
  };

  var convert = {};
  var models$1 = Object.keys(conversions);

  function wrapRaw(fn) {
    var wrappedFn = function wrappedFn(args) {
      if (args === undefined || args === null) {
        return args;
      }

      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }

      return fn(args);
    }; // preserve .conversion property if there is one


    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }

    return wrappedFn;
  }

  function wrapRounded(fn) {
    var wrappedFn = function wrappedFn(args) {
      if (args === undefined || args === null) {
        return args;
      }

      if (arguments.length > 1) {
        args = Array.prototype.slice.call(arguments);
      }

      var result = fn(args); // we're assuming the result is an array here.
      // see notice in conversions.js; don't use box types
      // in conversion functions.

      if (_typeof(result) === 'object') {
        for (var len = result.length, i = 0; i < len; i++) {
          result[i] = Math.round(result[i]);
        }
      }

      return result;
    }; // preserve .conversion property if there is one


    if ('conversion' in fn) {
      wrappedFn.conversion = fn.conversion;
    }

    return wrappedFn;
  }

  models$1.forEach(function (fromModel) {
    convert[fromModel] = {};
    Object.defineProperty(convert[fromModel], 'channels', {
      value: conversions[fromModel].channels
    });
    Object.defineProperty(convert[fromModel], 'labels', {
      value: conversions[fromModel].labels
    });
    var routes = route(fromModel);
    var routeModels = Object.keys(routes);
    routeModels.forEach(function (toModel) {
      var fn = routes[toModel];
      convert[fromModel][toModel] = wrapRounded(fn);
      convert[fromModel][toModel].raw = wrapRaw(fn);
    });
  });
  var colorConvert = convert;

  var ansiStyles = createCommonjsModule(function (module) {

    var wrapAnsi16 = function wrapAnsi16(fn, offset) {
      return function () {
        var code = fn.apply(colorConvert, arguments);
        return "\x1B[".concat(code + offset, "m");
      };
    };

    var wrapAnsi256 = function wrapAnsi256(fn, offset) {
      return function () {
        var code = fn.apply(colorConvert, arguments);
        return "\x1B[".concat(38 + offset, ";5;").concat(code, "m");
      };
    };

    var wrapAnsi16m = function wrapAnsi16m(fn, offset) {
      return function () {
        var rgb = fn.apply(colorConvert, arguments);
        return "\x1B[".concat(38 + offset, ";2;").concat(rgb[0], ";").concat(rgb[1], ";").concat(rgb[2], "m");
      };
    };

    function assembleStyles() {
      var codes = new Map();
      var styles = {
        modifier: {
          reset: [0, 0],
          // 21 isn't widely supported and 22 does the same thing
          bold: [1, 22],
          dim: [2, 22],
          italic: [3, 23],
          underline: [4, 24],
          inverse: [7, 27],
          hidden: [8, 28],
          strikethrough: [9, 29]
        },
        color: {
          black: [30, 39],
          red: [31, 39],
          green: [32, 39],
          yellow: [33, 39],
          blue: [34, 39],
          magenta: [35, 39],
          cyan: [36, 39],
          white: [37, 39],
          gray: [90, 39],
          // Bright color
          redBright: [91, 39],
          greenBright: [92, 39],
          yellowBright: [93, 39],
          blueBright: [94, 39],
          magentaBright: [95, 39],
          cyanBright: [96, 39],
          whiteBright: [97, 39]
        },
        bgColor: {
          bgBlack: [40, 49],
          bgRed: [41, 49],
          bgGreen: [42, 49],
          bgYellow: [43, 49],
          bgBlue: [44, 49],
          bgMagenta: [45, 49],
          bgCyan: [46, 49],
          bgWhite: [47, 49],
          // Bright color
          bgBlackBright: [100, 49],
          bgRedBright: [101, 49],
          bgGreenBright: [102, 49],
          bgYellowBright: [103, 49],
          bgBlueBright: [104, 49],
          bgMagentaBright: [105, 49],
          bgCyanBright: [106, 49],
          bgWhiteBright: [107, 49]
        }
      }; // Fix humans

      styles.color.grey = styles.color.gray;

      for (var _i = 0, _Object$keys = Object.keys(styles); _i < _Object$keys.length; _i++) {
        var groupName = _Object$keys[_i];
        var group = styles[groupName];

        for (var _i3 = 0, _Object$keys3 = Object.keys(group); _i3 < _Object$keys3.length; _i3++) {
          var styleName = _Object$keys3[_i3];
          var style = group[styleName];
          styles[styleName] = {
            open: "\x1B[".concat(style[0], "m"),
            close: "\x1B[".concat(style[1], "m")
          };
          group[styleName] = styles[styleName];
          codes.set(style[0], style[1]);
        }

        Object.defineProperty(styles, groupName, {
          value: group,
          enumerable: false
        });
        Object.defineProperty(styles, 'codes', {
          value: codes,
          enumerable: false
        });
      }

      var ansi2ansi = function ansi2ansi(n) {
        return n;
      };

      var rgb2rgb = function rgb2rgb(r, g, b) {
        return [r, g, b];
      };

      styles.color.close = "\x1B[39m";
      styles.bgColor.close = "\x1B[49m";
      styles.color.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 0)
      };
      styles.color.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 0)
      };
      styles.color.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 0)
      };
      styles.bgColor.ansi = {
        ansi: wrapAnsi16(ansi2ansi, 10)
      };
      styles.bgColor.ansi256 = {
        ansi256: wrapAnsi256(ansi2ansi, 10)
      };
      styles.bgColor.ansi16m = {
        rgb: wrapAnsi16m(rgb2rgb, 10)
      };

      for (var _i2 = 0, _Object$keys2 = Object.keys(colorConvert); _i2 < _Object$keys2.length; _i2++) {
        var key = _Object$keys2[_i2];

        if (_typeof(colorConvert[key]) !== 'object') {
          continue;
        }

        var suite = colorConvert[key];

        if (key === 'ansi16') {
          key = 'ansi';
        }

        if ('ansi16' in suite) {
          styles.color.ansi[key] = wrapAnsi16(suite.ansi16, 0);
          styles.bgColor.ansi[key] = wrapAnsi16(suite.ansi16, 10);
        }

        if ('ansi256' in suite) {
          styles.color.ansi256[key] = wrapAnsi256(suite.ansi256, 0);
          styles.bgColor.ansi256[key] = wrapAnsi256(suite.ansi256, 10);
        }

        if ('rgb' in suite) {
          styles.color.ansi16m[key] = wrapAnsi16m(suite.rgb, 0);
          styles.bgColor.ansi16m[key] = wrapAnsi16m(suite.rgb, 10);
        }
      }

      return styles;
    } // Make the export immutable


    Object.defineProperty(module, 'exports', {
      enumerable: true,
      get: assembleStyles
    });
  });

  var require$$0$1 = {
    EOL: "\n"
  };

  var hasFlag = function hasFlag(flag, argv) {
    argv = argv || process.argv;
    var prefix = flag.startsWith('-') ? '' : flag.length === 1 ? '-' : '--';
    var pos = argv.indexOf(prefix + flag);
    var terminatorPos = argv.indexOf('--');
    return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
  };

  var env$1 = process.env;
  var forceColor;

  if (hasFlag('no-color') || hasFlag('no-colors') || hasFlag('color=false')) {
    forceColor = false;
  } else if (hasFlag('color') || hasFlag('colors') || hasFlag('color=true') || hasFlag('color=always')) {
    forceColor = true;
  }

  if ('FORCE_COLOR' in env$1) {
    forceColor = env$1.FORCE_COLOR.length === 0 || parseInt(env$1.FORCE_COLOR, 10) !== 0;
  }

  function translateLevel(level) {
    if (level === 0) {
      return false;
    }

    return {
      level: level,
      hasBasic: true,
      has256: level >= 2,
      has16m: level >= 3
    };
  }

  function supportsColor(stream) {
    if (forceColor === false) {
      return 0;
    }

    if (hasFlag('color=16m') || hasFlag('color=full') || hasFlag('color=truecolor')) {
      return 3;
    }

    if (hasFlag('color=256')) {
      return 2;
    }

    if (stream && !stream.isTTY && forceColor !== true) {
      return 0;
    }

    var min = forceColor ? 1 : 0;

    if (process.platform === 'win32') {
      // Node.js 7.5.0 is the first version of Node.js to include a patch to
      // libuv that enables 256 color output on Windows. Anything earlier and it
      // won't work. However, here we target Node.js 8 at minimum as it is an LTS
      // release, and Node.js 7 is not. Windows 10 build 10586 is the first Windows
      // release that supports 256 colors. Windows 10 build 14931 is the first release
      // that supports 16m/TrueColor.
      var osRelease = require$$0$1.release().split('.');

      if (Number(process.versions.node.split('.')[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
        return Number(osRelease[2]) >= 14931 ? 3 : 2;
      }

      return 1;
    }

    if ('CI' in env$1) {
      if (['TRAVIS', 'CIRCLECI', 'APPVEYOR', 'GITLAB_CI'].some(function (sign) {
        return sign in env$1;
      }) || env$1.CI_NAME === 'codeship') {
        return 1;
      }

      return min;
    }

    if ('TEAMCITY_VERSION' in env$1) {
      return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env$1.TEAMCITY_VERSION) ? 1 : 0;
    }

    if (env$1.COLORTERM === 'truecolor') {
      return 3;
    }

    if ('TERM_PROGRAM' in env$1) {
      var version = parseInt((env$1.TERM_PROGRAM_VERSION || '').split('.')[0], 10);

      switch (env$1.TERM_PROGRAM) {
        case 'iTerm.app':
          return version >= 3 ? 3 : 2;

        case 'Apple_Terminal':
          return 2;
        // No default
      }
    }

    if (/-256(color)?$/i.test(env$1.TERM)) {
      return 2;
    }

    if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env$1.TERM)) {
      return 1;
    }

    if ('COLORTERM' in env$1) {
      return 1;
    }

    if (env$1.TERM === 'dumb') {
      return min;
    }

    return min;
  }

  function getSupportLevel(stream) {
    var level = supportsColor(stream);
    return translateLevel(level);
  }

  var supportsColor_1 = {
    supportsColor: getSupportLevel,
    stdout: getSupportLevel(process.stdout),
    stderr: getSupportLevel(process.stderr)
  };

  var TEMPLATE_REGEX = /(?:\\(u[a-f\d]{4}|x[a-f\d]{2}|.))|(?:\{(~)?(\w+(?:\([^)]*\))?(?:\.\w+(?:\([^)]*\))?)*)(?:[ \t]|(?=\r?\n)))|(\})|((?:.|[\r\n\f])+?)/gi;
  var STYLE_REGEX = /(?:^|\.)(\w+)(?:\(([^)]*)\))?/g;
  var STRING_REGEX = /^(['"])((?:\\.|(?!\1)[^\\])*)\1$/;
  var ESCAPE_REGEX = /\\(u[a-f\d]{4}|x[a-f\d]{2}|.)|([^\\])/gi;
  var ESCAPES = new Map([['n', '\n'], ['r', '\r'], ['t', '\t'], ['b', '\b'], ['f', '\f'], ['v', '\v'], ['0', '\0'], ['\\', '\\'], ['e', "\x1B"], ['a', "\x07"]]);

  function unescape(c) {
    if (c[0] === 'u' && c.length === 5 || c[0] === 'x' && c.length === 3) {
      return String.fromCharCode(parseInt(c.slice(1), 16));
    }

    return ESCAPES.get(c) || c;
  }

  function parseArguments(name, args) {
    var results = [];
    var chunks = args.trim().split(/\s*,\s*/g);
    var matches;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = chunks[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var chunk = _step.value;

        if (!isNaN(chunk)) {
          results.push(Number(chunk));
        } else if (matches = chunk.match(STRING_REGEX)) {
          results.push(matches[2].replace(ESCAPE_REGEX, function (m, escape, chr) {
            return escape ? unescape(escape) : chr;
          }));
        } else {
          throw new Error("Invalid Chalk template style argument: ".concat(chunk, " (in style '").concat(name, "')"));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return results;
  }

  function parseStyle(style) {
    STYLE_REGEX.lastIndex = 0;
    var results = [];
    var matches;

    while ((matches = STYLE_REGEX.exec(style)) !== null) {
      var name = matches[1];

      if (matches[2]) {
        var args = parseArguments(name, matches[2]);
        results.push([name].concat(args));
      } else {
        results.push([name]);
      }
    }

    return results;
  }

  function buildStyle(chalk, styles) {
    var enabled = {};
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = styles[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var layer = _step2.value;
        var _iteratorNormalCompletion3 = true;
        var _didIteratorError3 = false;
        var _iteratorError3 = undefined;

        try {
          for (var _iterator3 = layer.styles[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
            var style = _step3.value;
            enabled[style[0]] = layer.inverse ? null : style.slice(1);
          }
        } catch (err) {
          _didIteratorError3 = true;
          _iteratorError3 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
              _iterator3.return();
            }
          } finally {
            if (_didIteratorError3) {
              throw _iteratorError3;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    var current = chalk;

    for (var _i = 0, _Object$keys = Object.keys(enabled); _i < _Object$keys.length; _i++) {
      var styleName = _Object$keys[_i];

      if (Array.isArray(enabled[styleName])) {
        if (!(styleName in current)) {
          throw new Error("Unknown Chalk style: ".concat(styleName));
        }

        if (enabled[styleName].length > 0) {
          current = current[styleName].apply(current, enabled[styleName]);
        } else {
          current = current[styleName];
        }
      }
    }

    return current;
  }

  var templates = function templates(chalk, tmp) {
    var styles = [];
    var chunks = [];
    var chunk = []; // eslint-disable-next-line max-params

    tmp.replace(TEMPLATE_REGEX, function (m, escapeChar, inverse, style, close, chr) {
      if (escapeChar) {
        chunk.push(unescape(escapeChar));
      } else if (style) {
        var str = chunk.join('');
        chunk = [];
        chunks.push(styles.length === 0 ? str : buildStyle(chalk, styles)(str));
        styles.push({
          inverse: inverse,
          styles: parseStyle(style)
        });
      } else if (close) {
        if (styles.length === 0) {
          throw new Error('Found extraneous } in Chalk template literal');
        }

        chunks.push(buildStyle(chalk, styles)(chunk.join('')));
        chunk = [];
        styles.pop();
      } else {
        chunk.push(chr);
      }
    });
    chunks.push(chunk.join(''));

    if (styles.length > 0) {
      var errMsg = "Chalk template literal is missing ".concat(styles.length, " closing bracket").concat(styles.length === 1 ? '' : 's', " (`}`)");
      throw new Error(errMsg);
    }

    return chunks.join('');
  };

  var chalk = createCommonjsModule(function (module) {

    var stdoutColor = supportsColor_1.stdout;
    var isSimpleWindowsTerm = process.platform === 'win32' && !(process.env.TERM || '').toLowerCase().startsWith('xterm'); // `supportsColor.level`  `ansiStyles.color[name]` mapping

    var levelMapping = ['ansi', 'ansi', 'ansi256', 'ansi16m']; // `color-convert` models to exclude from the Chalk API due to conflicts and such

    var skipModels = new Set(['gray']);
    var styles = Object.create(null);

    function applyOptions(obj, options) {
      options = options || {}; // Detect level if not set manually

      var scLevel = stdoutColor ? stdoutColor.level : 0;
      obj.level = options.level === undefined ? scLevel : options.level;
      obj.enabled = 'enabled' in options ? options.enabled : obj.level > 0;
    }

    function Chalk(options) {
      // We check for this.template here since calling `chalk.constructor()`
      // by itself will have a `this` of a previously constructed chalk object
      if (!this || !(this instanceof Chalk) || this.template) {
        var _chalk = {};
        applyOptions(_chalk, options);

        _chalk.template = function () {
          var args = [].slice.call(arguments);
          return chalkTag.apply(null, [_chalk.template].concat(args));
        };

        Object.setPrototypeOf(_chalk, Chalk.prototype);
        Object.setPrototypeOf(_chalk.template, _chalk);
        _chalk.template.constructor = Chalk;
        return _chalk.template;
      }

      applyOptions(this, options);
    } // Use bright blue on Windows as the normal blue color is illegible


    if (isSimpleWindowsTerm) {
      ansiStyles.blue.open = "\x1B[94m";
    }

    var _loop = function _loop() {
      var key = _Object$keys[_i];
      ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), 'g');
      styles[key] = {
        get: function get() {
          var codes = ansiStyles[key];
          return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, key);
        }
      };
    };

    for (var _i = 0, _Object$keys = Object.keys(ansiStyles); _i < _Object$keys.length; _i++) {
      _loop();
    }

    styles.visible = {
      get: function get() {
        return build.call(this, this._styles || [], true, 'visible');
      }
    };
    ansiStyles.color.closeRe = new RegExp(escapeStringRegexp(ansiStyles.color.close), 'g');

    var _loop2 = function _loop2() {
      var model = _Object$keys2[_i2];

      if (skipModels.has(model)) {
        return "continue";
      }

      styles[model] = {
        get: function get() {
          var level = this.level;
          return function () {
            var open = ansiStyles.color[levelMapping[level]][model].apply(null, arguments);
            var codes = {
              open: open,
              close: ansiStyles.color.close,
              closeRe: ansiStyles.color.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    };

    for (var _i2 = 0, _Object$keys2 = Object.keys(ansiStyles.color.ansi); _i2 < _Object$keys2.length; _i2++) {
      var _ret = _loop2();

      if (_ret === "continue") continue;
    }

    ansiStyles.bgColor.closeRe = new RegExp(escapeStringRegexp(ansiStyles.bgColor.close), 'g');

    var _loop3 = function _loop3() {
      var model = _Object$keys3[_i3];

      if (skipModels.has(model)) {
        return "continue";
      }

      var bgModel = 'bg' + model[0].toUpperCase() + model.slice(1);
      styles[bgModel] = {
        get: function get() {
          var level = this.level;
          return function () {
            var open = ansiStyles.bgColor[levelMapping[level]][model].apply(null, arguments);
            var codes = {
              open: open,
              close: ansiStyles.bgColor.close,
              closeRe: ansiStyles.bgColor.closeRe
            };
            return build.call(this, this._styles ? this._styles.concat(codes) : [codes], this._empty, model);
          };
        }
      };
    };

    for (var _i3 = 0, _Object$keys3 = Object.keys(ansiStyles.bgColor.ansi); _i3 < _Object$keys3.length; _i3++) {
      var _ret2 = _loop3();

      if (_ret2 === "continue") continue;
    }

    var proto = Object.defineProperties(function () {}, styles);

    function build(_styles, _empty, key) {
      var builder = function builder() {
        return applyStyle.apply(builder, arguments);
      };

      builder._styles = _styles;
      builder._empty = _empty;
      var self = this;
      Object.defineProperty(builder, 'level', {
        enumerable: true,
        get: function get() {
          return self.level;
        },
        set: function set(level) {
          self.level = level;
        }
      });
      Object.defineProperty(builder, 'enabled', {
        enumerable: true,
        get: function get() {
          return self.enabled;
        },
        set: function set(enabled) {
          self.enabled = enabled;
        }
      }); // See below for fix regarding invisible grey/dim combination on Windows

      builder.hasGrey = this.hasGrey || key === 'gray' || key === 'grey'; // `__proto__` is used because we must return a function, but there is
      // no way to create a function with a different prototype

      builder.__proto__ = proto; // eslint-disable-line no-proto

      return builder;
    }

    function applyStyle() {
      // Support varags, but simply cast to string in case there's only one arg
      var args = arguments;
      var argsLen = args.length;
      var str = String(arguments[0]);

      if (argsLen === 0) {
        return '';
      }

      if (argsLen > 1) {
        // Don't slice `arguments`, it prevents V8 optimizations
        for (var a = 1; a < argsLen; a++) {
          str += ' ' + args[a];
        }
      }

      if (!this.enabled || this.level <= 0 || !str) {
        return this._empty ? '' : str;
      } // Turns out that on Windows dimmed gray text becomes invisible in cmd.exe,
      // see https://github.com/chalk/chalk/issues/58
      // If we're on Windows and we're dealing with a gray color, temporarily make 'dim' a noop.


      var originalDim = ansiStyles.dim.open;

      if (isSimpleWindowsTerm && this.hasGrey) {
        ansiStyles.dim.open = '';
      }

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = this._styles.slice().reverse()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var code = _step.value;
          // Replace any instances already present with a re-opening code
          // otherwise only the part of the string until said closing code
          // will be colored, and the rest will simply be 'plain'.
          str = code.open + str.replace(code.closeRe, code.open) + code.close; // Close the styling before a linebreak and reopen
          // after next line to fix a bleed issue on macOS
          // https://github.com/chalk/chalk/pull/92

          str = str.replace(/\r?\n/g, "".concat(code.close, "$&").concat(code.open));
        } // Reset the original `dim` if we changed it to work around the Windows dimmed gray issue

      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      ansiStyles.dim.open = originalDim;
      return str;
    }

    function chalkTag(chalk, strings) {
      if (!Array.isArray(strings)) {
        // If chalk() was called by itself or with a string,
        // return the string itself as a string.
        return [].slice.call(arguments, 1).join(' ');
      }

      var args = [].slice.call(arguments, 2);
      var parts = [strings.raw[0]];

      for (var i = 1; i < strings.length; i++) {
        parts.push(String(args[i - 1]).replace(/[{}\\]/g, '\\$&'));
        parts.push(String(strings.raw[i]));
      }

      return templates(chalk, parts.join(''));
    }

    Object.defineProperties(Chalk.prototype, styles);
    module.exports = Chalk(); // eslint-disable-line new-cap

    module.exports.supportsColor = stdoutColor;
    module.exports.default = module.exports; // For TypeScript
  });
  var chalk_1 = chalk.supportsColor;

  var common = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    exports.commonDeprecatedHandler = function (keyOrPair, redirectTo, _ref) {
      var descriptor = _ref.descriptor;
      var messages = ["".concat(chalk.default.yellow(typeof keyOrPair === 'string' ? descriptor.key(keyOrPair) : descriptor.pair(keyOrPair)), " is deprecated")];

      if (redirectTo) {
        messages.push("we now treat it as ".concat(chalk.default.blue(typeof redirectTo === 'string' ? descriptor.key(redirectTo) : descriptor.pair(redirectTo))));
      }

      return messages.join('; ') + '.';
    };
  });
  unwrapExports(common);
  var common_1 = common.commonDeprecatedHandler;

  var deprecated = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    tslib_1.__exportStar(common, exports);
  });
  unwrapExports(deprecated);

  var common$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    exports.commonInvalidHandler = function (key, value, utils) {
      return ["Invalid ".concat(chalk.default.red(utils.descriptor.key(key)), " value."), "Expected ".concat(chalk.default.blue(utils.schemas[key].expected(utils)), ","), "but received ".concat(chalk.default.red(utils.descriptor.value(value)), ".")].join(' ');
    };
  });
  unwrapExports(common$1);
  var common_1$1 = common$1.commonInvalidHandler;

  var invalid = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    tslib_1.__exportStar(common$1, exports);
  });
  unwrapExports(invalid);

  /* eslint-disable no-nested-ternary */

  var arr = [];
  var charCodeCache = [];

  var leven = function leven(a, b) {
    if (a === b) {
      return 0;
    }

    var swap = a; // Swapping the strings if `a` is longer than `b` so we know which one is the
    // shortest & which one is the longest

    if (a.length > b.length) {
      a = b;
      b = swap;
    }

    var aLen = a.length;
    var bLen = b.length;

    if (aLen === 0) {
      return bLen;
    }

    if (bLen === 0) {
      return aLen;
    } // Performing suffix trimming:
    // We can linearly drop suffix common to both strings since they
    // don't increase distance at all
    // Note: `~-` is the bitwise way to perform a `- 1` operation


    while (aLen > 0 && a.charCodeAt(~-aLen) === b.charCodeAt(~-bLen)) {
      aLen--;
      bLen--;
    }

    if (aLen === 0) {
      return bLen;
    } // Performing prefix trimming
    // We can linearly drop prefix common to both strings since they
    // don't increase distance at all


    var start = 0;

    while (start < aLen && a.charCodeAt(start) === b.charCodeAt(start)) {
      start++;
    }

    aLen -= start;
    bLen -= start;

    if (aLen === 0) {
      return bLen;
    }

    var bCharCode;
    var ret;
    var tmp;
    var tmp2;
    var i = 0;
    var j = 0;

    while (i < aLen) {
      charCodeCache[start + i] = a.charCodeAt(start + i);
      arr[i] = ++i;
    }

    while (j < bLen) {
      bCharCode = b.charCodeAt(start + j);
      tmp = j++;
      ret = j;

      for (i = 0; i < aLen; i++) {
        tmp2 = bCharCode === charCodeCache[start + i] ? tmp : tmp + 1;
        tmp = arr[i];
        ret = arr[i] = tmp > ret ? tmp2 > ret ? ret + 1 : tmp2 : tmp2 > tmp ? tmp + 1 : tmp2;
      }
    }

    return ret;
  };

  var leven_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    exports.levenUnknownHandler = function (key, value, _ref) {
      var descriptor = _ref.descriptor,
          logger = _ref.logger,
          schemas = _ref.schemas;
      var messages = ["Ignored unknown option ".concat(chalk.default.yellow(descriptor.pair({
        key: key,
        value: value
      })), ".")];
      var suggestion = Object.keys(schemas).sort().find(function (knownKey) {
        return leven(key, knownKey) < 3;
      });

      if (suggestion) {
        messages.push("Did you mean ".concat(chalk.default.blue(descriptor.key(suggestion)), "?"));
      }

      logger.warn(messages.join(' '));
    };
  });
  unwrapExports(leven_1);
  var leven_2 = leven_1.levenUnknownHandler;

  var unknown = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    tslib_1.__exportStar(leven_1, exports);
  });
  unwrapExports(unknown);

  var handlers = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    tslib_1.__exportStar(deprecated, exports);

    tslib_1.__exportStar(invalid, exports);

    tslib_1.__exportStar(unknown, exports);
  });
  unwrapExports(handlers);

  var schema = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    var HANDLER_KEYS = ['default', 'expected', 'validate', 'deprecated', 'forward', 'redirect', 'overlap', 'preprocess', 'postprocess'];

    function createSchema(SchemaConstructor, parameters) {
      var schema = new SchemaConstructor(parameters);
      var subSchema = Object.create(schema);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = HANDLER_KEYS[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var handlerKey = _step.value;

          if (handlerKey in parameters) {
            subSchema[handlerKey] = normalizeHandler(parameters[handlerKey], schema, Schema.prototype[handlerKey].length);
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return subSchema;
    }

    exports.createSchema = createSchema;

    var Schema =
    /*#__PURE__*/
    function () {
      function Schema(parameters) {
        _classCallCheck(this, Schema);

        this.name = parameters.name;
      }

      _createClass(Schema, [{
        key: "default",
        value: function _default(_utils) {
          return undefined;
        } // istanbul ignore next: this is actually an abstract method but we need a placeholder to get `function.length`

      }, {
        key: "expected",
        value: function expected(_utils) {
          return 'nothing';
        } // istanbul ignore next: this is actually an abstract method but we need a placeholder to get `function.length`

      }, {
        key: "validate",
        value: function validate(_value, _utils) {
          return false;
        }
      }, {
        key: "deprecated",
        value: function deprecated(_value, _utils) {
          return false;
        }
      }, {
        key: "forward",
        value: function forward(_value, _utils) {
          return undefined;
        }
      }, {
        key: "redirect",
        value: function redirect(_value, _utils) {
          return undefined;
        }
      }, {
        key: "overlap",
        value: function overlap(currentValue, _newValue, _utils) {
          return currentValue;
        }
      }, {
        key: "preprocess",
        value: function preprocess(value, _utils) {
          return value;
        }
      }, {
        key: "postprocess",
        value: function postprocess(value, _utils) {
          return value;
        }
      }], [{
        key: "create",
        value: function create(parameters) {
          // @ts-ignore: https://github.com/Microsoft/TypeScript/issues/5863
          return createSchema(this, parameters);
        }
      }]);

      return Schema;
    }();

    exports.Schema = Schema;

    function normalizeHandler(handler, superSchema, handlerArgumentsLength) {
      return typeof handler === 'function' ? function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return handler.apply(void 0, _toConsumableArray(args.slice(0, handlerArgumentsLength - 1)).concat([superSchema], _toConsumableArray(args.slice(handlerArgumentsLength - 1))));
      } : function () {
        return handler;
      };
    }
  });
  unwrapExports(schema);
  var schema_1 = schema.createSchema;
  var schema_2 = schema.Schema;

  var alias = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var AliasSchema =
    /*#__PURE__*/
    function (_schema_1$Schema) {
      _inherits(AliasSchema, _schema_1$Schema);

      function AliasSchema(parameters) {
        var _this;

        _classCallCheck(this, AliasSchema);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(AliasSchema).call(this, parameters));
        _this._sourceName = parameters.sourceName;
        return _this;
      }

      _createClass(AliasSchema, [{
        key: "expected",
        value: function expected(utils) {
          return utils.schemas[this._sourceName].expected(utils);
        }
      }, {
        key: "validate",
        value: function validate(value, utils) {
          return utils.schemas[this._sourceName].validate(value, utils);
        }
      }, {
        key: "redirect",
        value: function redirect(_value, _utils) {
          return this._sourceName;
        }
      }]);

      return AliasSchema;
    }(schema.Schema);

    exports.AliasSchema = AliasSchema;
  });
  unwrapExports(alias);
  var alias_1 = alias.AliasSchema;

  var any = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var AnySchema =
    /*#__PURE__*/
    function (_schema_1$Schema) {
      _inherits(AnySchema, _schema_1$Schema);

      function AnySchema() {
        _classCallCheck(this, AnySchema);

        return _possibleConstructorReturn(this, _getPrototypeOf(AnySchema).apply(this, arguments));
      }

      _createClass(AnySchema, [{
        key: "expected",
        value: function expected() {
          return 'anything';
        }
      }, {
        key: "validate",
        value: function validate() {
          return true;
        }
      }]);

      return AnySchema;
    }(schema.Schema);

    exports.AnySchema = AnySchema;
  });
  unwrapExports(any);
  var any_1 = any.AnySchema;

  var array = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var ArraySchema =
    /*#__PURE__*/
    function (_schema_1$Schema) {
      _inherits(ArraySchema, _schema_1$Schema);

      function ArraySchema(_a) {
        var _this;

        _classCallCheck(this, ArraySchema);

        var valueSchema = _a.valueSchema,
            _a$name = _a.name,
            name = _a$name === void 0 ? valueSchema.name : _a$name,
            handlers = tslib_1.__rest(_a, ["valueSchema", "name"]);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(ArraySchema).call(this, Object.assign({}, handlers, {
          name: name
        })));
        _this._valueSchema = valueSchema;
        return _this;
      }

      _createClass(ArraySchema, [{
        key: "expected",
        value: function expected(utils) {
          return "an array of ".concat(this._valueSchema.expected(utils));
        }
      }, {
        key: "validate",
        value: function validate(value, utils) {
          if (!Array.isArray(value)) {
            return false;
          }

          var invalidValues = [];
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = value[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              var subValue = _step.value;
              var subValidateResult = utils.normalizeValidateResult(this._valueSchema.validate(subValue, utils), subValue);

              if (subValidateResult !== true) {
                invalidValues.push(subValidateResult.value);
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          return invalidValues.length === 0 ? true : {
            value: invalidValues
          };
        }
      }, {
        key: "deprecated",
        value: function deprecated(value, utils) {
          var deprecatedResult = [];
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = value[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var subValue = _step2.value;
              var subDeprecatedResult = utils.normalizeDeprecatedResult(this._valueSchema.deprecated(subValue, utils), subValue);

              if (subDeprecatedResult !== false) {
                deprecatedResult.push.apply(deprecatedResult, _toConsumableArray(subDeprecatedResult.map(function (_ref) {
                  var deprecatedValue = _ref.value;
                  return {
                    value: [deprecatedValue]
                  };
                })));
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          return deprecatedResult;
        }
      }, {
        key: "forward",
        value: function forward(value, utils) {
          var forwardResult = [];
          var _iteratorNormalCompletion3 = true;
          var _didIteratorError3 = false;
          var _iteratorError3 = undefined;

          try {
            for (var _iterator3 = value[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
              var subValue = _step3.value;
              var subForwardResult = utils.normalizeForwardResult(this._valueSchema.forward(subValue, utils), subValue);
              forwardResult.push.apply(forwardResult, _toConsumableArray(subForwardResult.map(wrapTransferResult)));
            }
          } catch (err) {
            _didIteratorError3 = true;
            _iteratorError3 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                _iterator3.return();
              }
            } finally {
              if (_didIteratorError3) {
                throw _iteratorError3;
              }
            }
          }

          return forwardResult;
        }
      }, {
        key: "redirect",
        value: function redirect(value, utils) {
          var remain = [];
          var redirect = [];
          var _iteratorNormalCompletion4 = true;
          var _didIteratorError4 = false;
          var _iteratorError4 = undefined;

          try {
            for (var _iterator4 = value[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
              var subValue = _step4.value;
              var subRedirectResult = utils.normalizeRedirectResult(this._valueSchema.redirect(subValue, utils), subValue);

              if ('remain' in subRedirectResult) {
                remain.push(subRedirectResult.remain);
              }

              redirect.push.apply(redirect, _toConsumableArray(subRedirectResult.redirect.map(wrapTransferResult)));
            }
          } catch (err) {
            _didIteratorError4 = true;
            _iteratorError4 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
                _iterator4.return();
              }
            } finally {
              if (_didIteratorError4) {
                throw _iteratorError4;
              }
            }
          }

          return remain.length === 0 ? {
            redirect: redirect
          } : {
            redirect: redirect,
            remain: remain
          };
        }
      }, {
        key: "overlap",
        value: function overlap(currentValue, newValue) {
          return currentValue.concat(newValue);
        }
      }]);

      return ArraySchema;
    }(schema.Schema);

    exports.ArraySchema = ArraySchema;

    function wrapTransferResult(_ref2) {
      var from = _ref2.from,
          to = _ref2.to;
      return {
        from: [from],
        to: to
      };
    }
  });
  unwrapExports(array);
  var array_1 = array.ArraySchema;

  var boolean_1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var BooleanSchema =
    /*#__PURE__*/
    function (_schema_1$Schema) {
      _inherits(BooleanSchema, _schema_1$Schema);

      function BooleanSchema() {
        _classCallCheck(this, BooleanSchema);

        return _possibleConstructorReturn(this, _getPrototypeOf(BooleanSchema).apply(this, arguments));
      }

      _createClass(BooleanSchema, [{
        key: "expected",
        value: function expected() {
          return 'true or false';
        }
      }, {
        key: "validate",
        value: function validate(value) {
          return typeof value === 'boolean';
        }
      }]);

      return BooleanSchema;
    }(schema.Schema);

    exports.BooleanSchema = BooleanSchema;
  });
  unwrapExports(boolean_1);
  var boolean_2 = boolean_1.BooleanSchema;

  var utils = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    function recordFromArray(array, mainKey) {
      var record = Object.create(null);
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = array[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var value = _step.value;
          var key = value[mainKey]; // istanbul ignore next

          if (record[key]) {
            throw new Error("Duplicate ".concat(mainKey, " ").concat(JSON.stringify(key)));
          } // @ts-ignore


          record[key] = value;
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return record;
    }

    exports.recordFromArray = recordFromArray;

    function mapFromArray(array, mainKey) {
      var map = new Map();
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = array[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var value = _step2.value;
          var key = value[mainKey]; // istanbul ignore next

          if (map.has(key)) {
            throw new Error("Duplicate ".concat(mainKey, " ").concat(JSON.stringify(key)));
          }

          map.set(key, value);
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return map;
    }

    exports.mapFromArray = mapFromArray;

    function createAutoChecklist() {
      var map = Object.create(null);
      return function (id) {
        var idString = JSON.stringify(id);

        if (map[idString]) {
          return true;
        }

        map[idString] = true;
        return false;
      };
    }

    exports.createAutoChecklist = createAutoChecklist;

    function partition(array, predicate) {
      var trueArray = [];
      var falseArray = [];
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = array[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var value = _step3.value;

          if (predicate(value)) {
            trueArray.push(value);
          } else {
            falseArray.push(value);
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      return [trueArray, falseArray];
    }

    exports.partition = partition;

    function isInt(value) {
      return value === Math.floor(value);
    }

    exports.isInt = isInt;

    function comparePrimitive(a, b) {
      if (a === b) {
        return 0;
      }

      var typeofA = _typeof(a);

      var typeofB = _typeof(b);

      var orders = ['undefined', 'object', 'boolean', 'number', 'string'];

      if (typeofA !== typeofB) {
        return orders.indexOf(typeofA) - orders.indexOf(typeofB);
      }

      if (typeofA !== 'string') {
        return Number(a) - Number(b);
      }

      return a.localeCompare(b);
    }

    exports.comparePrimitive = comparePrimitive;

    function normalizeDefaultResult(result) {
      return result === undefined ? {} : result;
    }

    exports.normalizeDefaultResult = normalizeDefaultResult;

    function normalizeValidateResult(result, value) {
      return result === true ? true : result === false ? {
        value: value
      } : result;
    }

    exports.normalizeValidateResult = normalizeValidateResult;

    function normalizeDeprecatedResult(result, value) {
      var doNotNormalizeTrue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      return result === false ? false : result === true ? doNotNormalizeTrue ? true : [{
        value: value
      }] : 'value' in result ? [result] : result.length === 0 ? false : result;
    }

    exports.normalizeDeprecatedResult = normalizeDeprecatedResult;

    function normalizeTransferResult(result, value) {
      return typeof result === 'string' || 'key' in result ? {
        from: value,
        to: result
      } : 'from' in result ? {
        from: result.from,
        to: result.to
      } : {
        from: value,
        to: result.to
      };
    }

    exports.normalizeTransferResult = normalizeTransferResult;

    function normalizeForwardResult(result, value) {
      return result === undefined ? [] : Array.isArray(result) ? result.map(function (transferResult) {
        return normalizeTransferResult(transferResult, value);
      }) : [normalizeTransferResult(result, value)];
    }

    exports.normalizeForwardResult = normalizeForwardResult;

    function normalizeRedirectResult(result, value) {
      var redirect = normalizeForwardResult(_typeof(result) === 'object' && 'redirect' in result ? result.redirect : result, value);
      return redirect.length === 0 ? {
        remain: value,
        redirect: redirect
      } : _typeof(result) === 'object' && 'remain' in result ? {
        remain: result.remain,
        redirect: redirect
      } : {
        redirect: redirect
      };
    }

    exports.normalizeRedirectResult = normalizeRedirectResult;
  });
  unwrapExports(utils);
  var utils_1 = utils.recordFromArray;
  var utils_2 = utils.mapFromArray;
  var utils_3 = utils.createAutoChecklist;
  var utils_4 = utils.partition;
  var utils_5 = utils.isInt;
  var utils_6 = utils.comparePrimitive;
  var utils_7 = utils.normalizeDefaultResult;
  var utils_8 = utils.normalizeValidateResult;
  var utils_9 = utils.normalizeDeprecatedResult;
  var utils_10 = utils.normalizeTransferResult;
  var utils_11 = utils.normalizeForwardResult;
  var utils_12 = utils.normalizeRedirectResult;

  var choice = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var ChoiceSchema =
    /*#__PURE__*/
    function (_schema_1$Schema) {
      _inherits(ChoiceSchema, _schema_1$Schema);

      function ChoiceSchema(parameters) {
        var _this;

        _classCallCheck(this, ChoiceSchema);

        _this = _possibleConstructorReturn(this, _getPrototypeOf(ChoiceSchema).call(this, parameters));
        _this._choices = utils.mapFromArray(parameters.choices.map(function (choice) {
          return choice && _typeof(choice) === 'object' ? choice : {
            value: choice
          };
        }), 'value');
        return _this;
      }

      _createClass(ChoiceSchema, [{
        key: "expected",
        value: function expected(_ref) {
          var _this2 = this;

          var descriptor = _ref.descriptor;
          var choiceValues = Array.from(this._choices.keys()).map(function (value) {
            return _this2._choices.get(value);
          }).filter(function (choiceInfo) {
            return !choiceInfo.deprecated;
          }).map(function (choiceInfo) {
            return choiceInfo.value;
          }).sort(utils.comparePrimitive).map(descriptor.value);
          var head = choiceValues.slice(0, -2);
          var tail = choiceValues.slice(-2);
          return head.concat(tail.join(' or ')).join(', ');
        }
      }, {
        key: "validate",
        value: function validate(value) {
          return this._choices.has(value);
        }
      }, {
        key: "deprecated",
        value: function deprecated(value) {
          var choiceInfo = this._choices.get(value);

          return choiceInfo && choiceInfo.deprecated ? {
            value: value
          } : false;
        }
      }, {
        key: "forward",
        value: function forward(value) {
          var choiceInfo = this._choices.get(value);

          return choiceInfo ? choiceInfo.forward : undefined;
        }
      }, {
        key: "redirect",
        value: function redirect(value) {
          var choiceInfo = this._choices.get(value);

          return choiceInfo ? choiceInfo.redirect : undefined;
        }
      }]);

      return ChoiceSchema;
    }(schema.Schema);

    exports.ChoiceSchema = ChoiceSchema;
  });
  unwrapExports(choice);
  var choice_1 = choice.ChoiceSchema;

  var number = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var NumberSchema =
    /*#__PURE__*/
    function (_schema_1$Schema) {
      _inherits(NumberSchema, _schema_1$Schema);

      function NumberSchema() {
        _classCallCheck(this, NumberSchema);

        return _possibleConstructorReturn(this, _getPrototypeOf(NumberSchema).apply(this, arguments));
      }

      _createClass(NumberSchema, [{
        key: "expected",
        value: function expected() {
          return 'a number';
        }
      }, {
        key: "validate",
        value: function validate(value, _utils) {
          return typeof value === 'number';
        }
      }]);

      return NumberSchema;
    }(schema.Schema);

    exports.NumberSchema = NumberSchema;
  });
  unwrapExports(number);
  var number_1 = number.NumberSchema;

  var integer = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var IntegerSchema =
    /*#__PURE__*/
    function (_number_1$NumberSchem) {
      _inherits(IntegerSchema, _number_1$NumberSchem);

      function IntegerSchema() {
        _classCallCheck(this, IntegerSchema);

        return _possibleConstructorReturn(this, _getPrototypeOf(IntegerSchema).apply(this, arguments));
      }

      _createClass(IntegerSchema, [{
        key: "expected",
        value: function expected() {
          return 'an integer';
        }
      }, {
        key: "validate",
        value: function validate(value, utils$1) {
          return utils$1.normalizeValidateResult(_get(_getPrototypeOf(IntegerSchema.prototype), "validate", this).call(this, value, utils$1), value) === true && utils.isInt(value);
        }
      }]);

      return IntegerSchema;
    }(number.NumberSchema);

    exports.IntegerSchema = IntegerSchema;
  });
  unwrapExports(integer);
  var integer_1 = integer.IntegerSchema;

  var string = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    var StringSchema =
    /*#__PURE__*/
    function (_schema_1$Schema) {
      _inherits(StringSchema, _schema_1$Schema);

      function StringSchema() {
        _classCallCheck(this, StringSchema);

        return _possibleConstructorReturn(this, _getPrototypeOf(StringSchema).apply(this, arguments));
      }

      _createClass(StringSchema, [{
        key: "expected",
        value: function expected() {
          return 'a string';
        }
      }, {
        key: "validate",
        value: function validate(value) {
          return typeof value === 'string';
        }
      }]);

      return StringSchema;
    }(schema.Schema);

    exports.StringSchema = StringSchema;
  });
  unwrapExports(string);
  var string_1 = string.StringSchema;

  var schemas = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    tslib_1.__exportStar(alias, exports);

    tslib_1.__exportStar(any, exports);

    tslib_1.__exportStar(array, exports);

    tslib_1.__exportStar(boolean_1, exports);

    tslib_1.__exportStar(choice, exports);

    tslib_1.__exportStar(integer, exports);

    tslib_1.__exportStar(number, exports);

    tslib_1.__exportStar(string, exports);
  });
  unwrapExports(schemas);

  var defaults = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.defaultDescriptor = api.apiDescriptor;
    exports.defaultUnknownHandler = leven_1.levenUnknownHandler;
    exports.defaultInvalidHandler = invalid.commonInvalidHandler;
    exports.defaultDeprecatedHandler = common.commonDeprecatedHandler;
  });
  unwrapExports(defaults);
  var defaults_1 = defaults.defaultDescriptor;
  var defaults_2 = defaults.defaultUnknownHandler;
  var defaults_3 = defaults.defaultInvalidHandler;
  var defaults_4 = defaults.defaultDeprecatedHandler;

  var normalize = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    exports.normalize = function (options, schemas, opts) {
      return new Normalizer(schemas, opts).normalize(options);
    };

    var Normalizer =
    /*#__PURE__*/
    function () {
      function Normalizer(schemas, opts) {
        _classCallCheck(this, Normalizer);

        // istanbul ignore next
        var _ref = opts || {},
            _ref$logger = _ref.logger,
            logger = _ref$logger === void 0 ? console : _ref$logger,
            _ref$descriptor = _ref.descriptor,
            descriptor = _ref$descriptor === void 0 ? defaults.defaultDescriptor : _ref$descriptor,
            _ref$unknown = _ref.unknown,
            unknown = _ref$unknown === void 0 ? defaults.defaultUnknownHandler : _ref$unknown,
            _ref$invalid = _ref.invalid,
            invalid = _ref$invalid === void 0 ? defaults.defaultInvalidHandler : _ref$invalid,
            _ref$deprecated = _ref.deprecated,
            deprecated = _ref$deprecated === void 0 ? defaults.defaultDeprecatedHandler : _ref$deprecated;

        this._utils = {
          descriptor: descriptor,
          logger:
          /* istanbul ignore next */
          logger || {
            warn: function warn() {}
          },
          schemas: utils.recordFromArray(schemas, 'name'),
          normalizeDefaultResult: utils.normalizeDefaultResult,
          normalizeDeprecatedResult: utils.normalizeDeprecatedResult,
          normalizeForwardResult: utils.normalizeForwardResult,
          normalizeRedirectResult: utils.normalizeRedirectResult,
          normalizeValidateResult: utils.normalizeValidateResult
        };
        this._unknownHandler = unknown;
        this._invalidHandler = invalid;
        this._deprecatedHandler = deprecated;
        this.cleanHistory();
      }

      _createClass(Normalizer, [{
        key: "cleanHistory",
        value: function cleanHistory() {
          this._hasDeprecationWarned = utils.createAutoChecklist();
        }
      }, {
        key: "normalize",
        value: function normalize(options) {
          var _this = this;

          var normalized = {};
          var restOptionsArray = [options];

          var applyNormalization = function applyNormalization() {
            while (restOptionsArray.length !== 0) {
              var currentOptions = restOptionsArray.shift();

              var transferredOptionsArray = _this._applyNormalization(currentOptions, normalized);

              restOptionsArray.push.apply(restOptionsArray, _toConsumableArray(transferredOptionsArray));
            }
          };

          applyNormalization();

          for (var _i = 0, _Object$keys = Object.keys(this._utils.schemas); _i < _Object$keys.length; _i++) {
            var key = _Object$keys[_i];
            var schema = this._utils.schemas[key];

            if (!(key in normalized)) {
              var defaultResult = utils.normalizeDefaultResult(schema.default(this._utils));

              if ('value' in defaultResult) {
                restOptionsArray.push(_defineProperty({}, key, defaultResult.value));
              }
            }
          }

          applyNormalization();

          for (var _i2 = 0, _Object$keys2 = Object.keys(this._utils.schemas); _i2 < _Object$keys2.length; _i2++) {
            var _key = _Object$keys2[_i2];
            var _schema = this._utils.schemas[_key];

            if (_key in normalized) {
              normalized[_key] = _schema.postprocess(normalized[_key], this._utils);
            }
          }

          return normalized;
        }
      }, {
        key: "_applyNormalization",
        value: function _applyNormalization(options, normalized) {
          var _this2 = this;

          var transferredOptionsArray = [];

          var _utils_1$partition = utils.partition(Object.keys(options), function (key) {
            return key in _this2._utils.schemas;
          }),
              _utils_1$partition2 = _slicedToArray(_utils_1$partition, 2),
              knownOptionNames = _utils_1$partition2[0],
              unknownOptionNames = _utils_1$partition2[1];

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            var _loop = function _loop() {
              var key = _step.value;
              var schema = _this2._utils.schemas[key];
              var value = schema.preprocess(options[key], _this2._utils);
              var validateResult = utils.normalizeValidateResult(schema.validate(value, _this2._utils), value);

              if (validateResult !== true) {
                var invalidValue = validateResult.value;

                var errorMessageOrError = _this2._invalidHandler(key, invalidValue, _this2._utils);

                throw typeof errorMessageOrError === 'string' ? new Error(errorMessageOrError) :
                /* istanbul ignore next*/
                errorMessageOrError;
              }

              var appendTransferredOptions = function appendTransferredOptions(_ref2) {
                var from = _ref2.from,
                    to = _ref2.to;
                transferredOptionsArray.push(typeof to === 'string' ? _defineProperty({}, to, from) : _defineProperty({}, to.key, to.value));
              };

              var warnDeprecated = function warnDeprecated(_ref5) {
                var currentValue = _ref5.value,
                    redirectTo = _ref5.redirectTo;
                var deprecatedResult = utils.normalizeDeprecatedResult(schema.deprecated(currentValue, _this2._utils), value,
                /* doNotNormalizeTrue */
                true);

                if (deprecatedResult === false) {
                  return;
                }

                if (deprecatedResult === true) {
                  if (!_this2._hasDeprecationWarned(key)) {
                    _this2._utils.logger.warn(_this2._deprecatedHandler(key, redirectTo, _this2._utils));
                  }
                } else {
                  var _iteratorNormalCompletion3 = true;
                  var _didIteratorError3 = false;
                  var _iteratorError3 = undefined;

                  try {
                    for (var _iterator3 = deprecatedResult[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
                      var deprecatedValue = _step3.value.value;
                      var pair = {
                        key: key,
                        value: deprecatedValue
                      };

                      if (!_this2._hasDeprecationWarned(pair)) {
                        var redirectToPair = typeof redirectTo === 'string' ? {
                          key: redirectTo,
                          value: deprecatedValue
                        } : redirectTo;

                        _this2._utils.logger.warn(_this2._deprecatedHandler(pair, redirectToPair, _this2._utils));
                      }
                    }
                  } catch (err) {
                    _didIteratorError3 = true;
                    _iteratorError3 = err;
                  } finally {
                    try {
                      if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
                        _iterator3.return();
                      }
                    } finally {
                      if (_didIteratorError3) {
                        throw _iteratorError3;
                      }
                    }
                  }
                }
              };

              var forwardResult = utils.normalizeForwardResult(schema.forward(value, _this2._utils), value);
              forwardResult.forEach(appendTransferredOptions);
              var redirectResult = utils.normalizeRedirectResult(schema.redirect(value, _this2._utils), value);
              redirectResult.redirect.forEach(appendTransferredOptions);

              if ('remain' in redirectResult) {
                var remainingValue = redirectResult.remain;
                normalized[key] = key in normalized ? schema.overlap(normalized[key], remainingValue, _this2._utils) : remainingValue;
                warnDeprecated({
                  value: remainingValue
                });
              }

              var _iteratorNormalCompletion4 = true;
              var _didIteratorError4 = false;
              var _iteratorError4 = undefined;

              try {
                for (var _iterator4 = redirectResult.redirect[Symbol.iterator](), _step4; !(_iteratorNormalCompletion4 = (_step4 = _iterator4.next()).done); _iteratorNormalCompletion4 = true) {
                  var _step4$value = _step4.value,
                      from = _step4$value.from,
                      to = _step4$value.to;
                  warnDeprecated({
                    value: from,
                    redirectTo: to
                  });
                }
              } catch (err) {
                _didIteratorError4 = true;
                _iteratorError4 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion4 && _iterator4.return != null) {
                    _iterator4.return();
                  }
                } finally {
                  if (_didIteratorError4) {
                    throw _iteratorError4;
                  }
                }
              }
            };

            for (var _iterator = knownOptionNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              _loop();
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return != null) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = unknownOptionNames[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var key = _step2.value;
              var value = options[key];

              var unknownResult = this._unknownHandler(key, value, this._utils);

              if (unknownResult) {
                for (var _i3 = 0, _Object$keys3 = Object.keys(unknownResult); _i3 < _Object$keys3.length; _i3++) {
                  var unknownKey = _Object$keys3[_i3];

                  var unknownOption = _defineProperty({}, unknownKey, unknownResult[unknownKey]);

                  if (unknownKey in this._utils.schemas) {
                    transferredOptionsArray.push(unknownOption);
                  } else {
                    Object.assign(normalized, unknownOption);
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }

          return transferredOptionsArray;
        }
      }]);

      return Normalizer;
    }();

    exports.Normalizer = Normalizer;
  });
  unwrapExports(normalize);
  var normalize_1 = normalize.normalize;
  var normalize_2 = normalize.Normalizer;

  var lib = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });

    tslib_1.__exportStar(descriptors, exports);

    tslib_1.__exportStar(handlers, exports);

    tslib_1.__exportStar(schemas, exports);

    tslib_1.__exportStar(normalize, exports);

    tslib_1.__exportStar(schema, exports);
  });
  unwrapExports(lib);

  var array$1 = [];
  var charCodeCache$1 = [];

  var leven$1 = function leven(left, right) {
    if (left === right) {
      return 0;
    }

    var swap = left; // Swapping the strings if `a` is longer than `b` so we know which one is the
    // shortest & which one is the longest

    if (left.length > right.length) {
      left = right;
      right = swap;
    }

    var leftLength = left.length;
    var rightLength = right.length; // Performing suffix trimming:
    // We can linearly drop suffix common to both strings since they
    // don't increase distance at all
    // Note: `~-` is the bitwise way to perform a `- 1` operation

    while (leftLength > 0 && left.charCodeAt(~-leftLength) === right.charCodeAt(~-rightLength)) {
      leftLength--;
      rightLength--;
    } // Performing prefix trimming
    // We can linearly drop prefix common to both strings since they
    // don't increase distance at all


    var start = 0;

    while (start < leftLength && left.charCodeAt(start) === right.charCodeAt(start)) {
      start++;
    }

    leftLength -= start;
    rightLength -= start;

    if (leftLength === 0) {
      return rightLength;
    }

    var bCharCode;
    var result;
    var temp;
    var temp2;
    var i = 0;
    var j = 0;

    while (i < leftLength) {
      charCodeCache$1[i] = left.charCodeAt(start + i);
      array$1[i] = ++i;
    }

    while (j < rightLength) {
      bCharCode = right.charCodeAt(start + j);
      temp = j++;
      result = j;

      for (i = 0; i < leftLength; i++) {
        temp2 = bCharCode === charCodeCache$1[i] ? temp : temp + 1;
        temp = array$1[i]; // eslint-disable-next-line no-multi-assign

        result = array$1[i] = temp > result ? temp2 > result ? result + 1 : temp2 : temp2 > temp ? temp + 1 : temp2;
      }
    }

    return result;
  };

  var leven_1$1 = leven$1; // TODO: Remove this for the next major release

  var default_1 = leven$1;
  leven_1$1.default = default_1;

  var cliDescriptor = {
    key: function key(_key) {
      return _key.length === 1 ? "-".concat(_key) : "--".concat(_key);
    },
    value: function value(_value) {
      return lib.apiDescriptor.value(_value);
    },
    pair: function pair(_ref) {
      var key = _ref.key,
          value = _ref.value;
      return value === false ? "--no-".concat(key) : value === true ? cliDescriptor.key(key) : value === "" ? "".concat(cliDescriptor.key(key), " without an argument") : "".concat(cliDescriptor.key(key), "=").concat(value);
    }
  };

  var FlagSchema =
  /*#__PURE__*/
  function (_vnopts$ChoiceSchema) {
    _inherits(FlagSchema, _vnopts$ChoiceSchema);

    function FlagSchema(_ref2) {
      var _this;

      var name = _ref2.name,
          flags = _ref2.flags;

      _classCallCheck(this, FlagSchema);

      _this = _possibleConstructorReturn(this, _getPrototypeOf(FlagSchema).call(this, {
        name: name,
        choices: flags
      }));
      _this._flags = flags.slice().sort();
      return _this;
    }

    _createClass(FlagSchema, [{
      key: "preprocess",
      value: function preprocess(value, utils) {
        if (typeof value === "string" && value.length !== 0 && this._flags.indexOf(value) === -1) {
          var suggestion = this._flags.find(function (flag) {
            return leven_1$1(flag, value) < 3;
          });

          if (suggestion) {
            utils.logger.warn(["Unknown flag ".concat(chalk.yellow(utils.descriptor.value(value)), ","), "did you mean ".concat(chalk.blue(utils.descriptor.value(suggestion)), "?")].join(" "));
            return suggestion;
          }
        }

        return value;
      }
    }, {
      key: "expected",
      value: function expected() {
        return "a flag";
      }
    }]);

    return FlagSchema;
  }(lib.ChoiceSchema);

  var hasDeprecationWarned;

  function normalizeOptions(options, optionInfos) {
    var _ref3 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        logger = _ref3.logger,
        _ref3$isCLI = _ref3.isCLI,
        isCLI = _ref3$isCLI === void 0 ? false : _ref3$isCLI,
        _ref3$passThrough = _ref3.passThrough,
        passThrough = _ref3$passThrough === void 0 ? false : _ref3$passThrough;

    var unknown = !passThrough ? lib.levenUnknownHandler : Array.isArray(passThrough) ? function (key, value) {
      return passThrough.indexOf(key) === -1 ? undefined : _defineProperty({}, key, value);
    } : function (key, value) {
      return _defineProperty({}, key, value);
    };
    var descriptor = isCLI ? cliDescriptor : lib.apiDescriptor;
    var schemas = optionInfosToSchemas(optionInfos, {
      isCLI: isCLI
    });
    var normalizer = new lib.Normalizer(schemas, {
      logger: logger,
      unknown: unknown,
      descriptor: descriptor
    });
    var shouldSuppressDuplicateDeprecationWarnings = logger !== false;

    if (shouldSuppressDuplicateDeprecationWarnings && hasDeprecationWarned) {
      normalizer._hasDeprecationWarned = hasDeprecationWarned;
    }

    var normalized = normalizer.normalize(options);

    if (shouldSuppressDuplicateDeprecationWarnings) {
      hasDeprecationWarned = normalizer._hasDeprecationWarned;
    }

    return normalized;
  }

  function optionInfosToSchemas(optionInfos, _ref6) {
    var isCLI = _ref6.isCLI;
    var schemas = [];

    if (isCLI) {
      schemas.push(lib.AnySchema.create({
        name: "_"
      }));
    }

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = optionInfos[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var optionInfo = _step.value;
        schemas.push(optionInfoToSchema(optionInfo, {
          isCLI: isCLI,
          optionInfos: optionInfos
        }));

        if (optionInfo.alias && isCLI) {
          schemas.push(lib.AliasSchema.create({
            name: optionInfo.alias,
            sourceName: optionInfo.name
          }));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return schemas;
  }

  function optionInfoToSchema(optionInfo, _ref7) {
    var isCLI = _ref7.isCLI,
        optionInfos = _ref7.optionInfos;
    var SchemaConstructor;
    var parameters = {
      name: optionInfo.name
    };
    var handlers = {};

    switch (optionInfo.type) {
      case "int":
        SchemaConstructor = lib.IntegerSchema;

        if (isCLI) {
          parameters.preprocess = function (value) {
            return Number(value);
          };
        }

        break;

      case "string":
        SchemaConstructor = lib.StringSchema;
        break;

      case "choice":
        SchemaConstructor = lib.ChoiceSchema;
        parameters.choices = optionInfo.choices.map(function (choiceInfo) {
          return _typeof(choiceInfo) === "object" && choiceInfo.redirect ? Object.assign({}, choiceInfo, {
            redirect: {
              to: {
                key: optionInfo.name,
                value: choiceInfo.redirect
              }
            }
          }) : choiceInfo;
        });
        break;

      case "boolean":
        SchemaConstructor = lib.BooleanSchema;
        break;

      case "flag":
        SchemaConstructor = FlagSchema;
        parameters.flags = optionInfos.map(function (optionInfo) {
          return [].concat(optionInfo.alias || [], optionInfo.description ? optionInfo.name : [], optionInfo.oppositeDescription ? "no-".concat(optionInfo.name) : []);
        }).reduce(function (a, b) {
          return a.concat(b);
        }, []);
        break;

      case "path":
        SchemaConstructor = lib.StringSchema;
        break;

      default:
        throw new Error("Unexpected type ".concat(optionInfo.type));
    }

    if (optionInfo.exception) {
      parameters.validate = function (value, schema, utils) {
        return optionInfo.exception(value) || schema.validate(value, utils);
      };
    } else {
      parameters.validate = function (value, schema, utils) {
        return value === undefined || schema.validate(value, utils);
      };
    }

    if (optionInfo.redirect) {
      handlers.redirect = function (value) {
        return !value ? undefined : {
          to: {
            key: optionInfo.redirect.option,
            value: optionInfo.redirect.value
          }
        };
      };
    }

    if (optionInfo.deprecated) {
      handlers.deprecated = true;
    } // allow CLI overriding, e.g., prettier package.json --tab-width 1 --tab-width 2


    if (isCLI && !optionInfo.array) {
      var originalPreprocess = parameters.preprocess || function (x) {
        return x;
      };

      parameters.preprocess = function (value, schema, utils) {
        return schema.preprocess(originalPreprocess(Array.isArray(value) ? value[value.length - 1] : value), utils);
      };
    }

    return optionInfo.array ? lib.ArraySchema.create(Object.assign(isCLI ? {
      preprocess: function preprocess(v) {
        return [].concat(v);
      }
    } : {}, handlers, {
      valueSchema: SchemaConstructor.create(parameters)
    })) : SchemaConstructor.create(Object.assign({}, parameters, handlers));
  }

  function normalizeApiOptions(options, optionInfos, opts) {
    return normalizeOptions(options, optionInfos, opts);
  }

  function normalizeCliOptions(options, optionInfos, opts) {
    return normalizeOptions(options, optionInfos, Object.assign({
      isCLI: true
    }, opts));
  }

  var optionsNormalizer = {
    normalizeApiOptions: normalizeApiOptions,
    normalizeCliOptions: normalizeCliOptions
  };

  var getLast = function getLast(arr) {
    return arr.length > 0 ? arr[arr.length - 1] : null;
  };

  function locStart(node, opts) {
    opts = opts || {}; // Handle nodes with decorators. They should start at the first decorator

    if (!opts.ignoreDecorators && node.declaration && node.declaration.decorators && node.declaration.decorators.length > 0) {
      return locStart(node.declaration.decorators[0]);
    }

    if (!opts.ignoreDecorators && node.decorators && node.decorators.length > 0) {
      return locStart(node.decorators[0]);
    }

    if (node.__location) {
      return node.__location.startOffset;
    }

    if (node.range) {
      return node.range[0];
    }

    if (typeof node.start === "number") {
      return node.start;
    }

    if (node.loc) {
      return node.loc.start;
    }

    return null;
  }

  function locEnd(node) {
    var endNode = node.nodes && getLast(node.nodes);

    if (endNode && node.source && !node.source.end) {
      node = endNode;
    }

    if (node.__location) {
      return node.__location.endOffset;
    }

    var loc = node.range ? node.range[1] : typeof node.end === "number" ? node.end : null;

    if (node.typeAnnotation) {
      return Math.max(loc, locEnd(node.typeAnnotation));
    }

    if (node.loc && !loc) {
      return node.loc.end;
    }

    return loc;
  }

  var loc = {
    locStart: locStart,
    locEnd: locEnd
  };

  var jsTokens = createCommonjsModule(function (module, exports) {
    // Copyright 2014, 2015, 2016, 2017, 2018 Simon Lydell
    // License: MIT. (See LICENSE.)
    Object.defineProperty(exports, "__esModule", {
      value: true
    }); // This regex comes from regex.coffee, and is inserted here by generate-index.js
    // (run `npm run build`).

    exports.default = /((['"])(?:(?!\2|\\).|\\(?:\r\n|[\s\S]))*(\2)?|`(?:[^`\\$]|\\[\s\S]|\$(?!\{)|\$\{(?:[^{}]|\{[^}]*\}?)*\}?)*(`)?)|(\/\/.*)|(\/\*(?:[^*]|\*(?!\/))*(\*\/)?)|(\/(?!\*)(?:\[(?:(?![\]\\]).|\\.)*\]|(?![\/\]\\]).|\\.)+\/(?:(?!\s*(?:\b|[\u0080-\uFFFF$\\'"~({]|[+\-!](?!=)|\.?\d))|[gmiyus]{1,6}\b(?![\u0080-\uFFFF$\\]|\s*(?:[+\-*%&|^<>!=?({]|\/(?![\/*])))))|(0[xX][\da-fA-F]+|0[oO][0-7]+|0[bB][01]+|(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?)|((?!\d)(?:(?!\s)[$\w\u0080-\uFFFF]|\\u[\da-fA-F]{4}|\\u\{[\da-fA-F]+\})+)|(--|\+\+|&&|\|\||=>|\.{3}|(?:[+\-\/%&|^]|\*{1,2}|<{1,2}|>{1,3}|!=?|={1,2})=?|[?~.,:;[\](){}])|(\s+)|(^$|[\s\S])/g;

    exports.matchToToken = function (match) {
      var token = {
        type: "invalid",
        value: match[0],
        closed: undefined
      };
      if (match[1]) token.type = "string", token.closed = !!(match[3] || match[4]);else if (match[5]) token.type = "comment";else if (match[6]) token.type = "comment", token.closed = !!match[7];else if (match[8]) token.type = "regex";else if (match[9]) token.type = "number";else if (match[10]) token.type = "name";else if (match[11]) token.type = "punctuator";else if (match[12]) token.type = "whitespace";
      return token;
    };
  });
  unwrapExports(jsTokens);
  var jsTokens_1 = jsTokens.matchToToken;

  var ast = createCommonjsModule(function (module) {
    /*
      Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>
    
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:
    
        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
    
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS 'AS IS'
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */
    (function () {

      function isExpression(node) {
        if (node == null) {
          return false;
        }

        switch (node.type) {
          case 'ArrayExpression':
          case 'AssignmentExpression':
          case 'BinaryExpression':
          case 'CallExpression':
          case 'ConditionalExpression':
          case 'FunctionExpression':
          case 'Identifier':
          case 'Literal':
          case 'LogicalExpression':
          case 'MemberExpression':
          case 'NewExpression':
          case 'ObjectExpression':
          case 'SequenceExpression':
          case 'ThisExpression':
          case 'UnaryExpression':
          case 'UpdateExpression':
            return true;
        }

        return false;
      }

      function isIterationStatement(node) {
        if (node == null) {
          return false;
        }

        switch (node.type) {
          case 'DoWhileStatement':
          case 'ForInStatement':
          case 'ForStatement':
          case 'WhileStatement':
            return true;
        }

        return false;
      }

      function isStatement(node) {
        if (node == null) {
          return false;
        }

        switch (node.type) {
          case 'BlockStatement':
          case 'BreakStatement':
          case 'ContinueStatement':
          case 'DebuggerStatement':
          case 'DoWhileStatement':
          case 'EmptyStatement':
          case 'ExpressionStatement':
          case 'ForInStatement':
          case 'ForStatement':
          case 'IfStatement':
          case 'LabeledStatement':
          case 'ReturnStatement':
          case 'SwitchStatement':
          case 'ThrowStatement':
          case 'TryStatement':
          case 'VariableDeclaration':
          case 'WhileStatement':
          case 'WithStatement':
            return true;
        }

        return false;
      }

      function isSourceElement(node) {
        return isStatement(node) || node != null && node.type === 'FunctionDeclaration';
      }

      function trailingStatement(node) {
        switch (node.type) {
          case 'IfStatement':
            if (node.alternate != null) {
              return node.alternate;
            }

            return node.consequent;

          case 'LabeledStatement':
          case 'ForStatement':
          case 'ForInStatement':
          case 'WhileStatement':
          case 'WithStatement':
            return node.body;
        }

        return null;
      }

      function isProblematicIfStatement(node) {
        var current;

        if (node.type !== 'IfStatement') {
          return false;
        }

        if (node.alternate == null) {
          return false;
        }

        current = node.consequent;

        do {
          if (current.type === 'IfStatement') {
            if (current.alternate == null) {
              return true;
            }
          }

          current = trailingStatement(current);
        } while (current);

        return false;
      }

      module.exports = {
        isExpression: isExpression,
        isStatement: isStatement,
        isIterationStatement: isIterationStatement,
        isSourceElement: isSourceElement,
        isProblematicIfStatement: isProblematicIfStatement,
        trailingStatement: trailingStatement
      };
    })();
    /* vim: set sw=4 ts=4 et tw=80 : */

  });
  var ast_1 = ast.isExpression;
  var ast_2 = ast.isStatement;
  var ast_3 = ast.isIterationStatement;
  var ast_4 = ast.isSourceElement;
  var ast_5 = ast.isProblematicIfStatement;
  var ast_6 = ast.trailingStatement;

  var code = createCommonjsModule(function (module) {
    /*
      Copyright (C) 2013-2014 Yusuke Suzuki <utatane.tea@gmail.com>
      Copyright (C) 2014 Ivan Nikulin <ifaaan@gmail.com>
    
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:
    
        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
    
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */
    (function () {

      var ES6Regex, ES5Regex, NON_ASCII_WHITESPACES, IDENTIFIER_START, IDENTIFIER_PART, ch; // See `tools/generate-identifier-regex.js`.

      ES5Regex = {
        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,
        // ECMAScript 5.1/Unicode v9.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/
      };
      ES6Regex = {
        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierStart:
        NonAsciiIdentifierStart: /[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,
        // ECMAScript 6/Unicode v9.0.0 NonAsciiIdentifierPart:
        NonAsciiIdentifierPart: /[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/
      };

      function isDecimalDigit(ch) {
        return 0x30 <= ch && ch <= 0x39; // 0..9
      }

      function isHexDigit(ch) {
        return 0x30 <= ch && ch <= 0x39 || // 0..9
        0x61 <= ch && ch <= 0x66 || // a..f
        0x41 <= ch && ch <= 0x46; // A..F
      }

      function isOctalDigit(ch) {
        return ch >= 0x30 && ch <= 0x37; // 0..7
      } // 7.2 White Space


      NON_ASCII_WHITESPACES = [0x1680, 0x2000, 0x2001, 0x2002, 0x2003, 0x2004, 0x2005, 0x2006, 0x2007, 0x2008, 0x2009, 0x200A, 0x202F, 0x205F, 0x3000, 0xFEFF];

      function isWhiteSpace(ch) {
        return ch === 0x20 || ch === 0x09 || ch === 0x0B || ch === 0x0C || ch === 0xA0 || ch >= 0x1680 && NON_ASCII_WHITESPACES.indexOf(ch) >= 0;
      } // 7.3 Line Terminators


      function isLineTerminator(ch) {
        return ch === 0x0A || ch === 0x0D || ch === 0x2028 || ch === 0x2029;
      } // 7.6 Identifier Names and Identifiers


      function fromCodePoint(cp) {
        if (cp <= 0xFFFF) {
          return String.fromCharCode(cp);
        }

        var cu1 = String.fromCharCode(Math.floor((cp - 0x10000) / 0x400) + 0xD800);
        var cu2 = String.fromCharCode((cp - 0x10000) % 0x400 + 0xDC00);
        return cu1 + cu2;
      }

      IDENTIFIER_START = new Array(0x80);

      for (ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_START[ch] = ch >= 0x61 && ch <= 0x7A || // a..z
        ch >= 0x41 && ch <= 0x5A || // A..Z
        ch === 0x24 || ch === 0x5F; // $ (dollar) and _ (underscore)
      }

      IDENTIFIER_PART = new Array(0x80);

      for (ch = 0; ch < 0x80; ++ch) {
        IDENTIFIER_PART[ch] = ch >= 0x61 && ch <= 0x7A || // a..z
        ch >= 0x41 && ch <= 0x5A || // A..Z
        ch >= 0x30 && ch <= 0x39 || // 0..9
        ch === 0x24 || ch === 0x5F; // $ (dollar) and _ (underscore)
      }

      function isIdentifierStartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES5Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
      }

      function isIdentifierPartES5(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES5Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
      }

      function isIdentifierStartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_START[ch] : ES6Regex.NonAsciiIdentifierStart.test(fromCodePoint(ch));
      }

      function isIdentifierPartES6(ch) {
        return ch < 0x80 ? IDENTIFIER_PART[ch] : ES6Regex.NonAsciiIdentifierPart.test(fromCodePoint(ch));
      }

      module.exports = {
        isDecimalDigit: isDecimalDigit,
        isHexDigit: isHexDigit,
        isOctalDigit: isOctalDigit,
        isWhiteSpace: isWhiteSpace,
        isLineTerminator: isLineTerminator,
        isIdentifierStartES5: isIdentifierStartES5,
        isIdentifierPartES5: isIdentifierPartES5,
        isIdentifierStartES6: isIdentifierStartES6,
        isIdentifierPartES6: isIdentifierPartES6
      };
    })();
    /* vim: set sw=4 ts=4 et tw=80 : */

  });
  var code_1 = code.isDecimalDigit;
  var code_2 = code.isHexDigit;
  var code_3 = code.isOctalDigit;
  var code_4 = code.isWhiteSpace;
  var code_5 = code.isLineTerminator;
  var code_6 = code.isIdentifierStartES5;
  var code_7 = code.isIdentifierPartES5;
  var code_8 = code.isIdentifierStartES6;
  var code_9 = code.isIdentifierPartES6;

  var keyword = createCommonjsModule(function (module) {
    /*
      Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>
    
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:
    
        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
    
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */
    (function () {

      var code$1 = code;

      function isStrictModeReservedWordES6(id) {
        switch (id) {
          case 'implements':
          case 'interface':
          case 'package':
          case 'private':
          case 'protected':
          case 'public':
          case 'static':
          case 'let':
            return true;

          default:
            return false;
        }
      }

      function isKeywordES5(id, strict) {
        // yield should not be treated as keyword under non-strict mode.
        if (!strict && id === 'yield') {
          return false;
        }

        return isKeywordES6(id, strict);
      }

      function isKeywordES6(id, strict) {
        if (strict && isStrictModeReservedWordES6(id)) {
          return true;
        }

        switch (id.length) {
          case 2:
            return id === 'if' || id === 'in' || id === 'do';

          case 3:
            return id === 'var' || id === 'for' || id === 'new' || id === 'try';

          case 4:
            return id === 'this' || id === 'else' || id === 'case' || id === 'void' || id === 'with' || id === 'enum';

          case 5:
            return id === 'while' || id === 'break' || id === 'catch' || id === 'throw' || id === 'const' || id === 'yield' || id === 'class' || id === 'super';

          case 6:
            return id === 'return' || id === 'typeof' || id === 'delete' || id === 'switch' || id === 'export' || id === 'import';

          case 7:
            return id === 'default' || id === 'finally' || id === 'extends';

          case 8:
            return id === 'function' || id === 'continue' || id === 'debugger';

          case 10:
            return id === 'instanceof';

          default:
            return false;
        }
      }

      function isReservedWordES5(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES5(id, strict);
      }

      function isReservedWordES6(id, strict) {
        return id === 'null' || id === 'true' || id === 'false' || isKeywordES6(id, strict);
      }

      function isRestrictedWord(id) {
        return id === 'eval' || id === 'arguments';
      }

      function isIdentifierNameES5(id) {
        var i, iz, ch;

        if (id.length === 0) {
          return false;
        }

        ch = id.charCodeAt(0);

        if (!code$1.isIdentifierStartES5(ch)) {
          return false;
        }

        for (i = 1, iz = id.length; i < iz; ++i) {
          ch = id.charCodeAt(i);

          if (!code$1.isIdentifierPartES5(ch)) {
            return false;
          }
        }

        return true;
      }

      function decodeUtf16(lead, trail) {
        return (lead - 0xD800) * 0x400 + (trail - 0xDC00) + 0x10000;
      }

      function isIdentifierNameES6(id) {
        var i, iz, ch, lowCh, check;

        if (id.length === 0) {
          return false;
        }

        check = code$1.isIdentifierStartES6;

        for (i = 0, iz = id.length; i < iz; ++i) {
          ch = id.charCodeAt(i);

          if (0xD800 <= ch && ch <= 0xDBFF) {
            ++i;

            if (i >= iz) {
              return false;
            }

            lowCh = id.charCodeAt(i);

            if (!(0xDC00 <= lowCh && lowCh <= 0xDFFF)) {
              return false;
            }

            ch = decodeUtf16(ch, lowCh);
          }

          if (!check(ch)) {
            return false;
          }

          check = code$1.isIdentifierPartES6;
        }

        return true;
      }

      function isIdentifierES5(id, strict) {
        return isIdentifierNameES5(id) && !isReservedWordES5(id, strict);
      }

      function isIdentifierES6(id, strict) {
        return isIdentifierNameES6(id) && !isReservedWordES6(id, strict);
      }

      module.exports = {
        isKeywordES5: isKeywordES5,
        isKeywordES6: isKeywordES6,
        isReservedWordES5: isReservedWordES5,
        isReservedWordES6: isReservedWordES6,
        isRestrictedWord: isRestrictedWord,
        isIdentifierNameES5: isIdentifierNameES5,
        isIdentifierNameES6: isIdentifierNameES6,
        isIdentifierES5: isIdentifierES5,
        isIdentifierES6: isIdentifierES6
      };
    })();
    /* vim: set sw=4 ts=4 et tw=80 : */

  });
  var keyword_1 = keyword.isKeywordES5;
  var keyword_2 = keyword.isKeywordES6;
  var keyword_3 = keyword.isReservedWordES5;
  var keyword_4 = keyword.isReservedWordES6;
  var keyword_5 = keyword.isRestrictedWord;
  var keyword_6 = keyword.isIdentifierNameES5;
  var keyword_7 = keyword.isIdentifierNameES6;
  var keyword_8 = keyword.isIdentifierES5;
  var keyword_9 = keyword.isIdentifierES6;

  var utils$1 = createCommonjsModule(function (module, exports) {
    /*
      Copyright (C) 2013 Yusuke Suzuki <utatane.tea@gmail.com>
    
      Redistribution and use in source and binary forms, with or without
      modification, are permitted provided that the following conditions are met:
    
        * Redistributions of source code must retain the above copyright
          notice, this list of conditions and the following disclaimer.
        * Redistributions in binary form must reproduce the above copyright
          notice, this list of conditions and the following disclaimer in the
          documentation and/or other materials provided with the distribution.
    
      THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
      AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
      IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
      ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
      DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
      (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
      LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
      ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
      (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
      THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
    */
    (function () {

      exports.ast = ast;
      exports.code = code;
      exports.keyword = keyword;
    })();
    /* vim: set sw=4 ts=4 et tw=80 : */

  });
  var utils_1$1 = utils$1.ast;
  var utils_2$1 = utils$1.code;
  var utils_3$1 = utils$1.keyword;

  var lib$1 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.shouldHighlight = shouldHighlight;
    exports.getChalk = getChalk;
    exports.default = highlight;

    function _jsTokens() {
      var data = _interopRequireWildcard(jsTokens);

      _jsTokens = function _jsTokens() {
        return data;
      };

      return data;
    }

    function _esutils() {
      var data = _interopRequireDefault(utils$1);

      _esutils = function _esutils() {
        return data;
      };

      return data;
    }

    function _chalk() {
      var data = _interopRequireDefault(chalk);

      _chalk = function _chalk() {
        return data;
      };

      return data;
    }

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};

        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
        }

        newObj.default = obj;
        return newObj;
      }
    }

    function getDefs(chalk) {
      return {
        keyword: chalk.cyan,
        capitalized: chalk.yellow,
        jsx_tag: chalk.yellow,
        punctuator: chalk.yellow,
        number: chalk.magenta,
        string: chalk.green,
        regex: chalk.magenta,
        comment: chalk.grey,
        invalid: chalk.white.bgRed.bold
      };
    }

    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;
    var JSX_TAG = /^[a-z][\w-]*$/i;
    var BRACKET = /^[()[\]{}]$/;

    function getTokenType(match) {
      var _match$slice = match.slice(-2),
          _match$slice2 = _slicedToArray(_match$slice, 2),
          offset = _match$slice2[0],
          text = _match$slice2[1];

      var token = (0, _jsTokens().matchToToken)(match);

      if (token.type === "name") {
        if (_esutils().default.keyword.isReservedWordES6(token.value)) {
          return "keyword";
        }

        if (JSX_TAG.test(token.value) && (text[offset - 1] === "<" || text.substr(offset - 2, 2) == "</")) {
          return "jsx_tag";
        }

        if (token.value[0] !== token.value[0].toLowerCase()) {
          return "capitalized";
        }
      }

      if (token.type === "punctuator" && BRACKET.test(token.value)) {
        return "bracket";
      }

      if (token.type === "invalid" && (token.value === "@" || token.value === "#")) {
        return "punctuator";
      }

      return token.type;
    }

    function highlightTokens(defs, text) {
      return text.replace(_jsTokens().default, function () {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var type = getTokenType(args);
        var colorize = defs[type];

        if (colorize) {
          return args[0].split(NEWLINE).map(function (str) {
            return colorize(str);
          }).join("\n");
        } else {
          return args[0];
        }
      });
    }

    function shouldHighlight(options) {
      return _chalk().default.supportsColor || options.forceColor;
    }

    function getChalk(options) {
      var chalk = _chalk().default;

      if (options.forceColor) {
        chalk = new (_chalk().default.constructor)({
          enabled: true,
          level: 1
        });
      }

      return chalk;
    }

    function highlight(code) {
      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

      if (shouldHighlight(options)) {
        var chalk = getChalk(options);
        var defs = getDefs(chalk);
        return highlightTokens(defs, code);
      } else {
        return code;
      }
    }
  });
  unwrapExports(lib$1);
  var lib_1 = lib$1.shouldHighlight;
  var lib_2 = lib$1.getChalk;

  var lib$2 = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, "__esModule", {
      value: true
    });
    exports.codeFrameColumns = codeFrameColumns;
    exports.default = _default;

    function _highlight() {
      var data = _interopRequireWildcard(lib$1);

      _highlight = function _highlight() {
        return data;
      };

      return data;
    }

    function _interopRequireWildcard(obj) {
      if (obj && obj.__esModule) {
        return obj;
      } else {
        var newObj = {};

        if (obj != null) {
          for (var key in obj) {
            if (Object.prototype.hasOwnProperty.call(obj, key)) {
              var desc = Object.defineProperty && Object.getOwnPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : {};

              if (desc.get || desc.set) {
                Object.defineProperty(newObj, key, desc);
              } else {
                newObj[key] = obj[key];
              }
            }
          }
        }

        newObj.default = obj;
        return newObj;
      }
    }

    var deprecationWarningShown = false;

    function getDefs(chalk) {
      return {
        gutter: chalk.grey,
        marker: chalk.red.bold,
        message: chalk.red.bold
      };
    }

    var NEWLINE = /\r\n|[\n\r\u2028\u2029]/;

    function getMarkerLines(loc, source, opts) {
      var startLoc = Object.assign({
        column: 0,
        line: -1
      }, loc.start);
      var endLoc = Object.assign({}, startLoc, loc.end);

      var _ref = opts || {},
          _ref$linesAbove = _ref.linesAbove,
          linesAbove = _ref$linesAbove === void 0 ? 2 : _ref$linesAbove,
          _ref$linesBelow = _ref.linesBelow,
          linesBelow = _ref$linesBelow === void 0 ? 3 : _ref$linesBelow;

      var startLine = startLoc.line;
      var startColumn = startLoc.column;
      var endLine = endLoc.line;
      var endColumn = endLoc.column;
      var start = Math.max(startLine - (linesAbove + 1), 0);
      var end = Math.min(source.length, endLine + linesBelow);

      if (startLine === -1) {
        start = 0;
      }

      if (endLine === -1) {
        end = source.length;
      }

      var lineDiff = endLine - startLine;
      var markerLines = {};

      if (lineDiff) {
        for (var i = 0; i <= lineDiff; i++) {
          var lineNumber = i + startLine;

          if (!startColumn) {
            markerLines[lineNumber] = true;
          } else if (i === 0) {
            var sourceLength = source[lineNumber - 1].length;
            markerLines[lineNumber] = [startColumn, sourceLength - startColumn + 1];
          } else if (i === lineDiff) {
            markerLines[lineNumber] = [0, endColumn];
          } else {
            var _sourceLength = source[lineNumber - i].length;
            markerLines[lineNumber] = [0, _sourceLength];
          }
        }
      } else {
        if (startColumn === endColumn) {
          if (startColumn) {
            markerLines[startLine] = [startColumn, 0];
          } else {
            markerLines[startLine] = true;
          }
        } else {
          markerLines[startLine] = [startColumn, endColumn - startColumn];
        }
      }

      return {
        start: start,
        end: end,
        markerLines: markerLines
      };
    }

    function codeFrameColumns(rawLines, loc) {
      var opts = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      var highlighted = (opts.highlightCode || opts.forceColor) && (0, _highlight().shouldHighlight)(opts);
      var chalk = (0, _highlight().getChalk)(opts);
      var defs = getDefs(chalk);

      var maybeHighlight = function maybeHighlight(chalkFn, string) {
        return highlighted ? chalkFn(string) : string;
      };

      var lines = rawLines.split(NEWLINE);

      var _getMarkerLines = getMarkerLines(loc, lines, opts),
          start = _getMarkerLines.start,
          end = _getMarkerLines.end,
          markerLines = _getMarkerLines.markerLines;

      var hasColumns = loc.start && typeof loc.start.column === "number";
      var numberMaxWidth = String(end).length;
      var highlightedLines = highlighted ? (0, _highlight().default)(rawLines, opts) : rawLines;
      var frame = highlightedLines.split(NEWLINE).slice(start, end).map(function (line, index) {
        var number = start + 1 + index;
        var paddedNumber = " ".concat(number).slice(-numberMaxWidth);
        var gutter = " ".concat(paddedNumber, " | ");
        var hasMarker = markerLines[number];
        var lastMarkerLine = !markerLines[number + 1];

        if (hasMarker) {
          var markerLine = "";

          if (Array.isArray(hasMarker)) {
            var markerSpacing = line.slice(0, Math.max(hasMarker[0] - 1, 0)).replace(/[^\t]/g, " ");
            var numberOfMarkers = hasMarker[1] || 1;
            markerLine = ["\n ", maybeHighlight(defs.gutter, gutter.replace(/\d/g, " ")), markerSpacing, maybeHighlight(defs.marker, "^").repeat(numberOfMarkers)].join("");

            if (lastMarkerLine && opts.message) {
              markerLine += " " + maybeHighlight(defs.message, opts.message);
            }
          }

          return [maybeHighlight(defs.marker, ">"), maybeHighlight(defs.gutter, gutter), line, markerLine].join("");
        } else {
          return " ".concat(maybeHighlight(defs.gutter, gutter)).concat(line);
        }
      }).join("\n");

      if (opts.message && !hasColumns) {
        frame = "".concat(" ".repeat(numberMaxWidth + 1)).concat(opts.message, "\n").concat(frame);
      }

      if (highlighted) {
        return chalk.reset(frame);
      } else {
        return frame;
      }
    }

    function _default(rawLines, lineNumber, colNumber) {
      var opts = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

      if (!deprecationWarningShown) {
        deprecationWarningShown = true;
        var message = "Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";

        if (process.emitWarning) {
          process.emitWarning(message, "DeprecationWarning");
        } else {
          var deprecationError = new Error(message);
          deprecationError.name = "DeprecationWarning";
          console.warn(new Error(message));
        }
      }

      colNumber = Math.max(colNumber, 0);
      var location = {
        start: {
          column: colNumber,
          line: lineNumber
        }
      };
      return codeFrameColumns(rawLines, location, opts);
    }
  });
  unwrapExports(lib$2);
  var lib_1$1 = lib$2.codeFrameColumns;

  var ConfigError$1 = errors.ConfigError;
  var locStart$1 = loc.locStart,
      locEnd$1 = loc.locEnd; // Use defineProperties()/getOwnPropertyDescriptor() to prevent
  // triggering the parsers getters.

  var ownNames = Object.getOwnPropertyNames;
  var ownDescriptor = Object.getOwnPropertyDescriptor;

  function getParsers(options) {
    var parsers = {};
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = options.plugins[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var plugin = _step.value;

        if (!plugin.parsers) {
          continue;
        }

        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = ownNames(plugin.parsers)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            var name = _step2.value;
            Object.defineProperty(parsers, name, ownDescriptor(plugin.parsers, name));
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return parsers;
  }

  function resolveParser(opts, parsers) {
    parsers = parsers || getParsers(opts);

    if (typeof opts.parser === "function") {
      // Custom parser API always works with JavaScript.
      return {
        parse: opts.parser,
        astFormat: "estree",
        locStart: locStart$1,
        locEnd: locEnd$1
      };
    }

    if (typeof opts.parser === "string") {
      if (Object.prototype.hasOwnProperty.call(parsers, opts.parser)) {
        return parsers[opts.parser];
      }
      /* istanbul ignore next */


      {
        throw new ConfigError$1("Couldn't resolve parser \"".concat(opts.parser, "\". Parsers must be explicitly added to the standalone bundle."));
      }
    }
  }

  function parse(text, opts) {
    var parsers = getParsers(opts); // Create a new object {parserName: parseFn}. Uses defineProperty() to only call
    // the parsers getters when actually calling the parser `parse` function.

    var parsersForCustomParserApi = Object.keys(parsers).reduce(function (object, parserName) {
      return Object.defineProperty(object, parserName, {
        enumerable: true,
        get: function get() {
          return parsers[parserName].parse;
        }
      });
    }, {});
    var parser = resolveParser(opts, parsers);

    try {
      if (parser.preprocess) {
        text = parser.preprocess(text, opts);
      }

      return {
        text: text,
        ast: parser.parse(text, parsersForCustomParserApi, opts)
      };
    } catch (error) {
      var loc = error.loc;

      if (loc) {
        var codeFrame = lib$2;
        error.codeFrame = codeFrame.codeFrameColumns(text, loc, {
          highlightCode: true
        });
        error.message += "\n" + error.codeFrame;
        throw error;
      }
      /* istanbul ignore next */


      throw error.stack;
    }
  }

  var parser = {
    parse: parse,
    resolveParser: resolveParser
  };

  var UndefinedParserError$1 = errors.UndefinedParserError;
  var getSupportInfo$1 = support.getSupportInfo;
  var resolveParser$1 = parser.resolveParser;
  var hiddenDefaults = {
    astFormat: "estree",
    printer: {},
    originalText: undefined,
    locStart: null,
    locEnd: null
  }; // Copy options and fill in default values.

  function normalize$1(options, opts) {
    opts = opts || {};
    var rawOptions = Object.assign({}, options);
    var supportOptions = getSupportInfo$1(null, {
      plugins: options.plugins,
      showUnreleased: true,
      showDeprecated: true
    }).options;
    var defaults = supportOptions.reduce(function (reduced, optionInfo) {
      return optionInfo.default !== undefined ? Object.assign(reduced, _defineProperty({}, optionInfo.name, optionInfo.default)) : reduced;
    }, Object.assign({}, hiddenDefaults));

    if (!rawOptions.parser) {
      if (!rawOptions.filepath) {
        var logger = opts.logger || console;
        logger.warn("No parser and no filepath given, using 'babel' the parser now " + "but this will throw an error in the future. " + "Please specify a parser or a filepath so one can be inferred.");
        rawOptions.parser = "babel";
      } else {
        rawOptions.parser = inferParser(rawOptions.filepath, rawOptions.plugins);

        if (!rawOptions.parser) {
          throw new UndefinedParserError$1("No parser could be inferred for file: ".concat(rawOptions.filepath));
        }
      }
    }

    var parser = resolveParser$1(optionsNormalizer.normalizeApiOptions(rawOptions, [supportOptions.find(function (x) {
      return x.name === "parser";
    })], {
      passThrough: true,
      logger: false
    }));
    rawOptions.astFormat = parser.astFormat;
    rawOptions.locEnd = parser.locEnd;
    rawOptions.locStart = parser.locStart;
    var plugin = getPlugin(rawOptions);
    rawOptions.printer = plugin.printers[rawOptions.astFormat];
    var pluginDefaults = supportOptions.filter(function (optionInfo) {
      return optionInfo.pluginDefaults && optionInfo.pluginDefaults[plugin.name] !== undefined;
    }).reduce(function (reduced, optionInfo) {
      return Object.assign(reduced, _defineProperty({}, optionInfo.name, optionInfo.pluginDefaults[plugin.name]));
    }, {});
    var mixedDefaults = Object.assign({}, defaults, pluginDefaults);
    Object.keys(mixedDefaults).forEach(function (k) {
      if (rawOptions[k] == null) {
        rawOptions[k] = mixedDefaults[k];
      }
    });

    if (rawOptions.parser === "json") {
      rawOptions.trailingComma = "none";
    }

    return optionsNormalizer.normalizeApiOptions(rawOptions, supportOptions, Object.assign({
      passThrough: Object.keys(hiddenDefaults)
    }, opts));
  }

  function getPlugin(options) {
    var astFormat = options.astFormat;

    if (!astFormat) {
      throw new Error("getPlugin() requires astFormat to be set");
    }

    var printerPlugin = options.plugins.find(function (plugin) {
      return plugin.printers && plugin.printers[astFormat];
    });

    if (!printerPlugin) {
      throw new Error("Couldn't find plugin for AST format \"".concat(astFormat, "\""));
    }

    return printerPlugin;
  }

  function getInterpreter(filepath) {
    if (typeof filepath !== "string") {
      return "";
    }

    var fd;

    try {
      fd = fs.openSync(filepath, "r");
    } catch (err) {
      return "";
    }

    try {
      var liner = new readlines(fd);
      var firstLine = liner.next().toString("utf8"); // #!/bin/env node, #!/usr/bin/env node

      var m1 = firstLine.match(/^#!\/(?:usr\/)?bin\/env\s+(\S+)/);

      if (m1) {
        return m1[1];
      } // #!/bin/node, #!/usr/bin/node, #!/usr/local/bin/node


      var m2 = firstLine.match(/^#!\/(?:usr\/(?:local\/)?)?bin\/(\S+)/);

      if (m2) {
        return m2[1];
      }

      return "";
    } catch (err) {
      // There are some weird cases where paths are missing, causing Jest
      // failures. It's unclear what these correspond to in the real world.
      return "";
    } finally {
      try {
        // There are some weird cases where paths are missing, causing Jest
        // failures. It's unclear what these correspond to in the real world.
        fs.closeSync(fd);
      } catch (err) {// nop
      }
    }
  }

  function inferParser(filepath, plugins) {
    var filepathParts = normalizePath(filepath).split("/");
    var filename = filepathParts[filepathParts.length - 1].toLowerCase(); // If the file has no extension, we can try to infer the language from the
    // interpreter in the shebang line, if any; but since this requires FS access,
    // do it last.

    var language = getSupportInfo$1(null, {
      plugins: plugins
    }).languages.find(function (language) {
      return language.since !== null && (language.extensions && language.extensions.some(function (extension) {
        return filename.endsWith(extension);
      }) || language.filenames && language.filenames.find(function (name) {
        return name.toLowerCase() === filename;
      }) || filename.indexOf(".") === -1 && language.interpreters && language.interpreters.indexOf(getInterpreter(filepath)) !== -1);
    });
    return language && language.parsers[0];
  }

  var options$1 = {
    normalize: normalize$1,
    hiddenDefaults: hiddenDefaults,
    inferParser: inferParser
  };

  function massageAST(ast, options, parent) {
    if (Array.isArray(ast)) {
      return ast.map(function (e) {
        return massageAST(e, options, parent);
      }).filter(function (e) {
        return e;
      });
    }

    if (!ast || _typeof(ast) !== "object") {
      return ast;
    }

    var newObj = {};

    for (var _i = 0, _Object$keys = Object.keys(ast); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];

      if (typeof ast[key] !== "function") {
        newObj[key] = massageAST(ast[key], options, ast);
      }
    }

    if (options.printer.massageAstNode) {
      var result = options.printer.massageAstNode(ast, newObj, parent);

      if (result === null) {
        return undefined;
      }

      if (result) {
        return result;
      }
    }

    return newObj;
  }

  var massageAst = massageAST;

  function assert() {}

  assert.ok = function () {};

  assert.strictEqual = function () {};

  /**
   * @param {Doc[]} parts
   * @returns Doc
   */


  function concat(parts) {
    // access the internals of a document directly.
    // if(parts.length === 1) {
    //   // If it's a single document, no need to concat it.
    //   return parts[0];
    // }


    return {
      type: "concat",
      parts: parts
    };
  }
  /**
   * @param {Doc} contents
   * @returns Doc
   */


  function indent(contents) {

    return {
      type: "indent",
      contents: contents
    };
  }
  /**
   * @param {number} n
   * @param {Doc} contents
   * @returns Doc
   */


  function align(n, contents) {

    return {
      type: "align",
      contents: contents,
      n: n
    };
  }
  /**
   * @param {Doc} contents
   * @param {object} [opts] - TBD ???
   * @returns Doc
   */


  function group(contents, opts) {
    opts = opts || {};

    return {
      type: "group",
      id: opts.id,
      contents: contents,
      break: !!opts.shouldBreak,
      expandedStates: opts.expandedStates
    };
  }
  /**
   * @param {Doc} contents
   * @returns Doc
   */


  function dedentToRoot(contents) {
    return align(-Infinity, contents);
  }
  /**
   * @param {Doc} contents
   * @returns Doc
   */


  function markAsRoot(contents) {
    // @ts-ignore - TBD ???:
    return align({
      type: "root"
    }, contents);
  }
  /**
   * @param {Doc} contents
   * @returns Doc
   */


  function dedent(contents) {
    return align(-1, contents);
  }
  /**
   * @param {Doc[]} states
   * @param {object} [opts] - TBD ???
   * @returns Doc
   */


  function conditionalGroup(states, opts) {
    return group(states[0], Object.assign(opts || {}, {
      expandedStates: states
    }));
  }
  /**
   * @param {Doc[]} parts
   * @returns Doc
   */


  function fill(parts) {

    return {
      type: "fill",
      parts: parts
    };
  }
  /**
   * @param {Doc} [breakContents]
   * @param {Doc} [flatContents]
   * @param {object} [opts] - TBD ???
   * @returns Doc
   */


  function ifBreak(breakContents, flatContents, opts) {
    opts = opts || {};

    return {
      type: "if-break",
      breakContents: breakContents,
      flatContents: flatContents,
      groupId: opts.groupId
    };
  }
  /**
   * @param {Doc} contents
   * @returns Doc
   */


  function lineSuffix(contents) {

    return {
      type: "line-suffix",
      contents: contents
    };
  }

  var lineSuffixBoundary = {
    type: "line-suffix-boundary"
  };
  var breakParent = {
    type: "break-parent"
  };
  var trim = {
    type: "trim"
  };
  var line = {
    type: "line"
  };
  var softline = {
    type: "line",
    soft: true
  };
  var hardline = concat([{
    type: "line",
    hard: true
  }, breakParent]);
  var literalline = concat([{
    type: "line",
    hard: true,
    literal: true
  }, breakParent]);
  var cursor = {
    type: "cursor",
    placeholder: Symbol("cursor")
  };
  /**
   * @param {Doc} sep
   * @param {Doc[]} arr
   * @returns Doc
   */

  function join(sep, arr) {
    var res = [];

    for (var i = 0; i < arr.length; i++) {
      if (i !== 0) {
        res.push(sep);
      }

      res.push(arr[i]);
    }

    return concat(res);
  }
  /**
   * @param {Doc} doc
   * @param {number} size
   * @param {number} tabWidth
   */


  function addAlignmentToDoc(doc, size, tabWidth) {
    var aligned = doc;

    if (size > 0) {
      // Use indent to add tabs for all the levels of tabs we need
      for (var i = 0; i < Math.floor(size / tabWidth); ++i) {
        aligned = indent(aligned);
      } // Use align for all the spaces that are needed


      aligned = align(size % tabWidth, aligned); // size is absolute from 0 and not relative to the current
      // indentation, so we use -Infinity to reset the indentation to 0

      aligned = align(-Infinity, aligned);
    }

    return aligned;
  }

  var docBuilders = {
    concat: concat,
    join: join,
    line: line,
    softline: softline,
    hardline: hardline,
    literalline: literalline,
    group: group,
    conditionalGroup: conditionalGroup,
    fill: fill,
    lineSuffix: lineSuffix,
    lineSuffixBoundary: lineSuffixBoundary,
    cursor: cursor,
    breakParent: breakParent,
    ifBreak: ifBreak,
    trim: trim,
    indent: indent,
    align: align,
    addAlignmentToDoc: addAlignmentToDoc,
    markAsRoot: markAsRoot,
    dedentToRoot: dedentToRoot,
    dedent: dedent
  };

  var ansiRegex = function ansiRegex(options) {
    options = Object.assign({
      onlyFirst: false
    }, options);
    var pattern = ["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:[a-zA-Z\\d]*(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)", '(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))'].join('|');
    return new RegExp(pattern, options.onlyFirst ? undefined : 'g');
  };

  var stripAnsi = function stripAnsi(string) {
    return typeof string === 'string' ? string.replace(ansiRegex(), '') : string;
  };

  var stripAnsi_1 = stripAnsi;
  var default_1$1 = stripAnsi;
  stripAnsi_1.default = default_1$1;

  /* eslint-disable yoda */

  var isFullwidthCodePoint = function isFullwidthCodePoint(codePoint) {
    if (Number.isNaN(codePoint)) {
      return false;
    } // Code points are derived from:
    // http://www.unix.org/Public/UNIDATA/EastAsianWidth.txt


    if (codePoint >= 0x1100 && (codePoint <= 0x115F || // Hangul Jamo
    codePoint === 0x2329 || // LEFT-POINTING ANGLE BRACKET
    codePoint === 0x232A || // RIGHT-POINTING ANGLE BRACKET
    // CJK Radicals Supplement .. Enclosed CJK Letters and Months
    0x2E80 <= codePoint && codePoint <= 0x3247 && codePoint !== 0x303F || // Enclosed CJK Letters and Months .. CJK Unified Ideographs Extension A
    0x3250 <= codePoint && codePoint <= 0x4DBF || // CJK Unified Ideographs .. Yi Radicals
    0x4E00 <= codePoint && codePoint <= 0xA4C6 || // Hangul Jamo Extended-A
    0xA960 <= codePoint && codePoint <= 0xA97C || // Hangul Syllables
    0xAC00 <= codePoint && codePoint <= 0xD7A3 || // CJK Compatibility Ideographs
    0xF900 <= codePoint && codePoint <= 0xFAFF || // Vertical Forms
    0xFE10 <= codePoint && codePoint <= 0xFE19 || // CJK Compatibility Forms .. Small Form Variants
    0xFE30 <= codePoint && codePoint <= 0xFE6B || // Halfwidth and Fullwidth Forms
    0xFF01 <= codePoint && codePoint <= 0xFF60 || 0xFFE0 <= codePoint && codePoint <= 0xFFE6 || // Kana Supplement
    0x1B000 <= codePoint && codePoint <= 0x1B001 || // Enclosed Ideographic Supplement
    0x1F200 <= codePoint && codePoint <= 0x1F251 || // CJK Unified Ideographs Extension B .. Tertiary Ideographic Plane
    0x20000 <= codePoint && codePoint <= 0x3FFFD)) {
      return true;
    }

    return false;
  };

  var isFullwidthCodePoint_1 = isFullwidthCodePoint;
  var default_1$2 = isFullwidthCodePoint;
  isFullwidthCodePoint_1.default = default_1$2;

  var emojiRegex = function emojiRegex() {
    // https://mths.be/emoji
    return /\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73)\uDB40\uDC7F|\uD83D\uDC68(?:\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68\uD83C\uDFFB|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|[\u2695\u2696\u2708]\uFE0F|\uD83D[\uDC66\uDC67]|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708])\uFE0F|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C[\uDFFB-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)\uD83C\uDFFB|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB\uDFFC])|\uD83D\uDC69(?:\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D\uD83D\uDC69)(?:\uD83C[\uDFFB-\uDFFD])|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|(?:(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)\uFE0F|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:(?:\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\u200D[\u2640\u2642])|\uD83C\uDFF4\u200D\u2620)\uFE0F|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF4\uD83C\uDDF2|\uD83C\uDDF6\uD83C\uDDE6|[#\*0-9]\uFE0F\u20E3|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83D\uDC69(?:\uD83C[\uDFFB-\uDFFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270A-\u270D]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC70\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDCAA\uDD74\uDD7A\uDD90\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD36\uDDB5\uDDB6\uDDBB\uDDD2-\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5\uDEEB\uDEEC\uDEF4-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFA\uDFE0-\uDFEB]|\uD83E[\uDD0D-\uDD3A\uDD3C-\uDD45\uDD47-\uDD71\uDD73-\uDD76\uDD7A-\uDDA2\uDDA5-\uDDAA\uDDAE-\uDDCA\uDDCD-\uDDFF\uDE70-\uDE73\uDE78-\uDE7A\uDE80-\uDE82\uDE90-\uDE95])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g;
  };

  var stringWidth = function stringWidth(string) {
    string = string.replace(emojiRegex(), '  ');

    if (typeof string !== 'string' || string.length === 0) {
      return 0;
    }

    string = stripAnsi_1(string);
    var width = 0;

    for (var i = 0; i < string.length; i++) {
      var code = string.codePointAt(i); // Ignore control characters

      if (code <= 0x1F || code >= 0x7F && code <= 0x9F) {
        continue;
      } // Ignore combining characters


      if (code >= 0x300 && code <= 0x36F) {
        continue;
      } // Surrogates


      if (code > 0xFFFF) {
        i++;
      }

      width += isFullwidthCodePoint_1(code) ? 2 : 1;
    }

    return width;
  };

  var stringWidth_1 = stringWidth; // TODO: remove this in the next major version

  var default_1$3 = stringWidth;
  stringWidth_1.default = default_1$3;

  var notAsciiRegex = /[^\x20-\x7F]/;

  function isExportDeclaration(node) {
    if (node) {
      switch (node.type) {
        case "ExportDefaultDeclaration":
        case "ExportDefaultSpecifier":
        case "DeclareExportDeclaration":
        case "ExportNamedDeclaration":
        case "ExportAllDeclaration":
          return true;
      }
    }

    return false;
  }

  function getParentExportDeclaration(path) {
    var parentNode = path.getParentNode();

    if (path.getName() === "declaration" && isExportDeclaration(parentNode)) {
      return parentNode;
    }

    return null;
  }

  function getPenultimate(arr) {
    if (arr.length > 1) {
      return arr[arr.length - 2];
    }

    return null;
  }
  /**
   * @typedef {{backwards?: boolean}} SkipOptions
   */

  /**
   * @param {string | RegExp} chars
   * @returns {(text: string, index: number | false, opts?: SkipOptions) => number | false}
   */


  function skip(chars) {
    return function (text, index, opts) {
      var backwards = opts && opts.backwards; // Allow `skip` functions to be threaded together without having
      // to check for failures (did someone say monads?).

      if (index === false) {
        return false;
      }

      var length = text.length;
      var cursor = index;

      while (cursor >= 0 && cursor < length) {
        var c = text.charAt(cursor);

        if (chars instanceof RegExp) {
          if (!chars.test(c)) {
            return cursor;
          }
        } else if (chars.indexOf(c) === -1) {
          return cursor;
        }

        backwards ? cursor-- : cursor++;
      }

      if (cursor === -1 || cursor === length) {
        // If we reached the beginning or end of the file, return the
        // out-of-bounds cursor. It's up to the caller to handle this
        // correctly. We don't want to indicate `false` though if it
        // actually skipped valid characters.
        return cursor;
      }

      return false;
    };
  }
  /**
   * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}
   */


  var skipWhitespace = skip(/\s/);
  /**
   * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}
   */

  var skipSpaces = skip(" \t");
  /**
   * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}
   */

  var skipToLineEnd = skip(",; \t");
  /**
   * @type {(text: string, index: number | false, opts?: SkipOptions) => number | false}
   */

  var skipEverythingButNewLine = skip(/[^\r\n]/);
  /**
   * @param {string} text
   * @param {number | false} index
   * @returns {number | false}
   */

  function skipInlineComment(text, index) {
    if (index === false) {
      return false;
    }

    if (text.charAt(index) === "/" && text.charAt(index + 1) === "*") {
      for (var i = index + 2; i < text.length; ++i) {
        if (text.charAt(i) === "*" && text.charAt(i + 1) === "/") {
          return i + 2;
        }
      }
    }

    return index;
  }
  /**
   * @param {string} text
   * @param {number | false} index
   * @returns {number | false}
   */


  function skipTrailingComment(text, index) {
    if (index === false) {
      return false;
    }

    if (text.charAt(index) === "/" && text.charAt(index + 1) === "/") {
      return skipEverythingButNewLine(text, index);
    }

    return index;
  } // This one doesn't use the above helper function because it wants to
  // test \r\n in order and `skip` doesn't support ordering and we only
  // want to skip one newline. It's simple to implement.

  /**
   * @param {string} text
   * @param {number | false} index
   * @param {SkipOptions=} opts
   * @returns {number | false}
   */


  function skipNewline(text, index, opts) {
    var backwards = opts && opts.backwards;

    if (index === false) {
      return false;
    }

    var atIndex = text.charAt(index);

    if (backwards) {
      if (text.charAt(index - 1) === "\r" && atIndex === "\n") {
        return index - 2;
      }

      if (atIndex === "\n" || atIndex === "\r" || atIndex === "\u2028" || atIndex === "\u2029") {
        return index - 1;
      }
    } else {
      if (atIndex === "\r" && text.charAt(index + 1) === "\n") {
        return index + 2;
      }

      if (atIndex === "\n" || atIndex === "\r" || atIndex === "\u2028" || atIndex === "\u2029") {
        return index + 1;
      }
    }

    return index;
  }
  /**
   * @param {string} text
   * @param {number} index
   * @param {SkipOptions=} opts
   * @returns {boolean}
   */


  function hasNewline(text, index, opts) {
    opts = opts || {};
    var idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);
    var idx2 = skipNewline(text, idx, opts);
    return idx !== idx2;
  }
  /**
   * @param {string} text
   * @param {number} start
   * @param {number} end
   * @returns {boolean}
   */


  function hasNewlineInRange(text, start, end) {
    for (var i = start; i < end; ++i) {
      if (text.charAt(i) === "\n") {
        return true;
      }
    }

    return false;
  } // Note: this function doesn't ignore leading comments unlike isNextLineEmpty

  /**
   * @template N
   * @param {string} text
   * @param {N} node
   * @param {(node: N) => number} locStart
   */


  function isPreviousLineEmpty(text, node, locStart) {
    /** @type {number | false} */
    var idx = locStart(node) - 1;
    idx = skipSpaces(text, idx, {
      backwards: true
    });
    idx = skipNewline(text, idx, {
      backwards: true
    });
    idx = skipSpaces(text, idx, {
      backwards: true
    });
    var idx2 = skipNewline(text, idx, {
      backwards: true
    });
    return idx !== idx2;
  }
  /**
   * @param {string} text
   * @param {number} index
   * @returns {boolean}
   */


  function isNextLineEmptyAfterIndex(text, index) {
    /** @type {number | false} */
    var oldIdx = null;
    /** @type {number | false} */

    var idx = index;

    while (idx !== oldIdx) {
      // We need to skip all the potential trailing inline comments
      oldIdx = idx;
      idx = skipToLineEnd(text, idx);
      idx = skipInlineComment(text, idx);
      idx = skipSpaces(text, idx);
    }

    idx = skipTrailingComment(text, idx);
    idx = skipNewline(text, idx);
    return idx !== false && hasNewline(text, idx);
  }
  /**
   * @template N
   * @param {string} text
   * @param {N} node
   * @param {(node: N) => number} locEnd
   * @returns {boolean}
   */


  function isNextLineEmpty(text, node, locEnd) {
    return isNextLineEmptyAfterIndex(text, locEnd(node));
  }
  /**
   * @param {string} text
   * @param {number} idx
   * @returns {number | false}
   */


  function getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, idx) {
    /** @type {number | false} */
    var oldIdx = null;
    /** @type {number | false} */

    var nextIdx = idx;

    while (nextIdx !== oldIdx) {
      oldIdx = nextIdx;
      nextIdx = skipSpaces(text, nextIdx);
      nextIdx = skipInlineComment(text, nextIdx);
      nextIdx = skipTrailingComment(text, nextIdx);
      nextIdx = skipNewline(text, nextIdx);
    }

    return nextIdx;
  }
  /**
   * @template N
   * @param {string} text
   * @param {N} node
   * @param {(node: N) => number} locEnd
   * @returns {number | false}
   */


  function getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd) {
    return getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, locEnd(node));
  }
  /**
   * @template N
   * @param {string} text
   * @param {N} node
   * @param {(node: N) => number} locEnd
   * @returns {string}
   */


  function getNextNonSpaceNonCommentCharacter(text, node, locEnd) {
    return text.charAt( // @ts-ignore => TBD: can return false, should we define a fallback?
    getNextNonSpaceNonCommentCharacterIndex(text, node, locEnd));
  }
  /**
   * @param {string} text
   * @param {number} index
   * @param {SkipOptions=} opts
   * @returns {boolean}
   */


  function hasSpaces(text, index, opts) {
    opts = opts || {};
    var idx = skipSpaces(text, opts.backwards ? index - 1 : index, opts);
    return idx !== index;
  }
  /**
   * @param {{range?: [number, number], start?: number}} node
   * @param {number} index
   */


  function setLocStart(node, index) {
    if (node.range) {
      node.range[0] = index;
    } else {
      node.start = index;
    }
  }
  /**
   * @param {{range?: [number, number], end?: number}} node
   * @param {number} index
   */


  function setLocEnd(node, index) {
    if (node.range) {
      node.range[1] = index;
    } else {
      node.end = index;
    }
  }

  var PRECEDENCE = {};
  [["|>"], ["??"], ["||"], ["&&"], ["|"], ["^"], ["&"], ["==", "===", "!=", "!=="], ["<", ">", "<=", ">=", "in", "instanceof"], [">>", "<<", ">>>"], ["+", "-"], ["*", "/", "%"], ["**"]].forEach(function (tier, i) {
    tier.forEach(function (op) {
      PRECEDENCE[op] = i;
    });
  });

  function getPrecedence(op) {
    return PRECEDENCE[op];
  }

  var equalityOperators = {
    "==": true,
    "!=": true,
    "===": true,
    "!==": true
  };
  var multiplicativeOperators = {
    "*": true,
    "/": true,
    "%": true
  };
  var bitshiftOperators = {
    ">>": true,
    ">>>": true,
    "<<": true
  };

  function shouldFlatten(parentOp, nodeOp) {
    if (getPrecedence(nodeOp) !== getPrecedence(parentOp)) {
      return false;
    } // ** is right-associative
    // x ** y ** z --> x ** (y ** z)


    if (parentOp === "**") {
      return false;
    } // x == y == z --> (x == y) == z


    if (equalityOperators[parentOp] && equalityOperators[nodeOp]) {
      return false;
    } // x * y % z --> (x * y) % z


    if (nodeOp === "%" && multiplicativeOperators[parentOp] || parentOp === "%" && multiplicativeOperators[nodeOp]) {
      return false;
    } // x * y / z --> (x * y) / z
    // x / y * z --> (x / y) * z


    if (nodeOp !== parentOp && multiplicativeOperators[nodeOp] && multiplicativeOperators[parentOp]) {
      return false;
    } // x << y << z --> (x << y) << z


    if (bitshiftOperators[parentOp] && bitshiftOperators[nodeOp]) {
      return false;
    }

    return true;
  }

  function isBitwiseOperator(operator) {
    return !!bitshiftOperators[operator] || operator === "|" || operator === "^" || operator === "&";
  } // Tests if an expression starts with `{`, or (if forbidFunctionClassAndDoExpr
  // holds) `function`, `class`, or `do {}`. Will be overzealous if there's
  // already necessary grouping parentheses.


  function startsWithNoLookaheadToken(node, forbidFunctionClassAndDoExpr) {
    node = getLeftMost(node);

    switch (node.type) {
      case "FunctionExpression":
      case "ClassExpression":
      case "DoExpression":
        return forbidFunctionClassAndDoExpr;

      case "ObjectExpression":
        return true;

      case "MemberExpression":
      case "OptionalMemberExpression":
        return startsWithNoLookaheadToken(node.object, forbidFunctionClassAndDoExpr);

      case "TaggedTemplateExpression":
        if (node.tag.type === "FunctionExpression") {
          // IIFEs are always already parenthesized
          return false;
        }

        return startsWithNoLookaheadToken(node.tag, forbidFunctionClassAndDoExpr);

      case "CallExpression":
      case "OptionalCallExpression":
        if (node.callee.type === "FunctionExpression") {
          // IIFEs are always already parenthesized
          return false;
        }

        return startsWithNoLookaheadToken(node.callee, forbidFunctionClassAndDoExpr);

      case "ConditionalExpression":
        return startsWithNoLookaheadToken(node.test, forbidFunctionClassAndDoExpr);

      case "UpdateExpression":
        return !node.prefix && startsWithNoLookaheadToken(node.argument, forbidFunctionClassAndDoExpr);

      case "BindExpression":
        return node.object && startsWithNoLookaheadToken(node.object, forbidFunctionClassAndDoExpr);

      case "SequenceExpression":
        return startsWithNoLookaheadToken(node.expressions[0], forbidFunctionClassAndDoExpr);

      case "TSAsExpression":
        return startsWithNoLookaheadToken(node.expression, forbidFunctionClassAndDoExpr);

      default:
        return false;
    }
  }

  function getLeftMost(node) {
    if (node.left) {
      return getLeftMost(node.left);
    }

    return node;
  }
  /**
   * @param {string} value
   * @param {number} tabWidth
   * @param {number=} startIndex
   * @returns {number}
   */


  function getAlignmentSize(value, tabWidth, startIndex) {
    startIndex = startIndex || 0;
    var size = 0;

    for (var i = startIndex; i < value.length; ++i) {
      if (value[i] === "\t") {
        // Tabs behave in a way that they are aligned to the nearest
        // multiple of tabWidth:
        // 0 -> 4, 1 -> 4, 2 -> 4, 3 -> 4
        // 4 -> 8, 5 -> 8, 6 -> 8, 7 -> 8 ...
        size = size + tabWidth - size % tabWidth;
      } else {
        size++;
      }
    }

    return size;
  }
  /**
   * @param {string} value
   * @param {number} tabWidth
   * @returns {number}
   */


  function getIndentSize(value, tabWidth) {
    var lastNewlineIndex = value.lastIndexOf("\n");

    if (lastNewlineIndex === -1) {
      return 0;
    }

    return getAlignmentSize( // All the leading whitespaces
    value.slice(lastNewlineIndex + 1).match(/^[ \t]*/)[0], tabWidth);
  }
  /**
   * @typedef {'"' | "'"} Quote
   */

  /**
   *
   * @param {string} raw
   * @param {Quote} preferredQuote
   * @returns {Quote}
   */


  function getPreferredQuote(raw, preferredQuote) {
    // `rawContent` is the string exactly like it appeared in the input source
    // code, without its enclosing quotes.
    var rawContent = raw.slice(1, -1);
    /** @type {{ quote: '"', regex: RegExp }} */

    var double = {
      quote: '"',
      regex: /"/g
    };
    /** @type {{ quote: "'", regex: RegExp }} */

    var single = {
      quote: "'",
      regex: /'/g
    };
    var preferred = preferredQuote === "'" ? single : double;
    var alternate = preferred === single ? double : single;
    var result = preferred.quote; // If `rawContent` contains at least one of the quote preferred for enclosing
    // the string, we might want to enclose with the alternate quote instead, to
    // minimize the number of escaped quotes.

    if (rawContent.includes(preferred.quote) || rawContent.includes(alternate.quote)) {
      var numPreferredQuotes = (rawContent.match(preferred.regex) || []).length;
      var numAlternateQuotes = (rawContent.match(alternate.regex) || []).length;
      result = numPreferredQuotes > numAlternateQuotes ? alternate.quote : preferred.quote;
    }

    return result;
  }

  function printString(raw, options, isDirectiveLiteral) {
    // `rawContent` is the string exactly like it appeared in the input source
    // code, without its enclosing quotes.
    var rawContent = raw.slice(1, -1); // Check for the alternate quote, to determine if we're allowed to swap
    // the quotes on a DirectiveLiteral.

    var canChangeDirectiveQuotes = !rawContent.includes('"') && !rawContent.includes("'");
    /** @type {Quote} */

    var enclosingQuote = options.parser === "json" ? '"' : options.__isInHtmlAttribute ? "'" : getPreferredQuote(raw, options.singleQuote ? "'" : '"'); // Directives are exact code unit sequences, which means that you can't
    // change the escape sequences they use.
    // See https://github.com/prettier/prettier/issues/1555
    // and https://tc39.github.io/ecma262/#directive-prologue

    if (isDirectiveLiteral) {
      if (canChangeDirectiveQuotes) {
        return enclosingQuote + rawContent + enclosingQuote;
      }

      return raw;
    } // It might sound unnecessary to use `makeString` even if the string already
    // is enclosed with `enclosingQuote`, but it isn't. The string could contain
    // unnecessary escapes (such as in `"\'"`). Always using `makeString` makes
    // sure that we consistently output the minimum amount of escaped quotes.


    return makeString(rawContent, enclosingQuote, !(options.parser === "css" || options.parser === "less" || options.parser === "scss" || options.embeddedInHtml));
  }
  /**
   * @param {string} rawContent
   * @param {Quote} enclosingQuote
   * @param {boolean=} unescapeUnnecessaryEscapes
   * @returns {string}
   */


  function makeString(rawContent, enclosingQuote, unescapeUnnecessaryEscapes) {
    var otherQuote = enclosingQuote === '"' ? "'" : '"'; // Matches _any_ escape and unescaped quotes (both single and double).

    var regex = /\\([\s\S])|(['"])/g; // Escape and unescape single and double quotes as needed to be able to
    // enclose `rawContent` with `enclosingQuote`.

    var newContent = rawContent.replace(regex, function (match, escaped, quote) {
      // If we matched an escape, and the escaped character is a quote of the
      // other type than we intend to enclose the string with, there's no need for
      // it to be escaped, so return it _without_ the backslash.
      if (escaped === otherQuote) {
        return escaped;
      } // If we matched an unescaped quote and it is of the _same_ type as we
      // intend to enclose the string with, it must be escaped, so return it with
      // a backslash.


      if (quote === enclosingQuote) {
        return "\\" + quote;
      }

      if (quote) {
        return quote;
      } // Unescape any unnecessarily escaped character.
      // Adapted from https://github.com/eslint/eslint/blob/de0b4ad7bd820ade41b1f606008bea68683dc11a/lib/rules/no-useless-escape.js#L27


      return unescapeUnnecessaryEscapes && /^[^\\nrvtbfux\r\n\u2028\u2029"'0-7]$/.test(escaped) ? escaped : "\\" + escaped;
    });
    return enclosingQuote + newContent + enclosingQuote;
  }

  function printNumber(rawNumber) {
    return rawNumber.toLowerCase() // Remove unnecessary plus and zeroes from scientific notation.
    .replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/, "$1$2$3") // Remove unnecessary scientific notation (1e0).
    .replace(/^([+-]?[\d.]+)e[+-]?0+$/, "$1") // Make sure numbers always start with a digit.
    .replace(/^([+-])?\./, "$10.") // Remove extraneous trailing decimal zeroes.
    .replace(/(\.\d+?)0+(?=e|$)/, "$1") // Remove trailing dot.
    .replace(/\.(?=e|$)/, "");
  }
  /**
   * @param {string} str
   * @param {string} target
   * @returns {number}
   */


  function getMaxContinuousCount(str, target) {
    var results = str.match(new RegExp("(".concat(escapeStringRegexp(target), ")+"), "g"));

    if (results === null) {
      return 0;
    }

    return results.reduce(function (maxCount, result) {
      return Math.max(maxCount, result.length / target.length);
    }, 0);
  }

  function getMinNotPresentContinuousCount(str, target) {
    var matches = str.match(new RegExp("(".concat(escapeStringRegexp(target), ")+"), "g"));

    if (matches === null) {
      return 0;
    }

    var countPresent = new Map();
    var max = 0;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = matches[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var match = _step.value;
        var count = match.length / target.length;
        countPresent.set(count, true);

        if (count > max) {
          max = count;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    for (var i = 1; i < max; i++) {
      if (!countPresent.get(i)) {
        return i;
      }
    }

    return max + 1;
  }
  /**
   * @param {string} text
   * @returns {number}
   */


  function getStringWidth(text) {
    if (!text) {
      return 0;
    } // shortcut to avoid needless string `RegExp`s, replacements, and allocations within `string-width`


    if (!notAsciiRegex.test(text)) {
      return text.length;
    }

    return stringWidth_1(text);
  }

  function hasIgnoreComment(path) {
    var node = path.getValue();
    return hasNodeIgnoreComment(node);
  }

  function hasNodeIgnoreComment(node) {
    return node && node.comments && node.comments.length > 0 && node.comments.some(function (comment) {
      return comment.value.trim() === "prettier-ignore";
    });
  }

  function matchAncestorTypes(path, types, index) {
    index = index || 0;
    types = types.slice();

    while (types.length) {
      var parent = path.getParentNode(index);
      var type = types.shift();

      if (!parent || parent.type !== type) {
        return false;
      }

      index++;
    }

    return true;
  }

  function addCommentHelper(node, comment) {
    var comments = node.comments || (node.comments = []);
    comments.push(comment);
    comment.printed = false; // For some reason, TypeScript parses `// x` inside of JSXText as a comment
    // We already "print" it via the raw text, we don't need to re-print it as a
    // comment

    if (node.type === "JSXText") {
      comment.printed = true;
    }
  }

  function addLeadingComment(node, comment) {
    comment.leading = true;
    comment.trailing = false;
    addCommentHelper(node, comment);
  }

  function addDanglingComment(node, comment) {
    comment.leading = false;
    comment.trailing = false;
    addCommentHelper(node, comment);
  }

  function addTrailingComment(node, comment) {
    comment.leading = false;
    comment.trailing = true;
    addCommentHelper(node, comment);
  }

  function isWithinParentArrayProperty(path, propertyName) {
    var node = path.getValue();
    var parent = path.getParentNode();

    if (parent == null) {
      return false;
    }

    if (!Array.isArray(parent[propertyName])) {
      return false;
    }

    var key = path.getName();
    return parent[propertyName][key] === node;
  }

  function replaceEndOfLineWith(text, replacement) {
    var parts = [];
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = text.split("\n")[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var part = _step2.value;

        if (parts.length !== 0) {
          parts.push(replacement);
        }

        parts.push(part);
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return parts;
  }

  var util = {
    replaceEndOfLineWith: replaceEndOfLineWith,
    getStringWidth: getStringWidth,
    getMaxContinuousCount: getMaxContinuousCount,
    getMinNotPresentContinuousCount: getMinNotPresentContinuousCount,
    getPrecedence: getPrecedence,
    shouldFlatten: shouldFlatten,
    isBitwiseOperator: isBitwiseOperator,
    isExportDeclaration: isExportDeclaration,
    getParentExportDeclaration: getParentExportDeclaration,
    getPenultimate: getPenultimate,
    getLast: getLast,
    getNextNonSpaceNonCommentCharacterIndexWithStartIndex: getNextNonSpaceNonCommentCharacterIndexWithStartIndex,
    getNextNonSpaceNonCommentCharacterIndex: getNextNonSpaceNonCommentCharacterIndex,
    getNextNonSpaceNonCommentCharacter: getNextNonSpaceNonCommentCharacter,
    skip: skip,
    skipWhitespace: skipWhitespace,
    skipSpaces: skipSpaces,
    skipToLineEnd: skipToLineEnd,
    skipEverythingButNewLine: skipEverythingButNewLine,
    skipInlineComment: skipInlineComment,
    skipTrailingComment: skipTrailingComment,
    skipNewline: skipNewline,
    isNextLineEmptyAfterIndex: isNextLineEmptyAfterIndex,
    isNextLineEmpty: isNextLineEmpty,
    isPreviousLineEmpty: isPreviousLineEmpty,
    hasNewline: hasNewline,
    hasNewlineInRange: hasNewlineInRange,
    hasSpaces: hasSpaces,
    setLocStart: setLocStart,
    setLocEnd: setLocEnd,
    startsWithNoLookaheadToken: startsWithNoLookaheadToken,
    getAlignmentSize: getAlignmentSize,
    getIndentSize: getIndentSize,
    getPreferredQuote: getPreferredQuote,
    printString: printString,
    printNumber: printNumber,
    hasIgnoreComment: hasIgnoreComment,
    hasNodeIgnoreComment: hasNodeIgnoreComment,
    makeString: makeString,
    matchAncestorTypes: matchAncestorTypes,
    addLeadingComment: addLeadingComment,
    addDanglingComment: addDanglingComment,
    addTrailingComment: addTrailingComment,
    isWithinParentArrayProperty: isWithinParentArrayProperty
  };

  function guessEndOfLine(text) {
    var index = text.indexOf("\r");

    if (index >= 0) {
      return text.charAt(index + 1) === "\n" ? "crlf" : "cr";
    }

    return "lf";
  }

  function convertEndOfLineToChars(value) {
    switch (value) {
      case "cr":
        return "\r";

      case "crlf":
        return "\r\n";

      default:
        return "\n";
    }
  }

  var endOfLine = {
    guessEndOfLine: guessEndOfLine,
    convertEndOfLineToChars: convertEndOfLineToChars
  };

  var getStringWidth$1 = util.getStringWidth;
  var convertEndOfLineToChars$1 = endOfLine.convertEndOfLineToChars;
  var concat$1 = docBuilders.concat,
      fill$1 = docBuilders.fill,
      cursor$1 = docBuilders.cursor;
  /** @type {Record<symbol, typeof MODE_BREAK | typeof MODE_FLAT>} */

  var groupModeMap;
  var MODE_BREAK = 1;
  var MODE_FLAT = 2;

  function rootIndent() {
    return {
      value: "",
      length: 0,
      queue: []
    };
  }

  function makeIndent(ind, options) {
    return generateInd(ind, {
      type: "indent"
    }, options);
  }

  function makeAlign(ind, n, options) {
    return n === -Infinity ? ind.root || rootIndent() : n < 0 ? generateInd(ind, {
      type: "dedent"
    }, options) : !n ? ind : n.type === "root" ? Object.assign({}, ind, {
      root: ind
    }) : typeof n === "string" ? generateInd(ind, {
      type: "stringAlign",
      n: n
    }, options) : generateInd(ind, {
      type: "numberAlign",
      n: n
    }, options);
  }

  function generateInd(ind, newPart, options) {
    var queue = newPart.type === "dedent" ? ind.queue.slice(0, -1) : ind.queue.concat(newPart);
    var value = "";
    var length = 0;
    var lastTabs = 0;
    var lastSpaces = 0;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = queue[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var part = _step.value;

        switch (part.type) {
          case "indent":
            flush();

            if (options.useTabs) {
              addTabs(1);
            } else {
              addSpaces(options.tabWidth);
            }

            break;

          case "stringAlign":
            flush();
            value += part.n;
            length += part.n.length;
            break;

          case "numberAlign":
            lastTabs += 1;
            lastSpaces += part.n;
            break;

          /* istanbul ignore next */

          default:
            throw new Error("Unexpected type '".concat(part.type, "'"));
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    flushSpaces();
    return Object.assign({}, ind, {
      value: value,
      length: length,
      queue: queue
    });

    function addTabs(count) {
      value += "\t".repeat(count);
      length += options.tabWidth * count;
    }

    function addSpaces(count) {
      value += " ".repeat(count);
      length += count;
    }

    function flush() {
      if (options.useTabs) {
        flushTabs();
      } else {
        flushSpaces();
      }
    }

    function flushTabs() {
      if (lastTabs > 0) {
        addTabs(lastTabs);
      }

      resetLast();
    }

    function flushSpaces() {
      if (lastSpaces > 0) {
        addSpaces(lastSpaces);
      }

      resetLast();
    }

    function resetLast() {
      lastTabs = 0;
      lastSpaces = 0;
    }
  }

  function trim$1(out) {
    if (out.length === 0) {
      return 0;
    }

    var trimCount = 0; // Trim whitespace at the end of line

    while (out.length > 0 && typeof out[out.length - 1] === "string" && out[out.length - 1].match(/^[ \t]*$/)) {
      trimCount += out.pop().length;
    }

    if (out.length && typeof out[out.length - 1] === "string") {
      var trimmed = out[out.length - 1].replace(/[ \t]*$/, "");
      trimCount += out[out.length - 1].length - trimmed.length;
      out[out.length - 1] = trimmed;
    }

    return trimCount;
  }

  function fits(next, restCommands, width, options, mustBeFlat) {
    var restIdx = restCommands.length;
    var cmds = [next]; // `out` is only used for width counting because `trim` requires to look
    // backwards for space characters.

    var out = [];

    while (width >= 0) {
      if (cmds.length === 0) {
        if (restIdx === 0) {
          return true;
        }

        cmds.push(restCommands[restIdx - 1]);
        restIdx--;
        continue;
      }

      var x = cmds.pop();
      var ind = x[0];
      var mode = x[1];
      var doc = x[2];

      if (typeof doc === "string") {
        out.push(doc);
        width -= getStringWidth$1(doc);
      } else {
        switch (doc.type) {
          case "concat":
            for (var i = doc.parts.length - 1; i >= 0; i--) {
              cmds.push([ind, mode, doc.parts[i]]);
            }

            break;

          case "indent":
            cmds.push([makeIndent(ind, options), mode, doc.contents]);
            break;

          case "align":
            cmds.push([makeAlign(ind, doc.n, options), mode, doc.contents]);
            break;

          case "trim":
            width += trim$1(out);
            break;

          case "group":
            if (mustBeFlat && doc.break) {
              return false;
            }

            cmds.push([ind, doc.break ? MODE_BREAK : mode, doc.contents]);

            if (doc.id) {
              groupModeMap[doc.id] = cmds[cmds.length - 1][1];
            }

            break;

          case "fill":
            for (var _i = doc.parts.length - 1; _i >= 0; _i--) {
              cmds.push([ind, mode, doc.parts[_i]]);
            }

            break;

          case "if-break":
            {
              var groupMode = doc.groupId ? groupModeMap[doc.groupId] : mode;

              if (groupMode === MODE_BREAK) {
                if (doc.breakContents) {
                  cmds.push([ind, mode, doc.breakContents]);
                }
              }

              if (groupMode === MODE_FLAT) {
                if (doc.flatContents) {
                  cmds.push([ind, mode, doc.flatContents]);
                }
              }

              break;
            }

          case "line":
            switch (mode) {
              // fallthrough
              case MODE_FLAT:
                if (!doc.hard) {
                  if (!doc.soft) {
                    out.push(" ");
                    width -= 1;
                  }

                  break;
                }

                return true;

              case MODE_BREAK:
                return true;
            }

            break;
        }
      }
    }

    return false;
  }

  function printDocToString(doc, options) {
    groupModeMap = {};
    var width = options.printWidth;
    var newLine = convertEndOfLineToChars$1(options.endOfLine);
    var pos = 0; // cmds is basically a stack. We've turned a recursive call into a
    // while loop which is much faster. The while loop below adds new
    // cmds to the array instead of recursively calling `print`.

    var cmds = [[rootIndent(), MODE_BREAK, doc]];
    var out = [];
    var shouldRemeasure = false;
    var lineSuffix = [];

    while (cmds.length !== 0) {
      var x = cmds.pop();
      var ind = x[0];
      var mode = x[1];
      var _doc = x[2];

      if (typeof _doc === "string") {
        out.push(_doc);
        pos += getStringWidth$1(_doc);
      } else {
        switch (_doc.type) {
          case "cursor":
            out.push(cursor$1.placeholder);
            break;

          case "concat":
            for (var i = _doc.parts.length - 1; i >= 0; i--) {
              cmds.push([ind, mode, _doc.parts[i]]);
            }

            break;

          case "indent":
            cmds.push([makeIndent(ind, options), mode, _doc.contents]);
            break;

          case "align":
            cmds.push([makeAlign(ind, _doc.n, options), mode, _doc.contents]);
            break;

          case "trim":
            pos -= trim$1(out);
            break;

          case "group":
            switch (mode) {
              case MODE_FLAT:
                if (!shouldRemeasure) {
                  cmds.push([ind, _doc.break ? MODE_BREAK : MODE_FLAT, _doc.contents]);
                  break;
                }

              // fallthrough

              case MODE_BREAK:
                {
                  shouldRemeasure = false;
                  var next = [ind, MODE_FLAT, _doc.contents];
                  var rem = width - pos;

                  if (!_doc.break && fits(next, cmds, rem, options)) {
                    cmds.push(next);
                  } else {
                    // Expanded states are a rare case where a document
                    // can manually provide multiple representations of
                    // itself. It provides an array of documents
                    // going from the least expanded (most flattened)
                    // representation first to the most expanded. If a
                    // group has these, we need to manually go through
                    // these states and find the first one that fits.
                    if (_doc.expandedStates) {
                      var mostExpanded = _doc.expandedStates[_doc.expandedStates.length - 1];

                      if (_doc.break) {
                        cmds.push([ind, MODE_BREAK, mostExpanded]);
                        break;
                      } else {
                        for (var _i2 = 1; _i2 < _doc.expandedStates.length + 1; _i2++) {
                          if (_i2 >= _doc.expandedStates.length) {
                            cmds.push([ind, MODE_BREAK, mostExpanded]);
                            break;
                          } else {
                            var state = _doc.expandedStates[_i2];
                            var cmd = [ind, MODE_FLAT, state];

                            if (fits(cmd, cmds, rem, options)) {
                              cmds.push(cmd);
                              break;
                            }
                          }
                        }
                      }
                    } else {
                      cmds.push([ind, MODE_BREAK, _doc.contents]);
                    }
                  }

                  break;
                }
            }

            if (_doc.id) {
              groupModeMap[_doc.id] = cmds[cmds.length - 1][1];
            }

            break;
          // Fills each line with as much code as possible before moving to a new
          // line with the same indentation.
          //
          // Expects doc.parts to be an array of alternating content and
          // whitespace. The whitespace contains the linebreaks.
          //
          // For example:
          //   ["I", line, "love", line, "monkeys"]
          // or
          //   [{ type: group, ... }, softline, { type: group, ... }]
          //
          // It uses this parts structure to handle three main layout cases:
          // * The first two content items fit on the same line without
          //   breaking
          //   -> output the first content item and the whitespace "flat".
          // * Only the first content item fits on the line without breaking
          //   -> output the first content item "flat" and the whitespace with
          //   "break".
          // * Neither content item fits on the line without breaking
          //   -> output the first content item and the whitespace with "break".

          case "fill":
            {
              var _rem = width - pos;

              var parts = _doc.parts;

              if (parts.length === 0) {
                break;
              }

              var content = parts[0];
              var contentFlatCmd = [ind, MODE_FLAT, content];
              var contentBreakCmd = [ind, MODE_BREAK, content];
              var contentFits = fits(contentFlatCmd, [], _rem, options, true);

              if (parts.length === 1) {
                if (contentFits) {
                  cmds.push(contentFlatCmd);
                } else {
                  cmds.push(contentBreakCmd);
                }

                break;
              }

              var whitespace = parts[1];
              var whitespaceFlatCmd = [ind, MODE_FLAT, whitespace];
              var whitespaceBreakCmd = [ind, MODE_BREAK, whitespace];

              if (parts.length === 2) {
                if (contentFits) {
                  cmds.push(whitespaceFlatCmd);
                  cmds.push(contentFlatCmd);
                } else {
                  cmds.push(whitespaceBreakCmd);
                  cmds.push(contentBreakCmd);
                }

                break;
              } // At this point we've handled the first pair (context, separator)
              // and will create a new fill doc for the rest of the content.
              // Ideally we wouldn't mutate the array here but coping all the
              // elements to a new array would make this algorithm quadratic,
              // which is unusable for large arrays (e.g. large texts in JSX).


              parts.splice(0, 2);
              var remainingCmd = [ind, mode, fill$1(parts)];
              var secondContent = parts[0];
              var firstAndSecondContentFlatCmd = [ind, MODE_FLAT, concat$1([content, whitespace, secondContent])];
              var firstAndSecondContentFits = fits(firstAndSecondContentFlatCmd, [], _rem, options, true);

              if (firstAndSecondContentFits) {
                cmds.push(remainingCmd);
                cmds.push(whitespaceFlatCmd);
                cmds.push(contentFlatCmd);
              } else if (contentFits) {
                cmds.push(remainingCmd);
                cmds.push(whitespaceBreakCmd);
                cmds.push(contentFlatCmd);
              } else {
                cmds.push(remainingCmd);
                cmds.push(whitespaceBreakCmd);
                cmds.push(contentBreakCmd);
              }

              break;
            }

          case "if-break":
            {
              var groupMode = _doc.groupId ? groupModeMap[_doc.groupId] : mode;

              if (groupMode === MODE_BREAK) {
                if (_doc.breakContents) {
                  cmds.push([ind, mode, _doc.breakContents]);
                }
              }

              if (groupMode === MODE_FLAT) {
                if (_doc.flatContents) {
                  cmds.push([ind, mode, _doc.flatContents]);
                }
              }

              break;
            }

          case "line-suffix":
            lineSuffix.push([ind, mode, _doc.contents]);
            break;

          case "line-suffix-boundary":
            if (lineSuffix.length > 0) {
              cmds.push([ind, mode, {
                type: "line",
                hard: true
              }]);
            }

            break;

          case "line":
            switch (mode) {
              case MODE_FLAT:
                if (!_doc.hard) {
                  if (!_doc.soft) {
                    out.push(" ");
                    pos += 1;
                  }

                  break;
                } else {
                  // This line was forced into the output even if we
                  // were in flattened mode, so we need to tell the next
                  // group that no matter what, it needs to remeasure
                  // because the previous measurement didn't accurately
                  // capture the entire expression (this is necessary
                  // for nested groups)
                  shouldRemeasure = true;
                }

              // fallthrough

              case MODE_BREAK:
                if (lineSuffix.length) {
                  cmds.push([ind, mode, _doc]);
                  [].push.apply(cmds, lineSuffix.reverse());
                  lineSuffix = [];
                  break;
                }

                if (_doc.literal) {
                  if (ind.root) {
                    out.push(newLine, ind.root.value);
                    pos = ind.root.length;
                  } else {
                    out.push(newLine);
                    pos = 0;
                  }
                } else {
                  pos -= trim$1(out);
                  out.push(newLine + ind.value);
                  pos = ind.length;
                }

                break;
            }

            break;
        }
      }
    }

    var cursorPlaceholderIndex = out.indexOf(cursor$1.placeholder);

    if (cursorPlaceholderIndex !== -1) {
      var otherCursorPlaceholderIndex = out.indexOf(cursor$1.placeholder, cursorPlaceholderIndex + 1);
      var beforeCursor = out.slice(0, cursorPlaceholderIndex).join("");
      var aroundCursor = out.slice(cursorPlaceholderIndex + 1, otherCursorPlaceholderIndex).join("");
      var afterCursor = out.slice(otherCursorPlaceholderIndex + 1).join("");
      return {
        formatted: beforeCursor + aroundCursor + afterCursor,
        cursorNodeStart: beforeCursor.length,
        cursorNodeText: aroundCursor
      };
    }

    return {
      formatted: out.join("")
    };
  }

  var docPrinter = {
    printDocToString: printDocToString
  };

  var traverseDocOnExitStackMarker = {};

  function traverseDoc(doc, onEnter, onExit, shouldTraverseConditionalGroups) {
    var docsStack = [doc];

    while (docsStack.length !== 0) {
      var _doc = docsStack.pop();

      if (_doc === traverseDocOnExitStackMarker) {
        onExit(docsStack.pop());
        continue;
      }

      var shouldRecurse = true;

      if (onEnter) {
        if (onEnter(_doc) === false) {
          shouldRecurse = false;
        }
      }

      if (onExit) {
        docsStack.push(_doc);
        docsStack.push(traverseDocOnExitStackMarker);
      }

      if (shouldRecurse) {
        // When there are multiple parts to process,
        // the parts need to be pushed onto the stack in reverse order,
        // so that they are processed in the original order
        // when the stack is popped.
        if (_doc.type === "concat" || _doc.type === "fill") {
          for (var ic = _doc.parts.length, i = ic - 1; i >= 0; --i) {
            docsStack.push(_doc.parts[i]);
          }
        } else if (_doc.type === "if-break") {
          if (_doc.flatContents) {
            docsStack.push(_doc.flatContents);
          }

          if (_doc.breakContents) {
            docsStack.push(_doc.breakContents);
          }
        } else if (_doc.type === "group" && _doc.expandedStates) {
          if (shouldTraverseConditionalGroups) {
            for (var _ic = _doc.expandedStates.length, _i = _ic - 1; _i >= 0; --_i) {
              docsStack.push(_doc.expandedStates[_i]);
            }
          } else {
            docsStack.push(_doc.contents);
          }
        } else if (_doc.contents) {
          docsStack.push(_doc.contents);
        }
      }
    }
  }

  function mapDoc(doc, cb) {
    if (doc.type === "concat" || doc.type === "fill") {
      var parts = doc.parts.map(function (part) {
        return mapDoc(part, cb);
      });
      return cb(Object.assign({}, doc, {
        parts: parts
      }));
    } else if (doc.type === "if-break") {
      var breakContents = doc.breakContents && mapDoc(doc.breakContents, cb);
      var flatContents = doc.flatContents && mapDoc(doc.flatContents, cb);
      return cb(Object.assign({}, doc, {
        breakContents: breakContents,
        flatContents: flatContents
      }));
    } else if (doc.contents) {
      var contents = mapDoc(doc.contents, cb);
      return cb(Object.assign({}, doc, {
        contents: contents
      }));
    }

    return cb(doc);
  }

  function findInDoc(doc, fn, defaultValue) {
    var result = defaultValue;
    var hasStopped = false;

    function findInDocOnEnterFn(doc) {
      var maybeResult = fn(doc);

      if (maybeResult !== undefined) {
        hasStopped = true;
        result = maybeResult;
      }

      if (hasStopped) {
        return false;
      }
    }

    traverseDoc(doc, findInDocOnEnterFn);
    return result;
  }

  function isEmpty(n) {
    return typeof n === "string" && n.length === 0;
  }

  function isLineNextFn(doc) {
    if (typeof doc === "string") {
      return false;
    }

    if (doc.type === "line") {
      return true;
    }
  }

  function isLineNext(doc) {
    return findInDoc(doc, isLineNextFn, false);
  }

  function willBreakFn(doc) {
    if (doc.type === "group" && doc.break) {
      return true;
    }

    if (doc.type === "line" && doc.hard) {
      return true;
    }

    if (doc.type === "break-parent") {
      return true;
    }
  }

  function willBreak(doc) {
    return findInDoc(doc, willBreakFn, false);
  }

  function breakParentGroup(groupStack) {
    if (groupStack.length > 0) {
      var parentGroup = groupStack[groupStack.length - 1]; // Breaks are not propagated through conditional groups because
      // the user is expected to manually handle what breaks.

      if (!parentGroup.expandedStates) {
        parentGroup.break = true;
      }
    }

    return null;
  }

  function propagateBreaks(doc) {
    var alreadyVisitedSet = new Set();
    var groupStack = [];

    function propagateBreaksOnEnterFn(doc) {
      if (doc.type === "break-parent") {
        breakParentGroup(groupStack);
      }

      if (doc.type === "group") {
        groupStack.push(doc);

        if (alreadyVisitedSet.has(doc)) {
          return false;
        }

        alreadyVisitedSet.add(doc);
      }
    }

    function propagateBreaksOnExitFn(doc) {
      if (doc.type === "group") {
        var group = groupStack.pop();

        if (group.break) {
          breakParentGroup(groupStack);
        }
      }
    }

    traverseDoc(doc, propagateBreaksOnEnterFn, propagateBreaksOnExitFn,
    /* shouldTraverseConditionalGroups */
    true);
  }

  function removeLinesFn(doc) {
    // Force this doc into flat mode by statically converting all
    // lines into spaces (or soft lines into nothing). Hard lines
    // should still output because there's too great of a chance
    // of breaking existing assumptions otherwise.
    if (doc.type === "line" && !doc.hard) {
      return doc.soft ? "" : " ";
    } else if (doc.type === "if-break") {
      return doc.flatContents || "";
    }

    return doc;
  }

  function removeLines(doc) {
    return mapDoc(doc, removeLinesFn);
  }

  function stripTrailingHardline(doc) {
    // HACK remove ending hardline, original PR: #1984
    if (doc.type === "concat" && doc.parts.length !== 0) {
      var lastPart = doc.parts[doc.parts.length - 1];

      if (lastPart.type === "concat") {
        if (lastPart.parts.length === 2 && lastPart.parts[0].hard && lastPart.parts[1].type === "break-parent") {
          return {
            type: "concat",
            parts: doc.parts.slice(0, -1)
          };
        }

        return {
          type: "concat",
          parts: doc.parts.slice(0, -1).concat(stripTrailingHardline(lastPart))
        };
      }
    }

    return doc;
  }

  var docUtils = {
    isEmpty: isEmpty,
    willBreak: willBreak,
    isLineNext: isLineNext,
    traverseDoc: traverseDoc,
    findInDoc: findInDoc,
    mapDoc: mapDoc,
    propagateBreaks: propagateBreaks,
    removeLines: removeLines,
    stripTrailingHardline: stripTrailingHardline
  };

  function flattenDoc(doc) {
    if (doc.type === "concat") {
      var res = [];

      for (var i = 0; i < doc.parts.length; ++i) {
        var doc2 = doc.parts[i];

        if (typeof doc2 !== "string" && doc2.type === "concat") {
          [].push.apply(res, flattenDoc(doc2).parts);
        } else {
          var flattened = flattenDoc(doc2);

          if (flattened !== "") {
            res.push(flattened);
          }
        }
      }

      return Object.assign({}, doc, {
        parts: res
      });
    } else if (doc.type === "if-break") {
      return Object.assign({}, doc, {
        breakContents: doc.breakContents != null ? flattenDoc(doc.breakContents) : null,
        flatContents: doc.flatContents != null ? flattenDoc(doc.flatContents) : null
      });
    } else if (doc.type === "group") {
      return Object.assign({}, doc, {
        contents: flattenDoc(doc.contents),
        expandedStates: doc.expandedStates ? doc.expandedStates.map(flattenDoc) : doc.expandedStates
      });
    } else if (doc.contents) {
      return Object.assign({}, doc, {
        contents: flattenDoc(doc.contents)
      });
    }

    return doc;
  }

  function printDoc(doc) {
    if (typeof doc === "string") {
      return JSON.stringify(doc);
    }

    if (doc.type === "line") {
      if (doc.literal) {
        return "literalline";
      }

      if (doc.hard) {
        return "hardline";
      }

      if (doc.soft) {
        return "softline";
      }

      return "line";
    }

    if (doc.type === "break-parent") {
      return "breakParent";
    }

    if (doc.type === "trim") {
      return "trim";
    }

    if (doc.type === "concat") {
      return "[" + doc.parts.map(printDoc).join(", ") + "]";
    }

    if (doc.type === "indent") {
      return "indent(" + printDoc(doc.contents) + ")";
    }

    if (doc.type === "align") {
      return doc.n === -Infinity ? "dedentToRoot(" + printDoc(doc.contents) + ")" : doc.n < 0 ? "dedent(" + printDoc(doc.contents) + ")" : doc.n.type === "root" ? "markAsRoot(" + printDoc(doc.contents) + ")" : "align(" + JSON.stringify(doc.n) + ", " + printDoc(doc.contents) + ")";
    }

    if (doc.type === "if-break") {
      return "ifBreak(" + printDoc(doc.breakContents) + (doc.flatContents ? ", " + printDoc(doc.flatContents) : "") + ")";
    }

    if (doc.type === "group") {
      if (doc.expandedStates) {
        return "conditionalGroup(" + "[" + doc.expandedStates.map(printDoc).join(",") + "])";
      }

      return (doc.break ? "wrappedGroup" : "group") + "(" + printDoc(doc.contents) + ")";
    }

    if (doc.type === "fill") {
      return "fill" + "(" + doc.parts.map(printDoc).join(", ") + ")";
    }

    if (doc.type === "line-suffix") {
      return "lineSuffix(" + printDoc(doc.contents) + ")";
    }

    if (doc.type === "line-suffix-boundary") {
      return "lineSuffixBoundary";
    }

    throw new Error("Unknown doc type " + doc.type);
  }

  var docDebug = {
    printDocToDebug: function printDocToDebug(doc) {
      return printDoc(flattenDoc(doc));
    }
  };

  var doc = {
    builders: docBuilders,
    printer: docPrinter,
    utils: docUtils,
    debug: docDebug
  };

  var mapDoc$1 = doc.utils.mapDoc;

  function isNextLineEmpty$1(text, node, options) {
    return util.isNextLineEmpty(text, node, options.locEnd);
  }

  function isPreviousLineEmpty$1(text, node, options) {
    return util.isPreviousLineEmpty(text, node, options.locStart);
  }

  function getNextNonSpaceNonCommentCharacterIndex$1(text, node, options) {
    return util.getNextNonSpaceNonCommentCharacterIndex(text, node, options.locEnd);
  }

  var utilShared = {
    getMaxContinuousCount: util.getMaxContinuousCount,
    getStringWidth: util.getStringWidth,
    getAlignmentSize: util.getAlignmentSize,
    getIndentSize: util.getIndentSize,
    skip: util.skip,
    skipWhitespace: util.skipWhitespace,
    skipSpaces: util.skipSpaces,
    skipNewline: util.skipNewline,
    skipToLineEnd: util.skipToLineEnd,
    skipEverythingButNewLine: util.skipEverythingButNewLine,
    skipInlineComment: util.skipInlineComment,
    skipTrailingComment: util.skipTrailingComment,
    hasNewline: util.hasNewline,
    hasNewlineInRange: util.hasNewlineInRange,
    hasSpaces: util.hasSpaces,
    isNextLineEmpty: isNextLineEmpty$1,
    isNextLineEmptyAfterIndex: util.isNextLineEmptyAfterIndex,
    isPreviousLineEmpty: isPreviousLineEmpty$1,
    getNextNonSpaceNonCommentCharacterIndex: getNextNonSpaceNonCommentCharacterIndex$1,
    mapDoc: mapDoc$1,
    // TODO: remove in 2.0, we already exposed it in docUtils
    makeString: util.makeString,
    addLeadingComment: util.addLeadingComment,
    addDanglingComment: util.addDanglingComment,
    addTrailingComment: util.addTrailingComment
  };

  var _require$$0$builders = doc.builders,
      concat$2 = _require$$0$builders.concat,
      hardline$1 = _require$$0$builders.hardline,
      breakParent$1 = _require$$0$builders.breakParent,
      indent$1 = _require$$0$builders.indent,
      lineSuffix$1 = _require$$0$builders.lineSuffix,
      join$1 = _require$$0$builders.join,
      cursor$2 = _require$$0$builders.cursor;
  var hasNewline$1 = util.hasNewline,
      skipNewline$1 = util.skipNewline,
      isPreviousLineEmpty$2 = util.isPreviousLineEmpty;
  var addLeadingComment$1 = utilShared.addLeadingComment,
      addDanglingComment$1 = utilShared.addDanglingComment,
      addTrailingComment$1 = utilShared.addTrailingComment;
  var childNodesCacheKey = Symbol("child-nodes");

  function getSortedChildNodes(node, options, resultArray) {
    if (!node) {
      return;
    }

    var printer = options.printer,
        locStart = options.locStart,
        locEnd = options.locEnd;

    if (resultArray) {
      if (node && printer.canAttachComment && printer.canAttachComment(node)) {
        // This reverse insertion sort almost always takes constant
        // time because we almost always (maybe always?) append the
        // nodes in order anyway.
        var i;

        for (i = resultArray.length - 1; i >= 0; --i) {
          if (locStart(resultArray[i]) <= locStart(node) && locEnd(resultArray[i]) <= locEnd(node)) {
            break;
          }
        }

        resultArray.splice(i + 1, 0, node);
        return;
      }
    } else if (node[childNodesCacheKey]) {
      return node[childNodesCacheKey];
    }

    var childNodes;

    if (printer.getCommentChildNodes) {
      childNodes = printer.getCommentChildNodes(node);
    } else if (node && _typeof(node) === "object") {
      childNodes = Object.keys(node).filter(function (n) {
        return n !== "enclosingNode" && n !== "precedingNode" && n !== "followingNode";
      }).map(function (n) {
        return node[n];
      });
    }

    if (!childNodes) {
      return;
    }

    if (!resultArray) {
      Object.defineProperty(node, childNodesCacheKey, {
        value: resultArray = [],
        enumerable: false
      });
    }

    childNodes.forEach(function (childNode) {
      getSortedChildNodes(childNode, options, resultArray);
    });
    return resultArray;
  } // As efficiently as possible, decorate the comment object with
  // .precedingNode, .enclosingNode, and/or .followingNode properties, at
  // least one of which is guaranteed to be defined.


  function decorateComment(node, comment, options) {
    var locStart = options.locStart,
        locEnd = options.locEnd;
    var childNodes = getSortedChildNodes(node, options);
    var precedingNode;
    var followingNode; // Time to dust off the old binary search robes and wizard hat.

    var left = 0;
    var right = childNodes.length;

    while (left < right) {
      var middle = left + right >> 1;
      var child = childNodes[middle];

      if (locStart(child) - locStart(comment) <= 0 && locEnd(comment) - locEnd(child) <= 0) {
        // The comment is completely contained by this child node.
        comment.enclosingNode = child;
        decorateComment(child, comment, options);
        return; // Abandon the binary search at this level.
      }

      if (locEnd(child) - locStart(comment) <= 0) {
        // This child node falls completely before the comment.
        // Because we will never consider this node or any nodes
        // before it again, this node must be the closest preceding
        // node we have encountered so far.
        precedingNode = child;
        left = middle + 1;
        continue;
      }

      if (locEnd(comment) - locStart(child) <= 0) {
        // This child node falls completely after the comment.
        // Because we will never consider this node or any nodes after
        // it again, this node must be the closest following node we
        // have encountered so far.
        followingNode = child;
        right = middle;
        continue;
      }
      /* istanbul ignore next */


      throw new Error("Comment location overlaps with node location");
    } // We don't want comments inside of different expressions inside of the same
    // template literal to move to another expression.


    if (comment.enclosingNode && comment.enclosingNode.type === "TemplateLiteral") {
      var quasis = comment.enclosingNode.quasis;
      var commentIndex = findExpressionIndexForComment(quasis, comment, options);

      if (precedingNode && findExpressionIndexForComment(quasis, precedingNode, options) !== commentIndex) {
        precedingNode = null;
      }

      if (followingNode && findExpressionIndexForComment(quasis, followingNode, options) !== commentIndex) {
        followingNode = null;
      }
    }

    if (precedingNode) {
      comment.precedingNode = precedingNode;
    }

    if (followingNode) {
      comment.followingNode = followingNode;
    }
  }

  function attach(comments, ast, text, options) {
    if (!Array.isArray(comments)) {
      return;
    }

    var tiesToBreak = [];
    var locStart = options.locStart,
        locEnd = options.locEnd;
    comments.forEach(function (comment, i) {
      if (options.parser === "json" || options.parser === "json5" || options.parser === "__js_expression" || options.parser === "__vue_expression") {
        if (locStart(comment) - locStart(ast) <= 0) {
          addLeadingComment$1(ast, comment);
          return;
        }

        if (locEnd(comment) - locEnd(ast) >= 0) {
          addTrailingComment$1(ast, comment);
          return;
        }
      }

      decorateComment(ast, comment, options);
      var precedingNode = comment.precedingNode,
          enclosingNode = comment.enclosingNode,
          followingNode = comment.followingNode;
      var pluginHandleOwnLineComment = options.printer.handleComments && options.printer.handleComments.ownLine ? options.printer.handleComments.ownLine : function () {
        return false;
      };
      var pluginHandleEndOfLineComment = options.printer.handleComments && options.printer.handleComments.endOfLine ? options.printer.handleComments.endOfLine : function () {
        return false;
      };
      var pluginHandleRemainingComment = options.printer.handleComments && options.printer.handleComments.remaining ? options.printer.handleComments.remaining : function () {
        return false;
      };
      var isLastComment = comments.length - 1 === i;

      if (hasNewline$1(text, locStart(comment), {
        backwards: true
      })) {
        // If a comment exists on its own line, prefer a leading comment.
        // We also need to check if it's the first line of the file.
        if (pluginHandleOwnLineComment(comment, text, options, ast, isLastComment)) ; else if (followingNode) {
          // Always a leading comment.
          addLeadingComment$1(followingNode, comment);
        } else if (precedingNode) {
          addTrailingComment$1(precedingNode, comment);
        } else if (enclosingNode) {
          addDanglingComment$1(enclosingNode, comment);
        } else {
          // There are no nodes, let's attach it to the root of the ast

          /* istanbul ignore next */
          addDanglingComment$1(ast, comment);
        }
      } else if (hasNewline$1(text, locEnd(comment))) {
        if (pluginHandleEndOfLineComment(comment, text, options, ast, isLastComment)) ; else if (precedingNode) {
          // There is content before this comment on the same line, but
          // none after it, so prefer a trailing comment of the previous node.
          addTrailingComment$1(precedingNode, comment);
        } else if (followingNode) {
          addLeadingComment$1(followingNode, comment);
        } else if (enclosingNode) {
          addDanglingComment$1(enclosingNode, comment);
        } else {
          // There are no nodes, let's attach it to the root of the ast

          /* istanbul ignore next */
          addDanglingComment$1(ast, comment);
        }
      } else {
        if (pluginHandleRemainingComment(comment, text, options, ast, isLastComment)) ; else if (precedingNode && followingNode) {
          // Otherwise, text exists both before and after the comment on
          // the same line. If there is both a preceding and following
          // node, use a tie-breaking algorithm to determine if it should
          // be attached to the next or previous node. In the last case,
          // simply attach the right node;
          var tieCount = tiesToBreak.length;

          if (tieCount > 0) {
            var lastTie = tiesToBreak[tieCount - 1];

            if (lastTie.followingNode !== comment.followingNode) {
              breakTies(tiesToBreak, text, options);
            }
          }

          tiesToBreak.push(comment);
        } else if (precedingNode) {
          addTrailingComment$1(precedingNode, comment);
        } else if (followingNode) {
          addLeadingComment$1(followingNode, comment);
        } else if (enclosingNode) {
          addDanglingComment$1(enclosingNode, comment);
        } else {
          // There are no nodes, let's attach it to the root of the ast

          /* istanbul ignore next */
          addDanglingComment$1(ast, comment);
        }
      }
    });
    breakTies(tiesToBreak, text, options);
    comments.forEach(function (comment) {
      // These node references were useful for breaking ties, but we
      // don't need them anymore, and they create cycles in the AST that
      // may lead to infinite recursion if we don't delete them here.
      delete comment.precedingNode;
      delete comment.enclosingNode;
      delete comment.followingNode;
    });
  }

  function breakTies(tiesToBreak, text, options) {
    var tieCount = tiesToBreak.length;

    if (tieCount === 0) {
      return;
    }

    var _tiesToBreak$ = tiesToBreak[0],
        precedingNode = _tiesToBreak$.precedingNode,
        followingNode = _tiesToBreak$.followingNode;
    var gapEndPos = options.locStart(followingNode); // Iterate backwards through tiesToBreak, examining the gaps
    // between the tied comments. In order to qualify as leading, a
    // comment must be separated from followingNode by an unbroken series of
    // gaps (or other comments). Gaps should only contain whitespace or open
    // parentheses.

    var indexOfFirstLeadingComment;

    for (indexOfFirstLeadingComment = tieCount; indexOfFirstLeadingComment > 0; --indexOfFirstLeadingComment) {
      var comment = tiesToBreak[indexOfFirstLeadingComment - 1];
      assert.strictEqual(comment.precedingNode, precedingNode);
      assert.strictEqual(comment.followingNode, followingNode);
      var gap = text.slice(options.locEnd(comment), gapEndPos);

      if (/^[\s(]*$/.test(gap)) {
        gapEndPos = options.locStart(comment);
      } else {
        // The gap string contained something other than whitespace or open
        // parentheses.
        break;
      }
    }

    tiesToBreak.forEach(function (comment, i) {
      if (i < indexOfFirstLeadingComment) {
        addTrailingComment$1(precedingNode, comment);
      } else {
        addLeadingComment$1(followingNode, comment);
      }
    });
    tiesToBreak.length = 0;
  }

  function printComment(commentPath, options) {
    var comment = commentPath.getValue();
    comment.printed = true;
    return options.printer.printComment(commentPath, options);
  }

  function findExpressionIndexForComment(quasis, comment, options) {
    var startPos = options.locStart(comment) - 1;

    for (var i = 1; i < quasis.length; ++i) {
      if (startPos < getQuasiRange(quasis[i]).start) {
        return i - 1;
      }
    } // We haven't found it, it probably means that some of the locations are off.
    // Let's just return the first one.

    /* istanbul ignore next */


    return 0;
  }

  function getQuasiRange(expr) {
    if (expr.start !== undefined) {
      // Babel
      return {
        start: expr.start,
        end: expr.end
      };
    } // Flow


    return {
      start: expr.range[0],
      end: expr.range[1]
    };
  }

  function printLeadingComment(commentPath, print, options) {
    var comment = commentPath.getValue();
    var contents = printComment(commentPath, options);

    if (!contents) {
      return "";
    }

    var isBlock = options.printer.isBlockComment && options.printer.isBlockComment(comment); // Leading block comments should see if they need to stay on the
    // same line or not.

    if (isBlock) {
      return concat$2([contents, hasNewline$1(options.originalText, options.locEnd(comment)) ? hardline$1 : " "]);
    }

    return concat$2([contents, hardline$1]);
  }

  function printTrailingComment(commentPath, print, options) {
    var comment = commentPath.getValue();
    var contents = printComment(commentPath, options);

    if (!contents) {
      return "";
    }

    var isBlock = options.printer.isBlockComment && options.printer.isBlockComment(comment); // We don't want the line to break
    // when the parentParentNode is a ClassDeclaration/-Expression
    // And the parentNode is in the superClass property

    var parentNode = commentPath.getNode(1);
    var parentParentNode = commentPath.getNode(2);
    var isParentSuperClass = parentParentNode && (parentParentNode.type === "ClassDeclaration" || parentParentNode.type === "ClassExpression") && parentParentNode.superClass === parentNode;

    if (hasNewline$1(options.originalText, options.locStart(comment), {
      backwards: true
    })) {
      // This allows comments at the end of nested structures:
      // {
      //   x: 1,
      //   y: 2
      //   // A comment
      // }
      // Those kinds of comments are almost always leading comments, but
      // here it doesn't go "outside" the block and turns it into a
      // trailing comment for `2`. We can simulate the above by checking
      // if this a comment on its own line; normal trailing comments are
      // always at the end of another expression.
      var isLineBeforeEmpty = isPreviousLineEmpty$2(options.originalText, comment, options.locStart);
      return lineSuffix$1(concat$2([hardline$1, isLineBeforeEmpty ? hardline$1 : "", contents]));
    } else if (isBlock || isParentSuperClass) {
      // Trailing block comments never need a newline
      return concat$2([" ", contents]);
    }

    return concat$2([lineSuffix$1(concat$2([" ", contents])), !isBlock ? breakParent$1 : ""]);
  }

  function printDanglingComments(path, options, sameIndent, filter) {
    var parts = [];
    var node = path.getValue();

    if (!node || !node.comments) {
      return "";
    }

    path.each(function (commentPath) {
      var comment = commentPath.getValue();

      if (comment && !comment.leading && !comment.trailing && (!filter || filter(comment))) {
        parts.push(printComment(commentPath, options));
      }
    }, "comments");

    if (parts.length === 0) {
      return "";
    }

    if (sameIndent) {
      return join$1(hardline$1, parts);
    }

    return indent$1(concat$2([hardline$1, join$1(hardline$1, parts)]));
  }

  function prependCursorPlaceholder(path, options, printed) {
    if (path.getNode() === options.cursorNode && path.getValue()) {
      return concat$2([cursor$2, printed, cursor$2]);
    }

    return printed;
  }

  function printComments(path, print, options, needsSemi) {
    var value = path.getValue();
    var printed = print(path);
    var comments = value && value.comments;

    if (!comments || comments.length === 0) {
      return prependCursorPlaceholder(path, options, printed);
    }

    var leadingParts = [];
    var trailingParts = [needsSemi ? ";" : "", printed];
    path.each(function (commentPath) {
      var comment = commentPath.getValue();
      var leading = comment.leading,
          trailing = comment.trailing;

      if (leading) {
        var contents = printLeadingComment(commentPath, print, options);

        if (!contents) {
          return;
        }

        leadingParts.push(contents);
        var text = options.originalText;
        var index = skipNewline$1(text, options.locEnd(comment));

        if (index !== false && hasNewline$1(text, index)) {
          leadingParts.push(hardline$1);
        }
      } else if (trailing) {
        trailingParts.push(printTrailingComment(commentPath, print, options));
      }
    }, "comments");
    return prependCursorPlaceholder(path, options, concat$2(leadingParts.concat(trailingParts)));
  }

  var comments = {
    attach: attach,
    printComments: printComments,
    printDanglingComments: printDanglingComments,
    getSortedChildNodes: getSortedChildNodes
  };

  function FastPath(value) {
    assert.ok(this instanceof FastPath);
    this.stack = [value];
  } // The name of the current property is always the penultimate element of
  // this.stack, and always a String.


  FastPath.prototype.getName = function getName() {
    var s = this.stack;
    var len = s.length;

    if (len > 1) {
      return s[len - 2];
    } // Since the name is always a string, null is a safe sentinel value to
    // return if we do not know the name of the (root) value.

    /* istanbul ignore next */


    return null;
  }; // The value of the current property is always the final element of
  // this.stack.


  FastPath.prototype.getValue = function getValue() {
    var s = this.stack;
    return s[s.length - 1];
  };

  function getNodeHelper(path, count) {
    var stackIndex = getNodeStackIndexHelper(path.stack, count);
    return stackIndex === -1 ? null : path.stack[stackIndex];
  }

  function getNodeStackIndexHelper(stack, count) {
    for (var i = stack.length - 1; i >= 0; i -= 2) {
      var value = stack[i];

      if (value && !Array.isArray(value) && --count < 0) {
        return i;
      }
    }

    return -1;
  }

  FastPath.prototype.getNode = function getNode(count) {
    return getNodeHelper(this, ~~count);
  };

  FastPath.prototype.getParentNode = function getParentNode(count) {
    return getNodeHelper(this, ~~count + 1);
  }; // Temporarily push properties named by string arguments given after the
  // callback function onto this.stack, then call the callback with a
  // reference to this (modified) FastPath object. Note that the stack will
  // be restored to its original state after the callback is finished, so it
  // is probably a mistake to retain a reference to the path.


  FastPath.prototype.call = function call(callback
  /*, name1, name2, ... */
  ) {
    var s = this.stack;
    var origLen = s.length;
    var value = s[origLen - 1];
    var argc = arguments.length;

    for (var i = 1; i < argc; ++i) {
      var name = arguments[i];
      value = value[name];
      s.push(name, value);
    }

    var result = callback(this);
    s.length = origLen;
    return result;
  };

  FastPath.prototype.callParent = function callParent(callback, count) {
    var stackIndex = getNodeStackIndexHelper(this.stack, ~~count + 1);
    var parentValues = this.stack.splice(stackIndex + 1);
    var result = callback(this);
    Array.prototype.push.apply(this.stack, parentValues);
    return result;
  }; // Similar to FastPath.prototype.call, except that the value obtained by
  // accessing this.getValue()[name1][name2]... should be array-like. The
  // callback will be called with a reference to this path object for each
  // element of the array.


  FastPath.prototype.each = function each(callback
  /*, name1, name2, ... */
  ) {
    var s = this.stack;
    var origLen = s.length;
    var value = s[origLen - 1];
    var argc = arguments.length;

    for (var i = 1; i < argc; ++i) {
      var name = arguments[i];
      value = value[name];
      s.push(name, value);
    }

    for (var _i = 0; _i < value.length; ++_i) {
      if (_i in value) {
        s.push(_i, value[_i]); // If the callback needs to know the value of i, call
        // path.getName(), assuming path is the parameter name.

        callback(this);
        s.length -= 2;
      }
    }

    s.length = origLen;
  }; // Similar to FastPath.prototype.each, except that the results of the
  // callback function invocations are stored in an array and returned at
  // the end of the iteration.


  FastPath.prototype.map = function map(callback
  /*, name1, name2, ... */
  ) {
    var s = this.stack;
    var origLen = s.length;
    var value = s[origLen - 1];
    var argc = arguments.length;

    for (var i = 1; i < argc; ++i) {
      var name = arguments[i];
      value = value[name];
      s.push(name, value);
    }

    var result = new Array(value.length);

    for (var _i2 = 0; _i2 < value.length; ++_i2) {
      if (_i2 in value) {
        s.push(_i2, value[_i2]);
        result[_i2] = callback(this, _i2);
        s.length -= 2;
      }
    }

    s.length = origLen;
    return result;
  };

  var fastPath = FastPath;

  var normalize$2 = options$1.normalize;

  function printSubtree(path, print, options, printAstToDoc) {
    if (options.printer.embed) {
      return options.printer.embed(path, print, function (text, partialNextOptions) {
        return textToDoc(text, partialNextOptions, options, printAstToDoc);
      }, options);
    }
  }

  function textToDoc(text, partialNextOptions, parentOptions, printAstToDoc) {
    var nextOptions = normalize$2(Object.assign({}, parentOptions, partialNextOptions, {
      parentParser: parentOptions.parser,
      embeddedInHtml: !!(parentOptions.embeddedInHtml || parentOptions.parser === "html" || parentOptions.parser === "vue" || parentOptions.parser === "angular" || parentOptions.parser === "lwc"),
      originalText: text
    }), {
      passThrough: true
    });
    var result = parser.parse(text, nextOptions);
    var ast = result.ast;
    text = result.text;
    var astComments = ast.comments;
    delete ast.comments;
    comments.attach(astComments, ast, text, nextOptions);
    return printAstToDoc(ast, nextOptions);
  }

  var multiparser = {
    printSubtree: printSubtree
  };

  var doc$1 = doc;
  var docBuilders$1 = doc$1.builders;
  var concat$3 = docBuilders$1.concat;
  var hardline$2 = docBuilders$1.hardline;
  var addAlignmentToDoc$1 = docBuilders$1.addAlignmentToDoc;
  var docUtils$1 = doc$1.utils;
  /**
   * Takes an abstract syntax tree (AST) and recursively converts it to a
   * document (series of printing primitives).
   *
   * This is done by descending down the AST recursively. The recursion
   * involves two functions that call each other:
   *
   * 1. printGenerically(), which is defined as an inner function here.
   *    It basically takes care of node caching.
   * 2. callPluginPrintFunction(), which checks for some options, and
   *    ultimately calls the print() function provided by the plugin.
   *
   * The plugin function will call printGenerically() again for child nodes
   * of the current node, which will do its housekeeping, then call the
   * plugin function again, and so on.
   *
   * All the while, these functions pass a "path" variable around, which
   * is a stack-like data structure (FastPath) that maintains the current
   * state of the recursion. It is called "path", because it represents
   * the path to the current node through the Abstract Syntax Tree.
   */

  function printAstToDoc(ast, options) {
    var alignmentSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
    var printer = options.printer;

    if (printer.preprocess) {
      ast = printer.preprocess(ast, options);
    }

    var cache = new Map();

    function printGenerically(path, args) {
      var node = path.getValue();
      var shouldCache = node && _typeof(node) === "object" && args === undefined;

      if (shouldCache && cache.has(node)) {
        return cache.get(node);
      } // We let JSXElement print its comments itself because it adds () around
      // UnionTypeAnnotation has to align the child without the comments


      var res;

      if (printer.willPrintOwnComments && printer.willPrintOwnComments(path, options)) {
        res = callPluginPrintFunction(path, options, printGenerically, args);
      } else {
        // printComments will call the plugin print function and check for
        // comments to print
        res = comments.printComments(path, function (p) {
          return callPluginPrintFunction(p, options, printGenerically, args);
        }, options, args && args.needsSemi);
      }

      if (shouldCache) {
        cache.set(node, res);
      }

      return res;
    }

    var doc = printGenerically(new fastPath(ast));

    if (alignmentSize > 0) {
      // Add a hardline to make the indents take effect
      // It should be removed in index.js format()
      doc = addAlignmentToDoc$1(concat$3([hardline$2, doc]), alignmentSize, options.tabWidth);
    }

    docUtils$1.propagateBreaks(doc);
    return doc;
  }

  function callPluginPrintFunction(path, options, printPath, args) {
    assert.ok(path instanceof fastPath);
    var node = path.getValue();
    var printer = options.printer; // Escape hatch

    if (printer.hasPrettierIgnore && printer.hasPrettierIgnore(path)) {
      return options.originalText.slice(options.locStart(node), options.locEnd(node));
    }

    if (node) {
      try {
        // Potentially switch to a different parser
        var sub = multiparser.printSubtree(path, printPath, options, printAstToDoc);

        if (sub) {
          return sub;
        }
      } catch (error) {
        /* istanbul ignore if */
        if (commonjsGlobal.PRETTIER_DEBUG) {
          throw error;
        } // Continue with current parser

      }
    }

    return printer.print(path, options, printPath, args);
  }

  var astToDoc = printAstToDoc;

  function findSiblingAncestors(startNodeAndParents, endNodeAndParents, opts) {
    var resultStartNode = startNodeAndParents.node;
    var resultEndNode = endNodeAndParents.node;

    if (resultStartNode === resultEndNode) {
      return {
        startNode: resultStartNode,
        endNode: resultEndNode
      };
    }

    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = endNodeAndParents.parentNodes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var endParent = _step.value;

        if (endParent.type !== "Program" && endParent.type !== "File" && opts.locStart(endParent) >= opts.locStart(startNodeAndParents.node)) {
          resultEndNode = endParent;
        } else {
          break;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = startNodeAndParents.parentNodes[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var startParent = _step2.value;

        if (startParent.type !== "Program" && startParent.type !== "File" && opts.locEnd(startParent) <= opts.locEnd(endNodeAndParents.node)) {
          resultStartNode = startParent;
        } else {
          break;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return {
      startNode: resultStartNode,
      endNode: resultEndNode
    };
  }

  function findNodeAtOffset(node, offset, options, predicate, parentNodes) {
    predicate = predicate || function () {
      return true;
    };

    parentNodes = parentNodes || [];
    var start = options.locStart(node, options.locStart);
    var end = options.locEnd(node, options.locEnd);

    if (start <= offset && offset <= end) {
      var _iteratorNormalCompletion3 = true;
      var _didIteratorError3 = false;
      var _iteratorError3 = undefined;

      try {
        for (var _iterator3 = comments.getSortedChildNodes(node, options)[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {
          var childNode = _step3.value;
          var childResult = findNodeAtOffset(childNode, offset, options, predicate, [node].concat(parentNodes));

          if (childResult) {
            return childResult;
          }
        }
      } catch (err) {
        _didIteratorError3 = true;
        _iteratorError3 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion3 && _iterator3.return != null) {
            _iterator3.return();
          }
        } finally {
          if (_didIteratorError3) {
            throw _iteratorError3;
          }
        }
      }

      if (predicate(node)) {
        return {
          node: node,
          parentNodes: parentNodes
        };
      }
    }
  } // See https://www.ecma-international.org/ecma-262/5.1/#sec-A.5


  function isSourceElement(opts, node) {
    if (node == null) {
      return false;
    } // JS and JS like to avoid repetitions


    var jsSourceElements = ["FunctionDeclaration", "BlockStatement", "BreakStatement", "ContinueStatement", "DebuggerStatement", "DoWhileStatement", "EmptyStatement", "ExpressionStatement", "ForInStatement", "ForStatement", "IfStatement", "LabeledStatement", "ReturnStatement", "SwitchStatement", "ThrowStatement", "TryStatement", "VariableDeclaration", "WhileStatement", "WithStatement", "ClassDeclaration", // ES 2015
    "ImportDeclaration", // Module
    "ExportDefaultDeclaration", // Module
    "ExportNamedDeclaration", // Module
    "ExportAllDeclaration", // Module
    "TypeAlias", // Flow
    "InterfaceDeclaration", // Flow, TypeScript
    "TypeAliasDeclaration", // TypeScript
    "ExportAssignment", // TypeScript
    "ExportDeclaration" // TypeScript
    ];
    var jsonSourceElements = ["ObjectExpression", "ArrayExpression", "StringLiteral", "NumericLiteral", "BooleanLiteral", "NullLiteral"];
    var graphqlSourceElements = ["OperationDefinition", "FragmentDefinition", "VariableDefinition", "TypeExtensionDefinition", "ObjectTypeDefinition", "FieldDefinition", "DirectiveDefinition", "EnumTypeDefinition", "EnumValueDefinition", "InputValueDefinition", "InputObjectTypeDefinition", "SchemaDefinition", "OperationTypeDefinition", "InterfaceTypeDefinition", "UnionTypeDefinition", "ScalarTypeDefinition"];

    switch (opts.parser) {
      case "flow":
      case "babel":
      case "typescript":
        return jsSourceElements.indexOf(node.type) > -1;

      case "json":
        return jsonSourceElements.indexOf(node.type) > -1;

      case "graphql":
        return graphqlSourceElements.indexOf(node.kind) > -1;

      case "vue":
        return node.tag !== "root";
    }

    return false;
  }

  function calculateRange(text, opts, ast) {
    // Contract the range so that it has non-whitespace characters at its endpoints.
    // This ensures we can format a range that doesn't end on a node.
    var rangeStringOrig = text.slice(opts.rangeStart, opts.rangeEnd);
    var startNonWhitespace = Math.max(opts.rangeStart + rangeStringOrig.search(/\S/), opts.rangeStart);
    var endNonWhitespace;

    for (endNonWhitespace = opts.rangeEnd; endNonWhitespace > opts.rangeStart; --endNonWhitespace) {
      if (text[endNonWhitespace - 1].match(/\S/)) {
        break;
      }
    }

    var startNodeAndParents = findNodeAtOffset(ast, startNonWhitespace, opts, function (node) {
      return isSourceElement(opts, node);
    });
    var endNodeAndParents = findNodeAtOffset(ast, endNonWhitespace, opts, function (node) {
      return isSourceElement(opts, node);
    });

    if (!startNodeAndParents || !endNodeAndParents) {
      return {
        rangeStart: 0,
        rangeEnd: 0
      };
    }

    var siblingAncestors = findSiblingAncestors(startNodeAndParents, endNodeAndParents, opts);
    var startNode = siblingAncestors.startNode,
        endNode = siblingAncestors.endNode;
    var rangeStart = Math.min(opts.locStart(startNode, opts.locStart), opts.locStart(endNode, opts.locStart));
    var rangeEnd = Math.max(opts.locEnd(startNode, opts.locEnd), opts.locEnd(endNode, opts.locEnd));
    return {
      rangeStart: rangeStart,
      rangeEnd: rangeEnd
    };
  }

  var rangeUtil = {
    calculateRange: calculateRange,
    findNodeAtOffset: findNodeAtOffset
  };

  var diff = getCjsExportFromNamespace(index_es6);

  var normalizeOptions$1 = options$1.normalize;
  var guessEndOfLine$1 = endOfLine.guessEndOfLine,
      convertEndOfLineToChars$2 = endOfLine.convertEndOfLineToChars;
  var mapDoc$2 = doc.utils.mapDoc,
      _printDocToString = doc.printer.printDocToString,
      printDocToDebug = doc.debug.printDocToDebug;
  var UTF8BOM = 0xfeff;
  var CURSOR = Symbol("cursor");
  var PLACEHOLDERS = {
    cursorOffset: "<<<PRETTIER_CURSOR>>>",
    rangeStart: "<<<PRETTIER_RANGE_START>>>",
    rangeEnd: "<<<PRETTIER_RANGE_END>>>"
  };

  function ensureAllCommentsPrinted(astComments) {
    if (!astComments) {
      return;
    }

    for (var i = 0; i < astComments.length; ++i) {
      if (astComments[i].value.trim() === "prettier-ignore") {
        // If there's a prettier-ignore, we're not printing that sub-tree so we
        // don't know if the comments was printed or not.
        return;
      }
    }

    astComments.forEach(function (comment) {
      if (!comment.printed) {
        throw new Error('Comment "' + comment.value.trim() + '" was not printed. Please report this error!');
      }

      delete comment.printed;
    });
  }

  function attachComments(text, ast, opts) {
    var astComments = ast.comments;

    if (astComments) {
      delete ast.comments;
      comments.attach(astComments, ast, text, opts);
    }

    ast.tokens = [];
    opts.originalText = opts.parser === "yaml" ? text : text.trimRight();
    return astComments;
  }

  function coreFormat(text, opts, addAlignmentSize) {
    if (!text || !text.trim().length) {
      return {
        formatted: "",
        cursorOffset: 0
      };
    }

    addAlignmentSize = addAlignmentSize || 0;
    var parsed = parser.parse(text, opts);
    var ast = parsed.ast;
    text = parsed.text;

    if (opts.cursorOffset >= 0) {
      var nodeResult = rangeUtil.findNodeAtOffset(ast, opts.cursorOffset, opts);

      if (nodeResult && nodeResult.node) {
        opts.cursorNode = nodeResult.node;
      }
    }

    var astComments = attachComments(text, ast, opts);
    var doc = astToDoc(ast, opts, addAlignmentSize);
    var eol = convertEndOfLineToChars$2(opts.endOfLine);

    var result = _printDocToString(opts.endOfLine === "lf" ? doc : mapDoc$2(doc, function (currentDoc) {
      return typeof currentDoc === "string" && currentDoc.indexOf("\n") !== -1 ? currentDoc.replace(/\n/g, eol) : currentDoc;
    }), opts);

    ensureAllCommentsPrinted(astComments); // Remove extra leading indentation as well as the added indentation after last newline

    if (addAlignmentSize > 0) {
      var trimmed = result.formatted.trim();

      if (result.cursorNodeStart !== undefined) {
        result.cursorNodeStart -= result.formatted.indexOf(trimmed);
      }

      result.formatted = trimmed + convertEndOfLineToChars$2(opts.endOfLine);
    }

    if (opts.cursorOffset >= 0) {
      var oldCursorNodeStart;
      var oldCursorNodeText;
      var cursorOffsetRelativeToOldCursorNode;
      var newCursorNodeStart;
      var newCursorNodeText;

      if (opts.cursorNode && result.cursorNodeText) {
        oldCursorNodeStart = opts.locStart(opts.cursorNode);
        oldCursorNodeText = text.slice(oldCursorNodeStart, opts.locEnd(opts.cursorNode));
        cursorOffsetRelativeToOldCursorNode = opts.cursorOffset - oldCursorNodeStart;
        newCursorNodeStart = result.cursorNodeStart;
        newCursorNodeText = result.cursorNodeText;
      } else {
        oldCursorNodeStart = 0;
        oldCursorNodeText = text;
        cursorOffsetRelativeToOldCursorNode = opts.cursorOffset;
        newCursorNodeStart = 0;
        newCursorNodeText = result.formatted;
      }

      if (oldCursorNodeText === newCursorNodeText) {
        return {
          formatted: result.formatted,
          cursorOffset: newCursorNodeStart + cursorOffsetRelativeToOldCursorNode
        };
      } // diff old and new cursor node texts, with a special cursor
      // symbol inserted to find out where it moves to


      var oldCursorNodeCharArray = oldCursorNodeText.split("");
      oldCursorNodeCharArray.splice(cursorOffsetRelativeToOldCursorNode, 0, CURSOR);
      var newCursorNodeCharArray = newCursorNodeText.split("");
      var cursorNodeDiff = diff.diffArrays(oldCursorNodeCharArray, newCursorNodeCharArray);
      var cursorOffset = newCursorNodeStart;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = cursorNodeDiff[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var entry = _step.value;

          if (entry.removed) {
            if (entry.value.indexOf(CURSOR) > -1) {
              break;
            }
          } else {
            cursorOffset += entry.count;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return {
        formatted: result.formatted,
        cursorOffset: cursorOffset
      };
    }

    return {
      formatted: result.formatted
    };
  }

  function formatRange(text, opts) {
    var parsed = parser.parse(text, opts);
    var ast = parsed.ast;
    text = parsed.text;
    var range = rangeUtil.calculateRange(text, opts, ast);
    var rangeStart = range.rangeStart;
    var rangeEnd = range.rangeEnd;
    var rangeString = text.slice(rangeStart, rangeEnd); // Try to extend the range backwards to the beginning of the line.
    // This is so we can detect indentation correctly and restore it.
    // Use `Math.min` since `lastIndexOf` returns 0 when `rangeStart` is 0

    var rangeStart2 = Math.min(rangeStart, text.lastIndexOf("\n", rangeStart) + 1);
    var indentString = text.slice(rangeStart2, rangeStart);
    var alignmentSize = util.getAlignmentSize(indentString, opts.tabWidth);
    var rangeResult = coreFormat(rangeString, Object.assign({}, opts, {
      rangeStart: 0,
      rangeEnd: Infinity,
      // track the cursor offset only if it's within our range
      cursorOffset: opts.cursorOffset >= rangeStart && opts.cursorOffset < rangeEnd ? opts.cursorOffset - rangeStart : -1
    }), alignmentSize); // Since the range contracts to avoid trailing whitespace,
    // we need to remove the newline that was inserted by the `format` call.

    var rangeTrimmed = rangeResult.formatted.trimRight();
    var rangeLeft = text.slice(0, rangeStart);
    var rangeRight = text.slice(rangeEnd);
    var cursorOffset = opts.cursorOffset;

    if (opts.cursorOffset >= rangeEnd) {
      // handle the case where the cursor was past the end of the range
      cursorOffset = opts.cursorOffset - rangeEnd + (rangeStart + rangeTrimmed.length);
    } else if (rangeResult.cursorOffset !== undefined) {
      // handle the case where the cursor was in the range
      cursorOffset = rangeResult.cursorOffset + rangeStart;
    } // keep the cursor as it was if it was before the start of the range


    var formatted;

    if (opts.endOfLine === "lf") {
      formatted = rangeLeft + rangeTrimmed + rangeRight;
    } else {
      var eol = convertEndOfLineToChars$2(opts.endOfLine);

      if (cursorOffset >= 0) {
        var parts = [rangeLeft, rangeTrimmed, rangeRight];
        var partIndex = 0;
        var partOffset = cursorOffset;

        while (partIndex < parts.length) {
          var part = parts[partIndex];

          if (partOffset < part.length) {
            parts[partIndex] = parts[partIndex].slice(0, partOffset) + PLACEHOLDERS.cursorOffset + parts[partIndex].slice(partOffset);
            break;
          }

          partIndex++;
          partOffset -= part.length;
        }

        var newRangeLeft = parts[0],
            newRangeTrimmed = parts[1],
            newRangeRight = parts[2];
        formatted = (newRangeLeft.replace(/\n/g, eol) + newRangeTrimmed + newRangeRight.replace(/\n/g, eol)).replace(PLACEHOLDERS.cursorOffset, function (_, index) {
          cursorOffset = index;
          return "";
        });
      } else {
        formatted = rangeLeft.replace(/\n/g, eol) + rangeTrimmed + rangeRight.replace(/\n/g, eol);
      }
    }

    return {
      formatted: formatted,
      cursorOffset: cursorOffset
    };
  }

  function format(text, opts) {
    var selectedParser = parser.resolveParser(opts);
    var hasPragma = !selectedParser.hasPragma || selectedParser.hasPragma(text);

    if (opts.requirePragma && !hasPragma) {
      return {
        formatted: text
      };
    }

    if (opts.endOfLine === "auto") {
      opts.endOfLine = guessEndOfLine$1(text);
    }

    var hasCursor = opts.cursorOffset >= 0;
    var hasRangeStart = opts.rangeStart > 0;
    var hasRangeEnd = opts.rangeEnd < text.length; // get rid of CR/CRLF parsing

    if (text.indexOf("\r") !== -1) {
      var offsetKeys = [hasCursor && "cursorOffset", hasRangeStart && "rangeStart", hasRangeEnd && "rangeEnd"].filter(Boolean).sort(function (aKey, bKey) {
        return opts[aKey] - opts[bKey];
      });

      for (var i = offsetKeys.length - 1; i >= 0; i--) {
        var key = offsetKeys[i];
        text = text.slice(0, opts[key]) + PLACEHOLDERS[key] + text.slice(opts[key]);
      }

      text = text.replace(/\r\n?/g, "\n");

      var _loop = function _loop(_i) {
        var key = offsetKeys[_i];
        text = text.replace(PLACEHOLDERS[key], function (_, index) {
          opts[key] = index;
          return "";
        });
      };

      for (var _i = 0; _i < offsetKeys.length; _i++) {
        _loop(_i);
      }
    }

    var hasUnicodeBOM = text.charCodeAt(0) === UTF8BOM;

    if (hasUnicodeBOM) {
      text = text.substring(1);

      if (hasCursor) {
        opts.cursorOffset++;
      }

      if (hasRangeStart) {
        opts.rangeStart++;
      }

      if (hasRangeEnd) {
        opts.rangeEnd++;
      }
    }

    if (!hasCursor) {
      opts.cursorOffset = -1;
    }

    if (opts.rangeStart < 0) {
      opts.rangeStart = 0;
    }

    if (opts.rangeEnd > text.length) {
      opts.rangeEnd = text.length;
    }

    var result = hasRangeStart || hasRangeEnd ? formatRange(text, opts) : coreFormat(opts.insertPragma && opts.printer.insertPragma && !hasPragma ? opts.printer.insertPragma(text) : text, opts);

    if (hasUnicodeBOM) {
      result.formatted = String.fromCharCode(UTF8BOM) + result.formatted;

      if (hasCursor) {
        result.cursorOffset++;
      }
    }

    return result;
  }

  var core = {
    formatWithCursor: function formatWithCursor(text, opts) {
      opts = normalizeOptions$1(opts);
      return format(text, opts);
    },
    parse: function parse(text, opts, massage) {
      opts = normalizeOptions$1(opts);

      if (text.indexOf("\r") !== -1) {
        text = text.replace(/\r\n?/g, "\n");
      }

      var parsed = parser.parse(text, opts);

      if (massage) {
        parsed.ast = massageAst(parsed.ast, opts);
      }

      return parsed;
    },
    formatAST: function formatAST(ast, opts) {
      opts = normalizeOptions$1(opts);
      var doc = astToDoc(ast, opts);
      return _printDocToString(doc, opts);
    },
    // Doesn't handle shebang for now
    formatDoc: function formatDoc(doc, opts) {
      var debug = printDocToDebug(doc);
      opts = normalizeOptions$1(Object.assign({}, opts, {
        parser: "babel"
      }));
      return format(debug, opts).formatted;
    },
    printToDoc: function printToDoc(text, opts) {
      opts = normalizeOptions$1(opts);
      var parsed = parser.parse(text, opts);
      var ast = parsed.ast;
      text = parsed.text;
      attachComments(text, ast, opts);
      return astToDoc(ast, opts);
    },
    printDocToString: function printDocToString(doc, opts) {
      return _printDocToString(doc, normalizeOptions$1(opts));
    }
  };

  var index = [
  	"a",
  	"abbr",
  	"acronym",
  	"address",
  	"applet",
  	"area",
  	"article",
  	"aside",
  	"audio",
  	"b",
  	"base",
  	"basefont",
  	"bdi",
  	"bdo",
  	"bgsound",
  	"big",
  	"blink",
  	"blockquote",
  	"body",
  	"br",
  	"button",
  	"canvas",
  	"caption",
  	"center",
  	"cite",
  	"code",
  	"col",
  	"colgroup",
  	"command",
  	"content",
  	"data",
  	"datalist",
  	"dd",
  	"del",
  	"details",
  	"dfn",
  	"dialog",
  	"dir",
  	"div",
  	"dl",
  	"dt",
  	"element",
  	"em",
  	"embed",
  	"fieldset",
  	"figcaption",
  	"figure",
  	"font",
  	"footer",
  	"form",
  	"frame",
  	"frameset",
  	"h1",
  	"h2",
  	"h3",
  	"h4",
  	"h5",
  	"h6",
  	"head",
  	"header",
  	"hgroup",
  	"hr",
  	"html",
  	"i",
  	"iframe",
  	"image",
  	"img",
  	"input",
  	"ins",
  	"isindex",
  	"kbd",
  	"keygen",
  	"label",
  	"legend",
  	"li",
  	"link",
  	"listing",
  	"main",
  	"map",
  	"mark",
  	"marquee",
  	"math",
  	"menu",
  	"menuitem",
  	"meta",
  	"meter",
  	"multicol",
  	"nav",
  	"nextid",
  	"nobr",
  	"noembed",
  	"noframes",
  	"noscript",
  	"object",
  	"ol",
  	"optgroup",
  	"option",
  	"output",
  	"p",
  	"param",
  	"picture",
  	"plaintext",
  	"pre",
  	"progress",
  	"q",
  	"rb",
  	"rbc",
  	"rp",
  	"rt",
  	"rtc",
  	"ruby",
  	"s",
  	"samp",
  	"script",
  	"section",
  	"select",
  	"shadow",
  	"slot",
  	"small",
  	"source",
  	"spacer",
  	"span",
  	"strike",
  	"strong",
  	"style",
  	"sub",
  	"summary",
  	"sup",
  	"svg",
  	"table",
  	"tbody",
  	"td",
  	"template",
  	"textarea",
  	"tfoot",
  	"th",
  	"thead",
  	"time",
  	"title",
  	"tr",
  	"track",
  	"tt",
  	"u",
  	"ul",
  	"var",
  	"video",
  	"wbr",
  	"xmp"
  ];

  var htmlTagNames = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': index
  });

  var htmlTagNames$1 = getCjsExportFromNamespace(htmlTagNames);

  function clean(ast, newObj, parent) {
    ["raw", // front-matter
    "raws", "sourceIndex", "source", "before", "after", "trailingComma"].forEach(function (name) {
      delete newObj[name];
    });

    if (ast.type === "yaml") {
      delete newObj.value;
    } // --insert-pragma


    if (ast.type === "css-comment" && parent.type === "css-root" && parent.nodes.length !== 0 && ( // first non-front-matter comment
    parent.nodes[0] === ast || (parent.nodes[0].type === "yaml" || parent.nodes[0].type === "toml") && parent.nodes[1] === ast)) {
      /**
       * something
       *
       * @format
       */
      delete newObj.text; // standalone pragma

      if (/^\*\s*@(format|prettier)\s*$/.test(ast.text)) {
        return null;
      }
    }

    if (ast.type === "media-query" || ast.type === "media-query-list" || ast.type === "media-feature-expression") {
      delete newObj.value;
    }

    if (ast.type === "css-rule") {
      delete newObj.params;
    }

    if (ast.type === "selector-combinator") {
      newObj.value = newObj.value.replace(/\s+/g, " ");
    }

    if (ast.type === "media-feature") {
      newObj.value = newObj.value.replace(/ /g, "");
    }

    if (ast.type === "value-word" && (ast.isColor && ast.isHex || ["initial", "inherit", "unset", "revert"].indexOf(newObj.value.replace().toLowerCase()) !== -1) || ast.type === "media-feature" || ast.type === "selector-root-invalid" || ast.type === "selector-pseudo") {
      newObj.value = newObj.value.toLowerCase();
    }

    if (ast.type === "css-decl") {
      newObj.prop = newObj.prop.toLowerCase();
    }

    if (ast.type === "css-atrule" || ast.type === "css-import") {
      newObj.name = newObj.name.toLowerCase();
    }

    if (ast.type === "value-number") {
      newObj.unit = newObj.unit.toLowerCase();
    }

    if ((ast.type === "media-feature" || ast.type === "media-keyword" || ast.type === "media-type" || ast.type === "media-unknown" || ast.type === "media-url" || ast.type === "media-value" || ast.type === "selector-attribute" || ast.type === "selector-string" || ast.type === "selector-class" || ast.type === "selector-combinator" || ast.type === "value-string") && newObj.value) {
      newObj.value = cleanCSSStrings(newObj.value);
    }

    if (ast.type === "selector-attribute") {
      newObj.attribute = newObj.attribute.trim();

      if (newObj.namespace) {
        if (typeof newObj.namespace === "string") {
          newObj.namespace = newObj.namespace.trim();

          if (newObj.namespace.length === 0) {
            newObj.namespace = true;
          }
        }
      }

      if (newObj.value) {
        newObj.value = newObj.value.trim().replace(/^['"]|['"]$/g, "");
        delete newObj.quoted;
      }
    }

    if ((ast.type === "media-value" || ast.type === "media-type" || ast.type === "value-number" || ast.type === "selector-root-invalid" || ast.type === "selector-class" || ast.type === "selector-combinator" || ast.type === "selector-tag") && newObj.value) {
      newObj.value = newObj.value.replace(/([\d.eE+-]+)([a-zA-Z]*)/g, function (match, numStr, unit) {
        var num = Number(numStr);
        return isNaN(num) ? match : num + unit.toLowerCase();
      });
    }

    if (ast.type === "selector-tag") {
      var lowercasedValue = ast.value.toLowerCase();

      if (htmlTagNames$1.indexOf(lowercasedValue) !== -1) {
        newObj.value = lowercasedValue;
      }

      if (["from", "to"].indexOf(lowercasedValue) !== -1) {
        newObj.value = lowercasedValue;
      }
    } // Workaround when `postcss-values-parser` parse `not`, `and` or `or` keywords as `value-func`


    if (ast.type === "css-atrule" && ast.name.toLowerCase() === "supports") {
      delete newObj.value;
    } // Workaround for SCSS nested properties


    if (ast.type === "selector-unknown") {
      delete newObj.value;
    }
  }

  function cleanCSSStrings(value) {
    return value.replace(/'/g, '"').replace(/\\([^a-fA-F\d])/g, "$1");
  }

  var clean_1 = clean;

  var _require$$0$builders$1 = doc.builders,
      hardline$3 = _require$$0$builders$1.hardline,
      literalline$1 = _require$$0$builders$1.literalline,
      concat$4 = _require$$0$builders$1.concat,
      markAsRoot$1 = _require$$0$builders$1.markAsRoot,
      mapDoc$3 = doc.utils.mapDoc;

  function embed(path, print, textToDoc
  /*, options */
  ) {
    var node = path.getValue();

    if (node.type === "yaml") {
      return markAsRoot$1(concat$4(["---", hardline$3, node.value.trim() ? replaceNewlinesWithLiterallines(textToDoc(node.value, {
        parser: "yaml"
      })) : "", "---", hardline$3]));
    }

    return null;

    function replaceNewlinesWithLiterallines(doc) {
      return mapDoc$3(doc, function (currentDoc) {
        return typeof currentDoc === "string" && currentDoc.includes("\n") ? concat$4(currentDoc.split(/(\n)/g).map(function (v, i) {
          return i % 2 === 0 ? v : literalline$1;
        })) : currentDoc;
      });
    }
  }

  var embed_1 = embed;

  var detectNewline = createCommonjsModule(function (module) {

    module.exports = function (str) {
      if (typeof str !== 'string') {
        throw new TypeError('Expected a string');
      }

      var newlines = str.match(/(?:\r?\n)/g) || [];

      if (newlines.length === 0) {
        return null;
      }

      var crlf = newlines.filter(function (el) {
        return el === '\r\n';
      }).length;
      var lf = newlines.length - crlf;
      return crlf > lf ? '\r\n' : '\n';
    };

    module.exports.graceful = function (str) {
      return module.exports(str) || '\n';
    };
  });
  var detectNewline_1 = detectNewline.graceful;

  var build = createCommonjsModule(function (module, exports) {

    Object.defineProperty(exports, '__esModule', {
      value: true
    });
    exports.extract = extract;
    exports.strip = strip;
    exports.parse = parse;
    exports.parseWithComments = parseWithComments;
    exports.print = print;

    function _os() {
      var data = require$$0$1;

      _os = function _os() {
        return data;
      };

      return data;
    }

    function _detectNewline() {
      var data = _interopRequireDefault(detectNewline);

      _detectNewline = function _detectNewline() {
        return data;
      };

      return data;
    }

    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    /**
     * Copyright (c) Facebook, Inc. and its affiliates. All Rights Reserved.
     *
     * This source code is licensed under the MIT license found in the
     * LICENSE file in the root directory of this source tree.
     */


    var commentEndRe = /\*\/$/;
    var commentStartRe = /^\/\*\*/;
    var docblockRe = /^\s*(\/\*\*?(.|\r?\n)*?\*\/)/;
    var lineCommentRe = /(^|\s+)\/\/([^\r\n]*)/g;
    var ltrimNewlineRe = /^(\r?\n)+/;
    var multilineRe = /(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g;
    var propertyRe = /(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g;
    var stringStartRe = /(\r?\n|^) *\* ?/g;

    function extract(contents) {
      var match = contents.match(docblockRe);
      return match ? match[0].trimLeft() : '';
    }

    function strip(contents) {
      var match = contents.match(docblockRe);
      return match && match[0] ? contents.substring(match[0].length) : contents;
    }

    function parse(docblock) {
      return parseWithComments(docblock).pragmas;
    }

    function parseWithComments(docblock) {
      var line = (0, _detectNewline().default)(docblock) || _os().EOL;

      docblock = docblock.replace(commentStartRe, '').replace(commentEndRe, '').replace(stringStartRe, '$1'); // Normalize multi-line directives

      var prev = '';

      while (prev !== docblock) {
        prev = docblock;
        docblock = docblock.replace(multilineRe, "".concat(line, "$1 $2").concat(line));
      }

      docblock = docblock.replace(ltrimNewlineRe, '').trimRight();
      var result = Object.create(null);
      var comments = docblock.replace(propertyRe, '').replace(ltrimNewlineRe, '').trimRight();
      var match;

      while (match = propertyRe.exec(docblock)) {
        // strip linecomments from pragmas
        var nextPragma = match[2].replace(lineCommentRe, '');

        if (typeof result[match[1]] === 'string' || Array.isArray(result[match[1]])) {
          result[match[1]] = [].concat(result[match[1]], nextPragma);
        } else {
          result[match[1]] = nextPragma;
        }
      }

      return {
        comments: comments,
        pragmas: result
      };
    }

    function print(_ref) {
      var _ref$comments = _ref.comments,
          comments = _ref$comments === void 0 ? '' : _ref$comments,
          _ref$pragmas = _ref.pragmas,
          pragmas = _ref$pragmas === void 0 ? {} : _ref$pragmas;

      var line = (0, _detectNewline().default)(comments) || _os().EOL;

      var head = '/**';
      var start = ' *';
      var tail = ' */';
      var keys = Object.keys(pragmas);
      var printedObject = keys.map(function (key) {
        return printKeyValues(key, pragmas[key]);
      }).reduce(function (arr, next) {
        return arr.concat(next);
      }, []).map(function (keyValue) {
        return start + ' ' + keyValue + line;
      }).join('');

      if (!comments) {
        if (keys.length === 0) {
          return '';
        }

        if (keys.length === 1 && !Array.isArray(pragmas[keys[0]])) {
          var value = pragmas[keys[0]];
          return "".concat(head, " ").concat(printKeyValues(keys[0], value)[0]).concat(tail);
        }
      }

      var printedComments = comments.split(line).map(function (textLine) {
        return "".concat(start, " ").concat(textLine);
      }).join(line) + line;
      return head + line + (comments ? printedComments : '') + (comments && keys.length ? start + line : '') + printedObject + tail;
    }

    function printKeyValues(key, valueOrArray) {
      return [].concat(valueOrArray).map(function (value) {
        return "@".concat(key, " ").concat(value).trim();
      });
    }
  });
  unwrapExports(build);
  var build_1 = build.extract;
  var build_2 = build.strip;
  var build_3 = build.parse;
  var build_4 = build.parseWithComments;
  var build_5 = build.print;

  function hasPragma(text) {
    var pragmas = Object.keys(build.parse(build.extract(text)));
    return pragmas.indexOf("prettier") !== -1 || pragmas.indexOf("format") !== -1;
  }

  function insertPragma(text) {
    var parsedDocblock = build.parseWithComments(build.extract(text));
    var pragmas = Object.assign({
      format: ""
    }, parsedDocblock.pragmas);
    var newDocblock = build.print({
      pragmas: pragmas,
      comments: parsedDocblock.comments.replace(/^(\s+?\r?\n)+/, "") // remove leading newlines

    }).replace(/(\r\n|\r)/g, "\n"); // normalise newlines (mitigate use of os.EOL by jest-docblock)

    var strippedText = build.strip(text);
    var separatingNewlines = strippedText.startsWith("\n") ? "\n" : "\n\n";
    return newDocblock + separatingNewlines + strippedText;
  }

  var pragma = {
    hasPragma: hasPragma,
    insertPragma: insertPragma
  };

  var DELIMITER_MAP = {
    "---": "yaml",
    "+++": "toml"
  };

  function parse$1(text) {
    var delimiterRegex = Object.keys(DELIMITER_MAP).map(escapeStringRegexp).join("|");
    var match = text.match( // trailing spaces after delimiters are allowed
    new RegExp("^(".concat(delimiterRegex, ")[^\\n\\S]*\\n(?:([\\s\\S]*?)\\n)?\\1[^\\n\\S]*(\\n|$)")));

    if (match === null) {
      return {
        frontMatter: null,
        content: text
      };
    }

    var raw = match[0].replace(/\n$/, "");
    var delimiter = match[1];
    var value = match[2];
    return {
      frontMatter: {
        type: DELIMITER_MAP[delimiter],
        value: value,
        raw: raw
      },
      content: match[0].replace(/[^\n]/g, " ") + text.slice(match[0].length)
    };
  }

  var frontMatter = parse$1;

  function hasPragma$1(text) {
    return pragma.hasPragma(frontMatter(text).content);
  }

  function insertPragma$1(text) {
    var _parseFrontMatter = frontMatter(text),
        frontMatter$1 = _parseFrontMatter.frontMatter,
        content = _parseFrontMatter.content;

    return (frontMatter$1 ? frontMatter$1.raw + "\n\n" : "") + pragma.insertPragma(content);
  }

  var pragma$1 = {
    hasPragma: hasPragma$1,
    insertPragma: insertPragma$1
  };

  var colorAdjusterFunctions = ["red", "green", "blue", "alpha", "a", "rgb", "hue", "h", "saturation", "s", "lightness", "l", "whiteness", "w", "blackness", "b", "tint", "shade", "blend", "blenda", "contrast", "hsl", "hsla", "hwb", "hwba"];

  function getAncestorCounter(path, typeOrTypes) {
    var types = [].concat(typeOrTypes);
    var counter = -1;
    var ancestorNode;

    while (ancestorNode = path.getParentNode(++counter)) {
      if (types.indexOf(ancestorNode.type) !== -1) {
        return counter;
      }
    }

    return -1;
  }

  function getAncestorNode(path, typeOrTypes) {
    var counter = getAncestorCounter(path, typeOrTypes);
    return counter === -1 ? null : path.getParentNode(counter);
  }

  function getPropOfDeclNode(path) {
    var declAncestorNode = getAncestorNode(path, "css-decl");
    return declAncestorNode && declAncestorNode.prop && declAncestorNode.prop.toLowerCase();
  }

  function isSCSS(parser, text) {
    var hasExplicitParserChoice = parser === "less" || parser === "scss";
    var IS_POSSIBLY_SCSS = /(\w\s*: [^}:]+|#){|@import[^\n]+(url|,)/;
    return hasExplicitParserChoice ? parser === "scss" : IS_POSSIBLY_SCSS.test(text);
  }

  function isWideKeywords(value) {
    return ["initial", "inherit", "unset", "revert"].indexOf(value.toLowerCase()) !== -1;
  }

  function isKeyframeAtRuleKeywords(path, value) {
    var atRuleAncestorNode = getAncestorNode(path, "css-atrule");
    return atRuleAncestorNode && atRuleAncestorNode.name && atRuleAncestorNode.name.toLowerCase().endsWith("keyframes") && ["from", "to"].indexOf(value.toLowerCase()) !== -1;
  }

  function maybeToLowerCase(value) {
    return value.includes("$") || value.includes("@") || value.includes("#") || value.startsWith("%") || value.startsWith("--") || value.startsWith(":--") || value.includes("(") && value.includes(")") ? value : value.toLowerCase();
  }

  function insideValueFunctionNode(path, functionName) {
    var funcAncestorNode = getAncestorNode(path, "value-func");
    return funcAncestorNode && funcAncestorNode.value && funcAncestorNode.value.toLowerCase() === functionName;
  }

  function insideICSSRuleNode(path) {
    var ruleAncestorNode = getAncestorNode(path, "css-rule");
    return ruleAncestorNode && ruleAncestorNode.raws && ruleAncestorNode.raws.selector && (ruleAncestorNode.raws.selector.startsWith(":import") || ruleAncestorNode.raws.selector.startsWith(":export"));
  }

  function insideAtRuleNode(path, atRuleNameOrAtRuleNames) {
    var atRuleNames = [].concat(atRuleNameOrAtRuleNames);
    var atRuleAncestorNode = getAncestorNode(path, "css-atrule");
    return atRuleAncestorNode && atRuleNames.indexOf(atRuleAncestorNode.name.toLowerCase()) !== -1;
  }

  function insideURLFunctionInImportAtRuleNode(path) {
    var node = path.getValue();
    var atRuleAncestorNode = getAncestorNode(path, "css-atrule");
    return atRuleAncestorNode && atRuleAncestorNode.name === "import" && node.groups[0].value === "url" && node.groups.length === 2;
  }

  function isURLFunctionNode(node) {
    return node.type === "value-func" && node.value.toLowerCase() === "url";
  }

  function isLastNode(path, node) {
    var parentNode = path.getParentNode();

    if (!parentNode) {
      return false;
    }

    var nodes = parentNode.nodes;
    return nodes && nodes.indexOf(node) === nodes.length - 1;
  }

  function isHTMLTag(value) {
    return htmlTagNames$1.indexOf(value.toLowerCase()) !== -1;
  }

  function isDetachedRulesetDeclarationNode(node) {
    // If a Less file ends up being parsed with the SCSS parser, Less
    // variable declarations will be parsed as atrules with names ending
    // with a colon, so keep the original case then.
    if (!node.selector) {
      return false;
    }

    return typeof node.selector === "string" && /^@.+:.*$/.test(node.selector) || node.selector.value && /^@.+:.*$/.test(node.selector.value);
  }

  function isForKeywordNode(node) {
    return node.type === "value-word" && ["from", "through", "end"].indexOf(node.value) !== -1;
  }

  function isIfElseKeywordNode(node) {
    return node.type === "value-word" && ["and", "or", "not"].indexOf(node.value) !== -1;
  }

  function isEachKeywordNode(node) {
    return node.type === "value-word" && node.value === "in";
  }

  function isMultiplicationNode(node) {
    return node.type === "value-operator" && node.value === "*";
  }

  function isDivisionNode(node) {
    return node.type === "value-operator" && node.value === "/";
  }

  function isAdditionNode(node) {
    return node.type === "value-operator" && node.value === "+";
  }

  function isSubtractionNode(node) {
    return node.type === "value-operator" && node.value === "-";
  }

  function isModuloNode(node) {
    return node.type === "value-operator" && node.value === "%";
  }

  function isMathOperatorNode(node) {
    return isMultiplicationNode(node) || isDivisionNode(node) || isAdditionNode(node) || isSubtractionNode(node) || isModuloNode(node);
  }

  function isEqualityOperatorNode(node) {
    return node.type === "value-word" && ["==", "!="].indexOf(node.value) !== -1;
  }

  function isRelationalOperatorNode(node) {
    return node.type === "value-word" && ["<", ">", "<=", ">="].indexOf(node.value) !== -1;
  }

  function isSCSSControlDirectiveNode(node) {
    return node.type === "css-atrule" && ["if", "else", "for", "each", "while"].indexOf(node.name) !== -1;
  }

  function isSCSSNestedPropertyNode(node) {
    if (!node.selector) {
      return false;
    }

    return node.selector.replace(/\/\*.*?\*\//, "").replace(/\/\/.*?\n/, "").trim().endsWith(":");
  }

  function isDetachedRulesetCallNode(node) {
    return node.raws && node.raws.params && /^\(\s*\)$/.test(node.raws.params);
  }

  function isTemplatePlaceholderNode(node) {
    return node.name.startsWith("prettier-placeholder");
  }

  function isTemplatePropNode(node) {
    return node.prop.startsWith("@prettier-placeholder");
  }

  function isPostcssSimpleVarNode(currentNode, nextNode) {
    return currentNode.value === "$$" && currentNode.type === "value-func" && nextNode && nextNode.type === "value-word" && !nextNode.raws.before;
  }

  function hasComposesNode(node) {
    return node.value && node.value.type === "value-root" && node.value.group && node.value.group.type === "value-value" && node.prop.toLowerCase() === "composes";
  }

  function hasParensAroundNode(node) {
    return node.value && node.value.group && node.value.group.group && node.value.group.group.type === "value-paren_group" && node.value.group.group.open !== null && node.value.group.group.close !== null;
  }

  function hasEmptyRawBefore(node) {
    return node.raws && node.raws.before === "";
  }

  function isKeyValuePairNode(node) {
    return node.type === "value-comma_group" && node.groups && node.groups[1] && node.groups[1].type === "value-colon";
  }

  function isKeyValuePairInParenGroupNode(node) {
    return node.type === "value-paren_group" && node.groups && node.groups[0] && isKeyValuePairNode(node.groups[0]);
  }

  function isSCSSMapItemNode(path) {
    var node = path.getValue(); // Ignore empty item (i.e. `$key: ()`)

    if (node.groups.length === 0) {
      return false;
    }

    var parentParentNode = path.getParentNode(1); // Check open parens contain key/value pair (i.e. `(key: value)` and `(key: (value, other-value)`)

    if (!isKeyValuePairInParenGroupNode(node) && !(parentParentNode && isKeyValuePairInParenGroupNode(parentParentNode))) {
      return false;
    }

    var declNode = getAncestorNode(path, "css-decl"); // SCSS map declaration (i.e. `$map: (key: value, other-key: other-value)`)

    if (declNode && declNode.prop && declNode.prop.startsWith("$")) {
      return true;
    } // List as value of key inside SCSS map (i.e. `$map: (key: (value other-value other-other-value))`)


    if (isKeyValuePairInParenGroupNode(parentParentNode)) {
      return true;
    } // SCSS Map is argument of function (i.e. `func((key: value, other-key: other-value))`)


    if (parentParentNode.type === "value-func") {
      return true;
    }

    return false;
  }

  function isInlineValueCommentNode(node) {
    return node.type === "value-comment" && node.inline;
  }

  function isHashNode(node) {
    return node.type === "value-word" && node.value === "#";
  }

  function isLeftCurlyBraceNode(node) {
    return node.type === "value-word" && node.value === "{";
  }

  function isRightCurlyBraceNode(node) {
    return node.type === "value-word" && node.value === "}";
  }

  function isWordNode(node) {
    return ["value-word", "value-atword"].indexOf(node.type) !== -1;
  }

  function isColonNode(node) {
    return node.type === "value-colon";
  }

  function isMediaAndSupportsKeywords(node) {
    return node.value && ["not", "and", "or"].indexOf(node.value.toLowerCase()) !== -1;
  }

  function isColorAdjusterFuncNode(node) {
    if (node.type !== "value-func") {
      return false;
    }

    return colorAdjusterFunctions.indexOf(node.value.toLowerCase()) !== -1;
  }

  var utils$2 = {
    getAncestorCounter: getAncestorCounter,
    getAncestorNode: getAncestorNode,
    getPropOfDeclNode: getPropOfDeclNode,
    maybeToLowerCase: maybeToLowerCase,
    insideValueFunctionNode: insideValueFunctionNode,
    insideICSSRuleNode: insideICSSRuleNode,
    insideAtRuleNode: insideAtRuleNode,
    insideURLFunctionInImportAtRuleNode: insideURLFunctionInImportAtRuleNode,
    isKeyframeAtRuleKeywords: isKeyframeAtRuleKeywords,
    isHTMLTag: isHTMLTag,
    isWideKeywords: isWideKeywords,
    isSCSS: isSCSS,
    isLastNode: isLastNode,
    isSCSSControlDirectiveNode: isSCSSControlDirectiveNode,
    isDetachedRulesetDeclarationNode: isDetachedRulesetDeclarationNode,
    isRelationalOperatorNode: isRelationalOperatorNode,
    isEqualityOperatorNode: isEqualityOperatorNode,
    isMultiplicationNode: isMultiplicationNode,
    isDivisionNode: isDivisionNode,
    isAdditionNode: isAdditionNode,
    isSubtractionNode: isSubtractionNode,
    isModuloNode: isModuloNode,
    isMathOperatorNode: isMathOperatorNode,
    isEachKeywordNode: isEachKeywordNode,
    isForKeywordNode: isForKeywordNode,
    isURLFunctionNode: isURLFunctionNode,
    isIfElseKeywordNode: isIfElseKeywordNode,
    hasComposesNode: hasComposesNode,
    hasParensAroundNode: hasParensAroundNode,
    hasEmptyRawBefore: hasEmptyRawBefore,
    isSCSSNestedPropertyNode: isSCSSNestedPropertyNode,
    isDetachedRulesetCallNode: isDetachedRulesetCallNode,
    isTemplatePlaceholderNode: isTemplatePlaceholderNode,
    isTemplatePropNode: isTemplatePropNode,
    isPostcssSimpleVarNode: isPostcssSimpleVarNode,
    isKeyValuePairNode: isKeyValuePairNode,
    isKeyValuePairInParenGroupNode: isKeyValuePairInParenGroupNode,
    isSCSSMapItemNode: isSCSSMapItemNode,
    isInlineValueCommentNode: isInlineValueCommentNode,
    isHashNode: isHashNode,
    isLeftCurlyBraceNode: isLeftCurlyBraceNode,
    isRightCurlyBraceNode: isRightCurlyBraceNode,
    isWordNode: isWordNode,
    isColonNode: isColonNode,
    isMediaAndSupportsKeywords: isMediaAndSupportsKeywords,
    isColorAdjusterFuncNode: isColorAdjusterFuncNode
  };

  var insertPragma$2 = pragma$1.insertPragma;
  var printNumber$1 = util.printNumber,
      printString$1 = util.printString,
      hasIgnoreComment$1 = util.hasIgnoreComment,
      hasNewline$2 = util.hasNewline;
  var isNextLineEmpty$2 = utilShared.isNextLineEmpty;
  var _require$$3$builders = doc.builders,
      concat$5 = _require$$3$builders.concat,
      join$2 = _require$$3$builders.join,
      line$1 = _require$$3$builders.line,
      hardline$4 = _require$$3$builders.hardline,
      softline$1 = _require$$3$builders.softline,
      group$1 = _require$$3$builders.group,
      fill$2 = _require$$3$builders.fill,
      indent$2 = _require$$3$builders.indent,
      dedent$1 = _require$$3$builders.dedent,
      ifBreak$1 = _require$$3$builders.ifBreak,
      removeLines$1 = doc.utils.removeLines;
  var getAncestorNode$1 = utils$2.getAncestorNode,
      getPropOfDeclNode$1 = utils$2.getPropOfDeclNode,
      maybeToLowerCase$1 = utils$2.maybeToLowerCase,
      insideValueFunctionNode$1 = utils$2.insideValueFunctionNode,
      insideICSSRuleNode$1 = utils$2.insideICSSRuleNode,
      insideAtRuleNode$1 = utils$2.insideAtRuleNode,
      insideURLFunctionInImportAtRuleNode$1 = utils$2.insideURLFunctionInImportAtRuleNode,
      isKeyframeAtRuleKeywords$1 = utils$2.isKeyframeAtRuleKeywords,
      isHTMLTag$1 = utils$2.isHTMLTag,
      isWideKeywords$1 = utils$2.isWideKeywords,
      isSCSS$1 = utils$2.isSCSS,
      isLastNode$1 = utils$2.isLastNode,
      isSCSSControlDirectiveNode$1 = utils$2.isSCSSControlDirectiveNode,
      isDetachedRulesetDeclarationNode$1 = utils$2.isDetachedRulesetDeclarationNode,
      isRelationalOperatorNode$1 = utils$2.isRelationalOperatorNode,
      isEqualityOperatorNode$1 = utils$2.isEqualityOperatorNode,
      isMultiplicationNode$1 = utils$2.isMultiplicationNode,
      isDivisionNode$1 = utils$2.isDivisionNode,
      isAdditionNode$1 = utils$2.isAdditionNode,
      isSubtractionNode$1 = utils$2.isSubtractionNode,
      isMathOperatorNode$1 = utils$2.isMathOperatorNode,
      isEachKeywordNode$1 = utils$2.isEachKeywordNode,
      isForKeywordNode$1 = utils$2.isForKeywordNode,
      isURLFunctionNode$1 = utils$2.isURLFunctionNode,
      isIfElseKeywordNode$1 = utils$2.isIfElseKeywordNode,
      hasComposesNode$1 = utils$2.hasComposesNode,
      hasParensAroundNode$1 = utils$2.hasParensAroundNode,
      hasEmptyRawBefore$1 = utils$2.hasEmptyRawBefore,
      isKeyValuePairNode$1 = utils$2.isKeyValuePairNode,
      isDetachedRulesetCallNode$1 = utils$2.isDetachedRulesetCallNode,
      isTemplatePlaceholderNode$1 = utils$2.isTemplatePlaceholderNode,
      isTemplatePropNode$1 = utils$2.isTemplatePropNode,
      isPostcssSimpleVarNode$1 = utils$2.isPostcssSimpleVarNode,
      isSCSSMapItemNode$1 = utils$2.isSCSSMapItemNode,
      isInlineValueCommentNode$1 = utils$2.isInlineValueCommentNode,
      isHashNode$1 = utils$2.isHashNode,
      isLeftCurlyBraceNode$1 = utils$2.isLeftCurlyBraceNode,
      isRightCurlyBraceNode$1 = utils$2.isRightCurlyBraceNode,
      isWordNode$1 = utils$2.isWordNode,
      isColonNode$1 = utils$2.isColonNode,
      isMediaAndSupportsKeywords$1 = utils$2.isMediaAndSupportsKeywords,
      isColorAdjusterFuncNode$1 = utils$2.isColorAdjusterFuncNode;

  function shouldPrintComma(options) {
    switch (options.trailingComma) {
      case "all":
      case "es5":
        return true;

      case "none":
      default:
        return false;
    }
  }

  function genericPrint(path, options, print) {
    var node = path.getValue();
    /* istanbul ignore if */

    if (!node) {
      return "";
    }

    if (typeof node === "string") {
      return node;
    }

    switch (node.type) {
      case "yaml":
      case "toml":
        return concat$5([node.raw, hardline$4]);

      case "css-root":
        {
          var nodes = printNodeSequence(path, options, print);

          if (nodes.parts.length) {
            return concat$5([nodes, hardline$4]);
          }

          return nodes;
        }

      case "css-comment":
        {
          if (node.raws.content) {
            return node.raws.content;
          }

          var text = options.originalText.slice(options.locStart(node), options.locEnd(node));
          var rawText = node.raws.text || node.text; // Workaround a bug where the location is off.
          // https://github.com/postcss/postcss-scss/issues/63

          if (text.indexOf(rawText) === -1) {
            if (node.raws.inline) {
              return concat$5(["// ", rawText]);
            }

            return concat$5(["/* ", rawText, " */"]);
          }

          return text;
        }

      case "css-rule":
        {
          return concat$5([path.call(print, "selector"), node.important ? " !important" : "", node.nodes ? concat$5([" {", node.nodes.length > 0 ? indent$2(concat$5([hardline$4, printNodeSequence(path, options, print)])) : "", hardline$4, "}", isDetachedRulesetDeclarationNode$1(node) ? ";" : ""]) : ";"]);
        }

      case "css-decl":
        {
          var parentNode = path.getParentNode();
          return concat$5([node.raws.before.replace(/[\s;]/g, ""), insideICSSRuleNode$1(path) ? node.prop : maybeToLowerCase$1(node.prop), node.raws.between.trim() === ":" ? ":" : node.raws.between.trim(), node.extend ? "" : " ", hasComposesNode$1(node) ? removeLines$1(path.call(print, "value")) : path.call(print, "value"), node.raws.important ? node.raws.important.replace(/\s*!\s*important/i, " !important") : node.important ? " !important" : "", node.raws.scssDefault ? node.raws.scssDefault.replace(/\s*!default/i, " !default") : node.scssDefault ? " !default" : "", node.raws.scssGlobal ? node.raws.scssGlobal.replace(/\s*!global/i, " !global") : node.scssGlobal ? " !global" : "", node.nodes ? concat$5([" {", indent$2(concat$5([softline$1, printNodeSequence(path, options, print)])), softline$1, "}"]) : isTemplatePropNode$1(node) && !parentNode.raws.semicolon && options.originalText[options.locEnd(node) - 1] !== ";" ? "" : ";"]);
        }

      case "css-atrule":
        {
          var _parentNode = path.getParentNode();

          return concat$5(["@", // If a Less file ends up being parsed with the SCSS parser, Less
          // variable declarations will be parsed as at-rules with names ending
          // with a colon, so keep the original case then.
          isDetachedRulesetCallNode$1(node) || node.name.endsWith(":") ? node.name : maybeToLowerCase$1(node.name), node.params ? concat$5([isDetachedRulesetCallNode$1(node) ? "" : isTemplatePlaceholderNode$1(node) && /^\s*\n/.test(node.raws.afterName) ? /^\s*\n\s*\n/.test(node.raws.afterName) ? concat$5([hardline$4, hardline$4]) : hardline$4 : " ", path.call(print, "params")]) : "", node.selector ? indent$2(concat$5([" ", path.call(print, "selector")])) : "", node.value ? group$1(concat$5([" ", path.call(print, "value"), isSCSSControlDirectiveNode$1(node) ? hasParensAroundNode$1(node) ? " " : line$1 : ""])) : node.name === "else" ? " " : "", node.nodes ? concat$5([isSCSSControlDirectiveNode$1(node) ? "" : " ", "{", indent$2(concat$5([node.nodes.length > 0 ? softline$1 : "", printNodeSequence(path, options, print)])), softline$1, "}"]) : isTemplatePlaceholderNode$1(node) && !_parentNode.raws.semicolon && options.originalText[options.locEnd(node) - 1] !== ";" ? "" : ";"]);
        }
      // postcss-media-query-parser

      case "media-query-list":
        {
          var parts = [];
          path.each(function (childPath) {
            var node = childPath.getValue();

            if (node.type === "media-query" && node.value === "") {
              return;
            }

            parts.push(childPath.call(print));
          }, "nodes");
          return group$1(indent$2(join$2(line$1, parts)));
        }

      case "media-query":
        {
          return concat$5([join$2(" ", path.map(print, "nodes")), isLastNode$1(path, node) ? "" : ","]);
        }

      case "media-type":
        {
          return adjustNumbers(adjustStrings(node.value, options));
        }

      case "media-feature-expression":
        {
          if (!node.nodes) {
            return node.value;
          }

          return concat$5(["(", concat$5(path.map(print, "nodes")), ")"]);
        }

      case "media-feature":
        {
          return maybeToLowerCase$1(adjustStrings(node.value.replace(/ +/g, " "), options));
        }

      case "media-colon":
        {
          return concat$5([node.value, " "]);
        }

      case "media-value":
        {
          return adjustNumbers(adjustStrings(node.value, options));
        }

      case "media-keyword":
        {
          return adjustStrings(node.value, options);
        }

      case "media-url":
        {
          return adjustStrings(node.value.replace(/^url\(\s+/gi, "url(").replace(/\s+\)$/gi, ")"), options);
        }

      case "media-unknown":
        {
          return node.value;
        }
      // postcss-selector-parser

      case "selector-root":
        {
          return group$1(concat$5([insideAtRuleNode$1(path, "custom-selector") ? concat$5([getAncestorNode$1(path, "css-atrule").customSelector, line$1]) : "", join$2(concat$5([",", insideAtRuleNode$1(path, ["extend", "custom-selector", "nest"]) ? line$1 : hardline$4]), path.map(print, "nodes"))]));
        }

      case "selector-selector":
        {
          return group$1(indent$2(concat$5(path.map(print, "nodes"))));
        }

      case "selector-comment":
        {
          return node.value;
        }

      case "selector-string":
        {
          return adjustStrings(node.value, options);
        }

      case "selector-tag":
        {
          var _parentNode2 = path.getParentNode();

          var index = _parentNode2 && _parentNode2.nodes.indexOf(node);

          var prevNode = index && _parentNode2.nodes[index - 1];
          return concat$5([node.namespace ? concat$5([node.namespace === true ? "" : node.namespace.trim(), "|"]) : "", prevNode.type === "selector-nesting" ? node.value : adjustNumbers(isHTMLTag$1(node.value) || isKeyframeAtRuleKeywords$1(path, node.value) ? node.value.toLowerCase() : node.value)]);
        }

      case "selector-id":
        {
          return concat$5(["#", node.value]);
        }

      case "selector-class":
        {
          return concat$5([".", adjustNumbers(adjustStrings(node.value, options))]);
        }

      case "selector-attribute":
        {
          return concat$5(["[", node.namespace ? concat$5([node.namespace === true ? "" : node.namespace.trim(), "|"]) : "", node.attribute.trim(), node.operator ? node.operator : "", node.value ? quoteAttributeValue(adjustStrings(node.value.trim(), options), options) : "", node.insensitive ? " i" : "", "]"]);
        }

      case "selector-combinator":
        {
          if (node.value === "+" || node.value === ">" || node.value === "~" || node.value === ">>>") {
            var _parentNode3 = path.getParentNode();

            var _leading = _parentNode3.type === "selector-selector" && _parentNode3.nodes[0] === node ? "" : line$1;

            return concat$5([_leading, node.value, isLastNode$1(path, node) ? "" : " "]);
          }

          var leading = node.value.trim().startsWith("(") ? line$1 : "";
          var value = adjustNumbers(adjustStrings(node.value.trim(), options)) || line$1;
          return concat$5([leading, value]);
        }

      case "selector-universal":
        {
          return concat$5([node.namespace ? concat$5([node.namespace === true ? "" : node.namespace.trim(), "|"]) : "", node.value]);
        }

      case "selector-pseudo":
        {
          return concat$5([maybeToLowerCase$1(node.value), node.nodes && node.nodes.length > 0 ? concat$5(["(", join$2(", ", path.map(print, "nodes")), ")"]) : ""]);
        }

      case "selector-nesting":
        {
          return node.value;
        }

      case "selector-unknown":
        {
          var ruleAncestorNode = getAncestorNode$1(path, "css-rule"); // Nested SCSS property

          if (ruleAncestorNode && ruleAncestorNode.isSCSSNesterProperty) {
            return adjustNumbers(adjustStrings(maybeToLowerCase$1(node.value), options));
          }

          return node.value;
        }
      // postcss-values-parser

      case "value-value":
      case "value-root":
        {
          return path.call(print, "group");
        }

      case "value-comment":
        {
          return concat$5([node.inline ? "//" : "/*", node.value, node.inline ? "" : "*/"]);
        }

      case "value-comma_group":
        {
          var _parentNode4 = path.getParentNode();

          var parentParentNode = path.getParentNode(1);
          var declAncestorProp = getPropOfDeclNode$1(path);
          var isGridValue = declAncestorProp && _parentNode4.type === "value-value" && (declAncestorProp === "grid" || declAncestorProp.startsWith("grid-template"));
          var atRuleAncestorNode = getAncestorNode$1(path, "css-atrule");
          var isControlDirective = atRuleAncestorNode && isSCSSControlDirectiveNode$1(atRuleAncestorNode);
          var printed = path.map(print, "groups");
          var _parts = [];
          var insideURLFunction = insideValueFunctionNode$1(path, "url");
          var insideSCSSInterpolationInString = false;
          var didBreak = false;

          for (var i = 0; i < node.groups.length; ++i) {
            _parts.push(printed[i]); // Ignore value inside `url()`


            if (insideURLFunction) {
              continue;
            }

            var iPrevNode = node.groups[i - 1];
            var iNode = node.groups[i];
            var iNextNode = node.groups[i + 1];
            var iNextNextNode = node.groups[i + 2]; // Ignore after latest node (i.e. before semicolon)

            if (!iNextNode) {
              continue;
            } // Ignore spaces before/after string interpolation (i.e. `"#{my-fn("_")}"`)


            var isStartSCSSInterpolationInString = iNode.type === "value-string" && iNode.value.startsWith("#{");
            var isEndingSCSSInterpolationInString = insideSCSSInterpolationInString && iNextNode.type === "value-string" && iNextNode.value.endsWith("}");

            if (isStartSCSSInterpolationInString || isEndingSCSSInterpolationInString) {
              insideSCSSInterpolationInString = !insideSCSSInterpolationInString;
              continue;
            }

            if (insideSCSSInterpolationInString) {
              continue;
            } // Ignore colon (i.e. `:`)


            if (isColonNode$1(iNode) || isColonNode$1(iNextNode)) {
              continue;
            } // Ignore `@` in Less (i.e. `@@var;`)


            if (iNode.type === "value-atword" && iNode.value === "") {
              continue;
            } // Ignore `~` in Less (i.e. `content: ~"^//* some horrible but needed css hack";`)


            if (iNode.value === "~") {
              continue;
            } // Ignore escape `\`


            if (iNode.value && iNode.value.indexOf("\\") !== -1 && iNextNode && iNextNode.type !== "value-comment") {
              continue;
            } // Ignore escaped `/`


            if (iPrevNode && iPrevNode.value && iPrevNode.value.indexOf("\\") === iPrevNode.value.length - 1 && iNode.type === "value-operator" && iNode.value === "/") {
              continue;
            } // Ignore `\` (i.e. `$variable: \@small;`)


            if (iNode.value === "\\") {
              continue;
            } // Ignore `$$` (i.e. `background-color: $$(style)Color;`)


            if (isPostcssSimpleVarNode$1(iNode, iNextNode)) {
              continue;
            } // Ignore spaces after `#` and after `{` and before `}` in SCSS interpolation (i.e. `#{variable}`)


            if (isHashNode$1(iNode) || isLeftCurlyBraceNode$1(iNode) || isRightCurlyBraceNode$1(iNextNode) || isLeftCurlyBraceNode$1(iNextNode) && hasEmptyRawBefore$1(iNextNode) || isRightCurlyBraceNode$1(iNode) && hasEmptyRawBefore$1(iNextNode)) {
              continue;
            } // Ignore css variables and interpolation in SCSS (i.e. `--#{$var}`)


            if (iNode.value === "--" && isHashNode$1(iNextNode)) {
              continue;
            } // Formatting math operations


            var isMathOperator = isMathOperatorNode$1(iNode);
            var isNextMathOperator = isMathOperatorNode$1(iNextNode); // Print spaces before and after math operators beside SCSS interpolation as is
            // (i.e. `#{$var}+5`, `#{$var} +5`, `#{$var}+ 5`, `#{$var} + 5`)
            // (i.e. `5+#{$var}`, `5 +#{$var}`, `5+ #{$var}`, `5 + #{$var}`)

            if ((isMathOperator && isHashNode$1(iNextNode) || isNextMathOperator && isRightCurlyBraceNode$1(iNode)) && hasEmptyRawBefore$1(iNextNode)) {
              continue;
            } // Print spaces before and after addition and subtraction math operators as is in `calc` function
            // due to the fact that it is not valid syntax
            // (i.e. `calc(1px+1px)`, `calc(1px+ 1px)`, `calc(1px +1px)`, `calc(1px + 1px)`)


            if (insideValueFunctionNode$1(path, "calc") && (isAdditionNode$1(iNode) || isAdditionNode$1(iNextNode) || isSubtractionNode$1(iNode) || isSubtractionNode$1(iNextNode)) && hasEmptyRawBefore$1(iNextNode)) {
              continue;
            } // Print spaces after `+` and `-` in color adjuster functions as is (e.g. `color(red l(+ 20%))`)
            // Adjusters with signed numbers (e.g. `color(red l(+20%))`) output as-is.


            var isColorAdjusterNode = (isAdditionNode$1(iNode) || isSubtractionNode$1(iNode)) && i === 0 && (iNextNode.type === "value-number" || iNextNode.isHex) && parentParentNode && isColorAdjusterFuncNode$1(parentParentNode) && !hasEmptyRawBefore$1(iNextNode);
            var requireSpaceBeforeOperator = iNextNextNode && iNextNextNode.type === "value-func" || iNextNextNode && isWordNode$1(iNextNextNode) || iNode.type === "value-func" || isWordNode$1(iNode);
            var requireSpaceAfterOperator = iNextNode.type === "value-func" || isWordNode$1(iNextNode) || iPrevNode && iPrevNode.type === "value-func" || iPrevNode && isWordNode$1(iPrevNode); // Formatting `/`, `+`, `-` sign

            if (!(isMultiplicationNode$1(iNextNode) || isMultiplicationNode$1(iNode)) && !insideValueFunctionNode$1(path, "calc") && !isColorAdjusterNode && (isDivisionNode$1(iNextNode) && !requireSpaceBeforeOperator || isDivisionNode$1(iNode) && !requireSpaceAfterOperator || isAdditionNode$1(iNextNode) && !requireSpaceBeforeOperator || isAdditionNode$1(iNode) && !requireSpaceAfterOperator || isSubtractionNode$1(iNextNode) || isSubtractionNode$1(iNode)) && (hasEmptyRawBefore$1(iNextNode) || isMathOperator && (!iPrevNode || iPrevNode && isMathOperatorNode$1(iPrevNode)))) {
              continue;
            } // Add `hardline` after inline comment (i.e. `// comment\n foo: bar;`)


            if (isInlineValueCommentNode$1(iNode)) {
              _parts.push(hardline$4);

              continue;
            } // Handle keywords in SCSS control directive


            if (isControlDirective && (isEqualityOperatorNode$1(iNextNode) || isRelationalOperatorNode$1(iNextNode) || isIfElseKeywordNode$1(iNextNode) || isEachKeywordNode$1(iNode) || isForKeywordNode$1(iNode))) {
              _parts.push(" ");

              continue;
            } // At-rule `namespace` should be in one line


            if (atRuleAncestorNode && atRuleAncestorNode.name.toLowerCase() === "namespace") {
              _parts.push(" ");

              continue;
            } // Formatting `grid` property


            if (isGridValue) {
              if (iNode.source && iNextNode.source && iNode.source.start.line !== iNextNode.source.start.line) {
                _parts.push(hardline$4);

                didBreak = true;
              } else {
                _parts.push(" ");
              }

              continue;
            } // Add `space` before next math operation
            // Note: `grip` property have `/` delimiter and it is not math operation, so
            // `grid` property handles above


            if (isNextMathOperator) {
              _parts.push(" ");

              continue;
            } // Be default all values go through `line`


            _parts.push(line$1);
          }

          if (didBreak) {
            _parts.unshift(hardline$4);
          }

          if (isControlDirective) {
            return group$1(indent$2(concat$5(_parts)));
          } // Indent is not needed for import url when url is very long
          // and node has two groups
          // when type is value-comma_group
          // example @import url("verylongurl") projection,tv


          if (insideURLFunctionInImportAtRuleNode$1(path)) {
            return group$1(fill$2(_parts));
          }

          return group$1(indent$2(fill$2(_parts)));
        }

      case "value-paren_group":
        {
          var _parentNode5 = path.getParentNode();

          if (_parentNode5 && isURLFunctionNode$1(_parentNode5) && (node.groups.length === 1 || node.groups.length > 0 && node.groups[0].type === "value-comma_group" && node.groups[0].groups.length > 0 && node.groups[0].groups[0].type === "value-word" && node.groups[0].groups[0].value.startsWith("data:"))) {
            return concat$5([node.open ? path.call(print, "open") : "", join$2(",", path.map(print, "groups")), node.close ? path.call(print, "close") : ""]);
          }

          if (!node.open) {
            var _printed = path.map(print, "groups");

            var res = [];

            for (var _i = 0; _i < _printed.length; _i++) {
              if (_i !== 0) {
                res.push(concat$5([",", line$1]));
              }

              res.push(_printed[_i]);
            }

            return group$1(indent$2(fill$2(res)));
          }

          var isSCSSMapItem = isSCSSMapItemNode$1(path);
          return group$1(concat$5([node.open ? path.call(print, "open") : "", indent$2(concat$5([softline$1, join$2(concat$5([",", line$1]), path.map(function (childPath) {
            var node = childPath.getValue();
            var printed = print(childPath); // Key/Value pair in open paren already indented

            if (isKeyValuePairNode$1(node) && node.type === "value-comma_group" && node.groups && node.groups[2] && node.groups[2].type === "value-paren_group") {
              printed.contents.contents.parts[1] = group$1(printed.contents.contents.parts[1]);
              return group$1(dedent$1(printed));
            }

            return printed;
          }, "groups"))])), ifBreak$1(isSCSS$1(options.parser, options.originalText) && isSCSSMapItem && shouldPrintComma(options) ? "," : ""), softline$1, node.close ? path.call(print, "close") : ""]), {
            shouldBreak: isSCSSMapItem
          });
        }

      case "value-func":
        {
          return concat$5([node.value, insideAtRuleNode$1(path, "supports") && isMediaAndSupportsKeywords$1(node) ? " " : "", path.call(print, "group")]);
        }

      case "value-paren":
        {
          return node.value;
        }

      case "value-number":
        {
          return concat$5([printCssNumber(node.value), maybeToLowerCase$1(node.unit)]);
        }

      case "value-operator":
        {
          return node.value;
        }

      case "value-word":
        {
          if (node.isColor && node.isHex || isWideKeywords$1(node.value)) {
            return node.value.toLowerCase();
          }

          return node.value;
        }

      case "value-colon":
        {
          return concat$5([node.value, // Don't add spaces on `:` in `url` function (i.e. `url(fbglyph: cross-outline, fig-white)`)
          insideValueFunctionNode$1(path, "url") ? "" : line$1]);
        }

      case "value-comma":
        {
          return concat$5([node.value, " "]);
        }

      case "value-string":
        {
          return printString$1(node.raws.quote + node.value + node.raws.quote, options);
        }

      case "value-atword":
        {
          return concat$5(["@", node.value]);
        }

      case "value-unicode-range":
        {
          return node.value;
        }

      case "value-unknown":
        {
          return node.value;
        }

      default:
        /* istanbul ignore next */
        throw new Error("Unknown postcss type ".concat(JSON.stringify(node.type)));
    }
  }

  function printNodeSequence(path, options, print) {
    var node = path.getValue();
    var parts = [];
    var i = 0;
    path.map(function (pathChild) {
      var prevNode = node.nodes[i - 1];

      if (prevNode && prevNode.type === "css-comment" && prevNode.text.trim() === "prettier-ignore") {
        var childNode = pathChild.getValue();
        parts.push(options.originalText.slice(options.locStart(childNode), options.locEnd(childNode)));
      } else {
        parts.push(pathChild.call(print));
      }

      if (i !== node.nodes.length - 1) {
        if (node.nodes[i + 1].type === "css-comment" && !hasNewline$2(options.originalText, options.locStart(node.nodes[i + 1]), {
          backwards: true
        }) && node.nodes[i].type !== "yaml" && node.nodes[i].type !== "toml" || node.nodes[i + 1].type === "css-atrule" && node.nodes[i + 1].name === "else" && node.nodes[i].type !== "css-comment") {
          parts.push(" ");
        } else {
          parts.push(hardline$4);

          if (isNextLineEmpty$2(options.originalText, pathChild.getValue(), options) && node.nodes[i].type !== "yaml" && node.nodes[i].type !== "toml") {
            parts.push(hardline$4);
          }
        }
      }

      i++;
    }, "nodes");
    return concat$5(parts);
  }

  var STRING_REGEX$1 = /(['"])(?:(?!\1)[^\\]|\\[\s\S])*\1/g;
  var NUMBER_REGEX = /(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g;
  var STANDARD_UNIT_REGEX = /[a-zA-Z]+/g;
  var WORD_PART_REGEX = /[$@]?[a-zA-Z_\u0080-\uFFFF][\w\-\u0080-\uFFFF]*/g;
  var ADJUST_NUMBERS_REGEX = RegExp(STRING_REGEX$1.source + "|" + "(".concat(WORD_PART_REGEX.source, ")?") + "(".concat(NUMBER_REGEX.source, ")") + "(".concat(STANDARD_UNIT_REGEX.source, ")?"), "g");

  function adjustStrings(value, options) {
    return value.replace(STRING_REGEX$1, function (match) {
      return printString$1(match, options);
    });
  }

  function quoteAttributeValue(value, options) {
    var quote = options.singleQuote ? "'" : '"';
    return value.includes('"') || value.includes("'") ? value : quote + value + quote;
  }

  function adjustNumbers(value) {
    return value.replace(ADJUST_NUMBERS_REGEX, function (match, quote, wordPart, number, unit) {
      return !wordPart && number ? (wordPart || "") + printCssNumber(number) + maybeToLowerCase$1(unit || "") : match;
    });
  }

  function printCssNumber(rawNumber) {
    return printNumber$1(rawNumber) // Remove trailing `.0`.
    .replace(/\.0(?=$|e)/, "");
  }

  var printerPostcss = {
    print: genericPrint,
    embed: embed_1,
    insertPragma: insertPragma$2,
    hasPrettierIgnore: hasIgnoreComment$1,
    massageAstNode: clean_1
  };

  var CATEGORY_COMMON = "Common"; // format based on https://github.com/prettier/prettier/blob/master/src/main/core-options.js

  var commonOptions = {
    bracketSpacing: {
      since: "0.0.0",
      category: CATEGORY_COMMON,
      type: "boolean",
      default: true,
      description: "Print spaces between brackets.",
      oppositeDescription: "Do not print spaces between brackets."
    },
    singleQuote: {
      since: "0.0.0",
      category: CATEGORY_COMMON,
      type: "boolean",
      default: false,
      description: "Use single quotes instead of double quotes."
    },
    proseWrap: {
      since: "1.8.2",
      category: CATEGORY_COMMON,
      type: "choice",
      default: [{
        since: "1.8.2",
        value: true
      }, {
        since: "1.9.0",
        value: "preserve"
      }],
      description: "How to wrap prose.",
      choices: [{
        since: "1.9.0",
        value: "always",
        description: "Wrap prose if it exceeds the print width."
      }, {
        since: "1.9.0",
        value: "never",
        description: "Do not wrap prose."
      }, {
        since: "1.9.0",
        value: "preserve",
        description: "Wrap prose as-is."
      }, {
        value: false,
        deprecated: "1.9.0",
        redirect: "never"
      }, {
        value: true,
        deprecated: "1.9.0",
        redirect: "always"
      }]
    }
  };

  var options$2 = {
    singleQuote: commonOptions.singleQuote
  };

  var createLanguage = function createLanguage(linguistData, transform) {
    var language = {};

    for (var key in linguistData) {
      var newKey = key === "languageId" ? "linguistLanguageId" : key;
      language[newKey] = linguistData[key];
    }

    return transform(language);
  };

  var name$1 = "CSS";
  var type = "markup";
  var tmScope = "source.css";
  var aceMode = "css";
  var codemirrorMode = "css";
  var codemirrorMimeType = "text/css";
  var color = "#563d7c";
  var extensions = [
  	".css"
  ];
  var languageId = 50;
  var CSS = {
  	name: name$1,
  	type: type,
  	tmScope: tmScope,
  	aceMode: aceMode,
  	codemirrorMode: codemirrorMode,
  	codemirrorMimeType: codemirrorMimeType,
  	color: color,
  	extensions: extensions,
  	languageId: languageId
  };

  var CSS$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$1,
    type: type,
    tmScope: tmScope,
    aceMode: aceMode,
    codemirrorMode: codemirrorMode,
    codemirrorMimeType: codemirrorMimeType,
    color: color,
    extensions: extensions,
    languageId: languageId,
    'default': CSS
  });

  var name$2 = "PostCSS";
  var type$1 = "markup";
  var tmScope$1 = "source.postcss";
  var group$2 = "CSS";
  var extensions$1 = [
  	".pcss"
  ];
  var aceMode$1 = "text";
  var languageId$1 = 262764437;
  var PostCSS = {
  	name: name$2,
  	type: type$1,
  	tmScope: tmScope$1,
  	group: group$2,
  	extensions: extensions$1,
  	aceMode: aceMode$1,
  	languageId: languageId$1
  };

  var PostCSS$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$2,
    type: type$1,
    tmScope: tmScope$1,
    group: group$2,
    extensions: extensions$1,
    aceMode: aceMode$1,
    languageId: languageId$1,
    'default': PostCSS
  });

  var name$3 = "Less";
  var type$2 = "markup";
  var group$3 = "CSS";
  var extensions$2 = [
  	".less"
  ];
  var tmScope$2 = "source.css.less";
  var aceMode$2 = "less";
  var codemirrorMode$1 = "css";
  var codemirrorMimeType$1 = "text/css";
  var languageId$2 = 198;
  var Less = {
  	name: name$3,
  	type: type$2,
  	group: group$3,
  	extensions: extensions$2,
  	tmScope: tmScope$2,
  	aceMode: aceMode$2,
  	codemirrorMode: codemirrorMode$1,
  	codemirrorMimeType: codemirrorMimeType$1,
  	languageId: languageId$2
  };

  var Less$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$3,
    type: type$2,
    group: group$3,
    extensions: extensions$2,
    tmScope: tmScope$2,
    aceMode: aceMode$2,
    codemirrorMode: codemirrorMode$1,
    codemirrorMimeType: codemirrorMimeType$1,
    languageId: languageId$2,
    'default': Less
  });

  var name$4 = "SCSS";
  var type$3 = "markup";
  var tmScope$3 = "source.css.scss";
  var group$4 = "CSS";
  var aceMode$3 = "scss";
  var codemirrorMode$2 = "css";
  var codemirrorMimeType$2 = "text/x-scss";
  var extensions$3 = [
  	".scss"
  ];
  var languageId$3 = 329;
  var SCSS = {
  	name: name$4,
  	type: type$3,
  	tmScope: tmScope$3,
  	group: group$4,
  	aceMode: aceMode$3,
  	codemirrorMode: codemirrorMode$2,
  	codemirrorMimeType: codemirrorMimeType$2,
  	extensions: extensions$3,
  	languageId: languageId$3
  };

  var SCSS$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$4,
    type: type$3,
    tmScope: tmScope$3,
    group: group$4,
    aceMode: aceMode$3,
    codemirrorMode: codemirrorMode$2,
    codemirrorMimeType: codemirrorMimeType$2,
    extensions: extensions$3,
    languageId: languageId$3,
    'default': SCSS
  });

  var require$$0$2 = getCjsExportFromNamespace(CSS$1);

  var require$$1 = getCjsExportFromNamespace(PostCSS$1);

  var require$$2 = getCjsExportFromNamespace(Less$1);

  var require$$3 = getCjsExportFromNamespace(SCSS$1);

  var languages = [createLanguage(require$$0$2, function (data) {
    return Object.assign(data, {
      since: "1.4.0",
      parsers: ["css"],
      vscodeLanguageIds: ["css"]
    });
  }), createLanguage(require$$1, function (data) {
    return Object.assign(data, {
      since: "1.4.0",
      parsers: ["css"],
      vscodeLanguageIds: ["postcss"],
      extensions: data.extensions.concat(".postcss")
    });
  }), createLanguage(require$$2, function (data) {
    return Object.assign(data, {
      since: "1.4.0",
      parsers: ["less"],
      vscodeLanguageIds: ["less"]
    });
  }), createLanguage(require$$3, function (data) {
    return Object.assign(data, {
      since: "1.4.0",
      parsers: ["scss"],
      vscodeLanguageIds: ["scss"]
    });
  })];
  var printers = {
    postcss: printerPostcss
  };
  var languageCss = {
    languages: languages,
    options: options$2,
    printers: printers
  };

  function hasPragma$2(text) {
    return /^\s*#[^\n\S]*@(format|prettier)\s*(\n|$)/.test(text);
  }

  function insertPragma$3(text) {
    return "# @format\n\n" + text;
  }

  var pragma$2 = {
    hasPragma: hasPragma$2,
    insertPragma: insertPragma$3
  };

  var _require$$0$builders$2 = doc.builders,
      concat$6 = _require$$0$builders$2.concat,
      join$3 = _require$$0$builders$2.join,
      hardline$5 = _require$$0$builders$2.hardline,
      line$2 = _require$$0$builders$2.line,
      softline$2 = _require$$0$builders$2.softline,
      group$5 = _require$$0$builders$2.group,
      indent$3 = _require$$0$builders$2.indent,
      ifBreak$2 = _require$$0$builders$2.ifBreak;
  var hasIgnoreComment$2 = util.hasIgnoreComment;
  var isNextLineEmpty$3 = utilShared.isNextLineEmpty;
  var insertPragma$4 = pragma$2.insertPragma;

  function genericPrint$1(path, options, print) {
    var n = path.getValue();

    if (!n) {
      return "";
    }

    if (typeof n === "string") {
      return n;
    }

    switch (n.kind) {
      case "Document":
        {
          var parts = [];
          path.map(function (pathChild, index) {
            parts.push(concat$6([pathChild.call(print)]));

            if (index !== n.definitions.length - 1) {
              parts.push(hardline$5);

              if (isNextLineEmpty$3(options.originalText, pathChild.getValue(), options)) {
                parts.push(hardline$5);
              }
            }
          }, "definitions");
          return concat$6([concat$6(parts), hardline$5]);
        }

      case "OperationDefinition":
        {
          var hasOperation = options.originalText[options.locStart(n)] !== "{";
          var hasName = !!n.name;
          return concat$6([hasOperation ? n.operation : "", hasOperation && hasName ? concat$6([" ", path.call(print, "name")]) : "", n.variableDefinitions && n.variableDefinitions.length ? group$5(concat$6(["(", indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2("", ", "), softline$2]), path.map(print, "variableDefinitions"))])), softline$2, ")"])) : "", printDirectives(path, print, n), n.selectionSet ? !hasOperation && !hasName ? "" : " " : "", path.call(print, "selectionSet")]);
        }

      case "FragmentDefinition":
        {
          return concat$6(["fragment ", path.call(print, "name"), n.variableDefinitions && n.variableDefinitions.length ? group$5(concat$6(["(", indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2("", ", "), softline$2]), path.map(print, "variableDefinitions"))])), softline$2, ")"])) : "", " on ", path.call(print, "typeCondition"), printDirectives(path, print, n), " ", path.call(print, "selectionSet")]);
        }

      case "SelectionSet":
        {
          return concat$6(["{", indent$3(concat$6([hardline$5, join$3(hardline$5, path.call(function (selectionsPath) {
            return printSequence(selectionsPath, options, print);
          }, "selections"))])), hardline$5, "}"]);
        }

      case "Field":
        {
          return group$5(concat$6([n.alias ? concat$6([path.call(print, "alias"), ": "]) : "", path.call(print, "name"), n.arguments.length > 0 ? group$5(concat$6(["(", indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2("", ", "), softline$2]), path.call(function (argsPath) {
            return printSequence(argsPath, options, print);
          }, "arguments"))])), softline$2, ")"])) : "", printDirectives(path, print, n), n.selectionSet ? " " : "", path.call(print, "selectionSet")]));
        }

      case "Name":
        {
          return n.value;
        }

      case "StringValue":
        {
          if (n.block) {
            return concat$6(['"""', hardline$5, join$3(hardline$5, n.value.replace(/"""/g, "\\$&").split("\n")), hardline$5, '"""']);
          }

          return concat$6(['"', n.value.replace(/["\\]/g, "\\$&").replace(/\n/g, "\\n"), '"']);
        }

      case "IntValue":
      case "FloatValue":
      case "EnumValue":
        {
          return n.value;
        }

      case "BooleanValue":
        {
          return n.value ? "true" : "false";
        }

      case "NullValue":
        {
          return "null";
        }

      case "Variable":
        {
          return concat$6(["$", path.call(print, "name")]);
        }

      case "ListValue":
        {
          return group$5(concat$6(["[", indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2("", ", "), softline$2]), path.map(print, "values"))])), softline$2, "]"]));
        }

      case "ObjectValue":
        {
          return group$5(concat$6(["{", options.bracketSpacing && n.fields.length > 0 ? " " : "", indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2("", ", "), softline$2]), path.map(print, "fields"))])), softline$2, ifBreak$2("", options.bracketSpacing && n.fields.length > 0 ? " " : ""), "}"]));
        }

      case "ObjectField":
      case "Argument":
        {
          return concat$6([path.call(print, "name"), ": ", path.call(print, "value")]);
        }

      case "Directive":
        {
          return concat$6(["@", path.call(print, "name"), n.arguments.length > 0 ? group$5(concat$6(["(", indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2("", ", "), softline$2]), path.call(function (argsPath) {
            return printSequence(argsPath, options, print);
          }, "arguments"))])), softline$2, ")"])) : ""]);
        }

      case "NamedType":
        {
          return path.call(print, "name");
        }

      case "VariableDefinition":
        {
          return concat$6([path.call(print, "variable"), ": ", path.call(print, "type"), n.defaultValue ? concat$6([" = ", path.call(print, "defaultValue")]) : "", printDirectives(path, print, n)]);
        }

      case "TypeExtensionDefinition":
        {
          return concat$6(["extend ", path.call(print, "definition")]);
        }

      case "ObjectTypeExtension":
      case "ObjectTypeDefinition":
        {
          return concat$6([path.call(print, "description"), n.description ? hardline$5 : "", n.kind === "ObjectTypeExtension" ? "extend " : "", "type ", path.call(print, "name"), n.interfaces.length > 0 ? concat$6([" implements ", join$3(determineInterfaceSeparator(options.originalText.substr(options.locStart(n), options.locEnd(n))), path.map(print, "interfaces"))]) : "", printDirectives(path, print, n), n.fields.length > 0 ? concat$6([" {", indent$3(concat$6([hardline$5, join$3(hardline$5, path.call(function (fieldsPath) {
            return printSequence(fieldsPath, options, print);
          }, "fields"))])), hardline$5, "}"]) : ""]);
        }

      case "FieldDefinition":
        {
          return concat$6([path.call(print, "description"), n.description ? hardline$5 : "", path.call(print, "name"), n.arguments.length > 0 ? group$5(concat$6(["(", indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2("", ", "), softline$2]), path.call(function (argsPath) {
            return printSequence(argsPath, options, print);
          }, "arguments"))])), softline$2, ")"])) : "", ": ", path.call(print, "type"), printDirectives(path, print, n)]);
        }

      case "DirectiveDefinition":
        {
          return concat$6([path.call(print, "description"), n.description ? hardline$5 : "", "directive ", "@", path.call(print, "name"), n.arguments.length > 0 ? group$5(concat$6(["(", indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2("", ", "), softline$2]), path.call(function (argsPath) {
            return printSequence(argsPath, options, print);
          }, "arguments"))])), softline$2, ")"])) : "", concat$6([" on ", join$3(" | ", path.map(print, "locations"))])]);
        }

      case "EnumTypeExtension":
      case "EnumTypeDefinition":
        {
          return concat$6([path.call(print, "description"), n.description ? hardline$5 : "", n.kind === "EnumTypeExtension" ? "extend " : "", "enum ", path.call(print, "name"), printDirectives(path, print, n), n.values.length > 0 ? concat$6([" {", indent$3(concat$6([hardline$5, join$3(hardline$5, path.call(function (valuesPath) {
            return printSequence(valuesPath, options, print);
          }, "values"))])), hardline$5, "}"]) : ""]);
        }

      case "EnumValueDefinition":
        {
          return concat$6([path.call(print, "description"), n.description ? hardline$5 : "", path.call(print, "name"), printDirectives(path, print, n)]);
        }

      case "InputValueDefinition":
        {
          return concat$6([path.call(print, "description"), n.description ? n.description.block ? hardline$5 : line$2 : "", path.call(print, "name"), ": ", path.call(print, "type"), n.defaultValue ? concat$6([" = ", path.call(print, "defaultValue")]) : "", printDirectives(path, print, n)]);
        }

      case "InputObjectTypeExtension":
      case "InputObjectTypeDefinition":
        {
          return concat$6([path.call(print, "description"), n.description ? hardline$5 : "", n.kind === "InputObjectTypeExtension" ? "extend " : "", "input ", path.call(print, "name"), printDirectives(path, print, n), n.fields.length > 0 ? concat$6([" {", indent$3(concat$6([hardline$5, join$3(hardline$5, path.call(function (fieldsPath) {
            return printSequence(fieldsPath, options, print);
          }, "fields"))])), hardline$5, "}"]) : ""]);
        }

      case "SchemaDefinition":
        {
          return concat$6(["schema", printDirectives(path, print, n), " {", n.operationTypes.length > 0 ? indent$3(concat$6([hardline$5, join$3(hardline$5, path.call(function (opsPath) {
            return printSequence(opsPath, options, print);
          }, "operationTypes"))])) : "", hardline$5, "}"]);
        }

      case "OperationTypeDefinition":
        {
          return concat$6([path.call(print, "operation"), ": ", path.call(print, "type")]);
        }

      case "InterfaceTypeExtension":
      case "InterfaceTypeDefinition":
        {
          return concat$6([path.call(print, "description"), n.description ? hardline$5 : "", n.kind === "InterfaceTypeExtension" ? "extend " : "", "interface ", path.call(print, "name"), printDirectives(path, print, n), n.fields.length > 0 ? concat$6([" {", indent$3(concat$6([hardline$5, join$3(hardline$5, path.call(function (fieldsPath) {
            return printSequence(fieldsPath, options, print);
          }, "fields"))])), hardline$5, "}"]) : ""]);
        }

      case "FragmentSpread":
        {
          return concat$6(["...", path.call(print, "name"), printDirectives(path, print, n)]);
        }

      case "InlineFragment":
        {
          return concat$6(["...", n.typeCondition ? concat$6([" on ", path.call(print, "typeCondition")]) : "", printDirectives(path, print, n), " ", path.call(print, "selectionSet")]);
        }

      case "UnionTypeExtension":
      case "UnionTypeDefinition":
        {
          return group$5(concat$6([path.call(print, "description"), n.description ? hardline$5 : "", group$5(concat$6([n.kind === "UnionTypeExtension" ? "extend " : "", "union ", path.call(print, "name"), printDirectives(path, print, n), n.types.length > 0 ? concat$6([" =", ifBreak$2("", " "), indent$3(concat$6([ifBreak$2(concat$6([line$2, "  "])), join$3(concat$6([line$2, "| "]), path.map(print, "types"))]))]) : ""]))]));
        }

      case "ScalarTypeExtension":
      case "ScalarTypeDefinition":
        {
          return concat$6([path.call(print, "description"), n.description ? hardline$5 : "", n.kind === "ScalarTypeExtension" ? "extend " : "", "scalar ", path.call(print, "name"), printDirectives(path, print, n)]);
        }

      case "NonNullType":
        {
          return concat$6([path.call(print, "type"), "!"]);
        }

      case "ListType":
        {
          return concat$6(["[", path.call(print, "type"), "]"]);
        }

      default:
        /* istanbul ignore next */
        throw new Error("unknown graphql type: " + JSON.stringify(n.kind));
    }
  }

  function printDirectives(path, print, n) {
    if (n.directives.length === 0) {
      return "";
    }

    return concat$6([" ", group$5(indent$3(concat$6([softline$2, join$3(concat$6([ifBreak$2("", " "), softline$2]), path.map(print, "directives"))])))]);
  }

  function printSequence(sequencePath, options, print) {
    var count = sequencePath.getValue().length;
    return sequencePath.map(function (path, i) {
      var printed = print(path);

      if (isNextLineEmpty$3(options.originalText, path.getValue(), options) && i < count - 1) {
        return concat$6([printed, hardline$5]);
      }

      return printed;
    });
  }

  function canAttachComment(node) {
    return node.kind && node.kind !== "Comment";
  }

  function printComment$1(commentPath) {
    var comment = commentPath.getValue();

    if (comment.kind === "Comment") {
      return "#" + comment.value.trimRight();
    }

    throw new Error("Not a comment: " + JSON.stringify(comment));
  }

  function determineInterfaceSeparator(originalSource) {
    var start = originalSource.indexOf("implements");

    if (start === -1) {
      throw new Error("Must implement interfaces: " + originalSource);
    }

    var end = originalSource.indexOf("{");

    if (end === -1) {
      end = originalSource.length;
    }

    return originalSource.substr(start, end).includes("&") ? " & " : ", ";
  }

  function clean$1(node, newNode
  /*, parent*/
  ) {
    delete newNode.loc;
    delete newNode.comments;
  }

  var printerGraphql = {
    print: genericPrint$1,
    massageAstNode: clean$1,
    hasPrettierIgnore: hasIgnoreComment$2,
    insertPragma: insertPragma$4,
    printComment: printComment$1,
    canAttachComment: canAttachComment
  };

  var options$3 = {
    bracketSpacing: commonOptions.bracketSpacing
  };

  var name$5 = "GraphQL";
  var type$4 = "data";
  var extensions$4 = [
  	".graphql",
  	".gql",
  	".graphqls"
  ];
  var tmScope$4 = "source.graphql";
  var aceMode$4 = "text";
  var languageId$4 = 139;
  var GraphQL = {
  	name: name$5,
  	type: type$4,
  	extensions: extensions$4,
  	tmScope: tmScope$4,
  	aceMode: aceMode$4,
  	languageId: languageId$4
  };

  var GraphQL$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$5,
    type: type$4,
    extensions: extensions$4,
    tmScope: tmScope$4,
    aceMode: aceMode$4,
    languageId: languageId$4,
    'default': GraphQL
  });

  var require$$0$3 = getCjsExportFromNamespace(GraphQL$1);

  var languages$1 = [createLanguage(require$$0$3, function (data) {
    return Object.assign(data, {
      since: "1.5.0",
      parsers: ["graphql"],
      vscodeLanguageIds: ["graphql"]
    });
  })];
  var printers$1 = {
    graphql: printerGraphql
  };
  var languageGraphql = {
    languages: languages$1,
    options: options$3,
    printers: printers$1
  };

  var _require$$0$builders$3 = doc.builders,
      concat$7 = _require$$0$builders$3.concat,
      join$4 = _require$$0$builders$3.join,
      softline$3 = _require$$0$builders$3.softline,
      hardline$6 = _require$$0$builders$3.hardline,
      line$3 = _require$$0$builders$3.line,
      group$6 = _require$$0$builders$3.group,
      indent$4 = _require$$0$builders$3.indent,
      ifBreak$3 = _require$$0$builders$3.ifBreak; // http://w3c.github.io/html/single-page.html#void-elements

  var voidTags = ["area", "base", "br", "col", "embed", "hr", "img", "input", "link", "meta", "param", "source", "track", "wbr"]; // Formatter based on @glimmerjs/syntax's built-in test formatter:
  // https://github.com/glimmerjs/glimmer-vm/blob/master/packages/%40glimmer/syntax/lib/generation/print.ts

  function printChildren(path, options, print) {
    return concat$7(path.map(function (childPath, childIndex) {
      var childNode = path.getValue();
      var isFirstNode = childIndex === 0;
      var isLastNode = childIndex == path.getParentNode(0).children.length - 1;
      var isLastNodeInMultiNodeList = isLastNode && !isFirstNode;
      var isWhitespace = isWhitespaceNode(childNode);

      if (isWhitespace && isLastNodeInMultiNodeList) {
        return print(childPath, options, print);
      } else if (isFirstNode) {
        return concat$7([softline$3, print(childPath, options, print)]);
      }

      return print(childPath, options, print);
    }, "children"));
  }

  function print(path, options, print) {
    var n = path.getValue();
    /* istanbul ignore if*/

    if (!n) {
      return "";
    }

    switch (n.type) {
      case "Block":
      case "Program":
      case "Template":
        {
          return group$6(concat$7(path.map(print, "body").filter(function (text) {
            return text !== "";
          })));
        }

      case "ElementNode":
        {
          var tagFirstChar = n.tag[0];
          var isLocal = n.tag.indexOf(".") !== -1;
          var isGlimmerComponent = tagFirstChar.toUpperCase() === tagFirstChar || isLocal;
          var hasChildren = n.children.length > 0;
          var hasNonWhitespaceChildren = n.children.some(function (n) {
            return !isWhitespaceNode(n);
          });
          var isVoid = isGlimmerComponent && (!hasChildren || !hasNonWhitespaceChildren) || voidTags.indexOf(n.tag) !== -1;
          var closeTagForNoBreak = isVoid ? concat$7([" />", softline$3]) : ">";
          var closeTagForBreak = isVoid ? "/>" : ">";

          var _getParams = function _getParams(path, print) {
            return indent$4(concat$7([n.attributes.length ? line$3 : "", join$4(line$3, path.map(print, "attributes")), n.modifiers.length ? line$3 : "", join$4(line$3, path.map(print, "modifiers")), n.comments.length ? line$3 : "", join$4(line$3, path.map(print, "comments"))]));
          };

          var nextNode = getNextNode(path);
          return concat$7([group$6(concat$7(["<", n.tag, _getParams(path, print), n.blockParams.length ? " as |".concat(n.blockParams.join(" "), "|") : "", ifBreak$3(softline$3, ""), ifBreak$3(closeTagForBreak, closeTagForNoBreak)])), !isVoid ? group$6(concat$7([hasNonWhitespaceChildren ? indent$4(printChildren(path, options, print)) : "", ifBreak$3(hasChildren ? hardline$6 : "", ""), concat$7(["</", n.tag, ">"])])) : "", nextNode && nextNode.type === "ElementNode" ? hardline$6 : ""]);
        }

      case "BlockStatement":
        {
          var pp = path.getParentNode(1);
          var isElseIf = pp && pp.inverse && pp.inverse.body.length === 1 && pp.inverse.body[0] === n && pp.inverse.body[0].path.parts[0] === "if";
          var hasElseIf = n.inverse && n.inverse.body.length === 1 && n.inverse.body[0].type === "BlockStatement" && n.inverse.body[0].path.parts[0] === "if";
          var indentElse = hasElseIf ? function (a) {
            return a;
          } : indent$4;

          if (n.inverse) {
            return concat$7([isElseIf ? concat$7(["{{else ", printPathParams(path, print), "}}"]) : printOpenBlock(path, print), indent$4(concat$7([hardline$6, path.call(print, "program")])), n.inverse && !hasElseIf ? concat$7([hardline$6, "{{else}}"]) : "", n.inverse ? indentElse(concat$7([hardline$6, path.call(print, "inverse")])) : "", isElseIf ? "" : concat$7([hardline$6, printCloseBlock(path, print)])]);
          } else if (isElseIf) {
            return concat$7([concat$7(["{{else ", printPathParams(path, print), "}}"]), indent$4(concat$7([hardline$6, path.call(print, "program")]))]);
          }

          var _hasNonWhitespaceChildren = n.program.body.some(function (n) {
            return !isWhitespaceNode(n);
          });

          return concat$7([printOpenBlock(path, print), group$6(concat$7([indent$4(concat$7([softline$3, path.call(print, "program")])), _hasNonWhitespaceChildren ? hardline$6 : softline$3, printCloseBlock(path, print)]))]);
        }

      case "ElementModifierStatement":
      case "MustacheStatement":
        {
          var _pp = path.getParentNode(1);

          var isConcat = _pp && _pp.type === "ConcatStatement";
          return group$6(concat$7([n.escaped === false ? "{{{" : "{{", printPathParams(path, print, {
            group: false
          }), isConcat ? "" : softline$3, n.escaped === false ? "}}}" : "}}"]));
        }

      case "SubExpression":
        {
          var params = getParams(path, print);
          var printedParams = params.length > 0 ? indent$4(concat$7([line$3, group$6(join$4(line$3, params))])) : "";
          return group$6(concat$7(["(", printPath(path, print), printedParams, softline$3, ")"]));
        }

      case "AttrNode":
        {
          var isText = n.value.type === "TextNode";

          if (isText && n.value.loc.start.column === n.value.loc.end.column) {
            return concat$7([n.name]);
          }

          var value = path.call(print, "value");
          var quotedValue = isText ? printStringLiteral(value.parts.join(), options) : value;
          return concat$7([n.name, "=", quotedValue]);
        }

      case "ConcatStatement":
        {
          return concat$7(['"', group$6(indent$4(join$4(softline$3, path.map(function (partPath) {
            return print(partPath);
          }, "parts").filter(function (a) {
            return a !== "";
          })))), '"']);
        }

      case "Hash":
        {
          return concat$7([join$4(line$3, path.map(print, "pairs"))]);
        }

      case "HashPair":
        {
          return concat$7([n.key, "=", path.call(print, "value")]);
        }

      case "TextNode":
        {
          var maxLineBreaksToPreserve = 2;
          var isFirstElement = !getPreviousNode(path);
          var isLastElement = !getNextNode(path);
          var isWhitespaceOnly = !/\S/.test(n.chars);
          var lineBreaksCount = countNewLines(n.chars);
          var hasBlockParent = path.getParentNode(0).type === "Block";
          var hasElementParent = path.getParentNode(0).type === "ElementNode";
          var hasTemplateParent = path.getParentNode(0).type === "Template";
          var leadingLineBreaksCount = countLeadingNewLines(n.chars);
          var trailingLineBreaksCount = countTrailingNewLines(n.chars);

          if ((isFirstElement || isLastElement) && isWhitespaceOnly && (hasBlockParent || hasElementParent || hasTemplateParent)) {
            return "";
          }

          if (isWhitespaceOnly && lineBreaksCount) {
            leadingLineBreaksCount = Math.min(lineBreaksCount, maxLineBreaksToPreserve);
            trailingLineBreaksCount = 0;
          } else {
            if (isNextNodeOfType(path, "ElementNode") || isNextNodeOfType(path, "BlockStatement")) {
              trailingLineBreaksCount = Math.max(trailingLineBreaksCount, 1);
            }

            if (isPreviousNodeOfSomeType(path, ["ElementNode"]) || isPreviousNodeOfSomeType(path, ["BlockStatement"])) {
              leadingLineBreaksCount = Math.max(leadingLineBreaksCount, 1);
            }
          }

          var leadingSpace = "";
          var trailingSpace = ""; // preserve a space inside of an attribute node where whitespace present,
          // when next to mustache statement.

          var inAttrNode = path.stack.indexOf("attributes") >= 0;

          if (inAttrNode) {
            var parentNode = path.getParentNode(0);

            var _isConcat = parentNode.type === "ConcatStatement";

            if (_isConcat) {
              var parts = parentNode.parts;
              var partIndex = parts.indexOf(n);

              if (partIndex > 0) {
                var partType = parts[partIndex - 1].type;
                var isMustache = partType === "MustacheStatement";

                if (isMustache) {
                  leadingSpace = " ";
                }
              }

              if (partIndex < parts.length - 1) {
                var _partType = parts[partIndex + 1].type;

                var _isMustache = _partType === "MustacheStatement";

                if (_isMustache) {
                  trailingSpace = " ";
                }
              }
            }
          } else {
            if (trailingLineBreaksCount === 0 && isNextNodeOfType(path, "MustacheStatement")) {
              trailingSpace = " ";
            }

            if (leadingLineBreaksCount === 0 && isPreviousNodeOfSomeType(path, ["MustacheStatement"])) {
              leadingSpace = " ";
            }

            if (isFirstElement) {
              leadingLineBreaksCount = 0;
              leadingSpace = "";
            }

            if (isLastElement) {
              trailingLineBreaksCount = 0;
              trailingSpace = "";
            }
          }

          return concat$7([].concat(_toConsumableArray(generateHardlines(leadingLineBreaksCount, maxLineBreaksToPreserve)), [n.chars.replace(/^[\s ]+/g, leadingSpace).replace(/[\s ]+$/, trailingSpace)], _toConsumableArray(generateHardlines(trailingLineBreaksCount, maxLineBreaksToPreserve))).filter(Boolean));
        }

      case "MustacheCommentStatement":
        {
          var dashes = n.value.indexOf("}}") > -1 ? "--" : "";
          return concat$7(["{{!", dashes, n.value, dashes, "}}"]);
        }

      case "PathExpression":
        {
          return n.original;
        }

      case "BooleanLiteral":
        {
          return String(n.value);
        }

      case "CommentStatement":
        {
          return concat$7(["<!--", n.value, "-->"]);
        }

      case "StringLiteral":
        {
          return printStringLiteral(n.value, options);
        }

      case "NumberLiteral":
        {
          return String(n.value);
        }

      case "UndefinedLiteral":
        {
          return "undefined";
        }

      case "NullLiteral":
        {
          return "null";
        }

      /* istanbul ignore next */

      default:
        throw new Error("unknown glimmer type: " + JSON.stringify(n.type));
    }
  }
  /**
   * Prints a string literal with the correct surrounding quotes based on
   * `options.singleQuote` and the number of escaped quotes contained in
   * the string literal. This function is the glimmer equivalent of `printString`
   * in `common/util`, but has differences because of the way escaped characters
   * are treated in hbs string literals.
   * @param {string} stringLiteral - the string literal value
   * @param {object} options - the prettier options object
   */


  function printStringLiteral(stringLiteral, options) {
    var double = {
      quote: '"',
      regex: /"/g
    };
    var single = {
      quote: "'",
      regex: /'/g
    };
    var preferred = options.singleQuote ? single : double;
    var alternate = preferred === single ? double : single;
    var shouldUseAlternateQuote = false; // If `stringLiteral` contains at least one of the quote preferred for
    // enclosing the string, we might want to enclose with the alternate quote
    // instead, to minimize the number of escaped quotes.

    if (stringLiteral.includes(preferred.quote) || stringLiteral.includes(alternate.quote)) {
      var numPreferredQuotes = (stringLiteral.match(preferred.regex) || []).length;
      var numAlternateQuotes = (stringLiteral.match(alternate.regex) || []).length;
      shouldUseAlternateQuote = numPreferredQuotes > numAlternateQuotes;
    }

    var enclosingQuote = shouldUseAlternateQuote ? alternate : preferred;
    var escapedStringLiteral = stringLiteral.replace(enclosingQuote.regex, "\\".concat(enclosingQuote.quote));
    return "".concat(enclosingQuote.quote).concat(escapedStringLiteral).concat(enclosingQuote.quote);
  }

  function printPath(path, print) {
    return path.call(print, "path");
  }

  function getParams(path, print) {
    var node = path.getValue();
    var parts = [];

    if (node.params.length > 0) {
      parts = parts.concat(path.map(print, "params"));
    }

    if (node.hash && node.hash.pairs.length > 0) {
      parts.push(path.call(print, "hash"));
    }

    return parts;
  }

  function printPathParams(path, print, options) {
    var parts = [];
    options = Object.assign({
      group: true
    }, options || {});
    parts.push(printPath(path, print));
    parts = parts.concat(getParams(path, print));

    if (!options.group) {
      return indent$4(join$4(line$3, parts));
    }

    return indent$4(group$6(join$4(line$3, parts)));
  }

  function printBlockParams(path) {
    var block = path.getValue();

    if (!block.program || !block.program.blockParams.length) {
      return "";
    }

    return concat$7([" as |", block.program.blockParams.join(" "), "|"]);
  }

  function printOpenBlock(path, print) {
    return group$6(concat$7(["{{#", printPathParams(path, print), printBlockParams(path), softline$3, "}}"]));
  }

  function printCloseBlock(path, print) {
    return concat$7(["{{/", path.call(print, "path"), "}}"]);
  }

  function isWhitespaceNode(node) {
    return node.type === "TextNode" && !/\S/.test(node.chars);
  }

  function getPreviousNode(path) {
    var node = path.getValue();
    var parentNode = path.getParentNode(0);
    var children = parentNode.children || parentNode.body;

    if (children) {
      var nodeIndex = children.indexOf(node);

      if (nodeIndex > 0) {
        var previousNode = children[nodeIndex - 1];
        return previousNode;
      }
    }
  }

  function getNextNode(path) {
    var node = path.getValue();
    var parentNode = path.getParentNode(0);
    var children = parentNode.children || parentNode.body;

    if (children) {
      var nodeIndex = children.indexOf(node);

      if (nodeIndex < children.length) {
        var nextNode = children[nodeIndex + 1];
        return nextNode;
      }
    }
  }

  function isPreviousNodeOfSomeType(path, types) {
    var previousNode = getPreviousNode(path);

    if (previousNode) {
      return types.some(function (type) {
        return previousNode.type === type;
      });
    }

    return false;
  }

  function isNextNodeOfType(path, type) {
    var nextNode = getNextNode(path);
    return nextNode && nextNode.type === type;
  }

  function clean$2(ast, newObj) {
    delete newObj.loc;
    delete newObj.selfClosing; // (Glimmer/HTML) ignore TextNode whitespace

    if (ast.type === "TextNode") {
      if (ast.chars.replace(/\s+/, "") === "") {
        return null;
      }

      newObj.chars = ast.chars.replace(/^\s+/, "").replace(/\s+$/, "");
    }
  }

  function countNewLines(string) {
    /* istanbul ignore next */
    string = typeof string === "string" ? string : "";
    return string.split("\n").length - 1;
  }

  function countLeadingNewLines(string) {
    /* istanbul ignore next */
    string = typeof string === "string" ? string : "";
    var newLines = (string.match(/^([^\S\r\n]*[\r\n])+/g) || [])[0] || "";
    return countNewLines(newLines);
  }

  function countTrailingNewLines(string) {
    /* istanbul ignore next */
    string = typeof string === "string" ? string : "";
    var newLines = (string.match(/([\r\n][^\S\r\n]*)+$/g) || [])[0] || "";
    return countNewLines(newLines);
  }

  function generateHardlines() {
    var number = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;
    var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
    return new Array(Math.min(number, max)).fill(hardline$6);
  }

  var printerGlimmer = {
    print: print,
    massageAstNode: clean$2
  };

  var name$6 = "Handlebars";
  var type$5 = "markup";
  var group$7 = "HTML";
  var aliases = [
  	"hbs",
  	"htmlbars"
  ];
  var extensions$5 = [
  	".handlebars",
  	".hbs"
  ];
  var tmScope$5 = "text.html.handlebars";
  var aceMode$5 = "handlebars";
  var languageId$5 = 155;
  var Handlebars = {
  	name: name$6,
  	type: type$5,
  	group: group$7,
  	aliases: aliases,
  	extensions: extensions$5,
  	tmScope: tmScope$5,
  	aceMode: aceMode$5,
  	languageId: languageId$5
  };

  var Handlebars$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$6,
    type: type$5,
    group: group$7,
    aliases: aliases,
    extensions: extensions$5,
    tmScope: tmScope$5,
    aceMode: aceMode$5,
    languageId: languageId$5,
    'default': Handlebars
  });

  var require$$0$4 = getCjsExportFromNamespace(Handlebars$1);

  var languages$2 = [createLanguage(require$$0$4, function (data) {
    return Object.assign(data, {
      since: null,
      // unreleased
      parsers: ["glimmer"],
      vscodeLanguageIds: ["handlebars"]
    });
  })];
  var printers$2 = {
    glimmer: printerGlimmer
  };
  var languageHandlebars = {
    languages: languages$2,
    printers: printers$2
  };

  var clean$3 = function clean(ast, newNode) {
    delete newNode.sourceSpan;
    delete newNode.startSourceSpan;
    delete newNode.endSourceSpan;
    delete newNode.nameSpan;
    delete newNode.valueSpan;

    if (ast.type === "text" || ast.type === "comment") {
      return null;
    } // may be formatted by multiparser


    if (ast.type === "yaml" || ast.type === "toml") {
      return null;
    }

    if (ast.type === "attribute") {
      delete newNode.value;
    }

    if (ast.type === "docType") {
      delete newNode.value;
    }
  };

  var json = {
    "CSS_DISPLAY_TAGS": {
      "area": "none",
      "base": "none",
      "basefont": "none",
      "datalist": "none",
      "head": "none",
      "link": "none",
      "meta": "none",
      "noembed": "none",
      "noframes": "none",
      "param": "none",
      "rp": "none",
      "script": "block",
      "source": "block",
      "style": "none",
      "template": "inline",
      "track": "block",
      "title": "none",
      "html": "block",
      "body": "block",
      "address": "block",
      "blockquote": "block",
      "center": "block",
      "div": "block",
      "figure": "block",
      "figcaption": "block",
      "footer": "block",
      "form": "block",
      "header": "block",
      "hr": "block",
      "legend": "block",
      "listing": "block",
      "main": "block",
      "p": "block",
      "plaintext": "block",
      "pre": "block",
      "xmp": "block",
      "slot": "contents",
      "ruby": "ruby",
      "rt": "ruby-text",
      "article": "block",
      "aside": "block",
      "h1": "block",
      "h2": "block",
      "h3": "block",
      "h4": "block",
      "h5": "block",
      "h6": "block",
      "hgroup": "block",
      "nav": "block",
      "section": "block",
      "dir": "block",
      "dd": "block",
      "dl": "block",
      "dt": "block",
      "ol": "block",
      "ul": "block",
      "li": "list-item",
      "table": "table",
      "caption": "table-caption",
      "colgroup": "table-column-group",
      "col": "table-column",
      "thead": "table-header-group",
      "tbody": "table-row-group",
      "tfoot": "table-footer-group",
      "tr": "table-row",
      "td": "table-cell",
      "th": "table-cell",
      "fieldset": "block",
      "button": "inline-block",
      "video": "inline-block",
      "audio": "inline-block"
    },
    "CSS_DISPLAY_DEFAULT": "inline",
    "CSS_WHITE_SPACE_TAGS": {
      "listing": "pre",
      "plaintext": "pre",
      "pre": "pre",
      "xmp": "pre",
      "nobr": "nowrap",
      "table": "initial",
      "textarea": "pre-wrap"
    },
    "CSS_WHITE_SPACE_DEFAULT": "normal"
  };

  var a = [
  	"accesskey",
  	"charset",
  	"coords",
  	"download",
  	"href",
  	"hreflang",
  	"name",
  	"ping",
  	"referrerpolicy",
  	"rel",
  	"rev",
  	"shape",
  	"tabindex",
  	"target",
  	"type"
  ];
  var abbr = [
  	"title"
  ];
  var applet = [
  	"align",
  	"alt",
  	"archive",
  	"code",
  	"codebase",
  	"height",
  	"hspace",
  	"name",
  	"object",
  	"vspace",
  	"width"
  ];
  var area = [
  	"accesskey",
  	"alt",
  	"coords",
  	"download",
  	"href",
  	"hreflang",
  	"nohref",
  	"ping",
  	"referrerpolicy",
  	"rel",
  	"shape",
  	"tabindex",
  	"target",
  	"type"
  ];
  var audio = [
  	"autoplay",
  	"controls",
  	"crossorigin",
  	"loop",
  	"muted",
  	"preload",
  	"src"
  ];
  var base = [
  	"href",
  	"target"
  ];
  var basefont = [
  	"color",
  	"face",
  	"size"
  ];
  var bdo = [
  	"dir"
  ];
  var blockquote = [
  	"cite"
  ];
  var body = [
  	"alink",
  	"background",
  	"bgcolor",
  	"link",
  	"text",
  	"vlink"
  ];
  var br = [
  	"clear"
  ];
  var button = [
  	"accesskey",
  	"autofocus",
  	"disabled",
  	"form",
  	"formaction",
  	"formenctype",
  	"formmethod",
  	"formnovalidate",
  	"formtarget",
  	"name",
  	"tabindex",
  	"type",
  	"value"
  ];
  var canvas = [
  	"height",
  	"width"
  ];
  var caption = [
  	"align"
  ];
  var col = [
  	"align",
  	"char",
  	"charoff",
  	"span",
  	"valign",
  	"width"
  ];
  var colgroup = [
  	"align",
  	"char",
  	"charoff",
  	"span",
  	"valign",
  	"width"
  ];
  var data = [
  	"value"
  ];
  var del = [
  	"cite",
  	"datetime"
  ];
  var details = [
  	"open"
  ];
  var dfn = [
  	"title"
  ];
  var dialog = [
  	"open"
  ];
  var dir = [
  	"compact"
  ];
  var div = [
  	"align"
  ];
  var dl = [
  	"compact"
  ];
  var embed$1 = [
  	"height",
  	"src",
  	"type",
  	"width"
  ];
  var fieldset = [
  	"disabled",
  	"form",
  	"name"
  ];
  var font = [
  	"color",
  	"face",
  	"size"
  ];
  var form = [
  	"accept",
  	"accept-charset",
  	"action",
  	"autocomplete",
  	"enctype",
  	"method",
  	"name",
  	"novalidate",
  	"target"
  ];
  var frame = [
  	"frameborder",
  	"longdesc",
  	"marginheight",
  	"marginwidth",
  	"name",
  	"noresize",
  	"scrolling",
  	"src"
  ];
  var frameset = [
  	"cols",
  	"rows"
  ];
  var h1 = [
  	"align"
  ];
  var h2 = [
  	"align"
  ];
  var h3 = [
  	"align"
  ];
  var h4 = [
  	"align"
  ];
  var h5 = [
  	"align"
  ];
  var h6 = [
  	"align"
  ];
  var head = [
  	"profile"
  ];
  var hr = [
  	"align",
  	"noshade",
  	"size",
  	"width"
  ];
  var html = [
  	"manifest",
  	"version"
  ];
  var iframe = [
  	"align",
  	"allow",
  	"allowfullscreen",
  	"allowpaymentrequest",
  	"allowusermedia",
  	"frameborder",
  	"height",
  	"longdesc",
  	"marginheight",
  	"marginwidth",
  	"name",
  	"referrerpolicy",
  	"sandbox",
  	"scrolling",
  	"src",
  	"srcdoc",
  	"width"
  ];
  var img = [
  	"align",
  	"alt",
  	"border",
  	"crossorigin",
  	"decoding",
  	"height",
  	"hspace",
  	"ismap",
  	"longdesc",
  	"name",
  	"referrerpolicy",
  	"sizes",
  	"src",
  	"srcset",
  	"usemap",
  	"vspace",
  	"width"
  ];
  var input = [
  	"accept",
  	"accesskey",
  	"align",
  	"alt",
  	"autocomplete",
  	"autofocus",
  	"checked",
  	"dirname",
  	"disabled",
  	"form",
  	"formaction",
  	"formenctype",
  	"formmethod",
  	"formnovalidate",
  	"formtarget",
  	"height",
  	"ismap",
  	"list",
  	"max",
  	"maxlength",
  	"min",
  	"minlength",
  	"multiple",
  	"name",
  	"pattern",
  	"placeholder",
  	"readonly",
  	"required",
  	"size",
  	"src",
  	"step",
  	"tabindex",
  	"title",
  	"type",
  	"usemap",
  	"value",
  	"width"
  ];
  var ins = [
  	"cite",
  	"datetime"
  ];
  var isindex = [
  	"prompt"
  ];
  var label = [
  	"accesskey",
  	"for",
  	"form"
  ];
  var legend = [
  	"accesskey",
  	"align"
  ];
  var li = [
  	"type",
  	"value"
  ];
  var link$1 = [
  	"as",
  	"charset",
  	"color",
  	"crossorigin",
  	"href",
  	"hreflang",
  	"imagesizes",
  	"imagesrcset",
  	"integrity",
  	"media",
  	"nonce",
  	"referrerpolicy",
  	"rel",
  	"rev",
  	"sizes",
  	"target",
  	"title",
  	"type"
  ];
  var map = [
  	"name"
  ];
  var menu = [
  	"compact"
  ];
  var meta = [
  	"charset",
  	"content",
  	"http-equiv",
  	"name",
  	"scheme"
  ];
  var meter = [
  	"high",
  	"low",
  	"max",
  	"min",
  	"optimum",
  	"value"
  ];
  var object = [
  	"align",
  	"archive",
  	"border",
  	"classid",
  	"codebase",
  	"codetype",
  	"data",
  	"declare",
  	"form",
  	"height",
  	"hspace",
  	"name",
  	"standby",
  	"tabindex",
  	"type",
  	"typemustmatch",
  	"usemap",
  	"vspace",
  	"width"
  ];
  var ol = [
  	"compact",
  	"reversed",
  	"start",
  	"type"
  ];
  var optgroup = [
  	"disabled",
  	"label"
  ];
  var option = [
  	"disabled",
  	"label",
  	"selected",
  	"value"
  ];
  var output = [
  	"for",
  	"form",
  	"name"
  ];
  var p = [
  	"align"
  ];
  var param = [
  	"name",
  	"type",
  	"value",
  	"valuetype"
  ];
  var pre = [
  	"width"
  ];
  var progress = [
  	"max",
  	"value"
  ];
  var q = [
  	"cite"
  ];
  var script = [
  	"async",
  	"charset",
  	"crossorigin",
  	"defer",
  	"integrity",
  	"language",
  	"nomodule",
  	"nonce",
  	"referrerpolicy",
  	"src",
  	"type"
  ];
  var select = [
  	"autocomplete",
  	"autofocus",
  	"disabled",
  	"form",
  	"multiple",
  	"name",
  	"required",
  	"size",
  	"tabindex"
  ];
  var slot = [
  	"name"
  ];
  var source = [
  	"media",
  	"sizes",
  	"src",
  	"srcset",
  	"type"
  ];
  var style = [
  	"media",
  	"nonce",
  	"title",
  	"type"
  ];
  var table = [
  	"align",
  	"bgcolor",
  	"border",
  	"cellpadding",
  	"cellspacing",
  	"frame",
  	"rules",
  	"summary",
  	"width"
  ];
  var tbody = [
  	"align",
  	"char",
  	"charoff",
  	"valign"
  ];
  var td = [
  	"abbr",
  	"align",
  	"axis",
  	"bgcolor",
  	"char",
  	"charoff",
  	"colspan",
  	"headers",
  	"height",
  	"nowrap",
  	"rowspan",
  	"scope",
  	"valign",
  	"width"
  ];
  var textarea = [
  	"accesskey",
  	"autocomplete",
  	"autofocus",
  	"cols",
  	"dirname",
  	"disabled",
  	"form",
  	"maxlength",
  	"minlength",
  	"name",
  	"placeholder",
  	"readonly",
  	"required",
  	"rows",
  	"tabindex",
  	"wrap"
  ];
  var tfoot = [
  	"align",
  	"char",
  	"charoff",
  	"valign"
  ];
  var th = [
  	"abbr",
  	"align",
  	"axis",
  	"bgcolor",
  	"char",
  	"charoff",
  	"colspan",
  	"headers",
  	"height",
  	"nowrap",
  	"rowspan",
  	"scope",
  	"valign",
  	"width"
  ];
  var thead = [
  	"align",
  	"char",
  	"charoff",
  	"valign"
  ];
  var time = [
  	"datetime"
  ];
  var tr = [
  	"align",
  	"bgcolor",
  	"char",
  	"charoff",
  	"valign"
  ];
  var track = [
  	"default",
  	"kind",
  	"label",
  	"src",
  	"srclang"
  ];
  var ul = [
  	"compact",
  	"type"
  ];
  var video = [
  	"autoplay",
  	"controls",
  	"crossorigin",
  	"height",
  	"loop",
  	"muted",
  	"playsinline",
  	"poster",
  	"preload",
  	"src",
  	"width"
  ];
  var index$1 = {
  	"*": [
  	"accesskey",
  	"autocapitalize",
  	"autofocus",
  	"class",
  	"contenteditable",
  	"dir",
  	"draggable",
  	"enterkeyhint",
  	"hidden",
  	"id",
  	"inputmode",
  	"is",
  	"itemid",
  	"itemprop",
  	"itemref",
  	"itemscope",
  	"itemtype",
  	"lang",
  	"nonce",
  	"slot",
  	"spellcheck",
  	"style",
  	"tabindex",
  	"title",
  	"translate"
  ],
  	a: a,
  	abbr: abbr,
  	applet: applet,
  	area: area,
  	audio: audio,
  	base: base,
  	basefont: basefont,
  	bdo: bdo,
  	blockquote: blockquote,
  	body: body,
  	br: br,
  	button: button,
  	canvas: canvas,
  	caption: caption,
  	col: col,
  	colgroup: colgroup,
  	data: data,
  	del: del,
  	details: details,
  	dfn: dfn,
  	dialog: dialog,
  	dir: dir,
  	div: div,
  	dl: dl,
  	embed: embed$1,
  	fieldset: fieldset,
  	font: font,
  	form: form,
  	frame: frame,
  	frameset: frameset,
  	h1: h1,
  	h2: h2,
  	h3: h3,
  	h4: h4,
  	h5: h5,
  	h6: h6,
  	head: head,
  	hr: hr,
  	html: html,
  	iframe: iframe,
  	img: img,
  	input: input,
  	ins: ins,
  	isindex: isindex,
  	label: label,
  	legend: legend,
  	li: li,
  	link: link$1,
  	map: map,
  	menu: menu,
  	meta: meta,
  	meter: meter,
  	object: object,
  	ol: ol,
  	optgroup: optgroup,
  	option: option,
  	output: output,
  	p: p,
  	param: param,
  	pre: pre,
  	progress: progress,
  	q: q,
  	script: script,
  	select: select,
  	slot: slot,
  	source: source,
  	style: style,
  	table: table,
  	tbody: tbody,
  	td: td,
  	textarea: textarea,
  	tfoot: tfoot,
  	th: th,
  	thead: thead,
  	time: time,
  	tr: tr,
  	track: track,
  	ul: ul,
  	video: video
  };

  var htmlElementAttributes = /*#__PURE__*/Object.freeze({
    __proto__: null,
    a: a,
    abbr: abbr,
    applet: applet,
    area: area,
    audio: audio,
    base: base,
    basefont: basefont,
    bdo: bdo,
    blockquote: blockquote,
    body: body,
    br: br,
    button: button,
    canvas: canvas,
    caption: caption,
    col: col,
    colgroup: colgroup,
    data: data,
    del: del,
    details: details,
    dfn: dfn,
    dialog: dialog,
    dir: dir,
    div: div,
    dl: dl,
    embed: embed$1,
    fieldset: fieldset,
    font: font,
    form: form,
    frame: frame,
    frameset: frameset,
    h1: h1,
    h2: h2,
    h3: h3,
    h4: h4,
    h5: h5,
    h6: h6,
    head: head,
    hr: hr,
    html: html,
    iframe: iframe,
    img: img,
    input: input,
    ins: ins,
    isindex: isindex,
    label: label,
    legend: legend,
    li: li,
    link: link$1,
    map: map,
    menu: menu,
    meta: meta,
    meter: meter,
    object: object,
    ol: ol,
    optgroup: optgroup,
    option: option,
    output: output,
    p: p,
    param: param,
    pre: pre,
    progress: progress,
    q: q,
    script: script,
    select: select,
    slot: slot,
    source: source,
    style: style,
    table: table,
    tbody: tbody,
    td: td,
    textarea: textarea,
    tfoot: tfoot,
    th: th,
    thead: thead,
    time: time,
    tr: tr,
    track: track,
    ul: ul,
    video: video,
    'default': index$1
  });

  var htmlElementAttributes$1 = getCjsExportFromNamespace(htmlElementAttributes);

  var CSS_DISPLAY_TAGS = json.CSS_DISPLAY_TAGS,
      CSS_DISPLAY_DEFAULT = json.CSS_DISPLAY_DEFAULT,
      CSS_WHITE_SPACE_TAGS = json.CSS_WHITE_SPACE_TAGS,
      CSS_WHITE_SPACE_DEFAULT = json.CSS_WHITE_SPACE_DEFAULT;
  var HTML_TAGS = arrayToMap(htmlTagNames$1);
  var HTML_ELEMENT_ATTRIBUTES = mapObject(htmlElementAttributes$1, arrayToMap);

  function arrayToMap(array) {
    var map = Object.create(null);
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = array[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var value = _step.value;
        map[value] = true;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return map;
  }

  function mapObject(object, fn) {
    var newObject = Object.create(null);

    for (var _i = 0, _Object$keys = Object.keys(object); _i < _Object$keys.length; _i++) {
      var key = _Object$keys[_i];
      newObject[key] = fn(object[key], key);
    }

    return newObject;
  }

  function shouldPreserveContent(node, options) {
    if (node.type === "element" && node.fullName === "template" && node.attrMap.lang && node.attrMap.lang !== "html") {
      return true;
    } // unterminated node in ie conditional comment
    // e.g. <!--[if lt IE 9]><html><![endif]-->


    if (node.type === "ieConditionalComment" && node.lastChild && !node.lastChild.isSelfClosing && !node.lastChild.endSourceSpan) {
      return true;
    } // incomplete html in ie conditional comment
    // e.g. <!--[if lt IE 9]></div><![endif]-->


    if (node.type === "ieConditionalComment" && !node.complete) {
      return true;
    } // top-level elements (excluding <template>, <style> and <script>) in Vue SFC are considered custom block
    // custom blocks can be written in other languages so we should preserve them to not break the code


    if (options.parser === "vue" && node.type === "element" && node.parent.type === "root" && ["template", "style", "script", // vue parser can be used for vue dom template as well, so we should still format top-level <html>
    "html"].indexOf(node.fullName) === -1) {
      return true;
    } // TODO: handle non-text children in <pre>


    if (isPreLikeNode(node) && node.children.some(function (child) {
      return child.type !== "text" && child.type !== "interpolation";
    })) {
      return true;
    }

    return false;
  }

  function hasPrettierIgnore(node) {
    if (node.type === "attribute" || isTextLikeNode(node)) {
      return false;
    }

    if (!node.parent) {
      return false;
    }

    if (typeof node.index !== "number" || node.index === 0) {
      return false;
    }

    var prevNode = node.parent.children[node.index - 1];
    return isPrettierIgnore(prevNode);
  }

  function isPrettierIgnore(node) {
    return node.type === "comment" && node.value.trim() === "prettier-ignore";
  }

  function getPrettierIgnoreAttributeCommentData(value) {
    var match = value.trim().match(/^prettier-ignore-attribute(?:\s+([^]+))?$/);

    if (!match) {
      return false;
    }

    if (!match[1]) {
      return true;
    }

    return match[1].split(/\s+/);
  }
  /** there's no opening/closing tag or it's considered not breakable */


  function isTextLikeNode(node) {
    return node.type === "text" || node.type === "comment";
  }

  function isScriptLikeTag(node) {
    return node.type === "element" && (node.fullName === "script" || node.fullName === "style" || node.fullName === "svg:style");
  }

  function isFrontMatterNode(node) {
    return node.type === "yaml" || node.type === "toml";
  }

  function canHaveInterpolation(node) {
    return node.children && !isScriptLikeTag(node);
  }

  function isWhitespaceSensitiveNode(node) {
    return isScriptLikeTag(node) || node.type === "interpolation" || isIndentationSensitiveNode(node);
  }

  function isIndentationSensitiveNode(node) {
    return getNodeCssStyleWhiteSpace(node).startsWith("pre");
  }

  function isLeadingSpaceSensitiveNode(node) {
    var isLeadingSpaceSensitive = _isLeadingSpaceSensitiveNode();

    if (isLeadingSpaceSensitive && !node.prev && node.parent && node.parent.tagDefinition && node.parent.tagDefinition.ignoreFirstLf) {
      return node.type === "interpolation";
    }

    return isLeadingSpaceSensitive;

    function _isLeadingSpaceSensitiveNode() {
      if (isFrontMatterNode(node)) {
        return false;
      }

      if ((node.type === "text" || node.type === "interpolation") && node.prev && (node.prev.type === "text" || node.prev.type === "interpolation")) {
        return true;
      }

      if (!node.parent || node.parent.cssDisplay === "none") {
        return false;
      }

      if (isPreLikeNode(node.parent)) {
        return true;
      }

      if (!node.prev && (node.parent.type === "root" || isScriptLikeTag(node.parent) || !isFirstChildLeadingSpaceSensitiveCssDisplay(node.parent.cssDisplay))) {
        return false;
      }

      if (node.prev && !isNextLeadingSpaceSensitiveCssDisplay(node.prev.cssDisplay)) {
        return false;
      }

      return true;
    }
  }

  function isTrailingSpaceSensitiveNode(node) {
    if (isFrontMatterNode(node)) {
      return false;
    }

    if ((node.type === "text" || node.type === "interpolation") && node.next && (node.next.type === "text" || node.next.type === "interpolation")) {
      return true;
    }

    if (!node.parent || node.parent.cssDisplay === "none") {
      return false;
    }

    if (isPreLikeNode(node.parent)) {
      return true;
    }

    if (!node.next && (node.parent.type === "root" || isScriptLikeTag(node.parent) || !isLastChildTrailingSpaceSensitiveCssDisplay(node.parent.cssDisplay))) {
      return false;
    }

    if (node.next && !isPrevTrailingSpaceSensitiveCssDisplay(node.next.cssDisplay)) {
      return false;
    }

    return true;
  }

  function isDanglingSpaceSensitiveNode(node) {
    return isDanglingSpaceSensitiveCssDisplay(node.cssDisplay) && !isScriptLikeTag(node);
  }

  function forceNextEmptyLine(node) {
    return isFrontMatterNode(node) || node.next && node.sourceSpan.end.line + 1 < node.next.sourceSpan.start.line;
  }
  /** firstChild leadingSpaces and lastChild trailingSpaces */


  function forceBreakContent(node) {
    return forceBreakChildren(node) || node.type === "element" && node.children.length !== 0 && (["body", "script", "style"].indexOf(node.name) !== -1 || node.children.some(function (child) {
      return hasNonTextChild(child);
    })) || node.firstChild && node.firstChild === node.lastChild && hasLeadingLineBreak(node.firstChild) && (!node.lastChild.isTrailingSpaceSensitive || hasTrailingLineBreak(node.lastChild));
  }
  /** spaces between children */


  function forceBreakChildren(node) {
    return node.type === "element" && node.children.length !== 0 && (["html", "head", "ul", "ol", "select"].indexOf(node.name) !== -1 || node.cssDisplay.startsWith("table") && node.cssDisplay !== "table-cell");
  }

  function preferHardlineAsLeadingSpaces(node) {
    return preferHardlineAsSurroundingSpaces(node) || node.prev && preferHardlineAsTrailingSpaces(node.prev) || hasSurroundingLineBreak(node);
  }

  function preferHardlineAsTrailingSpaces(node) {
    return preferHardlineAsSurroundingSpaces(node) || node.type === "element" && node.fullName === "br" || hasSurroundingLineBreak(node);
  }

  function hasSurroundingLineBreak(node) {
    return hasLeadingLineBreak(node) && hasTrailingLineBreak(node);
  }

  function hasLeadingLineBreak(node) {
    return node.hasLeadingSpaces && (node.prev ? node.prev.sourceSpan.end.line < node.sourceSpan.start.line : node.parent.type === "root" || node.parent.startSourceSpan.end.line < node.sourceSpan.start.line);
  }

  function hasTrailingLineBreak(node) {
    return node.hasTrailingSpaces && (node.next ? node.next.sourceSpan.start.line > node.sourceSpan.end.line : node.parent.type === "root" || node.parent.endSourceSpan.start.line > node.sourceSpan.end.line);
  }

  function preferHardlineAsSurroundingSpaces(node) {
    switch (node.type) {
      case "ieConditionalComment":
      case "comment":
      case "directive":
        return true;

      case "element":
        return ["script", "select"].indexOf(node.name) !== -1;
    }

    return false;
  }

  function getLastDescendant(node) {
    return node.lastChild ? getLastDescendant(node.lastChild) : node;
  }

  function hasNonTextChild(node) {
    return node.children && node.children.some(function (child) {
      return child.type !== "text";
    });
  }

  function inferScriptParser(node) {
    if (node.name === "script" && !node.attrMap.src) {
      if (!node.attrMap.lang && !node.attrMap.type || node.attrMap.type === "module" || node.attrMap.type === "text/javascript" || node.attrMap.type === "text/babel" || node.attrMap.type === "application/javascript") {
        return "babel";
      }

      if (node.attrMap.type === "application/x-typescript" || node.attrMap.lang === "ts" || node.attrMap.lang === "tsx") {
        return "typescript";
      }

      if (node.attrMap.type === "text/markdown") {
        return "markdown";
      }

      if (node.attrMap.type.endsWith("json") || node.attrMap.type.endsWith("importmap")) {
        return "json";
      }
    }

    if (node.name === "style") {
      if (!node.attrMap.lang || node.attrMap.lang === "postcss" || node.attrMap.lang === "css") {
        return "css";
      }

      if (node.attrMap.lang === "scss") {
        return "scss";
      }

      if (node.attrMap.lang === "less") {
        return "less";
      }
    }

    return null;
  }

  function isBlockLikeCssDisplay(cssDisplay) {
    return cssDisplay === "block" || cssDisplay === "list-item" || cssDisplay.startsWith("table");
  }

  function isFirstChildLeadingSpaceSensitiveCssDisplay(cssDisplay) {
    return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== "inline-block";
  }

  function isLastChildTrailingSpaceSensitiveCssDisplay(cssDisplay) {
    return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== "inline-block";
  }

  function isPrevTrailingSpaceSensitiveCssDisplay(cssDisplay) {
    return !isBlockLikeCssDisplay(cssDisplay);
  }

  function isNextLeadingSpaceSensitiveCssDisplay(cssDisplay) {
    return !isBlockLikeCssDisplay(cssDisplay);
  }

  function isDanglingSpaceSensitiveCssDisplay(cssDisplay) {
    return !isBlockLikeCssDisplay(cssDisplay) && cssDisplay !== "inline-block";
  }

  function isPreLikeNode(node) {
    return getNodeCssStyleWhiteSpace(node).startsWith("pre");
  }

  function countParents(path) {
    var predicate = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
      return true;
    };
    var counter = 0;

    for (var i = path.stack.length - 1; i >= 0; i--) {
      var value = path.stack[i];

      if (value && _typeof(value) === "object" && !Array.isArray(value) && predicate(value)) {
        counter++;
      }
    }

    return counter;
  }

  function hasParent(node, fn) {
    var current = node;

    while (current) {
      if (fn(current)) {
        return true;
      }

      current = current.parent;
    }

    return false;
  }

  function getNodeCssStyleDisplay(node, options) {
    if (node.prev && node.prev.type === "comment") {
      // <!-- display: block -->
      var match = node.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);

      if (match) {
        return match[1];
      }
    }

    var isInSvgForeignObject = false;

    if (node.type === "element" && node.namespace === "svg") {
      if (hasParent(node, function (parent) {
        return parent.fullName === "svg:foreignObject";
      })) {
        isInSvgForeignObject = true;
      } else {
        return node.name === "svg" ? "inline-block" : "block";
      }
    }

    switch (options.htmlWhitespaceSensitivity) {
      case "strict":
        return "inline";

      case "ignore":
        return "block";

      default:
        return node.type === "element" && (!node.namespace || isInSvgForeignObject) && CSS_DISPLAY_TAGS[node.name] || CSS_DISPLAY_DEFAULT;
    }
  }

  function getNodeCssStyleWhiteSpace(node) {
    return node.type === "element" && !node.namespace && CSS_WHITE_SPACE_TAGS[node.name] || CSS_WHITE_SPACE_DEFAULT;
  }

  function getMinIndentation(text) {
    var minIndentation = Infinity;
    var _iteratorNormalCompletion2 = true;
    var _didIteratorError2 = false;
    var _iteratorError2 = undefined;

    try {
      for (var _iterator2 = text.split("\n")[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
        var lineText = _step2.value;

        if (lineText.length === 0) {
          continue;
        }

        if (/\S/.test(lineText[0])) {
          return 0;
        }

        var indentation = lineText.match(/^\s*/)[0].length;

        if (lineText.length === indentation) {
          continue;
        }

        if (indentation < minIndentation) {
          minIndentation = indentation;
        }
      }
    } catch (err) {
      _didIteratorError2 = true;
      _iteratorError2 = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
          _iterator2.return();
        }
      } finally {
        if (_didIteratorError2) {
          throw _iteratorError2;
        }
      }
    }

    return minIndentation === Infinity ? 0 : minIndentation;
  }

  function dedentString(text) {
    var minIndent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : getMinIndentation(text);
    return minIndent === 0 ? text : text.split("\n").map(function (lineText) {
      return lineText.slice(minIndent);
    }).join("\n");
  }

  function normalizeParts(parts) {
    var newParts = [];
    var restParts = parts.slice();

    while (restParts.length !== 0) {
      var part = restParts.shift();

      if (!part) {
        continue;
      }

      if (part.type === "concat") {
        Array.prototype.unshift.apply(restParts, part.parts);
        continue;
      }

      if (newParts.length !== 0 && typeof newParts[newParts.length - 1] === "string" && typeof part === "string") {
        newParts.push(newParts.pop() + part);
        continue;
      }

      newParts.push(part);
    }

    return newParts;
  }

  function identity(x) {
    return x;
  }

  function shouldNotPrintClosingTag(node, options) {
    return !node.isSelfClosing && !node.endSourceSpan && (hasPrettierIgnore(node) || shouldPreserveContent(node.parent, options));
  }

  function countChars(text, char) {
    var counter = 0;

    for (var i = 0; i < text.length; i++) {
      if (text[i] === char) {
        counter++;
      }
    }

    return counter;
  }

  function unescapeQuoteEntities(text) {
    return text.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
  }

  var utils$3 = {
    HTML_ELEMENT_ATTRIBUTES: HTML_ELEMENT_ATTRIBUTES,
    HTML_TAGS: HTML_TAGS,
    canHaveInterpolation: canHaveInterpolation,
    countChars: countChars,
    countParents: countParents,
    dedentString: dedentString,
    forceBreakChildren: forceBreakChildren,
    forceBreakContent: forceBreakContent,
    forceNextEmptyLine: forceNextEmptyLine,
    getLastDescendant: getLastDescendant,
    getNodeCssStyleDisplay: getNodeCssStyleDisplay,
    getNodeCssStyleWhiteSpace: getNodeCssStyleWhiteSpace,
    getPrettierIgnoreAttributeCommentData: getPrettierIgnoreAttributeCommentData,
    hasPrettierIgnore: hasPrettierIgnore,
    identity: identity,
    inferScriptParser: inferScriptParser,
    isDanglingSpaceSensitiveNode: isDanglingSpaceSensitiveNode,
    isFrontMatterNode: isFrontMatterNode,
    isIndentationSensitiveNode: isIndentationSensitiveNode,
    isLeadingSpaceSensitiveNode: isLeadingSpaceSensitiveNode,
    isPreLikeNode: isPreLikeNode,
    isScriptLikeTag: isScriptLikeTag,
    isTextLikeNode: isTextLikeNode,
    isTrailingSpaceSensitiveNode: isTrailingSpaceSensitiveNode,
    isWhitespaceSensitiveNode: isWhitespaceSensitiveNode,
    normalizeParts: normalizeParts,
    preferHardlineAsLeadingSpaces: preferHardlineAsLeadingSpaces,
    preferHardlineAsTrailingSpaces: preferHardlineAsTrailingSpaces,
    shouldNotPrintClosingTag: shouldNotPrintClosingTag,
    shouldPreserveContent: shouldPreserveContent,
    unescapeQuoteEntities: unescapeQuoteEntities
  };

  var canHaveInterpolation$1 = utils$3.canHaveInterpolation,
      getNodeCssStyleDisplay$1 = utils$3.getNodeCssStyleDisplay,
      isDanglingSpaceSensitiveNode$1 = utils$3.isDanglingSpaceSensitiveNode,
      isIndentationSensitiveNode$1 = utils$3.isIndentationSensitiveNode,
      isLeadingSpaceSensitiveNode$1 = utils$3.isLeadingSpaceSensitiveNode,
      isTrailingSpaceSensitiveNode$1 = utils$3.isTrailingSpaceSensitiveNode,
      isWhitespaceSensitiveNode$1 = utils$3.isWhitespaceSensitiveNode;
  var PREPROCESS_PIPELINE = [removeIgnorableFirstLf, mergeIeConditonalStartEndCommentIntoElementOpeningTag, mergeCdataIntoText, extractInterpolation, extractWhitespaces, addCssDisplay, addIsSelfClosing, addHasHtmComponentClosingTag, addIsSpaceSensitive, mergeSimpleElementIntoText];

  function preprocess(ast, options) {
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = PREPROCESS_PIPELINE[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var fn = _step.value;
        ast = fn(ast, options);
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return ast;
  }

  function removeIgnorableFirstLf(ast
  /*, options */
  ) {
    return ast.map(function (node) {
      if (node.type === "element" && node.tagDefinition.ignoreFirstLf && node.children.length !== 0 && node.children[0].type === "text" && node.children[0].value[0] === "\n") {
        var text = node.children[0];
        return node.clone({
          children: text.value.length === 1 ? node.children.slice(1) : [].concat(text.clone({
            value: text.value.slice(1)
          }), node.children.slice(1))
        });
      }

      return node;
    });
  }

  function mergeIeConditonalStartEndCommentIntoElementOpeningTag(ast
  /*, options */
  ) {
    /**
     *     <!--[if ...]><!--><target><!--<![endif]-->
     */
    var isTarget = function isTarget(node) {
      return node.type === "element" && node.prev && node.prev.type === "ieConditionalStartComment" && node.prev.sourceSpan.end.offset === node.startSourceSpan.start.offset && node.firstChild && node.firstChild.type === "ieConditionalEndComment" && node.firstChild.sourceSpan.start.offset === node.startSourceSpan.end.offset;
    };

    return ast.map(function (node) {
      if (node.children) {
        var isTargetResults = node.children.map(isTarget);

        if (isTargetResults.some(Boolean)) {
          var newChildren = [];

          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];

            if (isTargetResults[i + 1]) {
              // ieConditionalStartComment
              continue;
            }

            if (isTargetResults[i]) {
              var ieConditionalStartComment = child.prev;
              var ieConditionalEndComment = child.firstChild;
              var ParseSourceSpan = child.sourceSpan.constructor;
              var startSourceSpan = new ParseSourceSpan(ieConditionalStartComment.sourceSpan.start, ieConditionalEndComment.sourceSpan.end);
              var sourceSpan = new ParseSourceSpan(startSourceSpan.start, child.sourceSpan.end);
              newChildren.push(child.clone({
                condition: ieConditionalStartComment.condition,
                sourceSpan: sourceSpan,
                startSourceSpan: startSourceSpan,
                children: child.children.slice(1)
              }));
              continue;
            }

            newChildren.push(child);
          }

          return node.clone({
            children: newChildren
          });
        }
      }

      return node;
    });
  }

  function mergeNodeIntoText(ast, shouldMerge, getValue) {
    return ast.map(function (node) {
      if (node.children) {
        var shouldMergeResults = node.children.map(shouldMerge);

        if (shouldMergeResults.some(Boolean)) {
          var newChildren = [];

          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];

            if (child.type !== "text" && !shouldMergeResults[i]) {
              newChildren.push(child);
              continue;
            }

            var newChild = child.type === "text" ? child : child.clone({
              type: "text",
              value: getValue(child)
            });

            if (newChildren.length === 0 || newChildren[newChildren.length - 1].type !== "text") {
              newChildren.push(newChild);
              continue;
            }

            var lastChild = newChildren.pop();
            var ParseSourceSpan = lastChild.sourceSpan.constructor;
            newChildren.push(lastChild.clone({
              value: lastChild.value + newChild.value,
              sourceSpan: new ParseSourceSpan(lastChild.sourceSpan.start, newChild.sourceSpan.end)
            }));
          }

          return node.clone({
            children: newChildren
          });
        }
      }

      return node;
    });
  }

  function mergeCdataIntoText(ast
  /*, options */
  ) {
    return mergeNodeIntoText(ast, function (node) {
      return node.type === "cdata";
    }, function (node) {
      return "<![CDATA[".concat(node.value, "]]>");
    });
  }

  function mergeSimpleElementIntoText(ast
  /*, options */
  ) {
    var isSimpleElement = function isSimpleElement(node) {
      return node.type === "element" && node.attrs.length === 0 && node.children.length === 1 && node.firstChild.type === "text" && // \xA0: non-breaking whitespace
      !/[^\S\xA0]/.test(node.children[0].value) && !node.firstChild.hasLeadingSpaces && !node.firstChild.hasTrailingSpaces && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces && node.isTrailingSpaceSensitive && !node.hasTrailingSpaces && node.prev && node.prev.type === "text" && node.next && node.next.type === "text";
    };

    return ast.map(function (node) {
      if (node.children) {
        var isSimpleElementResults = node.children.map(isSimpleElement);

        if (isSimpleElementResults.some(Boolean)) {
          var newChildren = [];

          for (var i = 0; i < node.children.length; i++) {
            var child = node.children[i];

            if (isSimpleElementResults[i]) {
              var lastChild = newChildren.pop();
              var nextChild = node.children[++i];
              var ParseSourceSpan = node.sourceSpan.constructor;
              var isTrailingSpaceSensitive = nextChild.isTrailingSpaceSensitive,
                  hasTrailingSpaces = nextChild.hasTrailingSpaces;
              newChildren.push(lastChild.clone({
                value: lastChild.value + "<".concat(child.rawName, ">") + child.firstChild.value + "</".concat(child.rawName, ">") + nextChild.value,
                sourceSpan: new ParseSourceSpan(lastChild.sourceSpan.start, nextChild.sourceSpan.end),
                isTrailingSpaceSensitive: isTrailingSpaceSensitive,
                hasTrailingSpaces: hasTrailingSpaces
              }));
            } else {
              newChildren.push(child);
            }
          }

          return node.clone({
            children: newChildren
          });
        }
      }

      return node;
    });
  }

  function extractInterpolation(ast, options) {
    if (options.parser === "html") {
      return ast;
    }

    var interpolationRegex = /\{\{([\s\S]+?)\}\}/g;
    return ast.map(function (node) {
      if (!canHaveInterpolation$1(node)) {
        return node;
      }

      var newChildren = [];
      var _iteratorNormalCompletion2 = true;
      var _didIteratorError2 = false;
      var _iteratorError2 = undefined;

      try {
        for (var _iterator2 = node.children[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
          var child = _step2.value;

          if (child.type !== "text") {
            newChildren.push(child);
            continue;
          }

          var ParseSourceSpan = child.sourceSpan.constructor;
          var startSourceSpan = child.sourceSpan.start;
          var endSourceSpan = null;
          var components = child.value.split(interpolationRegex);

          for (var i = 0; i < components.length; i++, startSourceSpan = endSourceSpan) {
            var value = components[i];

            if (i % 2 === 0) {
              endSourceSpan = startSourceSpan.moveBy(value.length);

              if (value.length !== 0) {
                newChildren.push({
                  type: "text",
                  value: value,
                  sourceSpan: new ParseSourceSpan(startSourceSpan, endSourceSpan)
                });
              }

              continue;
            }

            endSourceSpan = startSourceSpan.moveBy(value.length + 4); // `{{` + `}}`

            newChildren.push({
              type: "interpolation",
              sourceSpan: new ParseSourceSpan(startSourceSpan, endSourceSpan),
              children: value.length === 0 ? [] : [{
                type: "text",
                value: value,
                sourceSpan: new ParseSourceSpan(startSourceSpan.moveBy(2), endSourceSpan.moveBy(-2))
              }]
            });
          }
        }
      } catch (err) {
        _didIteratorError2 = true;
        _iteratorError2 = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
            _iterator2.return();
          }
        } finally {
          if (_didIteratorError2) {
            throw _iteratorError2;
          }
        }
      }

      return node.clone({
        children: newChildren
      });
    });
  }
  /**
   * - add `hasLeadingSpaces` field
   * - add `hasTrailingSpaces` field
   * - add `hasDanglingSpaces` field for parent nodes
   * - add `isWhitespaceSensitive`, `isIndentationSensitive` field for text nodes
   * - remove insensitive whitespaces
   */


  function extractWhitespaces(ast
  /*, options*/
  ) {
    var TYPE_WHITESPACE = "whitespace";
    return ast.map(function (node) {
      if (!node.children) {
        return node;
      }

      if (node.children.length === 0 || node.children.length === 1 && node.children[0].type === "text" && node.children[0].value.trim().length === 0) {
        return node.clone({
          children: [],
          hasDanglingSpaces: node.children.length !== 0
        });
      }

      var isWhitespaceSensitive = isWhitespaceSensitiveNode$1(node);
      var isIndentationSensitive = isIndentationSensitiveNode$1(node);
      return node.clone({
        isWhitespaceSensitive: isWhitespaceSensitive,
        isIndentationSensitive: isIndentationSensitive,
        children: node.children // extract whitespace nodes
        .reduce(function (newChildren, child) {
          if (child.type !== "text" || isWhitespaceSensitive) {
            return newChildren.concat(child);
          }

          var localChildren = [];

          var _child$value$match = child.value.match(/^(\s*)([\s\S]*?)(\s*)$/),
              _child$value$match2 = _slicedToArray(_child$value$match, 4),
              leadingSpaces = _child$value$match2[1],
              text = _child$value$match2[2],
              trailingSpaces = _child$value$match2[3];

          if (leadingSpaces) {
            localChildren.push({
              type: TYPE_WHITESPACE
            });
          }

          var ParseSourceSpan = child.sourceSpan.constructor;

          if (text) {
            localChildren.push({
              type: "text",
              value: text,
              sourceSpan: new ParseSourceSpan(child.sourceSpan.start.moveBy(leadingSpaces.length), child.sourceSpan.end.moveBy(-trailingSpaces.length))
            });
          }

          if (trailingSpaces) {
            localChildren.push({
              type: TYPE_WHITESPACE
            });
          }

          return newChildren.concat(localChildren);
        }, []) // set hasLeadingSpaces/hasTrailingSpaces and filter whitespace nodes
        .reduce(function (newChildren, child, i, children) {
          if (child.type === TYPE_WHITESPACE) {
            return newChildren;
          }

          var hasLeadingSpaces = i !== 0 && children[i - 1].type === TYPE_WHITESPACE;
          var hasTrailingSpaces = i !== children.length - 1 && children[i + 1].type === TYPE_WHITESPACE;
          return newChildren.concat(Object.assign({}, child, {
            hasLeadingSpaces: hasLeadingSpaces,
            hasTrailingSpaces: hasTrailingSpaces
          }));
        }, [])
      });
    });
  }

  function addIsSelfClosing(ast
  /*, options */
  ) {
    return ast.map(function (node) {
      return Object.assign(node, {
        isSelfClosing: !node.children || node.type === "element" && (node.tagDefinition.isVoid || // self-closing
        node.startSourceSpan === node.endSourceSpan)
      });
    });
  }

  function addHasHtmComponentClosingTag(ast, options) {
    return ast.map(function (node) {
      return node.type !== "element" ? node : Object.assign(node, {
        hasHtmComponentClosingTag: node.endSourceSpan && /^<\s*\/\s*\/\s*>$/.test(options.originalText.slice(node.endSourceSpan.start.offset, node.endSourceSpan.end.offset))
      });
    });
  }

  function addCssDisplay(ast, options) {
    return ast.map(function (node) {
      return Object.assign(node, {
        cssDisplay: getNodeCssStyleDisplay$1(node, options)
      });
    });
  }
  /**
   * - add `isLeadingSpaceSensitive` field
   * - add `isTrailingSpaceSensitive` field
   * - add `isDanglingSpaceSensitive` field for parent nodes
   */


  function addIsSpaceSensitive(ast
  /*, options */
  ) {
    return ast.map(function (node) {
      if (!node.children) {
        return node;
      }

      if (node.children.length === 0) {
        return node.clone({
          isDanglingSpaceSensitive: isDanglingSpaceSensitiveNode$1(node)
        });
      }

      return node.clone({
        children: node.children.map(function (child) {
          return Object.assign({}, child, {
            isLeadingSpaceSensitive: isLeadingSpaceSensitiveNode$1(child),
            isTrailingSpaceSensitive: isTrailingSpaceSensitiveNode$1(child)
          });
        }).map(function (child, index, children) {
          return Object.assign({}, child, {
            isLeadingSpaceSensitive: index === 0 ? child.isLeadingSpaceSensitive : children[index - 1].isTrailingSpaceSensitive && child.isLeadingSpaceSensitive,
            isTrailingSpaceSensitive: index === children.length - 1 ? child.isTrailingSpaceSensitive : children[index + 1].isLeadingSpaceSensitive && child.isTrailingSpaceSensitive
          });
        })
      });
    });
  }

  var preprocess_1 = preprocess;

  function hasPragma$3(text) {
    return /^\s*<!--\s*@(format|prettier)\s*-->/.test(text);
  }

  function insertPragma$5(text) {
    return "<!-- @format -->\n\n" + text.replace(/^\s*\n/, "");
  }

  var pragma$3 = {
    hasPragma: hasPragma$3,
    insertPragma: insertPragma$5
  };

  var _require$$0$builders$4 = doc.builders,
      concat$8 = _require$$0$builders$4.concat,
      group$8 = _require$$0$builders$4.group;
  /**
   *     v-for="... in ..."
   *     v-for="... of ..."
   *     v-for="(..., ...) in ..."
   *     v-for="(..., ...) of ..."
   */

  function printVueFor(value, textToDoc) {
    var _parseVueFor = parseVueFor(value),
        left = _parseVueFor.left,
        operator = _parseVueFor.operator,
        right = _parseVueFor.right;

    return concat$8([group$8(textToDoc("function _(".concat(left, ") {}"), {
      parser: "babel",
      __isVueForBindingLeft: true
    })), " ", operator, " ", textToDoc(right, {
      parser: "__js_expression"
    })]);
  } // modified from https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/parser/index.js#L370-L387


  function parseVueFor(value) {
    var forAliasRE = /([^]*?)\s+(in|of)\s+([^]*)/;
    var forIteratorRE = /,([^,}\]]*)(?:,([^,}\]]*))?$/;
    var stripParensRE = /^\(|\)$/g;
    var inMatch = value.match(forAliasRE);

    if (!inMatch) {
      return;
    }

    var res = {};
    res.for = inMatch[3].trim();
    var alias = inMatch[1].trim().replace(stripParensRE, "");
    var iteratorMatch = alias.match(forIteratorRE);

    if (iteratorMatch) {
      res.alias = alias.replace(forIteratorRE, "");
      res.iterator1 = iteratorMatch[1].trim();

      if (iteratorMatch[2]) {
        res.iterator2 = iteratorMatch[2].trim();
      }
    } else {
      res.alias = alias;
    }

    return {
      left: "".concat([res.alias, res.iterator1, res.iterator2].filter(Boolean).join(",")),
      operator: inMatch[2],
      right: res.for
    };
  }

  function printVueSlotScope(value, textToDoc) {
    return textToDoc("function _(".concat(value, ") {}"), {
      parser: "babel",
      __isVueSlotScope: true
    });
  }

  function isVueEventBindingExpression(eventBindingValue) {
    // https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/codegen/events.js#L3-L4
    // arrow function or anonymous function
    var fnExpRE = /^([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/; // simple member expression chain (a, a.b, a['b'], a["b"], a[0], a[b])

    var simplePathRE = /^[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['[^']*?']|\["[^"]*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*$/; // https://github.com/vuejs/vue/blob/v2.5.17/src/compiler/helpers.js#L104

    var value = eventBindingValue.trim();
    return fnExpRE.test(value) || simplePathRE.test(value);
  }

  var syntaxVue = {
    isVueEventBindingExpression: isVueEventBindingExpression,
    printVueFor: printVueFor,
    printVueSlotScope: printVueSlotScope
  };

  var parseSrcset = createCommonjsModule(function (module) {
    /**
     * Srcset Parser
     *
     * By Alex Bell |  MIT License
     *
     * JS Parser for the string value that appears in markup <img srcset="here">
     *
     * @returns Array [{url: _, d: _, w: _, h:_}, ...]
     *
     * Based super duper closely on the reference algorithm at:
     * https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute
     *
     * Most comments are copied in directly from the spec
     * (except for comments in parens).
     */
    (function (root, factory) {
      if ( module.exports) {
        // Node. Does not work with strict CommonJS, but
        // only CommonJS-like environments that support module.exports,
        // like Node.
        module.exports = factory();
      } else {
        // Browser globals (root is window)
        root.parseSrcset = factory();
      }
    })(commonjsGlobal, function () {
      // 1. Let input be the value passed to this algorithm.
      return function (input, options) {
        var logger = options && options.logger || console; // UTILITY FUNCTIONS
        // Manual is faster than RegEx
        // http://bjorn.tipling.com/state-and-regular-expressions-in-javascript
        // http://jsperf.com/whitespace-character/5

        function isSpace(c) {
          return c === " " || // space
          c === "\t" || // horizontal tab
          c === "\n" || // new line
          c === "\f" || // form feed
          c === "\r"; // carriage return
        }

        function collectCharacters(regEx) {
          var chars,
              match = regEx.exec(input.substring(pos));

          if (match) {
            chars = match[0];
            pos += chars.length;
            return chars;
          }
        }

        var inputLength = input.length,
            // (Don't use \s, to avoid matching non-breaking space)
        regexLeadingSpaces = /^[ \t\n\r\u000c]+/,
            regexLeadingCommasOrSpaces = /^[, \t\n\r\u000c]+/,
            regexLeadingNotSpaces = /^[^ \t\n\r\u000c]+/,
            regexTrailingCommas = /[,]+$/,
            regexNonNegativeInteger = /^\d+$/,
            // ( Positive or negative or unsigned integers or decimals, without or without exponents.
        // Must include at least one digit.
        // According to spec tests any decimal point must be followed by a digit.
        // No leading plus sign is allowed.)
        // https://html.spec.whatwg.org/multipage/infrastructure.html#valid-floating-point-number
        regexFloatingPoint = /^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/,
            url,
            descriptors,
            currentDescriptor,
            state,
            c,
            // 2. Let position be a pointer into input, initially pointing at the start
        //    of the string.
        pos = 0,
            // 3. Let candidates be an initially empty source set.
        candidates = []; // 4. Splitting loop: Collect a sequence of characters that are space
        //    characters or U+002C COMMA characters. If any U+002C COMMA characters
        //    were collected, that is a parse error.

        while (true) {
          collectCharacters(regexLeadingCommasOrSpaces); // 5. If position is past the end of input, return candidates and abort these steps.

          if (pos >= inputLength) {
            return candidates; // (we're done, this is the sole return path)
          } // 6. Collect a sequence of characters that are not space characters,
          //    and let that be url.


          url = collectCharacters(regexLeadingNotSpaces); // 7. Let descriptors be a new empty list.

          descriptors = []; // 8. If url ends with a U+002C COMMA character (,), follow these substeps:
          //		(1). Remove all trailing U+002C COMMA characters from url. If this removed
          //         more than one character, that is a parse error.

          if (url.slice(-1) === ",") {
            url = url.replace(regexTrailingCommas, ""); // (Jump ahead to step 9 to skip tokenization and just push the candidate).

            parseDescriptors(); //	Otherwise, follow these substeps:
          } else {
            tokenize();
          } // (close else of step 8)
          // 16. Return to the step labeled splitting loop.

        } // (Close of big while loop.)

        /**
         * Tokenizes descriptor properties prior to parsing
         * Returns undefined.
         */


        function tokenize() {
          // 8.1. Descriptor tokeniser: Skip whitespace
          collectCharacters(regexLeadingSpaces); // 8.2. Let current descriptor be the empty string.

          currentDescriptor = ""; // 8.3. Let state be in descriptor.

          state = "in descriptor";

          while (true) {
            // 8.4. Let c be the character at position.
            c = input.charAt(pos); //  Do the following depending on the value of state.
            //  For the purpose of this step, "EOF" is a special character representing
            //  that position is past the end of input.
            // In descriptor

            if (state === "in descriptor") {
              // Do the following, depending on the value of c:
              // Space character
              // If current descriptor is not empty, append current descriptor to
              // descriptors and let current descriptor be the empty string.
              // Set state to after descriptor.
              if (isSpace(c)) {
                if (currentDescriptor) {
                  descriptors.push(currentDescriptor);
                  currentDescriptor = "";
                  state = "after descriptor";
                } // U+002C COMMA (,)
                // Advance position to the next character in input. If current descriptor
                // is not empty, append current descriptor to descriptors. Jump to the step
                // labeled descriptor parser.

              } else if (c === ",") {
                pos += 1;

                if (currentDescriptor) {
                  descriptors.push(currentDescriptor);
                }

                parseDescriptors();
                return; // U+0028 LEFT PARENTHESIS (()
                // Append c to current descriptor. Set state to in parens.
              } else if (c === "(") {
                currentDescriptor = currentDescriptor + c;
                state = "in parens"; // EOF
                // If current descriptor is not empty, append current descriptor to
                // descriptors. Jump to the step labeled descriptor parser.
              } else if (c === "") {
                if (currentDescriptor) {
                  descriptors.push(currentDescriptor);
                }

                parseDescriptors();
                return; // Anything else
                // Append c to current descriptor.
              } else {
                currentDescriptor = currentDescriptor + c;
              } // (end "in descriptor"
              // In parens

            } else if (state === "in parens") {
              // U+0029 RIGHT PARENTHESIS ())
              // Append c to current descriptor. Set state to in descriptor.
              if (c === ")") {
                currentDescriptor = currentDescriptor + c;
                state = "in descriptor"; // EOF
                // Append current descriptor to descriptors. Jump to the step labeled
                // descriptor parser.
              } else if (c === "") {
                descriptors.push(currentDescriptor);
                parseDescriptors();
                return; // Anything else
                // Append c to current descriptor.
              } else {
                currentDescriptor = currentDescriptor + c;
              } // After descriptor

            } else if (state === "after descriptor") {
              // Do the following, depending on the value of c:
              // Space character: Stay in this state.
              if (isSpace(c)) ; else if (c === "") {
                parseDescriptors();
                return; // Anything else
                // Set state to in descriptor. Set position to the previous character in input.
              } else {
                state = "in descriptor";
                pos -= 1;
              }
            } // Advance position to the next character in input.


            pos += 1; // Repeat this step.
          } // (close while true loop)

        }
        /**
         * Adds descriptor properties to a candidate, pushes to the candidates array
         * @return undefined
         */
        // Declared outside of the while loop so that it's only created once.


        function parseDescriptors() {
          // 9. Descriptor parser: Let error be no.
          var pError = false,
              // 10. Let width be absent.
          // 11. Let density be absent.
          // 12. Let future-compat-h be absent. (We're implementing it now as h)
          w,
              d,
              h,
              i,
              candidate = {},
              desc,
              lastChar,
              value,
              intVal,
              floatVal; // 13. For each descriptor in descriptors, run the appropriate set of steps
          // from the following list:

          for (i = 0; i < descriptors.length; i++) {
            desc = descriptors[i];
            lastChar = desc[desc.length - 1];
            value = desc.substring(0, desc.length - 1);
            intVal = parseInt(value, 10);
            floatVal = parseFloat(value); // If the descriptor consists of a valid non-negative integer followed by
            // a U+0077 LATIN SMALL LETTER W character

            if (regexNonNegativeInteger.test(value) && lastChar === "w") {
              // If width and density are not both absent, then let error be yes.
              if (w || d) {
                pError = true;
              } // Apply the rules for parsing non-negative integers to the descriptor.
              // If the result is zero, let error be yes.
              // Otherwise, let width be the result.


              if (intVal === 0) {
                pError = true;
              } else {
                w = intVal;
              } // If the descriptor consists of a valid floating-point number followed by
              // a U+0078 LATIN SMALL LETTER X character

            } else if (regexFloatingPoint.test(value) && lastChar === "x") {
              // If width, density and future-compat-h are not all absent, then let error
              // be yes.
              if (w || d || h) {
                pError = true;
              } // Apply the rules for parsing floating-point number values to the descriptor.
              // If the result is less than zero, let error be yes. Otherwise, let density
              // be the result.


              if (floatVal < 0) {
                pError = true;
              } else {
                d = floatVal;
              } // If the descriptor consists of a valid non-negative integer followed by
              // a U+0068 LATIN SMALL LETTER H character

            } else if (regexNonNegativeInteger.test(value) && lastChar === "h") {
              // If height and density are not both absent, then let error be yes.
              if (h || d) {
                pError = true;
              } // Apply the rules for parsing non-negative integers to the descriptor.
              // If the result is zero, let error be yes. Otherwise, let future-compat-h
              // be the result.


              if (intVal === 0) {
                pError = true;
              } else {
                h = intVal;
              } // Anything else, Let error be yes.

            } else {
              pError = true;
            }
          } // (close step 13 for loop)
          // 15. If error is still no, then append a new image source to candidates whose
          // URL is url, associated with a width width if not absent and a pixel
          // density density if not absent. Otherwise, there is a parse error.


          if (!pError) {
            candidate.url = url;

            if (w) {
              candidate.w = w;
            }

            if (d) {
              candidate.d = d;
            }

            if (h) {
              candidate.h = h;
            }

            candidates.push(candidate);
          } else if (logger && logger.error) {
            logger.error("Invalid srcset descriptor found in '" + input + "' at '" + desc + "'.");
          }
        } // (close parseDescriptors fn)

      };
    });
  });

  var _require$$0$builders$5 = doc.builders,
      concat$9 = _require$$0$builders$5.concat,
      ifBreak$4 = _require$$0$builders$5.ifBreak,
      join$5 = _require$$0$builders$5.join,
      line$4 = _require$$0$builders$5.line;

  function printImgSrcset(value) {
    var srcset = parseSrcset(value, {
      logger: {
        error: function error(message) {
          throw new Error(message);
        }
      }
    });
    var hasW = srcset.some(function (src) {
      return src.w;
    });
    var hasH = srcset.some(function (src) {
      return src.h;
    });
    var hasX = srcset.some(function (src) {
      return src.d;
    });

    if (hasW + hasH + hasX !== 1) {
      throw new Error("Mixed descriptor in srcset is not supported");
    }

    var key = hasW ? "w" : hasH ? "h" : "d";
    var unit = hasW ? "w" : hasH ? "h" : "x";

    var getMax = function getMax(values) {
      return Math.max.apply(Math, values);
    };

    var urls = srcset.map(function (src) {
      return src.url;
    });
    var maxUrlLength = getMax(urls.map(function (url) {
      return url.length;
    }));
    var descriptors = srcset.map(function (src) {
      return src[key];
    }).map(function (descriptor) {
      return descriptor ? descriptor.toString() : "";
    });
    var descriptorLeftLengths = descriptors.map(function (descriptor) {
      var index = descriptor.indexOf(".");
      return index === -1 ? descriptor.length : index;
    });
    var maxDescriptorLeftLength = getMax(descriptorLeftLengths);
    return join$5(concat$9([",", line$4]), urls.map(function (url, index) {
      var parts = [url];
      var descriptor = descriptors[index];

      if (descriptor) {
        var urlPadding = maxUrlLength - url.length + 1;
        var descriptorPadding = maxDescriptorLeftLength - descriptorLeftLengths[index];
        var alignment = " ".repeat(urlPadding + descriptorPadding);
        parts.push(ifBreak$4(alignment, " "), descriptor + unit);
      }

      return concat$9(parts);
    }));
  }

  var syntaxAttribute = {
    printImgSrcset: printImgSrcset
  };

  var builders = doc.builders,
      _require$$0$utils = doc.utils,
      stripTrailingHardline$1 = _require$$0$utils.stripTrailingHardline,
      mapDoc$4 = _require$$0$utils.mapDoc;
  var breakParent$2 = builders.breakParent,
      dedentToRoot$1 = builders.dedentToRoot,
      fill$3 = builders.fill,
      group$9 = builders.group,
      hardline$7 = builders.hardline,
      ifBreak$5 = builders.ifBreak,
      indent$5 = builders.indent,
      join$6 = builders.join,
      line$5 = builders.line,
      literalline$2 = builders.literalline,
      markAsRoot$2 = builders.markAsRoot,
      softline$4 = builders.softline;
  var countChars$1 = utils$3.countChars,
      countParents$1 = utils$3.countParents,
      dedentString$1 = utils$3.dedentString,
      forceBreakChildren$1 = utils$3.forceBreakChildren,
      forceBreakContent$1 = utils$3.forceBreakContent,
      forceNextEmptyLine$1 = utils$3.forceNextEmptyLine,
      getLastDescendant$1 = utils$3.getLastDescendant,
      getPrettierIgnoreAttributeCommentData$1 = utils$3.getPrettierIgnoreAttributeCommentData,
      hasPrettierIgnore$1 = utils$3.hasPrettierIgnore,
      inferScriptParser$1 = utils$3.inferScriptParser,
      isScriptLikeTag$1 = utils$3.isScriptLikeTag,
      isTextLikeNode$1 = utils$3.isTextLikeNode,
      normalizeParts$1 = utils$3.normalizeParts,
      preferHardlineAsLeadingSpaces$1 = utils$3.preferHardlineAsLeadingSpaces,
      shouldNotPrintClosingTag$1 = utils$3.shouldNotPrintClosingTag,
      shouldPreserveContent$1 = utils$3.shouldPreserveContent,
      unescapeQuoteEntities$1 = utils$3.unescapeQuoteEntities;
  var replaceEndOfLineWith$1 = util.replaceEndOfLineWith;
  var insertPragma$6 = pragma$3.insertPragma;
  var printVueFor$1 = syntaxVue.printVueFor,
      printVueSlotScope$1 = syntaxVue.printVueSlotScope,
      isVueEventBindingExpression$1 = syntaxVue.isVueEventBindingExpression;
  var printImgSrcset$1 = syntaxAttribute.printImgSrcset;

  function concat$a(parts) {
    var newParts = normalizeParts$1(parts);
    return newParts.length === 0 ? "" : newParts.length === 1 ? newParts[0] : builders.concat(newParts);
  }

  function embed$2(path, print, textToDoc, options) {
    var node = path.getValue();

    switch (node.type) {
      case "text":
        {
          if (isScriptLikeTag$1(node.parent)) {
            var parser = inferScriptParser$1(node.parent);

            if (parser) {
              var value = parser === "markdown" ? dedentString$1(node.value.replace(/^[^\S\n]*?\n/, "")) : node.value;
              return builders.concat([concat$a([breakParent$2, printOpeningTagPrefix(node, options), stripTrailingHardline$1(textToDoc(value, {
                parser: parser
              })), printClosingTagSuffix(node, options)])]);
            }
          } else if (node.parent.type === "interpolation") {
            return concat$a([indent$5(concat$a([line$5, textToDoc(node.value, Object.assign({
              __isInHtmlInterpolation: true // to avoid unexpected `}}`

            }, options.parser === "angular" ? {
              parser: "__ng_interpolation",
              trailingComma: "none"
            } : options.parser === "vue" ? {
              parser: "__vue_expression"
            } : {
              parser: "__js_expression"
            }))])), node.parent.next && needsToBorrowPrevClosingTagEndMarker(node.parent.next) ? " " : line$5]);
          }

          break;
        }

      case "attribute":
        {
          if (!node.value) {
            break;
          } // lit-html: html`<my-element obj=${obj}></my-element>`


          if (/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(options.originalText.slice(node.valueSpan.start.offset, node.valueSpan.end.offset))) {
            return concat$a([node.rawName, "=", node.value]);
          } // lwc: html`<my-element data-for={value}></my-element>`


          if (options.parser === "lwc") {
            var interpolationRegex = /^\{[\s\S]*\}$/;

            if (interpolationRegex.test(options.originalText.slice(node.valueSpan.start.offset, node.valueSpan.end.offset))) {
              return concat$a([node.rawName, "=", node.value]);
            }
          }

          var embeddedAttributeValueDoc = printEmbeddedAttributeValue(node, function (code, opts) {
            return (// strictly prefer single quote to avoid unnecessary html entity escape
              textToDoc(code, Object.assign({
                __isInHtmlAttribute: true
              }, opts))
            );
          }, options);

          if (embeddedAttributeValueDoc) {
            return concat$a([node.rawName, '="', group$9(mapDoc$4(embeddedAttributeValueDoc, function (doc) {
              return typeof doc === "string" ? doc.replace(/"/g, "&quot;") : doc;
            })), '"']);
          }

          break;
        }

      case "yaml":
        return markAsRoot$2(concat$a(["---", hardline$7, node.value.trim().length === 0 ? "" : textToDoc(node.value, {
          parser: "yaml"
        }), "---"]));
    }
  }

  function genericPrint$2(path, options, print) {
    var node = path.getValue();

    switch (node.type) {
      case "root":
        // use original concat to not break stripTrailingHardline
        return builders.concat([group$9(printChildren$1(path, options, print)), hardline$7]);

      case "element":
      case "ieConditionalComment":
        {
          /**
           * do not break:
           *
           *     <div>{{
           *         ~
           *       interpolation
           *     }}</div>
           *            ~
           *
           * exception: break if the opening tag breaks
           *
           *     <div
           *       long
           *           ~
           *       >{{
           *         interpolation
           *       }}</div
           *              ~
           *     >
           */
          var shouldHugContent = node.children.length === 1 && node.firstChild.type === "interpolation" && node.firstChild.isLeadingSpaceSensitive && !node.firstChild.hasLeadingSpaces && node.lastChild.isTrailingSpaceSensitive && !node.lastChild.hasTrailingSpaces;
          var attrGroupId = Symbol("element-attr-group-id");
          return concat$a([group$9(concat$a([group$9(printOpeningTag(path, options, print), {
            id: attrGroupId
          }), node.children.length === 0 ? node.hasDanglingSpaces && node.isDanglingSpaceSensitive ? line$5 : "" : concat$a([forceBreakContent$1(node) ? breakParent$2 : "", function (childrenDoc) {
            return shouldHugContent ? ifBreak$5(indent$5(childrenDoc), childrenDoc, {
              groupId: attrGroupId
            }) : isScriptLikeTag$1(node) && node.parent.type === "root" && options.parser === "vue" && !options.vueIndentScriptAndStyle ? childrenDoc : indent$5(childrenDoc);
          }(concat$a([shouldHugContent ? ifBreak$5(softline$4, "", {
            groupId: attrGroupId
          }) : node.firstChild.hasLeadingSpaces && node.firstChild.isLeadingSpaceSensitive ? line$5 : node.firstChild.type === "text" && node.isWhitespaceSensitive && node.isIndentationSensitive ? dedentToRoot$1(softline$4) : softline$4, printChildren$1(path, options, print)])), (node.next ? needsToBorrowPrevClosingTagEndMarker(node.next) : needsToBorrowLastChildClosingTagEndMarker(node.parent)) ? node.lastChild.hasTrailingSpaces && node.lastChild.isTrailingSpaceSensitive ? " " : "" : shouldHugContent ? ifBreak$5(softline$4, "", {
            groupId: attrGroupId
          }) : node.lastChild.hasTrailingSpaces && node.lastChild.isTrailingSpaceSensitive ? line$5 : (node.lastChild.type === "comment" || node.lastChild.type === "text" && node.isWhitespaceSensitive && node.isIndentationSensitive) && new RegExp("\\n\\s{".concat(options.tabWidth * countParents$1(path, function (n) {
            return n.parent && n.parent.type !== "root";
          }), "}$")).test(node.lastChild.value) ?
          /**
           *     <div>
           *       <pre>
           *         something
           *       </pre>
           *            ~
           *     </div>
           */
          "" : softline$4])])), printClosingTag(node, options)]);
        }

      case "ieConditionalStartComment":
      case "ieConditionalEndComment":
        return concat$a([printOpeningTagStart(node), printClosingTagEnd(node)]);

      case "interpolation":
        return concat$a([printOpeningTagStart(node, options), concat$a(path.map(print, "children")), printClosingTagEnd(node, options)]);

      case "text":
        {
          if (node.parent.type === "interpolation") {
            // replace the trailing literalline with hardline for better readability
            var trailingNewlineRegex = /\n[^\S\n]*?$/;
            var hasTrailingNewline = trailingNewlineRegex.test(node.value);
            var value = hasTrailingNewline ? node.value.replace(trailingNewlineRegex, "") : node.value;
            return concat$a([concat$a(replaceEndOfLineWith$1(value, literalline$2)), hasTrailingNewline ? hardline$7 : ""]);
          }

          return fill$3(normalizeParts$1([].concat(printOpeningTagPrefix(node, options), getTextValueParts(node), printClosingTagSuffix(node, options))));
        }

      case "docType":
        return concat$a([group$9(concat$a([printOpeningTagStart(node, options), " ", node.value.replace(/^html\b/i, "html").replace(/\s+/g, " ")])), printClosingTagEnd(node, options)]);

      case "comment":
        {
          return concat$a([printOpeningTagPrefix(node, options), concat$a(replaceEndOfLineWith$1(options.originalText.slice(options.locStart(node), options.locEnd(node)), literalline$2)), printClosingTagSuffix(node, options)]);
        }

      case "attribute":
        {
          if (node.value === null) {
            return node.rawName;
          }

          var _value = unescapeQuoteEntities$1(node.value);

          var singleQuoteCount = countChars$1(_value, "'");
          var doubleQuoteCount = countChars$1(_value, '"');
          var quote = singleQuoteCount < doubleQuoteCount ? "'" : '"';
          return concat$a([node.rawName, concat$a(["=", quote, concat$a(replaceEndOfLineWith$1(quote === '"' ? _value.replace(/"/g, "&quot;") : _value.replace(/'/g, "&apos;"), literalline$2)), quote])]);
        }

      case "yaml":
      case "toml":
        return concat$a(replaceEndOfLineWith$1(node.raw, literalline$2));

      default:
        throw new Error("Unexpected node type ".concat(node.type));
    }
  }

  function printChildren$1(path, options, print) {
    var node = path.getValue();

    if (forceBreakChildren$1(node)) {
      return concat$a([breakParent$2, concat$a(path.map(function (childPath) {
        var childNode = childPath.getValue();
        var prevBetweenLine = !childNode.prev ? "" : printBetweenLine(childNode.prev, childNode);
        return concat$a([!prevBetweenLine ? "" : concat$a([prevBetweenLine, forceNextEmptyLine$1(childNode.prev) ? hardline$7 : ""]), printChild(childPath)]);
      }, "children"))]);
    }

    var groupIds = node.children.map(function () {
      return Symbol("");
    });
    return concat$a(path.map(function (childPath, childIndex) {
      var childNode = childPath.getValue();

      if (isTextLikeNode$1(childNode)) {
        if (childNode.prev && isTextLikeNode$1(childNode.prev)) {
          var _prevBetweenLine = printBetweenLine(childNode.prev, childNode);

          if (_prevBetweenLine) {
            if (forceNextEmptyLine$1(childNode.prev)) {
              return concat$a([hardline$7, hardline$7, printChild(childPath)]);
            }

            return concat$a([_prevBetweenLine, printChild(childPath)]);
          }
        }

        return printChild(childPath);
      }

      var prevParts = [];
      var leadingParts = [];
      var trailingParts = [];
      var nextParts = [];
      var prevBetweenLine = childNode.prev ? printBetweenLine(childNode.prev, childNode) : "";
      var nextBetweenLine = childNode.next ? printBetweenLine(childNode, childNode.next) : "";

      if (prevBetweenLine) {
        if (forceNextEmptyLine$1(childNode.prev)) {
          prevParts.push(hardline$7, hardline$7);
        } else if (prevBetweenLine === hardline$7) {
          prevParts.push(hardline$7);
        } else {
          if (isTextLikeNode$1(childNode.prev)) {
            leadingParts.push(prevBetweenLine);
          } else {
            leadingParts.push(ifBreak$5("", softline$4, {
              groupId: groupIds[childIndex - 1]
            }));
          }
        }
      }

      if (nextBetweenLine) {
        if (forceNextEmptyLine$1(childNode)) {
          if (isTextLikeNode$1(childNode.next)) {
            nextParts.push(hardline$7, hardline$7);
          }
        } else if (nextBetweenLine === hardline$7) {
          if (isTextLikeNode$1(childNode.next)) {
            nextParts.push(hardline$7);
          }
        } else {
          trailingParts.push(nextBetweenLine);
        }
      }

      return concat$a([].concat(prevParts, group$9(concat$a([concat$a(leadingParts), group$9(concat$a([printChild(childPath), concat$a(trailingParts)]), {
        id: groupIds[childIndex]
      })])), nextParts));
    }, "children"));

    function printChild(childPath) {
      var child = childPath.getValue();

      if (hasPrettierIgnore$1(child)) {
        return concat$a([].concat(printOpeningTagPrefix(child, options), replaceEndOfLineWith$1(options.originalText.slice(options.locStart(child) + (child.prev && needsToBorrowNextOpeningTagStartMarker(child.prev) ? printOpeningTagStartMarker(child).length : 0), options.locEnd(child) - (child.next && needsToBorrowPrevClosingTagEndMarker(child.next) ? printClosingTagEndMarker(child, options).length : 0)), literalline$2), printClosingTagSuffix(child, options)));
      }

      if (shouldPreserveContent$1(child, options)) {
        return concat$a([].concat(printOpeningTagPrefix(child, options), group$9(printOpeningTag(childPath, options, print)), replaceEndOfLineWith$1(options.originalText.slice(child.startSourceSpan.end.offset + (child.firstChild && needsToBorrowParentOpeningTagEndMarker(child.firstChild) ? -printOpeningTagEndMarker(child).length : 0), child.endSourceSpan.start.offset + (child.lastChild && needsToBorrowParentClosingTagStartMarker(child.lastChild) ? printClosingTagStartMarker(child, options).length : needsToBorrowLastChildClosingTagEndMarker(child) ? -printClosingTagEndMarker(child.lastChild, options).length : 0)), literalline$2), printClosingTag(child, options), printClosingTagSuffix(child, options)));
      }

      return print(childPath);
    }

    function printBetweenLine(prevNode, nextNode) {
      return isTextLikeNode$1(prevNode) && isTextLikeNode$1(nextNode) ? prevNode.isTrailingSpaceSensitive ? prevNode.hasTrailingSpaces ? preferHardlineAsLeadingSpaces$1(nextNode) ? hardline$7 : line$5 : "" : preferHardlineAsLeadingSpaces$1(nextNode) ? hardline$7 : softline$4 : needsToBorrowNextOpeningTagStartMarker(prevNode) && (
      /**
       *     123<a
       *          ~
       *       ><b>
       */
      nextNode.firstChild ||
      /**
       *     123<!--
       *            ~
       *     -->
       */
      nextNode.isSelfClosing ||
      /**
       *     123<span
       *             ~
       *       attr
       */
      nextNode.type === "element" && nextNode.attrs.length !== 0) ||
      /**
       *     <img
       *       src="long"
       *                 ~
       *     />123
       */
      prevNode.type === "element" && prevNode.isSelfClosing && needsToBorrowPrevClosingTagEndMarker(nextNode) ? "" : !nextNode.isLeadingSpaceSensitive || preferHardlineAsLeadingSpaces$1(nextNode) ||
      /**
       *       Want to write us a letter? Use our<a
       *         ><b><a>mailing address</a></b></a
       *                                          ~
       *       >.
       */
      needsToBorrowPrevClosingTagEndMarker(nextNode) && prevNode.lastChild && needsToBorrowParentClosingTagStartMarker(prevNode.lastChild) && prevNode.lastChild.lastChild && needsToBorrowParentClosingTagStartMarker(prevNode.lastChild.lastChild) ? hardline$7 : nextNode.hasLeadingSpaces ? line$5 : softline$4;
    }
  }

  function printOpeningTag(path, options, print) {
    var node = path.getValue();
    var forceNotToBreakAttrContent = node.type === "element" && node.fullName === "script" && node.attrs.length === 1 && node.attrs[0].fullName === "src" && node.children.length === 0;
    return concat$a([printOpeningTagStart(node, options), !node.attrs || node.attrs.length === 0 ? node.isSelfClosing ?
    /**
     *     <br />
     *        ^
     */
    " " : "" : concat$a([indent$5(concat$a([forceNotToBreakAttrContent ? " " : line$5, join$6(line$5, function (ignoreAttributeData) {
      var hasPrettierIgnoreAttribute = typeof ignoreAttributeData === "boolean" ? function () {
        return ignoreAttributeData;
      } : Array.isArray(ignoreAttributeData) ? function (attr) {
        return ignoreAttributeData.indexOf(attr.rawName) !== -1;
      } : function () {
        return false;
      };
      return path.map(function (attrPath) {
        var attr = attrPath.getValue();
        return hasPrettierIgnoreAttribute(attr) ? concat$a(replaceEndOfLineWith$1(options.originalText.slice(options.locStart(attr), options.locEnd(attr)), literalline$2)) : print(attrPath);
      }, "attrs");
    }(node.prev && node.prev.type === "comment" && getPrettierIgnoreAttributeCommentData$1(node.prev.value)))])),
    /**
     *     123<a
     *       attr
     *           ~
     *       >456
     */
    node.firstChild && needsToBorrowParentOpeningTagEndMarker(node.firstChild) ||
    /**
     *     <span
     *       >123<meta
     *                ~
     *     /></span>
     */
    node.isSelfClosing && needsToBorrowLastChildClosingTagEndMarker(node.parent) ? "" : node.isSelfClosing ? forceNotToBreakAttrContent ? " " : line$5 : forceNotToBreakAttrContent ? "" : softline$4]), node.isSelfClosing ? "" : printOpeningTagEnd(node)]);
  }

  function printOpeningTagStart(node, options) {
    return node.prev && needsToBorrowNextOpeningTagStartMarker(node.prev) ? "" : concat$a([printOpeningTagPrefix(node, options), printOpeningTagStartMarker(node)]);
  }

  function printOpeningTagEnd(node) {
    return node.firstChild && needsToBorrowParentOpeningTagEndMarker(node.firstChild) ? "" : printOpeningTagEndMarker(node);
  }

  function printClosingTag(node, options) {
    return concat$a([node.isSelfClosing ? "" : printClosingTagStart(node, options), printClosingTagEnd(node, options)]);
  }

  function printClosingTagStart(node, options) {
    return node.lastChild && needsToBorrowParentClosingTagStartMarker(node.lastChild) ? "" : concat$a([printClosingTagPrefix(node, options), printClosingTagStartMarker(node, options)]);
  }

  function printClosingTagEnd(node, options) {
    return (node.next ? needsToBorrowPrevClosingTagEndMarker(node.next) : needsToBorrowLastChildClosingTagEndMarker(node.parent)) ? "" : concat$a([printClosingTagEndMarker(node, options), printClosingTagSuffix(node, options)]);
  }

  function needsToBorrowNextOpeningTagStartMarker(node) {
    /**
     *     123<p
     *        ^^
     *     >
     */
    return node.next && !isTextLikeNode$1(node.next) && isTextLikeNode$1(node) && node.isTrailingSpaceSensitive && !node.hasTrailingSpaces;
  }

  function needsToBorrowParentOpeningTagEndMarker(node) {
    /**
     *     <p
     *       >123
     *       ^
     *
     *     <p
     *       ><a
     *       ^
     */
    return !node.prev && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces;
  }

  function needsToBorrowPrevClosingTagEndMarker(node) {
    /**
     *     <p></p
     *     >123
     *     ^
     *
     *     <p></p
     *     ><a
     *     ^
     */
    return node.prev && !isTextLikeNode$1(node.prev) && node.isLeadingSpaceSensitive && !node.hasLeadingSpaces;
  }

  function needsToBorrowLastChildClosingTagEndMarker(node) {
    /**
     *     <p
     *       ><a></a
     *       ></p
     *       ^
     *     >
     */
    return node.lastChild && node.lastChild.isTrailingSpaceSensitive && !node.lastChild.hasTrailingSpaces && !isTextLikeNode$1(getLastDescendant$1(node.lastChild));
  }

  function needsToBorrowParentClosingTagStartMarker(node) {
    /**
     *     <p>
     *       123</p
     *          ^^^
     *     >
     *
     *         123</b
     *       ></a
     *        ^^^
     *     >
     */
    return !node.next && !node.hasTrailingSpaces && node.isTrailingSpaceSensitive && isTextLikeNode$1(getLastDescendant$1(node));
  }

  function printOpeningTagPrefix(node, options) {
    return needsToBorrowParentOpeningTagEndMarker(node) ? printOpeningTagEndMarker(node.parent) : needsToBorrowPrevClosingTagEndMarker(node) ? printClosingTagEndMarker(node.prev, options) : "";
  }

  function printClosingTagPrefix(node, options) {
    return needsToBorrowLastChildClosingTagEndMarker(node) ? printClosingTagEndMarker(node.lastChild, options) : "";
  }

  function printClosingTagSuffix(node, options) {
    return needsToBorrowParentClosingTagStartMarker(node) ? printClosingTagStartMarker(node.parent, options) : needsToBorrowNextOpeningTagStartMarker(node) ? printOpeningTagStartMarker(node.next) : "";
  }

  function printOpeningTagStartMarker(node) {
    switch (node.type) {
      case "ieConditionalComment":
      case "ieConditionalStartComment":
        return "<!--[if ".concat(node.condition);

      case "ieConditionalEndComment":
        return "<!--<!";

      case "interpolation":
        return "{{";

      case "docType":
        return "<!DOCTYPE";

      case "element":
        if (node.condition) {
          return "<!--[if ".concat(node.condition, "]><!--><").concat(node.rawName);
        }

      // fall through

      default:
        return "<".concat(node.rawName);
    }
  }

  function printOpeningTagEndMarker(node) {
    assert(!node.isSelfClosing);

    switch (node.type) {
      case "ieConditionalComment":
        return "]>";

      case "element":
        if (node.condition) {
          return "><!--<![endif]-->";
        }

      // fall through

      default:
        return ">";
    }
  }

  function printClosingTagStartMarker(node, options) {
    assert(!node.isSelfClosing);

    if (shouldNotPrintClosingTag$1(node, options)) {
      return "";
    }

    switch (node.type) {
      case "ieConditionalComment":
        return "<!";

      case "element":
        if (node.hasHtmComponentClosingTag) {
          return "<//";
        }

      // fall through

      default:
        return "</".concat(node.rawName);
    }
  }

  function printClosingTagEndMarker(node, options) {
    if (shouldNotPrintClosingTag$1(node, options)) {
      return "";
    }

    switch (node.type) {
      case "ieConditionalComment":
      case "ieConditionalEndComment":
        return "[endif]-->";

      case "ieConditionalStartComment":
        return "]><!-->";

      case "interpolation":
        return "}}";

      case "element":
        if (node.isSelfClosing) {
          return "/>";
        }

      // fall through

      default:
        return ">";
    }
  }

  function getTextValueParts(node) {
    var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : node.value;
    return node.parent.isWhitespaceSensitive ? node.parent.isIndentationSensitive ? replaceEndOfLineWith$1(value, literalline$2) : replaceEndOfLineWith$1(dedentString$1(value.replace(/^\s*?\n|\n\s*?$/g, "")), hardline$7) : // https://infra.spec.whatwg.org/#ascii-whitespace
    join$6(line$5, value.split(/[\t\n\f\r ]+/)).parts;
  }

  function printEmbeddedAttributeValue(node, originalTextToDoc, options) {
    var isKeyMatched = function isKeyMatched(patterns) {
      return new RegExp(patterns.join("|")).test(node.fullName);
    };

    var getValue = function getValue() {
      return unescapeQuoteEntities$1(node.value);
    };

    var shouldHug = false;

    var __onHtmlBindingRoot = function __onHtmlBindingRoot(root) {
      var rootNode = root.type === "NGRoot" ? root.node.type === "NGMicrosyntax" && root.node.body.length === 1 && root.node.body[0].type === "NGMicrosyntaxExpression" ? root.node.body[0].expression : root.node : root.type === "JsExpressionRoot" ? root.node : root;

      if (rootNode && (rootNode.type === "ObjectExpression" || rootNode.type === "ArrayExpression")) {
        shouldHug = true;
      }
    };

    var printHug = function printHug(doc) {
      return group$9(doc);
    };

    var printExpand = function printExpand(doc) {
      return group$9(concat$a([indent$5(concat$a([softline$4, doc])), softline$4]));
    };

    var printMaybeHug = function printMaybeHug(doc) {
      return shouldHug ? printHug(doc) : printExpand(doc);
    };

    var textToDoc = function textToDoc(code, opts) {
      return originalTextToDoc(code, Object.assign({
        __onHtmlBindingRoot: __onHtmlBindingRoot
      }, opts));
    };

    if (node.fullName === "srcset" && (node.parent.fullName === "img" || node.parent.fullName === "source")) {
      return printExpand(printImgSrcset$1(getValue()));
    }

    if (options.parser === "vue") {
      if (node.fullName === "v-for") {
        return printVueFor$1(getValue(), textToDoc);
      }

      if (node.fullName === "slot-scope") {
        return printVueSlotScope$1(getValue(), textToDoc);
      }
      /**
       *     @click="jsStatement"
       *     @click="jsExpression"
       *     v-on:click="jsStatement"
       *     v-on:click="jsExpression"
       */


      var vueEventBindingPatterns = ["^@", "^v-on:"];
      /**
       *     :class="vueExpression"
       *     v-bind:id="vueExpression"
       */

      var vueExpressionBindingPatterns = ["^:", "^v-bind:"];
      /**
       *     v-if="jsExpression"
       */

      var jsExpressionBindingPatterns = ["^v-"];

      if (isKeyMatched(vueEventBindingPatterns)) {
        var value = getValue();
        return printMaybeHug(isVueEventBindingExpression$1(value) ? textToDoc(value, {
          parser: "__js_expression"
        }) : stripTrailingHardline$1(textToDoc(value, {
          parser: "__vue_event_binding"
        })));
      }

      if (isKeyMatched(vueExpressionBindingPatterns)) {
        return printMaybeHug(textToDoc(getValue(), {
          parser: "__vue_expression"
        }));
      }

      if (isKeyMatched(jsExpressionBindingPatterns)) {
        return printMaybeHug(textToDoc(getValue(), {
          parser: "__js_expression"
        }));
      }
    }

    if (options.parser === "angular") {
      var ngTextToDoc = function ngTextToDoc(code, opts) {
        return (// angular does not allow trailing comma
          textToDoc(code, Object.assign({
            trailingComma: "none"
          }, opts))
        );
      };
      /**
       *     *directive="angularDirective"
       */


      var ngDirectiveBindingPatterns = ["^\\*"];
      /**
       *     (click)="angularStatement"
       *     on-click="angularStatement"
       */

      var ngStatementBindingPatterns = ["^\\(.+\\)$", "^on-"];
      /**
       *     [target]="angularExpression"
       *     bind-target="angularExpression"
       *     [(target)]="angularExpression"
       *     bindon-target="angularExpression"
       */

      var ngExpressionBindingPatterns = ["^\\[.+\\]$", "^bind(on)?-"];
      /**
       *     i18n="longDescription"
       *     i18n-attr="longDescription"
       */

      var ngI18nPatterns = ["^i18n(-.+)?$"];

      if (isKeyMatched(ngStatementBindingPatterns)) {
        return printMaybeHug(ngTextToDoc(getValue(), {
          parser: "__ng_action"
        }));
      }

      if (isKeyMatched(ngExpressionBindingPatterns)) {
        return printMaybeHug(ngTextToDoc(getValue(), {
          parser: "__ng_binding"
        }));
      }

      if (isKeyMatched(ngI18nPatterns)) {
        return printExpand(fill$3(getTextValueParts(node, getValue())));
      }

      if (isKeyMatched(ngDirectiveBindingPatterns)) {
        return printMaybeHug(ngTextToDoc(getValue(), {
          parser: "__ng_directive"
        }));
      }

      var interpolationRegex = /\{\{([\s\S]+?)\}\}/g;

      var _value2 = getValue();

      if (interpolationRegex.test(_value2)) {
        var parts = [];

        _value2.split(interpolationRegex).forEach(function (part, index) {
          if (index % 2 === 0) {
            parts.push(concat$a(replaceEndOfLineWith$1(part, literalline$2)));
          } else {
            try {
              parts.push(group$9(concat$a(["{{", indent$5(concat$a([line$5, ngTextToDoc(part, {
                parser: "__ng_interpolation",
                __isInHtmlInterpolation: true // to avoid unexpected `}}`

              })])), line$5, "}}"])));
            } catch (e) {
              parts.push("{{", concat$a(replaceEndOfLineWith$1(part, literalline$2)), "}}");
            }
          }
        });

        return group$9(concat$a(parts));
      }
    }

    return null;
  }

  var printerHtml = {
    preprocess: preprocess_1,
    print: genericPrint$2,
    insertPragma: insertPragma$6,
    massageAstNode: clean$3,
    embed: embed$2
  };

  var CATEGORY_HTML = "HTML"; // format based on https://github.com/prettier/prettier/blob/master/src/main/core-options.js

  var options$4 = {
    htmlWhitespaceSensitivity: {
      since: "1.15.0",
      category: CATEGORY_HTML,
      type: "choice",
      default: "css",
      description: "How to handle whitespaces in HTML.",
      choices: [{
        value: "css",
        description: "Respect the default value of CSS display property."
      }, {
        value: "strict",
        description: "Whitespaces are considered sensitive."
      }, {
        value: "ignore",
        description: "Whitespaces are considered insensitive."
      }]
    },
    vueIndentScriptAndStyle: {
      since: "1.19.0",
      category: CATEGORY_HTML,
      type: "boolean",
      default: false,
      description: "Indent script and style tags in Vue files."
    }
  };

  var name$7 = "HTML";
  var type$6 = "markup";
  var tmScope$6 = "text.html.basic";
  var aceMode$6 = "html";
  var codemirrorMode$3 = "htmlmixed";
  var codemirrorMimeType$3 = "text/html";
  var color$1 = "#e34c26";
  var aliases$1 = [
  	"xhtml"
  ];
  var extensions$6 = [
  	".html",
  	".htm",
  	".html.hl",
  	".inc",
  	".st",
  	".xht",
  	".xhtml"
  ];
  var languageId$6 = 146;
  var HTML = {
  	name: name$7,
  	type: type$6,
  	tmScope: tmScope$6,
  	aceMode: aceMode$6,
  	codemirrorMode: codemirrorMode$3,
  	codemirrorMimeType: codemirrorMimeType$3,
  	color: color$1,
  	aliases: aliases$1,
  	extensions: extensions$6,
  	languageId: languageId$6
  };

  var HTML$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$7,
    type: type$6,
    tmScope: tmScope$6,
    aceMode: aceMode$6,
    codemirrorMode: codemirrorMode$3,
    codemirrorMimeType: codemirrorMimeType$3,
    color: color$1,
    aliases: aliases$1,
    extensions: extensions$6,
    languageId: languageId$6,
    'default': HTML
  });

  var name$8 = "Vue";
  var type$7 = "markup";
  var color$2 = "#2c3e50";
  var extensions$7 = [
  	".vue"
  ];
  var tmScope$7 = "text.html.vue";
  var aceMode$7 = "html";
  var languageId$7 = 391;
  var Vue = {
  	name: name$8,
  	type: type$7,
  	color: color$2,
  	extensions: extensions$7,
  	tmScope: tmScope$7,
  	aceMode: aceMode$7,
  	languageId: languageId$7
  };

  var Vue$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$8,
    type: type$7,
    color: color$2,
    extensions: extensions$7,
    tmScope: tmScope$7,
    aceMode: aceMode$7,
    languageId: languageId$7,
    'default': Vue
  });

  var require$$0$5 = getCjsExportFromNamespace(HTML$1);

  var require$$1$1 = getCjsExportFromNamespace(Vue$1);

  var languages$3 = [createLanguage(require$$0$5, function (data) {
    return Object.assign(data, {
      name: "Angular",
      since: "1.15.0",
      parsers: ["angular"],
      vscodeLanguageIds: ["html"],
      extensions: [".component.html"],
      filenames: []
    });
  }), createLanguage(require$$0$5, function (data) {
    return Object.assign(data, {
      since: "1.15.0",
      parsers: ["html"],
      vscodeLanguageIds: ["html"],
      extensions: data.extensions.concat([".mjml" // MJML is considered XML in Linguist but it should be formatted as HTML
      ])
    });
  }), createLanguage(require$$0$5, function (data) {
    return Object.assign(data, {
      name: "Lightning Web Components",
      since: "1.17.0",
      parsers: ["lwc"],
      vscodeLanguageIds: ["html"],
      extensions: [],
      filenames: []
    });
  }), createLanguage(require$$1$1, function (data) {
    return Object.assign(data, {
      since: "1.10.0",
      parsers: ["vue"],
      vscodeLanguageIds: ["vue"]
    });
  })];
  var printers$3 = {
    html: printerHtml
  };
  var languageHtml = {
    languages: languages$3,
    printers: printers$3,
    options: options$4
  };

  var addLeadingComment$2 = utilShared.addLeadingComment,
      addTrailingComment$2 = utilShared.addTrailingComment,
      addDanglingComment$2 = utilShared.addDanglingComment;

  function handleOwnLineComment(comment, text, options, ast, isLastComment) {
    var precedingNode = comment.precedingNode,
        enclosingNode = comment.enclosingNode,
        followingNode = comment.followingNode;

    if (handleLastFunctionArgComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleMemberExpressionComments(enclosingNode, followingNode, comment) || handleIfStatementComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleWhileComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleTryStatementComments(enclosingNode, precedingNode, followingNode, comment) || handleClassComments(enclosingNode, precedingNode, followingNode, comment) || handleImportSpecifierComments(enclosingNode, comment) || handleForComments(enclosingNode, precedingNode, comment) || handleUnionTypeComments(precedingNode, enclosingNode, followingNode, comment) || handleOnlyComments(enclosingNode, ast, comment, isLastComment) || handleImportDeclarationComments(text, enclosingNode, precedingNode, comment, options) || handleAssignmentPatternComments(enclosingNode, comment) || handleMethodNameComments(text, enclosingNode, precedingNode, comment, options)) {
      return true;
    }

    return false;
  }

  function handleEndOfLineComment(comment, text, options, ast, isLastComment) {
    var precedingNode = comment.precedingNode,
        enclosingNode = comment.enclosingNode,
        followingNode = comment.followingNode;

    if (handleLastFunctionArgComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleConditionalExpressionComments(enclosingNode, precedingNode, followingNode, comment, text, options) || handleImportSpecifierComments(enclosingNode, comment) || handleIfStatementComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleWhileComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleTryStatementComments(enclosingNode, precedingNode, followingNode, comment) || handleClassComments(enclosingNode, precedingNode, followingNode, comment) || handleLabeledStatementComments(enclosingNode, comment) || handleCallExpressionComments(precedingNode, enclosingNode, comment) || handlePropertyComments(enclosingNode, comment) || handleOnlyComments(enclosingNode, ast, comment, isLastComment) || handleTypeAliasComments(enclosingNode, followingNode, comment) || handleVariableDeclaratorComments(enclosingNode, followingNode, comment)) {
      return true;
    }

    return false;
  }

  function handleRemainingComment(comment, text, options, ast, isLastComment) {
    var precedingNode = comment.precedingNode,
        enclosingNode = comment.enclosingNode,
        followingNode = comment.followingNode;

    if (handleIfStatementComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleWhileComments(text, precedingNode, enclosingNode, followingNode, comment, options) || handleObjectPropertyAssignment(enclosingNode, precedingNode, comment) || handleCommentInEmptyParens(text, enclosingNode, comment, options) || handleMethodNameComments(text, enclosingNode, precedingNode, comment, options) || handleOnlyComments(enclosingNode, ast, comment, isLastComment) || handleCommentAfterArrowParams(text, enclosingNode, comment, options) || handleFunctionNameComments(text, enclosingNode, precedingNode, comment, options) || handleTSMappedTypeComments(text, enclosingNode, precedingNode, followingNode, comment) || handleBreakAndContinueStatementComments(enclosingNode, comment)) {
      return true;
    }

    return false;
  }

  function addBlockStatementFirstComment(node, comment) {
    var body = node.body.filter(function (n) {
      return n.type !== "EmptyStatement";
    });

    if (body.length === 0) {
      addDanglingComment$2(node, comment);
    } else {
      addLeadingComment$2(body[0], comment);
    }
  }

  function addBlockOrNotComment(node, comment) {
    if (node.type === "BlockStatement") {
      addBlockStatementFirstComment(node, comment);
    } else {
      addLeadingComment$2(node, comment);
    }
  } // There are often comments before the else clause of if statements like
  //
  //   if (1) { ... }
  //   // comment
  //   else { ... }
  //
  // They are being attached as leading comments of the BlockExpression which
  // is not well printed. What we want is to instead move the comment inside
  // of the block and make it leadingComment of the first element of the block
  // or dangling comment of the block if there is nothing inside
  //
  //   if (1) { ... }
  //   else {
  //     // comment
  //     ...
  //   }


  function handleIfStatementComments(text, precedingNode, enclosingNode, followingNode, comment, options) {
    if (!enclosingNode || enclosingNode.type !== "IfStatement" || !followingNode) {
      return false;
    } // We unfortunately have no way using the AST or location of nodes to know
    // if the comment is positioned before the condition parenthesis:
    //   if (a /* comment */) {}
    // The only workaround I found is to look at the next character to see if
    // it is a ).


    var nextCharacter = util.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd);

    if (nextCharacter === ")") {
      addTrailingComment$2(precedingNode, comment);
      return true;
    } // Comments before `else`:
    // - treat as trailing comments of the consequent, if it's a BlockStatement
    // - treat as a dangling comment otherwise


    if (precedingNode === enclosingNode.consequent && followingNode === enclosingNode.alternate) {
      if (precedingNode.type === "BlockStatement") {
        addTrailingComment$2(precedingNode, comment);
      } else {
        addDanglingComment$2(enclosingNode, comment);
      }

      return true;
    }

    if (followingNode.type === "BlockStatement") {
      addBlockStatementFirstComment(followingNode, comment);
      return true;
    }

    if (followingNode.type === "IfStatement") {
      addBlockOrNotComment(followingNode.consequent, comment);
      return true;
    } // For comments positioned after the condition parenthesis in an if statement
    // before the consequent without brackets on, such as
    // if (a) /* comment */ true,
    // we look at the next character to see if the following node
    // is the consequent for the if statement


    if (enclosingNode.consequent === followingNode) {
      addLeadingComment$2(followingNode, comment);
      return true;
    }

    return false;
  }

  function handleWhileComments(text, precedingNode, enclosingNode, followingNode, comment, options) {
    if (!enclosingNode || enclosingNode.type !== "WhileStatement" || !followingNode) {
      return false;
    } // We unfortunately have no way using the AST or location of nodes to know
    // if the comment is positioned before the condition parenthesis:
    //   while (a /* comment */) {}
    // The only workaround I found is to look at the next character to see if
    // it is a ).


    var nextCharacter = util.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd);

    if (nextCharacter === ")") {
      addTrailingComment$2(precedingNode, comment);
      return true;
    }

    if (followingNode.type === "BlockStatement") {
      addBlockStatementFirstComment(followingNode, comment);
      return true;
    }

    return false;
  } // Same as IfStatement but for TryStatement


  function handleTryStatementComments(enclosingNode, precedingNode, followingNode, comment) {
    if (!enclosingNode || enclosingNode.type !== "TryStatement" && enclosingNode.type !== "CatchClause" || !followingNode) {
      return false;
    }

    if (enclosingNode.type === "CatchClause" && precedingNode) {
      addTrailingComment$2(precedingNode, comment);
      return true;
    }

    if (followingNode.type === "BlockStatement") {
      addBlockStatementFirstComment(followingNode, comment);
      return true;
    }

    if (followingNode.type === "TryStatement") {
      addBlockOrNotComment(followingNode.finalizer, comment);
      return true;
    }

    if (followingNode.type === "CatchClause") {
      addBlockOrNotComment(followingNode.body, comment);
      return true;
    }

    return false;
  }

  function handleMemberExpressionComments(enclosingNode, followingNode, comment) {
    if (enclosingNode && (enclosingNode.type === "MemberExpression" || enclosingNode.type === "OptionalMemberExpression") && followingNode && followingNode.type === "Identifier") {
      addLeadingComment$2(enclosingNode, comment);
      return true;
    }

    return false;
  }

  function handleConditionalExpressionComments(enclosingNode, precedingNode, followingNode, comment, text, options) {
    var isSameLineAsPrecedingNode = precedingNode && !util.hasNewlineInRange(text, options.locEnd(precedingNode), options.locStart(comment));

    if ((!precedingNode || !isSameLineAsPrecedingNode) && enclosingNode && enclosingNode.type === "ConditionalExpression" && followingNode) {
      addLeadingComment$2(followingNode, comment);
      return true;
    }

    return false;
  }

  function handleObjectPropertyAssignment(enclosingNode, precedingNode, comment) {
    if (enclosingNode && (enclosingNode.type === "ObjectProperty" || enclosingNode.type === "Property") && enclosingNode.shorthand && enclosingNode.key === precedingNode && enclosingNode.value.type === "AssignmentPattern") {
      addTrailingComment$2(enclosingNode.value.left, comment);
      return true;
    }

    return false;
  }

  function handleClassComments(enclosingNode, precedingNode, followingNode, comment) {
    if (enclosingNode && (enclosingNode.type === "ClassDeclaration" || enclosingNode.type === "ClassExpression") && enclosingNode.decorators && enclosingNode.decorators.length > 0 && !(followingNode && followingNode.type === "Decorator")) {
      if (!enclosingNode.decorators || enclosingNode.decorators.length === 0) {
        addLeadingComment$2(enclosingNode, comment);
      } else {
        addTrailingComment$2(enclosingNode.decorators[enclosingNode.decorators.length - 1], comment);
      }

      return true;
    }

    return false;
  }

  function handleMethodNameComments(text, enclosingNode, precedingNode, comment, options) {
    // This is only needed for estree parsers (flow, typescript) to attach
    // after a method name:
    // obj = { fn /*comment*/() {} };
    if (enclosingNode && precedingNode && (enclosingNode.type === "Property" || enclosingNode.type === "MethodDefinition") && precedingNode.type === "Identifier" && enclosingNode.key === precedingNode && // special Property case: { key: /*comment*/(value) };
    // comment should be attached to value instead of key
    util.getNextNonSpaceNonCommentCharacter(text, precedingNode, options.locEnd) !== ":") {
      addTrailingComment$2(precedingNode, comment);
      return true;
    } // Print comments between decorators and class methods as a trailing comment
    // on the decorator node instead of the method node


    if (precedingNode && enclosingNode && precedingNode.type === "Decorator" && (enclosingNode.type === "ClassMethod" || enclosingNode.type === "ClassProperty" || enclosingNode.type === "TSAbstractClassProperty" || enclosingNode.type === "TSAbstractMethodDefinition" || enclosingNode.type === "MethodDefinition")) {
      addTrailingComment$2(precedingNode, comment);
      return true;
    }

    return false;
  }

  function handleFunctionNameComments(text, enclosingNode, precedingNode, comment, options) {
    if (util.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd) !== "(") {
      return false;
    }

    if (precedingNode && enclosingNode && (enclosingNode.type === "FunctionDeclaration" || enclosingNode.type === "FunctionExpression" || enclosingNode.type === "ClassMethod" || enclosingNode.type === "MethodDefinition" || enclosingNode.type === "ObjectMethod")) {
      addTrailingComment$2(precedingNode, comment);
      return true;
    }

    return false;
  }

  function handleCommentAfterArrowParams(text, enclosingNode, comment, options) {
    if (!(enclosingNode && enclosingNode.type === "ArrowFunctionExpression")) {
      return false;
    }

    var index = utilShared.getNextNonSpaceNonCommentCharacterIndex(text, comment, options);

    if (text.substr(index, 2) === "=>") {
      addDanglingComment$2(enclosingNode, comment);
      return true;
    }

    return false;
  }

  function handleCommentInEmptyParens(text, enclosingNode, comment, options) {
    if (util.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd) !== ")") {
      return false;
    } // Only add dangling comments to fix the case when no params are present,
    // i.e. a function without any argument.


    if (enclosingNode && ((enclosingNode.type === "FunctionDeclaration" || enclosingNode.type === "FunctionExpression" || enclosingNode.type === "ArrowFunctionExpression" || enclosingNode.type === "ClassMethod" || enclosingNode.type === "ObjectMethod") && enclosingNode.params.length === 0 || (enclosingNode.type === "CallExpression" || enclosingNode.type === "OptionalCallExpression" || enclosingNode.type === "NewExpression") && enclosingNode.arguments.length === 0)) {
      addDanglingComment$2(enclosingNode, comment);
      return true;
    }

    if (enclosingNode && enclosingNode.type === "MethodDefinition" && enclosingNode.value.params.length === 0) {
      addDanglingComment$2(enclosingNode.value, comment);
      return true;
    }

    return false;
  }

  function handleLastFunctionArgComments(text, precedingNode, enclosingNode, followingNode, comment, options) {
    // Type definitions functions
    if (precedingNode && precedingNode.type === "FunctionTypeParam" && enclosingNode && enclosingNode.type === "FunctionTypeAnnotation" && followingNode && followingNode.type !== "FunctionTypeParam") {
      addTrailingComment$2(precedingNode, comment);
      return true;
    } // Real functions


    if (precedingNode && (precedingNode.type === "Identifier" || precedingNode.type === "AssignmentPattern") && enclosingNode && (enclosingNode.type === "ArrowFunctionExpression" || enclosingNode.type === "FunctionExpression" || enclosingNode.type === "FunctionDeclaration" || enclosingNode.type === "ObjectMethod" || enclosingNode.type === "ClassMethod") && util.getNextNonSpaceNonCommentCharacter(text, comment, options.locEnd) === ")") {
      addTrailingComment$2(precedingNode, comment);
      return true;
    }

    if (enclosingNode && enclosingNode.type === "FunctionDeclaration" && followingNode && followingNode.type === "BlockStatement") {
      var functionParamRightParenIndex = function () {
        if (enclosingNode.params.length !== 0) {
          return util.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, options.locEnd(util.getLast(enclosingNode.params)));
        }

        var functionParamLeftParenIndex = util.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, options.locEnd(enclosingNode.id));
        return util.getNextNonSpaceNonCommentCharacterIndexWithStartIndex(text, functionParamLeftParenIndex + 1);
      }();

      if (options.locStart(comment) > functionParamRightParenIndex) {
        addBlockStatementFirstComment(followingNode, comment);
        return true;
      }
    }

    return false;
  }

  function handleImportSpecifierComments(enclosingNode, comment) {
    if (enclosingNode && enclosingNode.type === "ImportSpecifier") {
      addLeadingComment$2(enclosingNode, comment);
      return true;
    }

    return false;
  }

  function handleLabeledStatementComments(enclosingNode, comment) {
    if (enclosingNode && enclosingNode.type === "LabeledStatement") {
      addLeadingComment$2(enclosingNode, comment);
      return true;
    }

    return false;
  }

  function handleBreakAndContinueStatementComments(enclosingNode, comment) {
    if (enclosingNode && (enclosingNode.type === "ContinueStatement" || enclosingNode.type === "BreakStatement") && !enclosingNode.label) {
      addTrailingComment$2(enclosingNode, comment);
      return true;
    }

    return false;
  }

  function handleCallExpressionComments(precedingNode, enclosingNode, comment) {
    if (enclosingNode && (enclosingNode.type === "CallExpression" || enclosingNode.type === "OptionalCallExpression") && precedingNode && enclosingNode.callee === precedingNode && enclosingNode.arguments.length > 0) {
      addLeadingComment$2(enclosingNode.arguments[0], comment);
      return true;
    }

    return false;
  }

  function handleUnionTypeComments(precedingNode, enclosingNode, followingNode, comment) {
    if (enclosingNode && (enclosingNode.type === "UnionTypeAnnotation" || enclosingNode.type === "TSUnionType")) {
      addTrailingComment$2(precedingNode, comment);
      return true;
    }

    return false;
  }

  function handlePropertyComments(enclosingNode, comment) {
    if (enclosingNode && (enclosingNode.type === "Property" || enclosingNode.type === "ObjectProperty")) {
      addLeadingComment$2(enclosingNode, comment);
      return true;
    }

    return false;
  }

  function handleOnlyComments(enclosingNode, ast, comment, isLastComment) {
    // With Flow the enclosingNode is undefined so use the AST instead.
    if (ast && ast.body && ast.body.length === 0) {
      if (isLastComment) {
        addDanglingComment$2(ast, comment);
      } else {
        addLeadingComment$2(ast, comment);
      }

      return true;
    } else if (enclosingNode && enclosingNode.type === "Program" && enclosingNode.body.length === 0 && enclosingNode.directives && enclosingNode.directives.length === 0) {
      if (isLastComment) {
        addDanglingComment$2(enclosingNode, comment);
      } else {
        addLeadingComment$2(enclosingNode, comment);
      }

      return true;
    }

    return false;
  }

  function handleForComments(enclosingNode, precedingNode, comment) {
    if (enclosingNode && (enclosingNode.type === "ForInStatement" || enclosingNode.type === "ForOfStatement")) {
      addLeadingComment$2(enclosingNode, comment);
      return true;
    }

    return false;
  }

  function handleImportDeclarationComments(text, enclosingNode, precedingNode, comment, options) {
    if (precedingNode && precedingNode.type === "ImportSpecifier" && enclosingNode && enclosingNode.type === "ImportDeclaration" && util.hasNewline(text, options.locEnd(comment))) {
      addTrailingComment$2(precedingNode, comment);
      return true;
    }

    return false;
  }

  function handleAssignmentPatternComments(enclosingNode, comment) {
    if (enclosingNode && enclosingNode.type === "AssignmentPattern") {
      addLeadingComment$2(enclosingNode, comment);
      return true;
    }

    return false;
  }

  function handleTypeAliasComments(enclosingNode, followingNode, comment) {
    if (enclosingNode && enclosingNode.type === "TypeAlias") {
      addLeadingComment$2(enclosingNode, comment);
      return true;
    }

    return false;
  }

  function handleVariableDeclaratorComments(enclosingNode, followingNode, comment) {
    if (enclosingNode && (enclosingNode.type === "VariableDeclarator" || enclosingNode.type === "AssignmentExpression") && followingNode && (followingNode.type === "ObjectExpression" || followingNode.type === "ArrayExpression" || followingNode.type === "TemplateLiteral" || followingNode.type === "TaggedTemplateExpression")) {
      addLeadingComment$2(followingNode, comment);
      return true;
    }

    return false;
  }

  function handleTSMappedTypeComments(text, enclosingNode, precedingNode, followingNode, comment) {
    if (!enclosingNode || enclosingNode.type !== "TSMappedType") {
      return false;
    }

    if (followingNode && followingNode.type === "TSTypeParameter" && followingNode.name) {
      addLeadingComment$2(followingNode.name, comment);
      return true;
    }

    if (precedingNode && precedingNode.type === "TSTypeParameter" && precedingNode.constraint) {
      addTrailingComment$2(precedingNode.constraint, comment);
      return true;
    }

    return false;
  }

  function isBlockComment(comment) {
    return comment.type === "Block" || comment.type === "CommentBlock";
  }

  function hasLeadingComment(node) {
    var fn = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {
      return true;
    };

    if (node.leadingComments) {
      return node.leadingComments.some(fn);
    }

    if (node.comments) {
      return node.comments.some(function (comment) {
        return comment.leading && fn(comment);
      });
    }

    return false;
  }

  var comments$1 = {
    handleOwnLineComment: handleOwnLineComment,
    handleEndOfLineComment: handleEndOfLineComment,
    handleRemainingComment: handleRemainingComment,
    hasLeadingComment: hasLeadingComment,
    isBlockComment: isBlockComment
  };

  var isBlockComment$1 = comments$1.isBlockComment,
      hasLeadingComment$1 = comments$1.hasLeadingComment;
  var _require$$1$builders = doc.builders,
      indent$6 = _require$$1$builders.indent,
      join$7 = _require$$1$builders.join,
      hardline$8 = _require$$1$builders.hardline,
      softline$5 = _require$$1$builders.softline,
      literalline$3 = _require$$1$builders.literalline,
      concat$b = _require$$1$builders.concat,
      group$a = _require$$1$builders.group,
      dedentToRoot$2 = _require$$1$builders.dedentToRoot,
      _require$$1$utils = doc.utils,
      mapDoc$5 = _require$$1$utils.mapDoc,
      stripTrailingHardline$2 = _require$$1$utils.stripTrailingHardline;

  function embed$3(path, print, textToDoc, options) {
    var node = path.getValue();
    var parent = path.getParentNode();
    var parentParent = path.getParentNode(1);

    switch (node.type) {
      case "TemplateLiteral":
        {
          var isCss = [isStyledJsx, isStyledComponents, isCssProp, isAngularComponentStyles].some(function (isIt) {
            return isIt(path);
          });

          if (isCss) {
            // Get full template literal with expressions replaced by placeholders
            var rawQuasis = node.quasis.map(function (q) {
              return q.value.raw;
            });
            var placeholderID = 0;
            var text = rawQuasis.reduce(function (prevVal, currVal, idx) {
              return idx == 0 ? currVal : prevVal + "@prettier-placeholder-" + placeholderID++ + "-id" + currVal;
            }, "");
            var doc = textToDoc(text, {
              parser: "css"
            });
            return transformCssDoc(doc, path, print);
          }
          /*
           * react-relay and graphql-tag
           * graphql`...`
           * graphql.experimental`...`
           * gql`...`
           *
           * This intentionally excludes Relay Classic tags, as Prettier does not
           * support Relay Classic formatting.
           */


          if (isGraphQL(path)) {
            var expressionDocs = node.expressions ? path.map(print, "expressions") : [];
            var numQuasis = node.quasis.length;

            if (numQuasis === 1 && node.quasis[0].value.raw.trim() === "") {
              return "``";
            }

            var parts = [];

            for (var i = 0; i < numQuasis; i++) {
              var templateElement = node.quasis[i];
              var isFirst = i === 0;
              var isLast = i === numQuasis - 1;
              var _text = templateElement.value.cooked; // Bail out if any of the quasis have an invalid escape sequence
              // (which would make the `cooked` value be `null` or `undefined`)

              if (typeof _text !== "string") {
                return null;
              }

              var lines = _text.split("\n");

              var numLines = lines.length;
              var expressionDoc = expressionDocs[i];
              var startsWithBlankLine = numLines > 2 && lines[0].trim() === "" && lines[1].trim() === "";
              var endsWithBlankLine = numLines > 2 && lines[numLines - 1].trim() === "" && lines[numLines - 2].trim() === "";
              var commentsAndWhitespaceOnly = lines.every(function (line) {
                return /^\s*(?:#[^\r\n]*)?$/.test(line);
              }); // Bail out if an interpolation occurs within a comment.

              if (!isLast && /#[^\r\n]*$/.test(lines[numLines - 1])) {
                return null;
              }

              var _doc = null;

              if (commentsAndWhitespaceOnly) {
                _doc = printGraphqlComments(lines);
              } else {
                _doc = stripTrailingHardline$2(textToDoc(_text, {
                  parser: "graphql"
                }));
              }

              if (_doc) {
                _doc = escapeTemplateCharacters(_doc, false);

                if (!isFirst && startsWithBlankLine) {
                  parts.push("");
                }

                parts.push(_doc);

                if (!isLast && endsWithBlankLine) {
                  parts.push("");
                }
              } else if (!isFirst && !isLast && startsWithBlankLine) {
                parts.push("");
              }

              if (expressionDoc) {
                parts.push(concat$b(["${", expressionDoc, "}"]));
              }
            }

            return concat$b(["`", indent$6(concat$b([hardline$8, join$7(hardline$8, parts)])), hardline$8, "`"]);
          }

          var htmlParser = isHtml(path) ? "html" : isAngularComponentTemplate(path) ? "angular" : undefined;

          if (htmlParser) {
            return printHtmlTemplateLiteral(path, print, textToDoc, htmlParser, options.embeddedInHtml);
          }

          break;
        }

      case "TemplateElement":
        {
          /**
           * md`...`
           * markdown`...`
           */
          if (parentParent && parentParent.type === "TaggedTemplateExpression" && parent.quasis.length === 1 && parentParent.tag.type === "Identifier" && (parentParent.tag.name === "md" || parentParent.tag.name === "markdown")) {
            var _text2 = parent.quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g, function (_, backslashes) {
              return "\\".repeat(backslashes.length / 2) + "`";
            });

            var indentation = getIndentation(_text2);
            var hasIndent = indentation !== "";
            return concat$b([hasIndent ? indent$6(concat$b([softline$5, printMarkdown(_text2.replace(new RegExp("^".concat(indentation), "gm"), ""))])) : concat$b([literalline$3, dedentToRoot$2(printMarkdown(_text2))]), softline$5]);
          }

          break;
        }
    }

    function printMarkdown(text) {
      var doc = textToDoc(text, {
        parser: "markdown",
        __inJsTemplate: true
      });
      return stripTrailingHardline$2(escapeTemplateCharacters(doc, true));
    }
  }

  function getIndentation(str) {
    var firstMatchedIndent = str.match(/^([^\S\n]*)\S/m);
    return firstMatchedIndent === null ? "" : firstMatchedIndent[1];
  }

  function uncook(cookedValue) {
    return cookedValue.replace(/([\\`]|\$\{)/g, "\\$1");
  }

  function escapeTemplateCharacters(doc, raw) {
    return mapDoc$5(doc, function (currentDoc) {
      if (!currentDoc.parts) {
        return currentDoc;
      }

      var parts = [];
      currentDoc.parts.forEach(function (part) {
        if (typeof part === "string") {
          parts.push(raw ? part.replace(/(\\*)`/g, "$1$1\\`") : uncook(part));
        } else {
          parts.push(part);
        }
      });
      return Object.assign({}, currentDoc, {
        parts: parts
      });
    });
  }

  function transformCssDoc(quasisDoc, path, print) {
    var parentNode = path.getValue();
    var isEmpty = parentNode.quasis.length === 1 && !parentNode.quasis[0].value.raw.trim();

    if (isEmpty) {
      return "``";
    }

    var expressionDocs = parentNode.expressions ? path.map(print, "expressions") : [];
    var newDoc = replacePlaceholders(quasisDoc, expressionDocs);
    /* istanbul ignore if */

    if (!newDoc) {
      throw new Error("Couldn't insert all the expressions");
    }

    return concat$b(["`", indent$6(concat$b([hardline$8, stripTrailingHardline$2(newDoc)])), softline$5, "`"]);
  } // Search all the placeholders in the quasisDoc tree
  // and replace them with the expression docs one by one
  // returns a new doc with all the placeholders replaced,
  // or null if it couldn't replace any expression


  function replacePlaceholders(quasisDoc, expressionDocs) {
    if (!expressionDocs || !expressionDocs.length) {
      return quasisDoc;
    }

    var expressions = expressionDocs.slice();
    var replaceCounter = 0;
    var newDoc = mapDoc$5(quasisDoc, function (doc) {
      if (!doc || !doc.parts || !doc.parts.length) {
        return doc;
      }

      var parts = doc.parts;
      var atIndex = parts.indexOf("@");
      var placeholderIndex = atIndex + 1;

      if (atIndex > -1 && typeof parts[placeholderIndex] === "string" && parts[placeholderIndex].startsWith("prettier-placeholder")) {
        // If placeholder is split, join it
        var at = parts[atIndex];
        var placeholder = parts[placeholderIndex];
        var rest = parts.slice(placeholderIndex + 1);
        parts = parts.slice(0, atIndex).concat([at + placeholder]).concat(rest);
      }

      var atPlaceholderIndex = parts.findIndex(function (part) {
        return typeof part === "string" && part.startsWith("@prettier-placeholder");
      });

      if (atPlaceholderIndex > -1) {
        var _placeholder = parts[atPlaceholderIndex];

        var _rest = parts.slice(atPlaceholderIndex + 1);

        var placeholderMatch = _placeholder.match(/@prettier-placeholder-(.+)-id([\s\S]*)/);

        var placeholderID = placeholderMatch[1]; // When the expression has a suffix appended, like:
        // animation: linear ${time}s ease-out;

        var suffix = placeholderMatch[2];
        var expression = expressions[placeholderID];
        replaceCounter++;
        parts = parts.slice(0, atPlaceholderIndex).concat(["${", expression, "}" + suffix]).concat(_rest);
      }

      return Object.assign({}, doc, {
        parts: parts
      });
    });
    return expressions.length === replaceCounter ? newDoc : null;
  }

  function printGraphqlComments(lines) {
    var parts = [];
    var seenComment = false;
    lines.map(function (textLine) {
      return textLine.trim();
    }).forEach(function (textLine, i, array) {
      // Lines are either whitespace only, or a comment (with potential whitespace
      // around it). Drop whitespace-only lines.
      if (textLine === "") {
        return;
      }

      if (array[i - 1] === "" && seenComment) {
        // If a non-first comment is preceded by a blank (whitespace only) line,
        // add in a blank line.
        parts.push(concat$b([hardline$8, textLine]));
      } else {
        parts.push(textLine);
      }

      seenComment = true;
    }); // If `lines` was whitespace only, return `null`.

    return parts.length === 0 ? null : join$7(hardline$8, parts);
  }
  /**
   * Template literal in these contexts:
   * <style jsx>{`div{color:red}`}</style>
   * css``
   * css.global``
   * css.resolve``
   */


  function isStyledJsx(path) {
    var node = path.getValue();
    var parent = path.getParentNode();
    var parentParent = path.getParentNode(1);
    return parentParent && node.quasis && parent.type === "JSXExpressionContainer" && parentParent.type === "JSXElement" && parentParent.openingElement.name.name === "style" && parentParent.openingElement.attributes.some(function (attribute) {
      return attribute.name.name === "jsx";
    }) || parent && parent.type === "TaggedTemplateExpression" && parent.tag.type === "Identifier" && parent.tag.name === "css" || parent && parent.type === "TaggedTemplateExpression" && parent.tag.type === "MemberExpression" && parent.tag.object.name === "css" && (parent.tag.property.name === "global" || parent.tag.property.name === "resolve");
  }
  /**
   * Angular Components can have:
   * - Inline HTML template
   * - Inline CSS styles
   *
   * ...which are both within template literals somewhere
   * inside of the Component decorator factory.
   *
   * E.g.
   * @Component({
   *  template: `<div>...</div>`,
   *  styles: [`h1 { color: blue; }`]
   * })
   */


  function isAngularComponentStyles(path) {
    return isPathMatch(path, [function (node) {
      return node.type === "TemplateLiteral";
    }, function (node, name) {
      return node.type === "ArrayExpression" && name === "elements";
    }, function (node, name) {
      return node.type === "Property" && node.key.type === "Identifier" && node.key.name === "styles" && name === "value";
    }].concat(getAngularComponentObjectExpressionPredicates()));
  }

  function isAngularComponentTemplate(path) {
    return isPathMatch(path, [function (node) {
      return node.type === "TemplateLiteral";
    }, function (node, name) {
      return node.type === "Property" && node.key.type === "Identifier" && node.key.name === "template" && name === "value";
    }].concat(getAngularComponentObjectExpressionPredicates()));
  }

  function getAngularComponentObjectExpressionPredicates() {
    return [function (node, name) {
      return node.type === "ObjectExpression" && name === "properties";
    }, function (node, name) {
      return node.type === "CallExpression" && node.callee.type === "Identifier" && node.callee.name === "Component" && name === "arguments";
    }, function (node, name) {
      return node.type === "Decorator" && name === "expression";
    }];
  }
  /**
   * styled-components template literals
   */


  function isStyledComponents(path) {
    var parent = path.getParentNode();

    if (!parent || parent.type !== "TaggedTemplateExpression") {
      return false;
    }

    var tag = parent.tag;

    switch (tag.type) {
      case "MemberExpression":
        return (// styled.foo``
          isStyledIdentifier(tag.object) || // Component.extend``
          isStyledExtend(tag)
        );

      case "CallExpression":
        return (// styled(Component)``
          isStyledIdentifier(tag.callee) || tag.callee.type === "MemberExpression" && (tag.callee.object.type === "MemberExpression" && ( // styled.foo.attrs({})``
          isStyledIdentifier(tag.callee.object.object) || // Component.extend.attrs({})``
          isStyledExtend(tag.callee.object)) || // styled(Component).attrs({})``
          tag.callee.object.type === "CallExpression" && isStyledIdentifier(tag.callee.object.callee))
        );

      case "Identifier":
        // css``
        return tag.name === "css";

      default:
        return false;
    }
  }
  /**
   * JSX element with CSS prop
   */


  function isCssProp(path) {
    var parent = path.getParentNode();
    var parentParent = path.getParentNode(1);
    return parentParent && parent.type === "JSXExpressionContainer" && parentParent.type === "JSXAttribute" && parentParent.name.type === "JSXIdentifier" && parentParent.name.name === "css";
  }

  function isStyledIdentifier(node) {
    return node.type === "Identifier" && node.name === "styled";
  }

  function isStyledExtend(node) {
    return /^[A-Z]/.test(node.object.name) && node.property.name === "extend";
  }
  /*
   * react-relay and graphql-tag
   * graphql`...`
   * graphql.experimental`...`
   * gql`...`
   * GraphQL comment block
   *
   * This intentionally excludes Relay Classic tags, as Prettier does not
   * support Relay Classic formatting.
   */


  function isGraphQL(path) {
    var node = path.getValue();
    var parent = path.getParentNode();
    return hasLanguageComment(node, "GraphQL") || parent && (parent.type === "TaggedTemplateExpression" && (parent.tag.type === "MemberExpression" && parent.tag.object.name === "graphql" && parent.tag.property.name === "experimental" || parent.tag.type === "Identifier" && (parent.tag.name === "gql" || parent.tag.name === "graphql")) || parent.type === "CallExpression" && parent.callee.type === "Identifier" && parent.callee.name === "graphql");
  }

  function hasLanguageComment(node, languageName) {
    // This checks for a leading comment that is exactly `/* GraphQL */`
    // In order to be in line with other implementations of this comment tag
    // we will not trim the comment value and we will expect exactly one space on
    // either side of the GraphQL string
    // Also see ./clean.js
    return hasLeadingComment$1(node, function (comment) {
      return isBlockComment$1(comment) && comment.value === " ".concat(languageName, " ");
    });
  }

  function isPathMatch(path, predicateStack) {
    var stack = path.stack.slice();
    var name = null;
    var node = stack.pop();
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = predicateStack[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var predicate = _step.value;

        if (node === undefined) {
          return false;
        } // skip index/array


        if (typeof name === "number") {
          name = stack.pop();
          node = stack.pop();
        }

        if (!predicate(node, name)) {
          return false;
        }

        name = stack.pop();
        node = stack.pop();
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return true;
  }
  /**
   *     - html`...`
   *     - HTML comment block
   */


  function isHtml(path) {
    var node = path.getValue();
    return hasLanguageComment(node, "HTML") || isPathMatch(path, [function (node) {
      return node.type === "TemplateLiteral";
    }, function (node, name) {
      return node.type === "TaggedTemplateExpression" && node.tag.type === "Identifier" && node.tag.name === "html" && name === "quasi";
    }]);
  } // The counter is needed to distinguish nested embeds.


  var htmlTemplateLiteralCounter = 0;

  function printHtmlTemplateLiteral(path, print, textToDoc, parser, escapeClosingScriptTag) {
    var node = path.getValue();
    var counter = htmlTemplateLiteralCounter;
    htmlTemplateLiteralCounter = htmlTemplateLiteralCounter + 1 >>> 0;

    var composePlaceholder = function composePlaceholder(index) {
      return "PRETTIER_HTML_PLACEHOLDER_".concat(index, "_").concat(counter, "_IN_JS");
    };

    var text = node.quasis.map(function (quasi, index, quasis) {
      return index === quasis.length - 1 ? quasi.value.cooked : quasi.value.cooked + composePlaceholder(index);
    }).join("");
    var expressionDocs = path.map(print, "expressions");

    if (expressionDocs.length === 0 && text.trim().length === 0) {
      return "``";
    }

    var placeholderRegex = RegExp(composePlaceholder("(\\d+)"), "g");
    var contentDoc = mapDoc$5(stripTrailingHardline$2(textToDoc(text, {
      parser: parser
    })), function (doc) {
      if (typeof doc !== "string") {
        return doc;
      }

      var parts = [];
      var components = doc.split(placeholderRegex);

      for (var i = 0; i < components.length; i++) {
        var component = components[i];

        if (i % 2 === 0) {
          if (component) {
            component = uncook(component);

            if (escapeClosingScriptTag) {
              component = component.replace(/<\/(script)\b/gi, "<\\/$1");
            }

            parts.push(component);
          }

          continue;
        }

        var placeholderIndex = +component;
        parts.push(concat$b(["${", group$a(expressionDocs[placeholderIndex]), "}"]));
      }

      return concat$b(parts);
    });
    return group$a(concat$b(["`", indent$6(concat$b([hardline$8, group$a(contentDoc)])), softline$5, "`"]));
  }

  var embed_1$1 = embed$3;

  function clean$4(ast, newObj, parent) {
    ["range", "raw", "comments", "leadingComments", "trailingComments", "extra", "start", "end", "flags", "errors"].forEach(function (name) {
      delete newObj[name];
    });

    if (ast.type === "BigIntLiteral") {
      newObj.value = newObj.value.toLowerCase();
    } // We remove extra `;` and add them when needed


    if (ast.type === "EmptyStatement") {
      return null;
    } // We move text around, including whitespaces and add {" "}


    if (ast.type === "JSXText") {
      return null;
    }

    if (ast.type === "JSXExpressionContainer" && ast.expression.type === "Literal" && ast.expression.value === " ") {
      return null;
    } // We remove unneeded parens around same-operator LogicalExpressions


    if (isUnbalancedLogicalTree(newObj)) {
      return rebalanceLogicalTree(newObj);
    } // (TypeScript) Ignore `static` in `constructor(static p) {}`
    // and `export` in `constructor(export p) {}`


    if (ast.type === "TSParameterProperty" && ast.accessibility === null && !ast.readonly) {
      return {
        type: "Identifier",
        name: ast.parameter.name,
        typeAnnotation: newObj.parameter.typeAnnotation,
        decorators: newObj.decorators
      };
    } // (TypeScript) ignore empty `specifiers` array


    if (ast.type === "TSNamespaceExportDeclaration" && ast.specifiers && ast.specifiers.length === 0) {
      delete newObj.specifiers;
    } // We convert <div></div> to <div />


    if (ast.type === "JSXOpeningElement") {
      delete newObj.selfClosing;
    }

    if (ast.type === "JSXElement") {
      delete newObj.closingElement;
    } // We change {'key': value} into {key: value}


    if ((ast.type === "Property" || ast.type === "ObjectProperty" || ast.type === "MethodDefinition" || ast.type === "ClassProperty" || ast.type === "TSPropertySignature" || ast.type === "ObjectTypeProperty") && _typeof(ast.key) === "object" && ast.key && (ast.key.type === "Literal" || ast.key.type === "StringLiteral" || ast.key.type === "Identifier")) {
      delete newObj.key;
    }

    if (ast.type === "OptionalMemberExpression" && ast.optional === false) {
      newObj.type = "MemberExpression";
      delete newObj.optional;
    } // Remove raw and cooked values from TemplateElement when it's CSS
    // styled-jsx


    if (ast.type === "JSXElement" && ast.openingElement.name.name === "style" && ast.openingElement.attributes.some(function (attr) {
      return attr.name.name === "jsx";
    })) {
      var templateLiterals = newObj.children.filter(function (child) {
        return child.type === "JSXExpressionContainer" && child.expression.type === "TemplateLiteral";
      }).map(function (container) {
        return container.expression;
      });
      var quasis = templateLiterals.reduce(function (quasis, templateLiteral) {
        return quasis.concat(templateLiteral.quasis);
      }, []);
      quasis.forEach(function (q) {
        return delete q.value;
      });
    } // CSS template literals in css prop


    if (ast.type === "JSXAttribute" && ast.name.name === "css" && ast.value.type === "JSXExpressionContainer" && ast.value.expression.type === "TemplateLiteral") {
      newObj.value.expression.quasis.forEach(function (q) {
        return delete q.value;
      });
    } // Angular Components: Inline HTML template and Inline CSS styles


    var expression = ast.expression || ast.callee;

    if (ast.type === "Decorator" && expression.type === "CallExpression" && expression.callee.name === "Component" && expression.arguments.length === 1) {
      var astProps = ast.expression.arguments[0].properties;
      newObj.expression.arguments[0].properties.forEach(function (prop, index) {
        var templateLiteral = null;

        switch (astProps[index].key.name) {
          case "styles":
            if (prop.value.type === "ArrayExpression") {
              templateLiteral = prop.value.elements[0];
            }

            break;

          case "template":
            if (prop.value.type === "TemplateLiteral") {
              templateLiteral = prop.value;
            }

            break;
        }

        if (templateLiteral) {
          templateLiteral.quasis.forEach(function (q) {
            return delete q.value;
          });
        }
      });
    } // styled-components, graphql, markdown


    if (ast.type === "TaggedTemplateExpression" && (ast.tag.type === "MemberExpression" || ast.tag.type === "Identifier" && (ast.tag.name === "gql" || ast.tag.name === "graphql" || ast.tag.name === "css" || ast.tag.name === "md" || ast.tag.name === "markdown" || ast.tag.name === "html") || ast.tag.type === "CallExpression")) {
      newObj.quasi.quasis.forEach(function (quasi) {
        return delete quasi.value;
      });
    }

    if (ast.type === "TemplateLiteral") {
      // This checks for a leading comment that is exactly `/* GraphQL */`
      // In order to be in line with other implementations of this comment tag
      // we will not trim the comment value and we will expect exactly one space on
      // either side of the GraphQL string
      // Also see ./embed.js
      var hasLanguageComment = ast.leadingComments && ast.leadingComments.some(function (comment) {
        return comment.type === "CommentBlock" && ["GraphQL", "HTML"].some(function (languageName) {
          return comment.value === " ".concat(languageName, " ");
        });
      });

      if (hasLanguageComment || parent.type === "CallExpression" && parent.callee.name === "graphql") {
        newObj.quasis.forEach(function (quasi) {
          return delete quasi.value;
        });
      }
    }
  }

  function isUnbalancedLogicalTree(newObj) {
    return newObj.type === "LogicalExpression" && newObj.right.type === "LogicalExpression" && newObj.operator === newObj.right.operator;
  }

  function rebalanceLogicalTree(newObj) {
    if (isUnbalancedLogicalTree(newObj)) {
      return rebalanceLogicalTree({
        type: "LogicalExpression",
        operator: newObj.operator,
        left: rebalanceLogicalTree({
          type: "LogicalExpression",
          operator: newObj.operator,
          left: newObj.left,
          right: newObj.right.left,
          loc: {}
        }),
        right: newObj.right.right,
        loc: {}
      });
    }

    return newObj;
  }

  var clean_1$1 = clean$4;

  var getLast$1 = util.getLast,
      hasNewline$3 = util.hasNewline,
      hasNewlineInRange$1 = util.hasNewlineInRange,
      hasIgnoreComment$3 = util.hasIgnoreComment,
      hasNodeIgnoreComment$1 = util.hasNodeIgnoreComment,
      skipWhitespace$1 = util.skipWhitespace;
  var isIdentifierName = utils$1.keyword.isIdentifierNameES5; // We match any whitespace except line terminators because
  // Flow annotation comments cannot be split across lines. For example:
  //
  // (this /*
  // : any */).foo = 5;
  //
  // is not picked up by Flow (see https://github.com/facebook/flow/issues/7050), so
  // removing the newline would create a type annotation that the user did not intend
  // to create.

  var NON_LINE_TERMINATING_WHITE_SPACE = "(?:(?=.)\\s)";
  var FLOW_SHORTHAND_ANNOTATION = new RegExp("^".concat(NON_LINE_TERMINATING_WHITE_SPACE, "*:"));
  var FLOW_ANNOTATION = new RegExp("^".concat(NON_LINE_TERMINATING_WHITE_SPACE, "*::"));

  function hasFlowShorthandAnnotationComment(node) {
    // https://flow.org/en/docs/types/comments/
    // Syntax example: const r = new (window.Request /*: Class<Request> */)("");
    return node.extra && node.extra.parenthesized && node.trailingComments && node.trailingComments[0].value.match(FLOW_SHORTHAND_ANNOTATION);
  }

  function hasFlowAnnotationComment(comments) {
    return comments && comments[0].value.match(FLOW_ANNOTATION);
  }

  function hasNode(node, fn) {
    if (!node || _typeof(node) !== "object") {
      return false;
    }

    if (Array.isArray(node)) {
      return node.some(function (value) {
        return hasNode(value, fn);
      });
    }

    var result = fn(node);
    return typeof result === "boolean" ? result : Object.keys(node).some(function (key) {
      return hasNode(node[key], fn);
    });
  }

  function hasNakedLeftSide(node) {
    return node.type === "AssignmentExpression" || node.type === "BinaryExpression" || node.type === "LogicalExpression" || node.type === "NGPipeExpression" || node.type === "ConditionalExpression" || node.type === "CallExpression" || node.type === "OptionalCallExpression" || node.type === "MemberExpression" || node.type === "OptionalMemberExpression" || node.type === "SequenceExpression" || node.type === "TaggedTemplateExpression" || node.type === "BindExpression" || node.type === "UpdateExpression" && !node.prefix || node.type === "TSAsExpression" || node.type === "TSNonNullExpression";
  }

  function getLeftSide(node) {
    if (node.expressions) {
      return node.expressions[0];
    }

    return node.left || node.test || node.callee || node.object || node.tag || node.argument || node.expression;
  }

  function getLeftSidePathName(path, node) {
    if (node.expressions) {
      return ["expressions", 0];
    }

    if (node.left) {
      return ["left"];
    }

    if (node.test) {
      return ["test"];
    }

    if (node.object) {
      return ["object"];
    }

    if (node.callee) {
      return ["callee"];
    }

    if (node.tag) {
      return ["tag"];
    }

    if (node.argument) {
      return ["argument"];
    }

    if (node.expression) {
      return ["expression"];
    }

    throw new Error("Unexpected node has no left side", node);
  }

  function isLiteral(node) {
    return node.type === "BooleanLiteral" || node.type === "DirectiveLiteral" || node.type === "Literal" || node.type === "NullLiteral" || node.type === "NumericLiteral" || node.type === "RegExpLiteral" || node.type === "StringLiteral" || node.type === "TemplateLiteral" || node.type === "TSTypeLiteral" || node.type === "JSXText";
  }

  function isNumericLiteral(node) {
    return node.type === "NumericLiteral" || node.type === "Literal" && typeof node.value === "number";
  }

  function isStringLiteral(node) {
    return node.type === "StringLiteral" || node.type === "Literal" && typeof node.value === "string";
  }

  function isObjectType(n) {
    return n.type === "ObjectTypeAnnotation" || n.type === "TSTypeLiteral";
  }

  function isFunctionOrArrowExpression(node) {
    return node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression";
  }

  function isFunctionOrArrowExpressionWithBody(node) {
    return node.type === "FunctionExpression" || node.type === "ArrowFunctionExpression" && node.body.type === "BlockStatement";
  }

  function isTemplateLiteral(node) {
    return node.type === "TemplateLiteral";
  } // `inject` is used in AngularJS 1.x, `async` in Angular 2+
  // example: https://docs.angularjs.org/guide/unit-testing#using-beforeall-


  function isAngularTestWrapper(node) {
    return (node.type === "CallExpression" || node.type === "OptionalCallExpression") && node.callee.type === "Identifier" && (node.callee.name === "async" || node.callee.name === "inject" || node.callee.name === "fakeAsync");
  }

  function isJSXNode(node) {
    return node.type === "JSXElement" || node.type === "JSXFragment";
  }

  function isTheOnlyJSXElementInMarkdown(options, path) {
    if (options.parentParser !== "markdown" && options.parentParser !== "mdx") {
      return false;
    }

    var node = path.getNode();

    if (!node.expression || !isJSXNode(node.expression)) {
      return false;
    }

    var parent = path.getParentNode();
    return parent.type === "Program" && parent.body.length == 1;
  } // Detect an expression node representing `{" "}`


  function isJSXWhitespaceExpression(node) {
    return node.type === "JSXExpressionContainer" && isLiteral(node.expression) && node.expression.value === " " && !node.expression.comments;
  }

  function isMemberExpressionChain(node) {
    if (node.type !== "MemberExpression" && node.type !== "OptionalMemberExpression") {
      return false;
    }

    if (node.object.type === "Identifier") {
      return true;
    }

    return isMemberExpressionChain(node.object);
  }

  function isGetterOrSetter(node) {
    return node.kind === "get" || node.kind === "set";
  }

  function sameLocStart(nodeA, nodeB, options) {
    return options.locStart(nodeA) === options.locStart(nodeB);
  } // TODO: This is a bad hack and we need a better way to distinguish between
  // arrow functions and otherwise


  function isFunctionNotation(node, options) {
    return isGetterOrSetter(node) || sameLocStart(node, node.value, options);
  } // Hack to differentiate between the following two which have the same ast
  // type T = { method: () => void };
  // type T = { method(): void };


  function isObjectTypePropertyAFunction(node, options) {
    return (node.type === "ObjectTypeProperty" || node.type === "ObjectTypeInternalSlot") && node.value.type === "FunctionTypeAnnotation" && !node.static && !isFunctionNotation(node, options);
  } // Hack to differentiate between the following two which have the same ast
  // declare function f(a): void;
  // var f: (a) => void;


  function isTypeAnnotationAFunction(node, options) {
    return (node.type === "TypeAnnotation" || node.type === "TSTypeAnnotation") && node.typeAnnotation.type === "FunctionTypeAnnotation" && !node.static && !sameLocStart(node, node.typeAnnotation, options);
  }

  function isBinaryish(node) {
    return node.type === "BinaryExpression" || node.type === "LogicalExpression" || node.type === "NGPipeExpression";
  }

  function isMemberish(node) {
    return node.type === "MemberExpression" || node.type === "OptionalMemberExpression" || node.type === "BindExpression" && node.object;
  }

  function isSimpleFlowType(node) {
    var flowTypeAnnotations = ["AnyTypeAnnotation", "NullLiteralTypeAnnotation", "GenericTypeAnnotation", "ThisTypeAnnotation", "NumberTypeAnnotation", "VoidTypeAnnotation", "EmptyTypeAnnotation", "MixedTypeAnnotation", "BooleanTypeAnnotation", "BooleanLiteralTypeAnnotation", "StringTypeAnnotation"];
    return node && flowTypeAnnotations.indexOf(node.type) !== -1 && !(node.type === "GenericTypeAnnotation" && node.typeParameters);
  }

  var unitTestRe = /^(skip|[fx]?(it|describe|test))$/;

  function isSkipOrOnlyBlock(node) {
    return (node.callee.type === "MemberExpression" || node.callee.type === "OptionalMemberExpression") && node.callee.object.type === "Identifier" && node.callee.property.type === "Identifier" && unitTestRe.test(node.callee.object.name) && (node.callee.property.name === "only" || node.callee.property.name === "skip");
  }

  function isUnitTestSetUp(n) {
    var unitTestSetUpRe = /^(before|after)(Each|All)$/;
    return n.callee.type === "Identifier" && unitTestSetUpRe.test(n.callee.name) && n.arguments.length === 1;
  } // eg; `describe("some string", (done) => {})`


  function isTestCall(n, parent) {
    if (n.type !== "CallExpression") {
      return false;
    }

    if (n.arguments.length === 1) {
      if (isAngularTestWrapper(n) && parent && isTestCall(parent)) {
        return isFunctionOrArrowExpression(n.arguments[0]);
      }

      if (isUnitTestSetUp(n)) {
        return isAngularTestWrapper(n.arguments[0]);
      }
    } else if (n.arguments.length === 2 || n.arguments.length === 3) {
      if ((n.callee.type === "Identifier" && unitTestRe.test(n.callee.name) || isSkipOrOnlyBlock(n)) && (isTemplateLiteral(n.arguments[0]) || isStringLiteral(n.arguments[0]))) {
        // it("name", () => { ... }, 2500)
        if (n.arguments[2] && !isNumericLiteral(n.arguments[2])) {
          return false;
        }

        return (n.arguments.length === 2 ? isFunctionOrArrowExpression(n.arguments[1]) : isFunctionOrArrowExpressionWithBody(n.arguments[1]) && n.arguments[1].params.length <= 1) || isAngularTestWrapper(n.arguments[1]);
      }
    }

    return false;
  }

  function hasLeadingComment$2(node) {
    return node.comments && node.comments.some(function (comment) {
      return comment.leading;
    });
  }

  function hasTrailingComment(node) {
    return node.comments && node.comments.some(function (comment) {
      return comment.trailing;
    });
  }

  function isCallOrOptionalCallExpression(node) {
    return node.type === "CallExpression" || node.type === "OptionalCallExpression";
  }

  function hasDanglingComments(node) {
    return node.comments && node.comments.some(function (comment) {
      return !comment.leading && !comment.trailing;
    });
  }
  /** identify if an angular expression seems to have side effects */


  function hasNgSideEffect(path) {
    return hasNode(path.getValue(), function (node) {
      switch (node.type) {
        case undefined:
          return false;

        case "CallExpression":
        case "OptionalCallExpression":
        case "AssignmentExpression":
          return true;
      }
    });
  }

  function isNgForOf(node, index, parentNode) {
    return node.type === "NGMicrosyntaxKeyedExpression" && node.key.name === "of" && index === 1 && parentNode.body[0].type === "NGMicrosyntaxLet" && parentNode.body[0].value === null;
  }
  /** @param node {import("estree").TemplateLiteral} */


  function isSimpleTemplateLiteral(node) {
    if (node.expressions.length === 0) {
      return false;
    }

    return node.expressions.every(function (expr) {
      // Disallow comments since printDocToString can't print them here
      if (expr.comments) {
        return false;
      } // Allow `x` and `this`


      if (expr.type === "Identifier" || expr.type === "ThisExpression") {
        return true;
      } // Allow `a.b.c`, `a.b[c]`, and `this.x.y`


      if (expr.type === "MemberExpression" || expr.type === "OptionalMemberExpression") {
        var head = expr;

        while (head.type === "MemberExpression" || head.type === "OptionalMemberExpression") {
          if (head.property.type !== "Identifier" && head.property.type !== "Literal" && head.property.type !== "StringLiteral" && head.property.type !== "NumericLiteral") {
            return false;
          }

          head = head.object;

          if (head.comments) {
            return false;
          }
        }

        if (head.type === "Identifier" || head.type === "ThisExpression") {
          return true;
        }

        return false;
      }

      return false;
    });
  }

  function getFlowVariance(path) {
    if (!path.variance) {
      return null;
    } // Babel 7.0 currently uses variance node type, and flow should
    // follow suit soon:
    // https://github.com/babel/babel/issues/4722


    var variance = path.variance.kind || path.variance;

    switch (variance) {
      case "plus":
        return "+";

      case "minus":
        return "-";

      default:
        /* istanbul ignore next */
        return variance;
    }
  }

  function classPropMayCauseASIProblems(path) {
    var node = path.getNode();

    if (node.type !== "ClassProperty") {
      return false;
    }

    var name = node.key && node.key.name; // this isn't actually possible yet with most parsers available today
    // so isn't properly tested yet.

    if ((name === "static" || name === "get" || name === "set") && !node.value && !node.typeAnnotation) {
      return true;
    }
  }

  function classChildNeedsASIProtection(node) {
    if (!node) {
      return;
    }

    if (node.static || node.accessibility // TypeScript
    ) {
        return false;
      }

    if (!node.computed) {
      var name = node.key && node.key.name;

      if (name === "in" || name === "instanceof") {
        return true;
      }
    }

    switch (node.type) {
      case "ClassProperty":
      case "TSAbstractClassProperty":
        return node.computed;

      case "MethodDefinition": // Flow

      case "TSAbstractMethodDefinition": // TypeScript

      case "ClassMethod":
      case "ClassPrivateMethod":
        {
          // Babel
          var isAsync = node.value ? node.value.async : node.async;
          var isGenerator = node.value ? node.value.generator : node.generator;

          if (isAsync || node.kind === "get" || node.kind === "set") {
            return false;
          }

          if (node.computed || isGenerator) {
            return true;
          }

          return false;
        }

      case "TSIndexSignature":
        return true;

      default:
        /* istanbul ignore next */
        return false;
    }
  }

  function getTypeScriptMappedTypeModifier(tokenNode, keyword) {
    if (tokenNode === "+") {
      return "+" + keyword;
    } else if (tokenNode === "-") {
      return "-" + keyword;
    }

    return keyword;
  }

  function hasNewlineBetweenOrAfterDecorators(node, options) {
    return hasNewlineInRange$1(options.originalText, options.locStart(node.decorators[0]), options.locEnd(getLast$1(node.decorators))) || hasNewline$3(options.originalText, options.locEnd(getLast$1(node.decorators)));
  } // Only space, newline, carriage return, and tab are treated as whitespace
  // inside JSX.


  var jsxWhitespaceChars = " \n\r\t";
  var matchJsxWhitespaceRegex = new RegExp("([" + jsxWhitespaceChars + "]+)");
  var containsNonJsxWhitespaceRegex = new RegExp("[^" + jsxWhitespaceChars + "]"); // Meaningful if it contains non-whitespace characters,
  // or it contains whitespace without a new line.

  function isMeaningfulJSXText(node) {
    return isLiteral(node) && (containsNonJsxWhitespaceRegex.test(rawText(node)) || !/\n/.test(rawText(node)));
  }

  function hasJsxIgnoreComment(path) {
    var node = path.getValue();
    var parent = path.getParentNode();

    if (!parent || !node || !isJSXNode(node) || !isJSXNode(parent)) {
      return false;
    } // Lookup the previous sibling, ignoring any empty JSXText elements


    var index = parent.children.indexOf(node);
    var prevSibling = null;

    for (var i = index; i > 0; i--) {
      var candidate = parent.children[i - 1];

      if (candidate.type === "JSXText" && !isMeaningfulJSXText(candidate)) {
        continue;
      }

      prevSibling = candidate;
      break;
    }

    return prevSibling && prevSibling.type === "JSXExpressionContainer" && prevSibling.expression.type === "JSXEmptyExpression" && prevSibling.expression.comments && prevSibling.expression.comments.find(function (comment) {
      return comment.value.trim() === "prettier-ignore";
    });
  }

  function isEmptyJSXElement(node) {
    if (node.children.length === 0) {
      return true;
    }

    if (node.children.length > 1) {
      return false;
    } // if there is one text child and does not contain any meaningful text
    // we can treat the element as empty.


    var child = node.children[0];
    return isLiteral(child) && !isMeaningfulJSXText(child);
  }

  function hasPrettierIgnore$2(path) {
    return hasIgnoreComment$3(path) || hasJsxIgnoreComment(path);
  }

  function isLastStatement(path) {
    var parent = path.getParentNode();

    if (!parent) {
      return true;
    }

    var node = path.getValue();
    var body = (parent.body || parent.consequent).filter(function (stmt) {
      return stmt.type !== "EmptyStatement";
    });
    return body && body[body.length - 1] === node;
  }

  function isFlowAnnotationComment(text, typeAnnotation, options) {
    var start = options.locStart(typeAnnotation);
    var end = skipWhitespace$1(text, options.locEnd(typeAnnotation));
    return text.substr(start, 2) === "/*" && text.substr(end, 2) === "*/";
  }

  function hasLeadingOwnLineComment(text, node, options) {
    if (isJSXNode(node)) {
      return hasNodeIgnoreComment$1(node);
    }

    var res = node.comments && node.comments.some(function (comment) {
      return comment.leading && hasNewline$3(text, options.locEnd(comment));
    });
    return res;
  } // This recurses the return argument, looking for the first token
  // (the leftmost leaf node) and, if it (or its parents) has any
  // leadingComments, returns true (so it can be wrapped in parens).


  function returnArgumentHasLeadingComment(options, argument) {
    if (hasLeadingOwnLineComment(options.originalText, argument, options)) {
      return true;
    }

    if (hasNakedLeftSide(argument)) {
      var leftMost = argument;
      var newLeftMost;

      while (newLeftMost = getLeftSide(leftMost)) {
        leftMost = newLeftMost;

        if (hasLeadingOwnLineComment(options.originalText, leftMost, options)) {
          return true;
        }
      }
    }

    return false;
  }

  function isStringPropSafeToCoerceToIdentifier(node, options) {
    return isStringLiteral(node.key) && isIdentifierName(node.key.value) && options.parser !== "json" && !(options.parser === "typescript" && node.type === "ClassProperty");
  }

  function isJestEachTemplateLiteral(node, parentNode) {
    /**
     * describe.each`table`(name, fn)
     * describe.only.each`table`(name, fn)
     * describe.skip.each`table`(name, fn)
     * test.each`table`(name, fn)
     * test.only.each`table`(name, fn)
     * test.skip.each`table`(name, fn)
     *
     * Ref: https://github.com/facebook/jest/pull/6102
     */
    var jestEachTriggerRegex = /^[xf]?(describe|it|test)$/;
    return parentNode.type === "TaggedTemplateExpression" && parentNode.quasi === node && parentNode.tag.type === "MemberExpression" && parentNode.tag.property.type === "Identifier" && parentNode.tag.property.name === "each" && (parentNode.tag.object.type === "Identifier" && jestEachTriggerRegex.test(parentNode.tag.object.name) || parentNode.tag.object.type === "MemberExpression" && parentNode.tag.object.property.type === "Identifier" && (parentNode.tag.object.property.name === "only" || parentNode.tag.object.property.name === "skip") && parentNode.tag.object.object.type === "Identifier" && jestEachTriggerRegex.test(parentNode.tag.object.object.name));
  }

  function templateLiteralHasNewLines(template) {
    return template.quasis.some(function (quasi) {
      return quasi.value.raw.includes("\n");
    });
  }

  function isTemplateOnItsOwnLine(n, text, options) {
    return (n.type === "TemplateLiteral" && templateLiteralHasNewLines(n) || n.type === "TaggedTemplateExpression" && templateLiteralHasNewLines(n.quasi)) && !hasNewline$3(text, options.locStart(n), {
      backwards: true
    });
  }

  function needsHardlineAfterDanglingComment(node) {
    if (!node.comments) {
      return false;
    }

    var lastDanglingComment = getLast$1(node.comments.filter(function (comment) {
      return !comment.leading && !comment.trailing;
    }));
    return lastDanglingComment && !comments$1.isBlockComment(lastDanglingComment);
  } // If we have nested conditional expressions, we want to print them in JSX mode
  // if there's at least one JSXElement somewhere in the tree.
  //
  // A conditional expression chain like this should be printed in normal mode,
  // because there aren't JSXElements anywhere in it:
  //
  // isA ? "A" : isB ? "B" : isC ? "C" : "Unknown";
  //
  // But a conditional expression chain like this should be printed in JSX mode,
  // because there is a JSXElement in the last ConditionalExpression:
  //
  // isA ? "A" : isB ? "B" : isC ? "C" : <span className="warning">Unknown</span>;
  //
  // This type of ConditionalExpression chain is structured like this in the AST:
  //
  // ConditionalExpression {
  //   test: ...,
  //   consequent: ...,
  //   alternate: ConditionalExpression {
  //     test: ...,
  //     consequent: ...,
  //     alternate: ConditionalExpression {
  //       test: ...,
  //       consequent: ...,
  //       alternate: ...,
  //     }
  //   }
  // }
  //
  // We want to traverse over that shape and convert it into a flat structure so
  // that we can find if there's a JSXElement somewhere inside.


  function getConditionalChainContents(node) {
    // Given this code:
    //
    // // Using a ConditionalExpression as the consequent is uncommon, but should
    // // be handled.
    // A ? B : C ? D : E ? F ? G : H : I
    //
    // which has this AST:
    //
    // ConditionalExpression {
    //   test: Identifier(A),
    //   consequent: Identifier(B),
    //   alternate: ConditionalExpression {
    //     test: Identifier(C),
    //     consequent: Identifier(D),
    //     alternate: ConditionalExpression {
    //       test: Identifier(E),
    //       consequent: ConditionalExpression {
    //         test: Identifier(F),
    //         consequent: Identifier(G),
    //         alternate: Identifier(H),
    //       },
    //       alternate: Identifier(I),
    //     }
    //   }
    // }
    //
    // we should return this Array:
    //
    // [
    //   Identifier(A),
    //   Identifier(B),
    //   Identifier(C),
    //   Identifier(D),
    //   Identifier(E),
    //   Identifier(F),
    //   Identifier(G),
    //   Identifier(H),
    //   Identifier(I)
    // ];
    //
    // This loses the information about whether each node was the test,
    // consequent, or alternate, but we don't care about that here- we are only
    // flattening this structure to find if there's any JSXElements inside.
    var nonConditionalExpressions = [];

    function recurse(node) {
      if (node.type === "ConditionalExpression") {
        recurse(node.test);
        recurse(node.consequent);
        recurse(node.alternate);
      } else {
        nonConditionalExpressions.push(node);
      }
    }

    recurse(node);
    return nonConditionalExpressions;
  }

  function conditionalExpressionChainContainsJSX(node) {
    return Boolean(getConditionalChainContents(node).find(isJSXNode));
  } // Logic to check for args with multiple anonymous functions. For instance,
  // the following call should be split on multiple lines for readability:
  // source.pipe(map((x) => x + x), filter((x) => x % 2 === 0))


  function isFunctionCompositionArgs(args) {
    if (args.length <= 1) {
      return false;
    }

    var count = 0;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = args[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var arg = _step.value;

        if (isFunctionOrArrowExpression(arg)) {
          count += 1;

          if (count > 1) {
            return true;
          }
        } else if (isCallOrOptionalCallExpression(arg)) {
          var _iteratorNormalCompletion2 = true;
          var _didIteratorError2 = false;
          var _iteratorError2 = undefined;

          try {
            for (var _iterator2 = arg.arguments[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
              var childArg = _step2.value;

              if (isFunctionOrArrowExpression(childArg)) {
                return true;
              }
            }
          } catch (err) {
            _didIteratorError2 = true;
            _iteratorError2 = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion2 && _iterator2.return != null) {
                _iterator2.return();
              }
            } finally {
              if (_didIteratorError2) {
                throw _iteratorError2;
              }
            }
          }
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    return false;
  } // Logic to determine if a call is a long curried function call.
  // See https://github.com/prettier/prettier/issues/1420.
  //
  // `connect(a, b, c)(d)`
  // In the above call expression, the second call is the parent node and the
  // first call is the current node.


  function isLongCurriedCallExpression(path) {
    var node = path.getValue();
    var parent = path.getParentNode();
    return isCallOrOptionalCallExpression(node) && isCallOrOptionalCallExpression(parent) && parent.callee === node && node.arguments.length > parent.arguments.length && parent.arguments.length > 0;
  }

  function rawText(node) {
    return node.extra ? node.extra.raw : node.raw;
  }

  function identity$1(x) {
    return x;
  }

  function isTSXFile(options) {
    return options.filepath && /\.tsx$/i.test(options.filepath);
  }

  var utils$4 = {
    classChildNeedsASIProtection: classChildNeedsASIProtection,
    classPropMayCauseASIProblems: classPropMayCauseASIProblems,
    conditionalExpressionChainContainsJSX: conditionalExpressionChainContainsJSX,
    getFlowVariance: getFlowVariance,
    getLeftSidePathName: getLeftSidePathName,
    getTypeScriptMappedTypeModifier: getTypeScriptMappedTypeModifier,
    hasDanglingComments: hasDanglingComments,
    hasFlowAnnotationComment: hasFlowAnnotationComment,
    hasFlowShorthandAnnotationComment: hasFlowShorthandAnnotationComment,
    hasLeadingComment: hasLeadingComment$2,
    hasLeadingOwnLineComment: hasLeadingOwnLineComment,
    hasNakedLeftSide: hasNakedLeftSide,
    hasNewlineBetweenOrAfterDecorators: hasNewlineBetweenOrAfterDecorators,
    hasNgSideEffect: hasNgSideEffect,
    hasNode: hasNode,
    hasPrettierIgnore: hasPrettierIgnore$2,
    hasTrailingComment: hasTrailingComment,
    identity: identity$1,
    isBinaryish: isBinaryish,
    isCallOrOptionalCallExpression: isCallOrOptionalCallExpression,
    isEmptyJSXElement: isEmptyJSXElement,
    isFlowAnnotationComment: isFlowAnnotationComment,
    isFunctionCompositionArgs: isFunctionCompositionArgs,
    isFunctionNotation: isFunctionNotation,
    isFunctionOrArrowExpression: isFunctionOrArrowExpression,
    isGetterOrSetter: isGetterOrSetter,
    isJestEachTemplateLiteral: isJestEachTemplateLiteral,
    isJSXNode: isJSXNode,
    isJSXWhitespaceExpression: isJSXWhitespaceExpression,
    isLastStatement: isLastStatement,
    isLiteral: isLiteral,
    isLongCurriedCallExpression: isLongCurriedCallExpression,
    isMeaningfulJSXText: isMeaningfulJSXText,
    isMemberExpressionChain: isMemberExpressionChain,
    isMemberish: isMemberish,
    isNgForOf: isNgForOf,
    isNumericLiteral: isNumericLiteral,
    isObjectType: isObjectType,
    isObjectTypePropertyAFunction: isObjectTypePropertyAFunction,
    isSimpleFlowType: isSimpleFlowType,
    isSimpleTemplateLiteral: isSimpleTemplateLiteral,
    isStringLiteral: isStringLiteral,
    isStringPropSafeToCoerceToIdentifier: isStringPropSafeToCoerceToIdentifier,
    isTemplateOnItsOwnLine: isTemplateOnItsOwnLine,
    isTestCall: isTestCall,
    isTheOnlyJSXElementInMarkdown: isTheOnlyJSXElementInMarkdown,
    isTSXFile: isTSXFile,
    isTypeAnnotationAFunction: isTypeAnnotationAFunction,
    matchJsxWhitespaceRegex: matchJsxWhitespaceRegex,
    needsHardlineAfterDanglingComment: needsHardlineAfterDanglingComment,
    rawText: rawText,
    returnArgumentHasLeadingComment: returnArgumentHasLeadingComment
  };

  var getLeftSidePathName$1 = utils$4.getLeftSidePathName,
      hasFlowShorthandAnnotationComment$1 = utils$4.hasFlowShorthandAnnotationComment,
      hasNakedLeftSide$1 = utils$4.hasNakedLeftSide,
      hasNode$1 = utils$4.hasNode;

  function hasClosureCompilerTypeCastComment(text, path) {
    // https://github.com/google/closure-compiler/wiki/Annotating-Types#type-casts
    // Syntax example: var x = /** @type {string} */ (fruit);
    var n = path.getValue();
    return isParenthesized(n) && (hasTypeCastComment(n) || hasAncestorTypeCastComment(0)); // for sub-item: /** @type {array} */ (numberOrString).map(x => x);

    function hasAncestorTypeCastComment(index) {
      var ancestor = path.getParentNode(index);
      return ancestor && !isParenthesized(ancestor) ? hasTypeCastComment(ancestor) || hasAncestorTypeCastComment(index + 1) : false;
    }

    function hasTypeCastComment(node) {
      return node.comments && node.comments.some(function (comment) {
        return comment.leading && comments$1.isBlockComment(comment) && isTypeCastComment(comment.value);
      });
    }

    function isParenthesized(node) {
      // Closure typecast comments only really make sense when _not_ using
      // typescript or flow parsers, so we take advantage of the babel parser's
      // parenthesized expressions.
      return node.extra && node.extra.parenthesized;
    }

    function isTypeCastComment(comment) {
      var cleaned = comment.trim().split("\n").map(function (line) {
        return line.replace(/^[\s*]+/, "");
      }).join(" ").trim();

      if (!/^@type\s*\{[^]+\}$/.test(cleaned)) {
        return false;
      }

      var isCompletelyClosed = false;
      var unpairedBracketCount = 0;
      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {
        for (var _iterator = cleaned[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var char = _step.value;

          if (char === "{") {
            if (isCompletelyClosed) {
              return false;
            }

            unpairedBracketCount++;
          } else if (char === "}") {
            if (unpairedBracketCount === 0) {
              return false;
            }

            unpairedBracketCount--;

            if (unpairedBracketCount === 0) {
              isCompletelyClosed = true;
            }
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return != null) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return unpairedBracketCount === 0;
    }
  }

  function needsParens(path, options) {
    var parent = path.getParentNode();

    if (!parent) {
      return false;
    }

    var name = path.getName();
    var node = path.getNode(); // If the value of this path is some child of a Node and not a Node
    // itself, then it doesn't need parentheses. Only Node objects (in
    // fact, only Expression nodes) need parentheses.

    if (path.getValue() !== node) {
      return false;
    } // to avoid unexpected `}}` in HTML interpolations


    if (options.__isInHtmlInterpolation && !options.bracketSpacing && endsWithRightBracket(node) && isFollowedByRightBracket(path)) {
      return true;
    } // Only statements don't need parentheses.


    if (isStatement(node)) {
      return false;
    } // Closure compiler requires that type casted expressions to be surrounded by
    // parentheses.


    if (hasClosureCompilerTypeCastComment(options.originalText, path)) {
      return true;
    }

    if ( // Preserve parens if we have a Flow annotation comment, unless we're using the Flow
    // parser. The Flow parser turns Flow comments into type annotation nodes in its
    // AST, which we handle separately.
    options.parser !== "flow" && hasFlowShorthandAnnotationComment$1(path.getValue())) {
      return true;
    } // Identifiers never need parentheses.


    if (node.type === "Identifier") {
      // ...unless those identifiers are embed placeholders. They might be substituted by complex
      // expressions, so the parens around them should not be dropped. Example (JS-in-HTML-in-JS):
      //     let tpl = html`<script> f((${expr}) / 2); </script>`;
      // If the inner JS formatter removes the parens, the expression might change its meaning:
      //     f((a + b) / 2)  vs  f(a + b / 2)
      if (node.extra && node.extra.parenthesized && /^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(node.name)) {
        return true;
      }

      return false;
    }

    if (parent.type === "ParenthesizedExpression") {
      return false;
    } // Add parens around the extends clause of a class. It is needed for almost
    // all expressions.


    if ((parent.type === "ClassDeclaration" || parent.type === "ClassExpression") && parent.superClass === node && (node.type === "ArrowFunctionExpression" || node.type === "AssignmentExpression" || node.type === "AwaitExpression" || node.type === "BinaryExpression" || node.type === "ConditionalExpression" || node.type === "LogicalExpression" || node.type === "NewExpression" || node.type === "ObjectExpression" || node.type === "ParenthesizedExpression" || node.type === "SequenceExpression" || node.type === "TaggedTemplateExpression" || node.type === "UnaryExpression" || node.type === "UpdateExpression" || node.type === "YieldExpression")) {
      return true;
    } // `export default function` or `export default class` can't be followed by
    // anything after. So an expression like `export default (function(){}).toString()`
    // needs to be followed by a parentheses


    if (parent.type === "ExportDefaultDeclaration") {
      return shouldWrapFunctionForExportDefault(path, options);
    }

    if (parent.type === "Decorator" && parent.expression === node) {
      var hasCallExpression = false;
      var hasMemberExpression = false;
      var current = node;

      while (current) {
        switch (current.type) {
          case "MemberExpression":
            hasMemberExpression = true;
            current = current.object;
            break;

          case "CallExpression":
            if (
            /** @(x().y) */
            hasMemberExpression ||
            /** @(x().y()) */
            hasCallExpression) {
              return true;
            }

            hasCallExpression = true;
            current = current.callee;
            break;

          case "Identifier":
            return false;

          default:
            return true;
        }
      }

      return true;
    }

    if (parent.type === "ArrowFunctionExpression" && parent.body === node && node.type !== "SequenceExpression" && // these have parens added anyway
    util.startsWithNoLookaheadToken(node,
    /* forbidFunctionClassAndDoExpr */
    false) || parent.type === "ExpressionStatement" && util.startsWithNoLookaheadToken(node,
    /* forbidFunctionClassAndDoExpr */
    true)) {
      return true;
    }

    switch (node.type) {
      case "SpreadElement":
      case "SpreadProperty":
        return parent.type === "MemberExpression" && name === "object" && parent.object === node;

      case "UpdateExpression":
        if (parent.type === "UnaryExpression") {
          return node.prefix && (node.operator === "++" && parent.operator === "+" || node.operator === "--" && parent.operator === "-");
        }

      // else fallthrough

      case "UnaryExpression":
        switch (parent.type) {
          case "UnaryExpression":
            return node.operator === parent.operator && (node.operator === "+" || node.operator === "-");

          case "BindExpression":
            return true;

          case "MemberExpression":
          case "OptionalMemberExpression":
            return name === "object";

          case "TaggedTemplateExpression":
            return true;

          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return name === "callee";

          case "BinaryExpression":
            return parent.operator === "**" && name === "left";

          case "TSNonNullExpression":
            return true;

          default:
            return false;
        }

      case "BinaryExpression":
        {
          if (parent.type === "UpdateExpression") {
            return true;
          }

          var isLeftOfAForStatement = function isLeftOfAForStatement(node) {
            var i = 0;

            while (node) {
              var _parent = path.getParentNode(i++);

              if (!_parent) {
                return false;
              }

              if (_parent.type === "ForStatement" && _parent.init === node) {
                return true;
              }

              node = _parent;
            }

            return false;
          };

          if (node.operator === "in" && isLeftOfAForStatement(node)) {
            return true;
          }
        }
      // fallthrough

      case "TSTypeAssertion":
      case "TSAsExpression":
      case "LogicalExpression":
        switch (parent.type) {
          case "ConditionalExpression":
            return node.type === "TSAsExpression";

          case "CallExpression":
          case "NewExpression":
          case "OptionalCallExpression":
            return name === "callee";

          case "ClassExpression":
          case "ClassDeclaration":
            return name === "superClass" && parent.superClass === node;

          case "TSTypeAssertion":
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "JSXSpreadAttribute":
          case "SpreadElement":
          case "SpreadProperty":
          case "BindExpression":
          case "AwaitExpression":
          case "TSAsExpression":
          case "TSNonNullExpression":
          case "UpdateExpression":
            return true;

          case "MemberExpression":
          case "OptionalMemberExpression":
            return name === "object";

          case "AssignmentExpression":
            return parent.left === node && (node.type === "TSTypeAssertion" || node.type === "TSAsExpression");

          case "LogicalExpression":
            if (node.type === "LogicalExpression") {
              return parent.operator !== node.operator;
            }

          // else fallthrough

          case "BinaryExpression":
            {
              if (!node.operator && node.type !== "TSTypeAssertion") {
                return true;
              }

              var po = parent.operator;
              var pp = util.getPrecedence(po);
              var no = node.operator;
              var np = util.getPrecedence(no);

              if (pp > np) {
                return true;
              }

              if (pp === np && name === "right") {
                assert.strictEqual(parent.right, node);
                return true;
              }

              if (pp === np && !util.shouldFlatten(po, no)) {
                return true;
              }

              if (pp < np && no === "%") {
                return po === "+" || po === "-";
              } // Add parenthesis when working with bitwise operators
              // It's not strictly needed but helps with code understanding


              if (util.isBitwiseOperator(po)) {
                return true;
              }

              return false;
            }

          default:
            return false;
        }

      case "SequenceExpression":
        switch (parent.type) {
          case "ReturnStatement":
            return false;

          case "ForStatement":
            // Although parentheses wouldn't hurt around sequence
            // expressions in the head of for loops, traditional style
            // dictates that e.g. i++, j++ should not be wrapped with
            // parentheses.
            return false;

          case "ExpressionStatement":
            return name !== "expression";

          case "ArrowFunctionExpression":
            // We do need parentheses, but SequenceExpressions are handled
            // specially when printing bodies of arrow functions.
            return name !== "body";

          default:
            // Otherwise err on the side of overparenthesization, adding
            // explicit exceptions above if this proves overzealous.
            return true;
        }

      case "YieldExpression":
        if (parent.type === "UnaryExpression" || parent.type === "AwaitExpression" || parent.type === "TSAsExpression" || parent.type === "TSNonNullExpression") {
          return true;
        }

      // else fallthrough

      case "AwaitExpression":
        switch (parent.type) {
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "BinaryExpression":
          case "LogicalExpression":
          case "SpreadElement":
          case "SpreadProperty":
          case "TSAsExpression":
          case "TSNonNullExpression":
          case "BindExpression":
            return true;

          case "MemberExpression":
          case "OptionalMemberExpression":
            return name === "object";

          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return name === "callee";

          case "ConditionalExpression":
            return parent.test === node;

          default:
            return false;
        }

      case "TSConditionalType":
        if (parent.type === "TSConditionalType" && node === parent.extendsType) {
          return true;
        }

      // fallthrough

      case "TSFunctionType":
      case "TSConstructorType":
        if (parent.type === "TSConditionalType" && node === parent.checkType) {
          return true;
        }

      // fallthrough

      case "TSUnionType":
      case "TSIntersectionType":
        if (parent.type === "TSUnionType" || parent.type === "TSIntersectionType") {
          return true;
        }

      // fallthrough

      case "TSTypeOperator":
      case "TSInferType":
        return parent.type === "TSArrayType" || parent.type === "TSOptionalType" || parent.type === "TSRestType" || parent.type === "TSIndexedAccessType" && node === parent.objectType || parent.type === "TSTypeOperator";

      case "ArrayTypeAnnotation":
        return parent.type === "NullableTypeAnnotation";

      case "IntersectionTypeAnnotation":
      case "UnionTypeAnnotation":
        return parent.type === "ArrayTypeAnnotation" || parent.type === "NullableTypeAnnotation" || parent.type === "IntersectionTypeAnnotation" || parent.type === "UnionTypeAnnotation";

      case "NullableTypeAnnotation":
        return parent.type === "ArrayTypeAnnotation";

      case "FunctionTypeAnnotation":
        {
          var ancestor = parent.type === "NullableTypeAnnotation" ? path.getParentNode(1) : parent;
          return ancestor.type === "UnionTypeAnnotation" || ancestor.type === "IntersectionTypeAnnotation" || ancestor.type === "ArrayTypeAnnotation" || // We should check ancestor's parent to know whether the parentheses
          // are really needed, but since ??T doesn't make sense this check
          // will almost never be true.
          ancestor.type === "NullableTypeAnnotation";
        }

      case "StringLiteral":
      case "NumericLiteral":
      case "Literal":
        if (typeof node.value === "string" && parent.type === "ExpressionStatement" && ( // TypeScript workaround for https://github.com/JamesHenry/typescript-estree/issues/2
        // See corresponding workaround in printer.js case: "Literal"
        options.parser !== "typescript" && !parent.directive || options.parser === "typescript" && options.originalText.substr(options.locStart(node) - 1, 1) === "(")) {
          // To avoid becoming a directive
          var grandParent = path.getParentNode(1);
          return grandParent.type === "Program" || grandParent.type === "BlockStatement";
        }

        return parent.type === "MemberExpression" && typeof node.value === "number" && name === "object" && parent.object === node;

      case "AssignmentExpression":
        {
          var _grandParent = path.getParentNode(1);

          if (parent.type === "ArrowFunctionExpression" && parent.body === node) {
            return true;
          } else if (parent.type === "ClassProperty" && parent.key === node && parent.computed) {
            return false;
          } else if (parent.type === "TSPropertySignature" && parent.name === node) {
            return false;
          } else if (parent.type === "ForStatement" && (parent.init === node || parent.update === node)) {
            return false;
          } else if (parent.type === "ExpressionStatement") {
            return node.left.type === "ObjectPattern";
          } else if (parent.type === "TSPropertySignature" && parent.key === node) {
            return false;
          } else if (parent.type === "AssignmentExpression") {
            return false;
          } else if (parent.type === "SequenceExpression" && _grandParent && _grandParent.type === "ForStatement" && (_grandParent.init === parent || _grandParent.update === parent)) {
            return false;
          } else if (parent.type === "Property" && parent.value === node) {
            return false;
          } else if (parent.type === "NGChainedExpression") {
            return false;
          }

          return true;
        }

      case "ConditionalExpression":
        switch (parent.type) {
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "SpreadElement":
          case "SpreadProperty":
          case "BinaryExpression":
          case "LogicalExpression":
          case "NGPipeExpression":
          case "ExportDefaultDeclaration":
          case "AwaitExpression":
          case "JSXSpreadAttribute":
          case "TSTypeAssertion":
          case "TypeCastExpression":
          case "TSAsExpression":
          case "TSNonNullExpression":
            return true;

          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return name === "callee";

          case "ConditionalExpression":
            return name === "test" && parent.test === node;

          case "MemberExpression":
          case "OptionalMemberExpression":
            return name === "object";

          default:
            return false;
        }

      case "FunctionExpression":
        switch (parent.type) {
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            // Not always necessary, but it's clearer to the reader if IIFEs are wrapped in parentheses.
            // Is necessary if it is `expression` of `ExpressionStatement`.
            return name === "callee";

          case "TaggedTemplateExpression":
            return true;
          // This is basically a kind of IIFE.

          default:
            return false;
        }

      case "ArrowFunctionExpression":
        switch (parent.type) {
          case "NewExpression":
          case "CallExpression":
          case "OptionalCallExpression":
            return name === "callee";

          case "MemberExpression":
          case "OptionalMemberExpression":
            return name === "object";

          case "TSAsExpression":
          case "BindExpression":
          case "TaggedTemplateExpression":
          case "UnaryExpression":
          case "LogicalExpression":
          case "BinaryExpression":
          case "AwaitExpression":
          case "TSTypeAssertion":
            return true;

          case "ConditionalExpression":
            return name === "test";

          default:
            return false;
        }

      case "ClassExpression":
        switch (parent.type) {
          case "NewExpression":
            return name === "callee" && parent.callee === node;

          default:
            return false;
        }

      case "OptionalMemberExpression":
      case "OptionalCallExpression":
        if ((parent.type === "MemberExpression" && name === "object" || parent.type === "CallExpression" && name === "callee") && // workaround for https://github.com/facebook/flow/issues/8159
        !(options.parser === "flow" && parent.range[0] === node.range[0])) {
          return true;
        }

      // fallthrough

      case "CallExpression":
      case "MemberExpression":
      case "TaggedTemplateExpression":
      case "TSNonNullExpression":
        if ((parent.type === "BindExpression" || parent.type === "NewExpression") && name === "callee") {
          var object = node;

          while (object) {
            switch (object.type) {
              case "CallExpression":
              case "OptionalCallExpression":
                return true;

              case "MemberExpression":
              case "OptionalMemberExpression":
              case "BindExpression":
                object = object.object;
                break;
              // tagged templates are basically member expressions from a grammar perspective
              // see https://tc39.github.io/ecma262/#prod-MemberExpression

              case "TaggedTemplateExpression":
                object = object.tag;
                break;

              case "TSNonNullExpression":
                object = object.expression;
                break;

              default:
                return false;
            }
          }
        }

        return false;

      case "BindExpression":
        return (parent.type === "BindExpression" || parent.type === "NewExpression") && name === "callee" || (parent.type === "MemberExpression" || parent.type === "OptionalMemberExpression") && name === "object";

      case "NGPipeExpression":
        if (parent.type === "NGRoot" || parent.type === "NGMicrosyntaxExpression" || parent.type === "ObjectProperty" || parent.type === "ArrayExpression" || (parent.type === "CallExpression" || parent.type === "OptionalCallExpression") && parent.arguments[name] === node || parent.type === "NGPipeExpression" && name === "right" || parent.type === "MemberExpression" && name === "property" || parent.type === "AssignmentExpression") {
          return false;
        }

        return true;

      case "JSXFragment":
      case "JSXElement":
        return name === "callee" || parent.type !== "ArrayExpression" && parent.type !== "ArrowFunctionExpression" && parent.type !== "AssignmentExpression" && parent.type !== "AssignmentPattern" && parent.type !== "BinaryExpression" && parent.type !== "CallExpression" && parent.type !== "ConditionalExpression" && parent.type !== "ExpressionStatement" && parent.type !== "JsExpressionRoot" && parent.type !== "JSXAttribute" && parent.type !== "JSXElement" && parent.type !== "JSXExpressionContainer" && parent.type !== "JSXFragment" && parent.type !== "LogicalExpression" && parent.type !== "ObjectProperty" && parent.type !== "OptionalCallExpression" && parent.type !== "Property" && parent.type !== "ReturnStatement" && parent.type !== "TypeCastExpression" && parent.type !== "VariableDeclarator";

      case "TypeAnnotation":
        return name === "returnType" && parent.type === "ArrowFunctionExpression" && includesFunctionTypeInObjectType(node);
    }

    return false;
  }

  function isStatement(node) {
    return node.type === "BlockStatement" || node.type === "BreakStatement" || node.type === "ClassBody" || node.type === "ClassDeclaration" || node.type === "ClassMethod" || node.type === "ClassProperty" || node.type === "ClassPrivateProperty" || node.type === "ContinueStatement" || node.type === "DebuggerStatement" || node.type === "DeclareClass" || node.type === "DeclareExportAllDeclaration" || node.type === "DeclareExportDeclaration" || node.type === "DeclareFunction" || node.type === "DeclareInterface" || node.type === "DeclareModule" || node.type === "DeclareModuleExports" || node.type === "DeclareVariable" || node.type === "DoWhileStatement" || node.type === "EnumDeclaration" || node.type === "ExportAllDeclaration" || node.type === "ExportDefaultDeclaration" || node.type === "ExportNamedDeclaration" || node.type === "ExpressionStatement" || node.type === "ForAwaitStatement" || node.type === "ForInStatement" || node.type === "ForOfStatement" || node.type === "ForStatement" || node.type === "FunctionDeclaration" || node.type === "IfStatement" || node.type === "ImportDeclaration" || node.type === "InterfaceDeclaration" || node.type === "LabeledStatement" || node.type === "MethodDefinition" || node.type === "ReturnStatement" || node.type === "SwitchStatement" || node.type === "ThrowStatement" || node.type === "TryStatement" || node.type === "TSDeclareFunction" || node.type === "TSEnumDeclaration" || node.type === "TSImportEqualsDeclaration" || node.type === "TSInterfaceDeclaration" || node.type === "TSModuleDeclaration" || node.type === "TSNamespaceExportDeclaration" || node.type === "TypeAlias" || node.type === "VariableDeclaration" || node.type === "WhileStatement" || node.type === "WithStatement";
  }

  function includesFunctionTypeInObjectType(node) {
    return hasNode$1(node, function (n1) {
      return n1.type === "ObjectTypeAnnotation" && hasNode$1(n1, function (n2) {
        return n2.type === "FunctionTypeAnnotation" || undefined;
      }) || undefined;
    });
  }

  function endsWithRightBracket(node) {
    switch (node.type) {
      case "ObjectExpression":
        return true;

      default:
        return false;
    }
  }

  function isFollowedByRightBracket(path) {
    var node = path.getValue();
    var parent = path.getParentNode();
    var name = path.getName();

    switch (parent.type) {
      case "NGPipeExpression":
        if (typeof name === "number" && parent.arguments[name] === node && parent.arguments.length - 1 === name) {
          return path.callParent(isFollowedByRightBracket);
        }

        break;

      case "ObjectProperty":
        if (name === "value") {
          var parentParent = path.getParentNode(1);
          return parentParent.properties[parentParent.properties.length - 1] === parent;
        }

        break;

      case "BinaryExpression":
      case "LogicalExpression":
        if (name === "right") {
          return path.callParent(isFollowedByRightBracket);
        }

        break;

      case "ConditionalExpression":
        if (name === "alternate") {
          return path.callParent(isFollowedByRightBracket);
        }

        break;

      case "UnaryExpression":
        if (parent.prefix) {
          return path.callParent(isFollowedByRightBracket);
        }

        break;
    }

    return false;
  }

  function shouldWrapFunctionForExportDefault(path, options) {
    var node = path.getValue();
    var parent = path.getParentNode();

    if (node.type === "FunctionExpression" || node.type === "ClassExpression") {
      return parent.type === "ExportDefaultDeclaration" || // in some cases the function is already wrapped
      // (e.g. `export default (function() {})();`)
      // in this case we don't need to add extra parens
      !needsParens(path, options);
    }

    if (!hasNakedLeftSide$1(node) || parent.type !== "ExportDefaultDeclaration" && needsParens(path, options)) {
      return false;
    }

    return path.call.apply(path, [function (childPath) {
      return shouldWrapFunctionForExportDefault(childPath, options);
    }].concat(getLeftSidePathName$1(path, node)));
  }

  var needsParens_1 = needsParens;

  var _require$$0$builders$6 = doc.builders,
      concat$c = _require$$0$builders$6.concat,
      join$8 = _require$$0$builders$6.join,
      line$6 = _require$$0$builders$6.line;

  function printHtmlBinding(path, options, print) {
    var node = path.getValue();

    if (options.__onHtmlBindingRoot && path.getName() === null) {
      options.__onHtmlBindingRoot(node);
    }

    if (node.type !== "File") {
      return;
    }

    if (options.__isVueForBindingLeft) {
      return path.call(function (functionDeclarationPath) {
        var _functionDeclarationP = functionDeclarationPath.getValue(),
            params = _functionDeclarationP.params;

        return concat$c([params.length > 1 ? "(" : "", join$8(concat$c([",", line$6]), functionDeclarationPath.map(print, "params")), params.length > 1 ? ")" : ""]);
      }, "program", "body", 0);
    }

    if (options.__isVueSlotScope) {
      return path.call(function (functionDeclarationPath) {
        return join$8(concat$c([",", line$6]), functionDeclarationPath.map(print, "params"));
      }, "program", "body", 0);
    }
  } // based on https://github.com/prettier/prettier/blob/master/src/language-html/syntax-vue.js isVueEventBindingExpression()


  function isVueEventBindingExpression$2(node) {
    switch (node.type) {
      case "MemberExpression":
        switch (node.property.type) {
          case "Identifier":
          case "NumericLiteral":
          case "StringLiteral":
            return isVueEventBindingExpression$2(node.object);
        }

        return false;

      case "Identifier":
        return true;

      default:
        return false;
    }
  }

  var htmlBinding = {
    isVueEventBindingExpression: isVueEventBindingExpression$2,
    printHtmlBinding: printHtmlBinding
  };

  function preprocess$1(ast, options) {
    switch (options.parser) {
      case "json":
      case "json5":
      case "json-stringify":
      case "__js_expression":
      case "__vue_expression":
        return Object.assign({}, ast, {
          type: options.parser.startsWith("__") ? "JsExpressionRoot" : "JsonRoot",
          node: ast,
          comments: []
        });

      default:
        return ast;
    }
  }

  var preprocess_1$1 = preprocess$1;

  var getParentExportDeclaration$1 = util.getParentExportDeclaration,
      isExportDeclaration$1 = util.isExportDeclaration,
      shouldFlatten$1 = util.shouldFlatten,
      getNextNonSpaceNonCommentCharacter$1 = util.getNextNonSpaceNonCommentCharacter,
      hasNewline$4 = util.hasNewline,
      hasNewlineInRange$2 = util.hasNewlineInRange,
      getLast$2 = util.getLast,
      getStringWidth$2 = util.getStringWidth,
      printString$2 = util.printString,
      printNumber$2 = util.printNumber,
      hasIgnoreComment$4 = util.hasIgnoreComment,
      hasNodeIgnoreComment$2 = util.hasNodeIgnoreComment,
      getPenultimate$1 = util.getPenultimate,
      startsWithNoLookaheadToken$1 = util.startsWithNoLookaheadToken,
      getIndentSize$1 = util.getIndentSize,
      matchAncestorTypes$1 = util.matchAncestorTypes,
      getPreferredQuote$1 = util.getPreferredQuote;
  var isNextLineEmpty$4 = utilShared.isNextLineEmpty,
      isNextLineEmptyAfterIndex$1 = utilShared.isNextLineEmptyAfterIndex,
      getNextNonSpaceNonCommentCharacterIndex$2 = utilShared.getNextNonSpaceNonCommentCharacterIndex;
  var insertPragma$7 = pragma.insertPragma;
  var printHtmlBinding$1 = htmlBinding.printHtmlBinding,
      isVueEventBindingExpression$3 = htmlBinding.isVueEventBindingExpression;
  var classChildNeedsASIProtection$1 = utils$4.classChildNeedsASIProtection,
      classPropMayCauseASIProblems$1 = utils$4.classPropMayCauseASIProblems,
      conditionalExpressionChainContainsJSX$1 = utils$4.conditionalExpressionChainContainsJSX,
      getFlowVariance$1 = utils$4.getFlowVariance,
      getLeftSidePathName$2 = utils$4.getLeftSidePathName,
      getTypeScriptMappedTypeModifier$1 = utils$4.getTypeScriptMappedTypeModifier,
      hasDanglingComments$1 = utils$4.hasDanglingComments,
      hasFlowAnnotationComment$1 = utils$4.hasFlowAnnotationComment,
      hasFlowShorthandAnnotationComment$2 = utils$4.hasFlowShorthandAnnotationComment,
      hasLeadingComment$3 = utils$4.hasLeadingComment,
      hasLeadingOwnLineComment$1 = utils$4.hasLeadingOwnLineComment,
      hasNakedLeftSide$2 = utils$4.hasNakedLeftSide,
      hasNewlineBetweenOrAfterDecorators$1 = utils$4.hasNewlineBetweenOrAfterDecorators,
      hasNgSideEffect$1 = utils$4.hasNgSideEffect,
      hasPrettierIgnore$3 = utils$4.hasPrettierIgnore,
      hasTrailingComment$1 = utils$4.hasTrailingComment,
      identity$2 = utils$4.identity,
      isBinaryish$1 = utils$4.isBinaryish,
      isCallOrOptionalCallExpression$1 = utils$4.isCallOrOptionalCallExpression,
      isEmptyJSXElement$1 = utils$4.isEmptyJSXElement,
      isFlowAnnotationComment$1 = utils$4.isFlowAnnotationComment,
      isFunctionCompositionArgs$1 = utils$4.isFunctionCompositionArgs,
      isFunctionNotation$1 = utils$4.isFunctionNotation,
      isFunctionOrArrowExpression$1 = utils$4.isFunctionOrArrowExpression,
      isGetterOrSetter$1 = utils$4.isGetterOrSetter,
      isJestEachTemplateLiteral$1 = utils$4.isJestEachTemplateLiteral,
      isJSXNode$1 = utils$4.isJSXNode,
      isJSXWhitespaceExpression$1 = utils$4.isJSXWhitespaceExpression,
      isLastStatement$1 = utils$4.isLastStatement,
      isLiteral$1 = utils$4.isLiteral,
      isLongCurriedCallExpression$1 = utils$4.isLongCurriedCallExpression,
      isMeaningfulJSXText$1 = utils$4.isMeaningfulJSXText,
      isMemberExpressionChain$1 = utils$4.isMemberExpressionChain,
      isMemberish$1 = utils$4.isMemberish,
      isNgForOf$1 = utils$4.isNgForOf,
      isNumericLiteral$1 = utils$4.isNumericLiteral,
      isObjectType$1 = utils$4.isObjectType,
      isObjectTypePropertyAFunction$1 = utils$4.isObjectTypePropertyAFunction,
      isSimpleFlowType$1 = utils$4.isSimpleFlowType,
      isSimpleTemplateLiteral$1 = utils$4.isSimpleTemplateLiteral,
      isStringLiteral$1 = utils$4.isStringLiteral,
      isStringPropSafeToCoerceToIdentifier$1 = utils$4.isStringPropSafeToCoerceToIdentifier,
      isTemplateOnItsOwnLine$1 = utils$4.isTemplateOnItsOwnLine,
      isTestCall$1 = utils$4.isTestCall,
      isTheOnlyJSXElementInMarkdown$1 = utils$4.isTheOnlyJSXElementInMarkdown,
      isTSXFile$1 = utils$4.isTSXFile,
      isTypeAnnotationAFunction$1 = utils$4.isTypeAnnotationAFunction,
      matchJsxWhitespaceRegex$1 = utils$4.matchJsxWhitespaceRegex,
      needsHardlineAfterDanglingComment$1 = utils$4.needsHardlineAfterDanglingComment,
      rawText$1 = utils$4.rawText,
      returnArgumentHasLeadingComment$1 = utils$4.returnArgumentHasLeadingComment;
  var needsQuoteProps = new WeakMap();
  var _require$$5$builders = doc.builders,
      concat$d = _require$$5$builders.concat,
      join$9 = _require$$5$builders.join,
      line$7 = _require$$5$builders.line,
      hardline$9 = _require$$5$builders.hardline,
      softline$6 = _require$$5$builders.softline,
      literalline$4 = _require$$5$builders.literalline,
      group$b = _require$$5$builders.group,
      indent$7 = _require$$5$builders.indent,
      align$1 = _require$$5$builders.align,
      conditionalGroup$1 = _require$$5$builders.conditionalGroup,
      fill$4 = _require$$5$builders.fill,
      ifBreak$6 = _require$$5$builders.ifBreak,
      breakParent$3 = _require$$5$builders.breakParent,
      lineSuffixBoundary$1 = _require$$5$builders.lineSuffixBoundary,
      addAlignmentToDoc$2 = _require$$5$builders.addAlignmentToDoc,
      dedent$2 = _require$$5$builders.dedent,
      _require$$5$utils = doc.utils,
      willBreak$1 = _require$$5$utils.willBreak,
      isLineNext$1 = _require$$5$utils.isLineNext,
      isEmpty$1 = _require$$5$utils.isEmpty,
      removeLines$2 = _require$$5$utils.removeLines,
      printDocToString$1 = doc.printer.printDocToString;
  var uid = 0;

  function shouldPrintComma$1(options, level) {
    level = level || "es5";

    switch (options.trailingComma) {
      case "all":
        if (level === "all") {
          return true;
        }

      // fallthrough

      case "es5":
        if (level === "es5") {
          return true;
        }

      // fallthrough

      case "none":
      default:
        return false;
    }
  }

  function genericPrint$3(path, options, printPath, args) {
    var node = path.getValue();
    var needsParens = false;
    var linesWithoutParens = printPathNoParens(path, options, printPath, args);

    if (!node || isEmpty$1(linesWithoutParens)) {
      return linesWithoutParens;
    }

    var parentExportDecl = getParentExportDeclaration$1(path);
    var decorators = [];

    if (node.type === "ClassMethod" || node.type === "ClassPrivateMethod" || node.type === "ClassProperty" || node.type === "TSAbstractClassProperty" || node.type === "ClassPrivateProperty" || node.type === "MethodDefinition" || node.type === "TSAbstractMethodDefinition") ; else if (node.decorators && node.decorators.length > 0 && // If the parent node is an export declaration and the decorator
    // was written before the export, the export will be responsible
    // for printing the decorators.
    !(parentExportDecl && options.locStart(parentExportDecl, {
      ignoreDecorators: true
    }) > options.locStart(node.decorators[0]))) {
      var shouldBreak = node.type === "ClassExpression" || node.type === "ClassDeclaration" || hasNewlineBetweenOrAfterDecorators$1(node, options);
      var separator = shouldBreak ? hardline$9 : line$7;
      path.each(function (decoratorPath) {
        var decorator = decoratorPath.getValue();

        if (decorator.expression) {
          decorator = decorator.expression;
        } else {
          decorator = decorator.callee;
        }

        decorators.push(printPath(decoratorPath), separator);
      }, "decorators");

      if (parentExportDecl) {
        decorators.unshift(hardline$9);
      }
    } else if (isExportDeclaration$1(node) && node.declaration && node.declaration.decorators && node.declaration.decorators.length > 0 && // Only print decorators here if they were written before the export,
    // otherwise they are printed by the node.declaration
    options.locStart(node, {
      ignoreDecorators: true
    }) > options.locStart(node.declaration.decorators[0])) {
      // Export declarations are responsible for printing any decorators
      // that logically apply to node.declaration.
      path.each(function (decoratorPath) {
        var decorator = decoratorPath.getValue();
        var prefix = decorator.type === "Decorator" ? "" : "@";
        decorators.push(prefix, printPath(decoratorPath), hardline$9);
      }, "declaration", "decorators");
    } else {
      // Nodes with decorators can't have parentheses, so we can avoid
      // computing pathNeedsParens() except in this case.
      needsParens = needsParens_1(path, options);
    }

    var parts = [];

    if (needsParens) {
      parts.unshift("(");
    }

    parts.push(linesWithoutParens);

    if (needsParens) {
      var _node = path.getValue();

      if (hasFlowShorthandAnnotationComment$2(_node)) {
        parts.push(" /*");
        parts.push(_node.trailingComments[0].value.trimLeft());
        parts.push("*/");
        _node.trailingComments[0].printed = true;
      }

      parts.push(")");
    }

    if (decorators.length > 0) {
      return group$b(concat$d(decorators.concat(parts)));
    }

    return concat$d(parts);
  }

  function printDecorators(path, options, print) {
    var node = path.getValue();
    return group$b(concat$d([join$9(line$7, path.map(print, "decorators")), hasNewlineBetweenOrAfterDecorators$1(node, options) ? hardline$9 : line$7]));
  }
  /**
   * The following is the shared logic for
   * ternary operators, namely ConditionalExpression
   * and TSConditionalType
   * @typedef {Object} OperatorOptions
   * @property {() => Array<string | Doc>} beforeParts - Parts to print before the `?`.
   * @property {(breakClosingParen: boolean) => Array<string | Doc>} afterParts - Parts to print after the conditional expression.
   * @property {boolean} shouldCheckJsx - Whether to check for and print in JSX mode.
   * @property {string} conditionalNodeType - The type of the conditional expression node, ie "ConditionalExpression" or "TSConditionalType".
   * @property {string} consequentNodePropertyName - The property at which the consequent node can be found on the main node, eg "consequent".
   * @property {string} alternateNodePropertyName - The property at which the alternate node can be found on the main node, eg "alternate".
   * @property {string} testNodePropertyName - The property at which the test node can be found on the main node, eg "test".
   * @property {boolean} breakNested - Whether to break all nested ternaries when one breaks.
   * @param {FastPath} path - The path to the ConditionalExpression/TSConditionalType node.
   * @param {Options} options - Prettier options
   * @param {Function} print - Print function to call recursively
   * @param {OperatorOptions} operatorOptions
   * @returns Doc
   */


  function printTernaryOperator(path, options, print, operatorOptions) {
    var node = path.getValue();
    var testNode = node[operatorOptions.testNodePropertyName];
    var consequentNode = node[operatorOptions.consequentNodePropertyName];
    var alternateNode = node[operatorOptions.alternateNodePropertyName];
    var parts = []; // We print a ConditionalExpression in either "JSX mode" or "normal mode".
    // See tests/jsx/conditional-expression.js for more info.

    var jsxMode = false;
    var parent = path.getParentNode();
    var forceNoIndent = parent.type === operatorOptions.conditionalNodeType; // Find the outermost non-ConditionalExpression parent, and the outermost
    // ConditionalExpression parent. We'll use these to determine if we should
    // print in JSX mode.

    var currentParent;
    var previousParent;
    var i = 0;

    do {
      previousParent = currentParent || node;
      currentParent = path.getParentNode(i);
      i++;
    } while (currentParent && currentParent.type === operatorOptions.conditionalNodeType);

    var firstNonConditionalParent = currentParent || parent;
    var lastConditionalParent = previousParent;

    if (operatorOptions.shouldCheckJsx && (isJSXNode$1(testNode) || isJSXNode$1(consequentNode) || isJSXNode$1(alternateNode) || conditionalExpressionChainContainsJSX$1(lastConditionalParent))) {
      jsxMode = true;
      forceNoIndent = true; // Even though they don't need parens, we wrap (almost) everything in
      // parens when using ?: within JSX, because the parens are analogous to
      // curly braces in an if statement.

      var wrap = function wrap(doc) {
        return concat$d([ifBreak$6("(", ""), indent$7(concat$d([softline$6, doc])), softline$6, ifBreak$6(")", "")]);
      }; // The only things we don't wrap are:
      // * Nested conditional expressions in alternates
      // * null


      var isNull = function isNull(node) {
        return node.type === "NullLiteral" || node.type === "Literal" && node.value === null;
      };

      parts.push(" ? ", isNull(consequentNode) ? path.call(print, operatorOptions.consequentNodePropertyName) : wrap(path.call(print, operatorOptions.consequentNodePropertyName)), " : ", alternateNode.type === operatorOptions.conditionalNodeType || isNull(alternateNode) ? path.call(print, operatorOptions.alternateNodePropertyName) : wrap(path.call(print, operatorOptions.alternateNodePropertyName)));
    } else {
      // normal mode
      var part = concat$d([line$7, "? ", consequentNode.type === operatorOptions.conditionalNodeType ? ifBreak$6("", "(") : "", align$1(2, path.call(print, operatorOptions.consequentNodePropertyName)), consequentNode.type === operatorOptions.conditionalNodeType ? ifBreak$6("", ")") : "", line$7, ": ", alternateNode.type === operatorOptions.conditionalNodeType ? path.call(print, operatorOptions.alternateNodePropertyName) : align$1(2, path.call(print, operatorOptions.alternateNodePropertyName))]);
      parts.push(parent.type !== operatorOptions.conditionalNodeType || parent[operatorOptions.alternateNodePropertyName] === node ? part : options.useTabs ? dedent$2(indent$7(part)) : align$1(Math.max(0, options.tabWidth - 2), part));
    } // We want a whole chain of ConditionalExpressions to all
    // break if any of them break. That means we should only group around the
    // outer-most ConditionalExpression.


    var maybeGroup = function maybeGroup(doc) {
      return operatorOptions.breakNested ? parent === firstNonConditionalParent ? group$b(doc) : doc : group$b(doc);
    }; // Break the closing paren to keep the chain right after it:
    // (a
    //   ? b
    //   : c
    // ).call()


    var breakClosingParen = !jsxMode && (parent.type === "MemberExpression" || parent.type === "OptionalMemberExpression" || parent.type === "NGPipeExpression" && parent.left === node && operatorOptions.breakNested) && !parent.computed;
    return maybeGroup(concat$d([].concat(function (testDoc) {
      return (
        /**
         *     a
         *       ? b
         *       : multiline
         *         test
         *         node
         *       ^^ align(2)
         *       ? d
         *       : e
         */
        parent.type === operatorOptions.conditionalNodeType && parent[operatorOptions.alternateNodePropertyName] === node ? align$1(2, testDoc) : testDoc
      );
    }(concat$d(operatorOptions.beforeParts())), forceNoIndent ? concat$d(parts) : indent$7(concat$d(parts)), operatorOptions.afterParts(breakClosingParen))));
  }

  function printPathNoParens(path, options, print, args) {
    var n = path.getValue();
    var semi = options.semi ? ";" : "";

    if (!n) {
      return "";
    }

    if (typeof n === "string") {
      return n;
    }

    var htmlBinding = printHtmlBinding$1(path, options, print);

    if (htmlBinding) {
      return htmlBinding;
    }

    var parts = [];

    switch (n.type) {
      case "JsExpressionRoot":
        return path.call(print, "node");

      case "JsonRoot":
        return concat$d([path.call(print, "node"), hardline$9]);

      case "File":
        // Print @babel/parser's InterpreterDirective here so that
        // leading comments on the `Program` node get printed after the hashbang.
        if (n.program && n.program.interpreter) {
          parts.push(path.call(function (programPath) {
            return programPath.call(print, "interpreter");
          }, "program"));
        }

        parts.push(path.call(print, "program"));
        return concat$d(parts);

      case "Program":
        // Babel 6
        if (n.directives) {
          path.each(function (childPath) {
            parts.push(print(childPath), semi, hardline$9);

            if (isNextLineEmpty$4(options.originalText, childPath.getValue(), options)) {
              parts.push(hardline$9);
            }
          }, "directives");
        }

        parts.push(path.call(function (bodyPath) {
          return printStatementSequence(bodyPath, options, print);
        }, "body"));
        parts.push(comments.printDanglingComments(path, options,
        /* sameIndent */
        true)); // Only force a trailing newline if there were any contents.

        if (n.body.length || n.comments) {
          parts.push(hardline$9);
        }

        return concat$d(parts);
      // Babel extension.

      case "EmptyStatement":
        return "";

      case "ExpressionStatement":
        // Detect Flow-parsed directives
        if (n.directive) {
          return concat$d([nodeStr(n.expression, options, true), semi]);
        }

        if (options.parser === "__vue_event_binding") {
          var parent = path.getParentNode();

          if (parent.type === "Program" && parent.body.length === 1 && parent.body[0] === n) {
            return concat$d([path.call(print, "expression"), isVueEventBindingExpression$3(n.expression) ? ";" : ""]);
          }
        } // Do not append semicolon after the only JSX element in a program


        return concat$d([path.call(print, "expression"), isTheOnlyJSXElementInMarkdown$1(options, path) ? "" : semi]);
      // Babel extension.

      case "ParenthesizedExpression":
        return concat$d(["(", path.call(print, "expression"), ")"]);

      case "AssignmentExpression":
        return printAssignment(n.left, path.call(print, "left"), concat$d([" ", n.operator]), n.right, path.call(print, "right"), options);

      case "BinaryExpression":
      case "LogicalExpression":
      case "NGPipeExpression":
        {
          var _parent = path.getParentNode();

          var parentParent = path.getParentNode(1);
          var isInsideParenthesis = n !== _parent.body && (_parent.type === "IfStatement" || _parent.type === "WhileStatement" || _parent.type === "SwitchStatement" || _parent.type === "DoWhileStatement");

          var _parts = printBinaryishExpressions(path, print, options,
          /* isNested */
          false, isInsideParenthesis); //   if (
          //     this.hasPlugin("dynamicImports") && this.lookahead().type === tt.parenLeft
          //   ) {
          //
          // looks super weird, we want to break the children if the parent breaks
          //
          //   if (
          //     this.hasPlugin("dynamicImports") &&
          //     this.lookahead().type === tt.parenLeft
          //   ) {


          if (isInsideParenthesis) {
            return concat$d(_parts);
          } // Break between the parens in
          // unaries or in a member or specific call expression, i.e.
          //
          //   (
          //     a &&
          //     b &&
          //     c
          //   ).call()


          if ((_parent.type === "CallExpression" || _parent.type === "OptionalCallExpression") && _parent.callee === n || _parent.type === "UnaryExpression" || (_parent.type === "MemberExpression" || _parent.type === "OptionalMemberExpression") && !_parent.computed) {
            return group$b(concat$d([indent$7(concat$d([softline$6, concat$d(_parts)])), softline$6]));
          } // Avoid indenting sub-expressions in some cases where the first sub-expression is already
          // indented accordingly. We should indent sub-expressions where the first case isn't indented.


          var shouldNotIndent = _parent.type === "ReturnStatement" || _parent.type === "JSXExpressionContainer" && parentParent.type === "JSXAttribute" || n.type !== "NGPipeExpression" && (_parent.type === "NGRoot" && options.parser === "__ng_binding" || _parent.type === "NGMicrosyntaxExpression" && parentParent.type === "NGMicrosyntax" && parentParent.body.length === 1) || n === _parent.body && _parent.type === "ArrowFunctionExpression" || n !== _parent.body && _parent.type === "ForStatement" || _parent.type === "ConditionalExpression" && parentParent.type !== "ReturnStatement" && parentParent.type !== "CallExpression" && parentParent.type !== "OptionalCallExpression";
          var shouldIndentIfInlining = _parent.type === "AssignmentExpression" || _parent.type === "VariableDeclarator" || _parent.type === "ClassProperty" || _parent.type === "TSAbstractClassProperty" || _parent.type === "ClassPrivateProperty" || _parent.type === "ObjectProperty" || _parent.type === "Property";
          var samePrecedenceSubExpression = isBinaryish$1(n.left) && shouldFlatten$1(n.operator, n.left.operator);

          if (shouldNotIndent || shouldInlineLogicalExpression(n) && !samePrecedenceSubExpression || !shouldInlineLogicalExpression(n) && shouldIndentIfInlining) {
            return group$b(concat$d(_parts));
          }

          if (_parts.length === 0) {
            return "";
          } // If the right part is a JSX node, we include it in a separate group to
          // prevent it breaking the whole chain, so we can print the expression like:
          //
          //   foo && bar && (
          //     <Foo>
          //       <Bar />
          //     </Foo>
          //   )


          var hasJSX = isJSXNode$1(n.right);
          var rest = concat$d(hasJSX ? _parts.slice(1, -1) : _parts.slice(1));
          var groupId = Symbol("logicalChain-" + ++uid);
          var chain = group$b(concat$d([// Don't include the initial expression in the indentation
          // level. The first item is guaranteed to be the first
          // left-most expression.
          _parts.length > 0 ? _parts[0] : "", indent$7(rest)]), {
            id: groupId
          });

          if (!hasJSX) {
            return chain;
          }

          var jsxPart = getLast$2(_parts);
          return group$b(concat$d([chain, ifBreak$6(indent$7(jsxPart), jsxPart, {
            groupId: groupId
          })]));
        }

      case "AssignmentPattern":
        return concat$d([path.call(print, "left"), " = ", path.call(print, "right")]);

      case "TSTypeAssertion":
        {
          var shouldBreakAfterCast = !(n.expression.type === "ArrayExpression" || n.expression.type === "ObjectExpression");
          var castGroup = group$b(concat$d(["<", indent$7(concat$d([softline$6, path.call(print, "typeAnnotation")])), softline$6, ">"]));
          var exprContents = concat$d([ifBreak$6("("), indent$7(concat$d([softline$6, path.call(print, "expression")])), softline$6, ifBreak$6(")")]);

          if (shouldBreakAfterCast) {
            return conditionalGroup$1([concat$d([castGroup, path.call(print, "expression")]), concat$d([castGroup, group$b(exprContents, {
              shouldBreak: true
            })]), concat$d([castGroup, path.call(print, "expression")])]);
          }

          return group$b(concat$d([castGroup, path.call(print, "expression")]));
        }

      case "OptionalMemberExpression":
      case "MemberExpression":
        {
          var _parent2 = path.getParentNode();

          var firstNonMemberParent;
          var i = 0;

          do {
            firstNonMemberParent = path.getParentNode(i);
            i++;
          } while (firstNonMemberParent && (firstNonMemberParent.type === "MemberExpression" || firstNonMemberParent.type === "OptionalMemberExpression" || firstNonMemberParent.type === "TSNonNullExpression"));

          var shouldInline = firstNonMemberParent && (firstNonMemberParent.type === "NewExpression" || firstNonMemberParent.type === "BindExpression" || firstNonMemberParent.type === "VariableDeclarator" && firstNonMemberParent.id.type !== "Identifier" || firstNonMemberParent.type === "AssignmentExpression" && firstNonMemberParent.left.type !== "Identifier") || n.computed || n.object.type === "Identifier" && n.property.type === "Identifier" && _parent2.type !== "MemberExpression" && _parent2.type !== "OptionalMemberExpression";
          return concat$d([path.call(print, "object"), shouldInline ? printMemberLookup(path, options, print) : group$b(indent$7(concat$d([softline$6, printMemberLookup(path, options, print)])))]);
        }

      case "MetaProperty":
        return concat$d([path.call(print, "meta"), ".", path.call(print, "property")]);

      case "BindExpression":
        if (n.object) {
          parts.push(path.call(print, "object"));
        }

        parts.push(group$b(indent$7(concat$d([softline$6, printBindExpressionCallee(path, options, print)]))));
        return concat$d(parts);

      case "Identifier":
        {
          return concat$d([n.name, printOptionalToken(path), printTypeAnnotation(path, options, print)]);
        }

      case "V8IntrinsicIdentifier":
        return concat$d(["%", n.name]);

      case "SpreadElement":
      case "SpreadElementPattern":
      case "RestProperty":
      case "SpreadProperty":
      case "SpreadPropertyPattern":
      case "RestElement":
      case "ObjectTypeSpreadProperty":
        return concat$d(["...", path.call(print, "argument"), printTypeAnnotation(path, options, print)]);

      case "FunctionDeclaration":
      case "FunctionExpression":
        parts.push(printFunctionDeclaration(path, print, options));

        if (!n.body) {
          parts.push(semi);
        }

        return concat$d(parts);

      case "ArrowFunctionExpression":
        {
          if (n.async) {
            parts.push("async ");
          }

          if (shouldPrintParamsWithoutParens(path, options)) {
            parts.push(path.call(print, "params", 0));
          } else {
            parts.push(group$b(concat$d([printFunctionParams(path, print, options,
            /* expandLast */
            args && (args.expandLastArg || args.expandFirstArg),
            /* printTypeParams */
            true), printReturnType(path, print, options)])));
          }

          var dangling = comments.printDanglingComments(path, options,
          /* sameIndent */
          true, function (comment) {
            var nextCharacter = getNextNonSpaceNonCommentCharacterIndex$2(options.originalText, comment, options);
            return options.originalText.substr(nextCharacter, 2) === "=>";
          });

          if (dangling) {
            parts.push(" ", dangling);
          }

          parts.push(" =>");
          var body = path.call(function (bodyPath) {
            return print(bodyPath, args);
          }, "body"); // We want to always keep these types of nodes on the same line
          // as the arrow.

          if (!hasLeadingOwnLineComment$1(options.originalText, n.body, options) && (n.body.type === "ArrayExpression" || n.body.type === "ObjectExpression" || n.body.type === "BlockStatement" || isJSXNode$1(n.body) || isTemplateOnItsOwnLine$1(n.body, options.originalText, options) || n.body.type === "ArrowFunctionExpression" || n.body.type === "DoExpression")) {
            return group$b(concat$d([concat$d(parts), " ", body]));
          } // We handle sequence expressions as the body of arrows specially,
          // so that the required parentheses end up on their own lines.


          if (n.body.type === "SequenceExpression") {
            return group$b(concat$d([concat$d(parts), group$b(concat$d([" (", indent$7(concat$d([softline$6, body])), softline$6, ")"]))]));
          } // if the arrow function is expanded as last argument, we are adding a
          // level of indentation and need to add a softline to align the closing )
          // with the opening (, or if it's inside a JSXExpression (e.g. an attribute)
          // we should align the expression's closing } with the line with the opening {.


          var shouldAddSoftLine = (args && args.expandLastArg || path.getParentNode().type === "JSXExpressionContainer") && !(n.comments && n.comments.length);
          var printTrailingComma = args && args.expandLastArg && shouldPrintComma$1(options, "all"); // In order to avoid confusion between
          // a => a ? a : a
          // a <= a ? a : a

          var shouldAddParens = n.body.type === "ConditionalExpression" && !startsWithNoLookaheadToken$1(n.body,
          /* forbidFunctionAndClass */
          false);
          return group$b(concat$d([concat$d(parts), group$b(concat$d([indent$7(concat$d([line$7, shouldAddParens ? ifBreak$6("", "(") : "", body, shouldAddParens ? ifBreak$6("", ")") : ""])), shouldAddSoftLine ? concat$d([ifBreak$6(printTrailingComma ? "," : ""), softline$6]) : ""]))]));
        }

      case "YieldExpression":
        parts.push("yield");

        if (n.delegate) {
          parts.push("*");
        }

        if (n.argument) {
          parts.push(" ", path.call(print, "argument"));
        }

        return concat$d(parts);

      case "AwaitExpression":
        {
          parts.push("await ", path.call(print, "argument"));

          var _parent3 = path.getParentNode();

          if ((_parent3.type === "CallExpression" || _parent3.type === "OptionalCallExpression") && _parent3.callee === n || (_parent3.type === "MemberExpression" || _parent3.type === "OptionalMemberExpression") && _parent3.object === n) {
            return group$b(concat$d([indent$7(concat$d([softline$6, concat$d(parts)])), softline$6]));
          }

          return concat$d(parts);
        }

      case "ImportSpecifier":
        if (n.importKind) {
          parts.push(path.call(print, "importKind"), " ");
        }

        parts.push(path.call(print, "imported"));

        if (n.local && n.local.name !== n.imported.name) {
          parts.push(" as ", path.call(print, "local"));
        }

        return concat$d(parts);

      case "ExportSpecifier":
        parts.push(path.call(print, "local"));

        if (n.exported && n.exported.name !== n.local.name) {
          parts.push(" as ", path.call(print, "exported"));
        }

        return concat$d(parts);

      case "ImportNamespaceSpecifier":
        parts.push("* as ");
        parts.push(path.call(print, "local"));
        return concat$d(parts);

      case "ImportDefaultSpecifier":
        return path.call(print, "local");

      case "TSExportAssignment":
        return concat$d(["export = ", path.call(print, "expression"), semi]);

      case "ExportDefaultDeclaration":
      case "ExportNamedDeclaration":
        return printExportDeclaration(path, options, print);

      case "ExportAllDeclaration":
        parts.push("export ");

        if (n.exportKind === "type") {
          parts.push("type ");
        }

        parts.push("* from ", path.call(print, "source"), semi);
        return concat$d(parts);

      case "ExportNamespaceSpecifier":
      case "ExportDefaultSpecifier":
        return path.call(print, "exported");

      case "ImportDeclaration":
        {
          parts.push("import ");

          if (n.importKind && n.importKind !== "value") {
            parts.push(n.importKind + " ");
          }

          var standalones = [];
          var grouped = [];

          if (n.specifiers && n.specifiers.length > 0) {
            path.each(function (specifierPath) {
              var value = specifierPath.getValue();

              if (value.type === "ImportDefaultSpecifier" || value.type === "ImportNamespaceSpecifier") {
                standalones.push(print(specifierPath));
              } else {
                grouped.push(print(specifierPath));
              }
            }, "specifiers");

            if (standalones.length > 0) {
              parts.push(join$9(", ", standalones));
            }

            if (standalones.length > 0 && grouped.length > 0) {
              parts.push(", ");
            }

            if (grouped.length === 1 && standalones.length === 0 && n.specifiers && !n.specifiers.some(function (node) {
              return node.comments;
            })) {
              parts.push(concat$d(["{", options.bracketSpacing ? " " : "", concat$d(grouped), options.bracketSpacing ? " " : "", "}"]));
            } else if (grouped.length >= 1) {
              parts.push(group$b(concat$d(["{", indent$7(concat$d([options.bracketSpacing ? line$7 : softline$6, join$9(concat$d([",", line$7]), grouped)])), ifBreak$6(shouldPrintComma$1(options) ? "," : ""), options.bracketSpacing ? line$7 : softline$6, "}"])));
            }

            parts.push(" from ");
          } else if (n.importKind && n.importKind === "type" || // import {} from 'x'
          /{\s*}/.test(options.originalText.slice(options.locStart(n), options.locStart(n.source)))) {
            parts.push("{} from ");
          }

          parts.push(path.call(print, "source"), semi);
          return concat$d(parts);
        }

      case "Import":
        return "import";

      case "TSModuleBlock":
      case "BlockStatement":
        {
          var naked = path.call(function (bodyPath) {
            return printStatementSequence(bodyPath, options, print);
          }, "body");
          var hasContent = n.body.find(function (node) {
            return node.type !== "EmptyStatement";
          });
          var hasDirectives = n.directives && n.directives.length > 0;

          var _parent4 = path.getParentNode();

          var _parentParent = path.getParentNode(1);

          if (!hasContent && !hasDirectives && !hasDanglingComments$1(n) && (_parent4.type === "ArrowFunctionExpression" || _parent4.type === "FunctionExpression" || _parent4.type === "FunctionDeclaration" || _parent4.type === "ObjectMethod" || _parent4.type === "ClassMethod" || _parent4.type === "ClassPrivateMethod" || _parent4.type === "ForStatement" || _parent4.type === "WhileStatement" || _parent4.type === "DoWhileStatement" || _parent4.type === "DoExpression" || _parent4.type === "CatchClause" && !_parentParent.finalizer || _parent4.type === "TSModuleDeclaration")) {
            return "{}";
          }

          parts.push("{"); // Babel 6

          if (hasDirectives) {
            path.each(function (childPath) {
              parts.push(indent$7(concat$d([hardline$9, print(childPath), semi])));

              if (isNextLineEmpty$4(options.originalText, childPath.getValue(), options)) {
                parts.push(hardline$9);
              }
            }, "directives");
          }

          if (hasContent) {
            parts.push(indent$7(concat$d([hardline$9, naked])));
          }

          parts.push(comments.printDanglingComments(path, options));
          parts.push(hardline$9, "}");
          return concat$d(parts);
        }

      case "ReturnStatement":
        parts.push("return");

        if (n.argument) {
          if (returnArgumentHasLeadingComment$1(options, n.argument)) {
            parts.push(concat$d([" (", indent$7(concat$d([hardline$9, path.call(print, "argument")])), hardline$9, ")"]));
          } else if (n.argument.type === "LogicalExpression" || n.argument.type === "BinaryExpression" || n.argument.type === "SequenceExpression") {
            parts.push(group$b(concat$d([ifBreak$6(" (", " "), indent$7(concat$d([softline$6, path.call(print, "argument")])), softline$6, ifBreak$6(")")])));
          } else {
            parts.push(" ", path.call(print, "argument"));
          }
        }

        if (hasDanglingComments$1(n)) {
          parts.push(" ", comments.printDanglingComments(path, options,
          /* sameIndent */
          true));
        }

        parts.push(semi);
        return concat$d(parts);

      case "NewExpression":
      case "OptionalCallExpression":
      case "CallExpression":
        {
          var isNew = n.type === "NewExpression";
          var optional = printOptionalToken(path);

          if ( // We want to keep CommonJS- and AMD-style require calls, and AMD-style
          // define calls, as a unit.
          // e.g. `define(["some/lib", (lib) => {`
          !isNew && n.callee.type === "Identifier" && (n.callee.name === "require" || n.callee.name === "define") || // Template literals as single arguments
          n.arguments.length === 1 && isTemplateOnItsOwnLine$1(n.arguments[0], options.originalText, options) || // Keep test declarations on a single line
          // e.g. `it('long name', () => {`
          !isNew && isTestCall$1(n, path.getParentNode())) {
            return concat$d([isNew ? "new " : "", path.call(print, "callee"), optional, printFunctionTypeParameters(path, options, print), concat$d(["(", join$9(", ", path.map(print, "arguments")), ")"])]);
          } // Inline Flow annotation comments following Identifiers in Call nodes need to
          // stay with the Identifier. For example:
          //
          // foo /*:: <SomeGeneric> */(bar);
          //
          // Here, we ensure that such comments stay between the Identifier and the Callee.


          var isIdentifierWithFlowAnnotation = n.callee.type === "Identifier" && hasFlowAnnotationComment$1(n.callee.trailingComments);

          if (isIdentifierWithFlowAnnotation) {
            n.callee.trailingComments[0].printed = true;
          } // We detect calls on member lookups and possibly print them in a
          // special chain format. See `printMemberChain` for more info.


          if (!isNew && isMemberish$1(n.callee)) {
            return printMemberChain(path, options, print);
          }

          var contents = concat$d([isNew ? "new " : "", path.call(print, "callee"), optional, isIdentifierWithFlowAnnotation ? "/*:: ".concat(n.callee.trailingComments[0].value.substring(2).trim(), " */") : "", printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)]); // We group here when the callee is itself a call expression.
          // See `isLongCurriedCallExpression` for more info.

          if (isCallOrOptionalCallExpression$1(n.callee)) {
            return group$b(contents);
          }

          return contents;
        }

      case "TSInterfaceDeclaration":
        if (n.declare) {
          parts.push("declare ");
        }

        parts.push(n.abstract ? "abstract " : "", printTypeScriptModifiers(path, options, print), "interface ", path.call(print, "id"), n.typeParameters ? path.call(print, "typeParameters") : "", " ");

        if (n.extends && n.extends.length) {
          parts.push(group$b(indent$7(concat$d([softline$6, "extends ", (n.extends.length === 1 ? identity$2 : indent$7)(join$9(concat$d([",", line$7]), path.map(print, "extends"))), " "]))));
        }

        parts.push(path.call(print, "body"));
        return concat$d(parts);

      case "ObjectTypeInternalSlot":
        return concat$d([n.static ? "static " : "", "[[", path.call(print, "id"), "]]", printOptionalToken(path), n.method ? "" : ": ", path.call(print, "value")]);

      case "ObjectExpression":
      case "ObjectPattern":
      case "ObjectTypeAnnotation":
      case "TSInterfaceBody":
      case "TSTypeLiteral":
        {
          var propertiesField;

          if (n.type === "TSTypeLiteral") {
            propertiesField = "members";
          } else if (n.type === "TSInterfaceBody") {
            propertiesField = "body";
          } else {
            propertiesField = "properties";
          }

          var isTypeAnnotation = n.type === "ObjectTypeAnnotation";
          var fields = [];

          if (isTypeAnnotation) {
            fields.push("indexers", "callProperties", "internalSlots");
          }

          fields.push(propertiesField);
          var firstProperty = fields.map(function (field) {
            return n[field][0];
          }).sort(function (a, b) {
            return options.locStart(a) - options.locStart(b);
          })[0];

          var _parent5 = path.getParentNode(0);

          var isFlowInterfaceLikeBody = isTypeAnnotation && _parent5 && (_parent5.type === "InterfaceDeclaration" || _parent5.type === "DeclareInterface" || _parent5.type === "DeclareClass") && path.getName() === "body";
          var shouldBreak = n.type === "TSInterfaceBody" || isFlowInterfaceLikeBody || n.type === "ObjectPattern" && _parent5.type !== "FunctionDeclaration" && _parent5.type !== "FunctionExpression" && _parent5.type !== "ArrowFunctionExpression" && _parent5.type !== "ObjectMethod" && _parent5.type !== "ClassMethod" && _parent5.type !== "ClassPrivateMethod" && _parent5.type !== "AssignmentPattern" && _parent5.type !== "CatchClause" && n.properties.some(function (property) {
            return property.value && (property.value.type === "ObjectPattern" || property.value.type === "ArrayPattern");
          }) || n.type !== "ObjectPattern" && firstProperty && hasNewlineInRange$2(options.originalText, options.locStart(n), options.locStart(firstProperty));
          var separator = isFlowInterfaceLikeBody ? ";" : n.type === "TSInterfaceBody" || n.type === "TSTypeLiteral" ? ifBreak$6(semi, ";") : ",";
          var leftBrace = n.exact ? "{|" : "{";
          var rightBrace = n.exact ? "|}" : "}"; // Unfortunately, things are grouped together in the ast can be
          // interleaved in the source code. So we need to reorder them before
          // printing them.

          var propsAndLoc = [];
          fields.forEach(function (field) {
            path.each(function (childPath) {
              var node = childPath.getValue();
              propsAndLoc.push({
                node: node,
                printed: print(childPath),
                loc: options.locStart(node)
              });
            }, field);
          });
          var separatorParts = [];
          var props = propsAndLoc.sort(function (a, b) {
            return a.loc - b.loc;
          }).map(function (prop) {
            var result = concat$d(separatorParts.concat(group$b(prop.printed)));
            separatorParts = [separator, line$7];

            if ((prop.node.type === "TSPropertySignature" || prop.node.type === "TSMethodSignature" || prop.node.type === "TSConstructSignatureDeclaration") && hasNodeIgnoreComment$2(prop.node)) {
              separatorParts.shift();
            }

            if (isNextLineEmpty$4(options.originalText, prop.node, options)) {
              separatorParts.push(hardline$9);
            }

            return result;
          });

          if (n.inexact) {
            props.push(concat$d(separatorParts.concat(group$b("..."))));
          }

          var lastElem = getLast$2(n[propertiesField]);
          var canHaveTrailingSeparator = !(lastElem && (lastElem.type === "RestProperty" || lastElem.type === "RestElement" || hasNodeIgnoreComment$2(lastElem) || n.inexact));
          var content;

          if (props.length === 0) {
            if (!hasDanglingComments$1(n)) {
              return concat$d([leftBrace, rightBrace, printTypeAnnotation(path, options, print)]);
            }

            content = group$b(concat$d([leftBrace, comments.printDanglingComments(path, options), softline$6, rightBrace, printOptionalToken(path), printTypeAnnotation(path, options, print)]));
          } else {
            content = concat$d([leftBrace, indent$7(concat$d([options.bracketSpacing ? line$7 : softline$6, concat$d(props)])), ifBreak$6(canHaveTrailingSeparator && (separator !== "," || shouldPrintComma$1(options)) ? separator : ""), concat$d([options.bracketSpacing ? line$7 : softline$6, rightBrace]), printOptionalToken(path), printTypeAnnotation(path, options, print)]);
          } // If we inline the object as first argument of the parent, we don't want
          // to create another group so that the object breaks before the return
          // type


          var parentParentParent = path.getParentNode(2);

          if (n.type === "ObjectPattern" && _parent5 && shouldHugArguments(_parent5) && !n.decorators && _parent5.params[0] === n || shouldHugType(n) && parentParentParent && shouldHugArguments(parentParentParent) && parentParentParent.params[0].typeAnnotation && parentParentParent.params[0].typeAnnotation.typeAnnotation === n) {
            return content;
          }

          return group$b(content, {
            shouldBreak: shouldBreak
          });
        }
      // Babel 6

      case "ObjectProperty": // Non-standard AST node type.

      case "Property":
        if (n.method || n.kind === "get" || n.kind === "set") {
          return printMethod(path, options, print);
        }

        if (n.shorthand) {
          parts.push(path.call(print, "value"));
        } else {
          parts.push(printAssignment(n.key, printPropertyKey(path, options, print), ":", n.value, path.call(print, "value"), options));
        }

        return concat$d(parts);
      // Babel 6

      case "ClassMethod":
      case "ClassPrivateMethod":
      case "MethodDefinition":
      case "TSAbstractMethodDefinition":
        if (n.decorators && n.decorators.length !== 0) {
          parts.push(printDecorators(path, options, print));
        }

        if (n.accessibility) {
          parts.push(n.accessibility + " ");
        }

        if (n.static) {
          parts.push("static ");
        }

        if (n.type === "TSAbstractMethodDefinition") {
          parts.push("abstract ");
        }

        parts.push(printMethod(path, options, print));
        return concat$d(parts);

      case "ObjectMethod":
        return printMethod(path, options, print);

      case "Decorator":
        return concat$d(["@", path.call(print, "expression"), path.call(print, "callee")]);

      case "ArrayExpression":
      case "ArrayPattern":
        if (n.elements.length === 0) {
          if (!hasDanglingComments$1(n)) {
            parts.push("[]");
          } else {
            parts.push(group$b(concat$d(["[", comments.printDanglingComments(path, options), softline$6, "]"])));
          }
        } else {
          var _lastElem = getLast$2(n.elements);

          var canHaveTrailingComma = !(_lastElem && _lastElem.type === "RestElement"); // JavaScript allows you to have empty elements in an array which
          // changes its length based on the number of commas. The algorithm
          // is that if the last argument is null, we need to force insert
          // a comma to ensure JavaScript recognizes it.
          //   [,].length === 1
          //   [1,].length === 1
          //   [1,,].length === 2
          //
          // Note that getLast returns null if the array is empty, but
          // we already check for an empty array just above so we are safe

          var needsForcedTrailingComma = canHaveTrailingComma && _lastElem === null;

          var _shouldBreak = n.elements.length > 1 && n.elements.every(function (element, i, elements) {
            var elementType = element && element.type;

            if (elementType !== "ArrayExpression" && elementType !== "ObjectExpression") {
              return false;
            }

            var nextElement = elements[i + 1];

            if (nextElement && elementType !== nextElement.type) {
              return false;
            }

            var itemsKey = elementType === "ArrayExpression" ? "elements" : "properties";
            return element[itemsKey] && element[itemsKey].length > 1;
          });

          parts.push(group$b(concat$d(["[", indent$7(concat$d([softline$6, printArrayItems(path, options, "elements", print)])), needsForcedTrailingComma ? "," : "", ifBreak$6(canHaveTrailingComma && !needsForcedTrailingComma && shouldPrintComma$1(options) ? "," : ""), comments.printDanglingComments(path, options,
          /* sameIndent */
          true), softline$6, "]"]), {
            shouldBreak: _shouldBreak
          }));
        }

        parts.push(printOptionalToken(path), printTypeAnnotation(path, options, print));
        return concat$d(parts);

      case "SequenceExpression":
        {
          var _parent6 = path.getParentNode(0);

          if (_parent6.type === "ExpressionStatement" || _parent6.type === "ForStatement") {
            // For ExpressionStatements and for-loop heads, which are among
            // the few places a SequenceExpression appears unparenthesized, we want
            // to indent expressions after the first.
            var _parts2 = [];
            path.each(function (p) {
              if (p.getName() === 0) {
                _parts2.push(print(p));
              } else {
                _parts2.push(",", indent$7(concat$d([line$7, print(p)])));
              }
            }, "expressions");
            return group$b(concat$d(_parts2));
          }

          return group$b(concat$d([join$9(concat$d([",", line$7]), path.map(print, "expressions"))]));
        }

      case "ThisExpression":
        return "this";

      case "Super":
        return "super";

      case "NullLiteral":
        // Babel 6 Literal split
        return "null";

      case "RegExpLiteral":
        // Babel 6 Literal split
        return printRegex(n);

      case "NumericLiteral":
        // Babel 6 Literal split
        return printNumber$2(n.extra.raw);

      case "BigIntLiteral":
        // babel: n.extra.raw, typescript: n.raw, flow: n.bigint
        return (n.bigint || (n.extra ? n.extra.raw : n.raw)).toLowerCase();

      case "BooleanLiteral": // Babel 6 Literal split

      case "StringLiteral": // Babel 6 Literal split

      case "Literal":
        {
          if (n.regex) {
            return printRegex(n.regex);
          }

          if (typeof n.value === "number") {
            return printNumber$2(n.raw);
          }

          if (typeof n.value !== "string") {
            return "" + n.value;
          } // TypeScript workaround for https://github.com/JamesHenry/typescript-estree/issues/2
          // See corresponding workaround in needs-parens.js


          var grandParent = path.getParentNode(1);
          var isTypeScriptDirective = options.parser === "typescript" && typeof n.value === "string" && grandParent && (grandParent.type === "Program" || grandParent.type === "BlockStatement");
          return nodeStr(n, options, isTypeScriptDirective);
        }

      case "Directive":
        return path.call(print, "value");
      // Babel 6

      case "DirectiveLiteral":
        return nodeStr(n, options);

      case "UnaryExpression":
        parts.push(n.operator);

        if (/[a-z]$/.test(n.operator)) {
          parts.push(" ");
        }

        if (n.argument.comments && n.argument.comments.length > 0) {
          parts.push(group$b(concat$d(["(", indent$7(concat$d([softline$6, path.call(print, "argument")])), softline$6, ")"])));
        } else {
          parts.push(path.call(print, "argument"));
        }

        return concat$d(parts);

      case "UpdateExpression":
        parts.push(path.call(print, "argument"), n.operator);

        if (n.prefix) {
          parts.reverse();
        }

        return concat$d(parts);

      case "ConditionalExpression":
        return printTernaryOperator(path, options, print, {
          beforeParts: function beforeParts() {
            return [path.call(print, "test")];
          },
          afterParts: function afterParts(breakClosingParen) {
            return [breakClosingParen ? softline$6 : ""];
          },
          shouldCheckJsx: true,
          conditionalNodeType: "ConditionalExpression",
          consequentNodePropertyName: "consequent",
          alternateNodePropertyName: "alternate",
          testNodePropertyName: "test",
          breakNested: true
        });

      case "VariableDeclaration":
        {
          var printed = path.map(function (childPath) {
            return print(childPath);
          }, "declarations"); // We generally want to terminate all variable declarations with a
          // semicolon, except when they in the () part of for loops.

          var parentNode = path.getParentNode();
          var isParentForLoop = parentNode.type === "ForStatement" || parentNode.type === "ForInStatement" || parentNode.type === "ForOfStatement" || parentNode.type === "ForAwaitStatement";
          var hasValue = n.declarations.some(function (decl) {
            return decl.init;
          });
          var firstVariable;

          if (printed.length === 1 && !n.declarations[0].comments) {
            firstVariable = printed[0];
          } else if (printed.length > 0) {
            // Indent first var to comply with eslint one-var rule
            firstVariable = indent$7(printed[0]);
          }

          parts = [n.declare ? "declare " : "", n.kind, firstVariable ? concat$d([" ", firstVariable]) : "", indent$7(concat$d(printed.slice(1).map(function (p) {
            return concat$d([",", hasValue && !isParentForLoop ? hardline$9 : line$7, p]);
          })))];

          if (!(isParentForLoop && parentNode.body !== n)) {
            parts.push(semi);
          }

          return group$b(concat$d(parts));
        }

      case "TSTypeAliasDeclaration":
        {
          if (n.declare) {
            parts.push("declare ");
          }

          var _printed = printAssignmentRight(n.id, n.typeAnnotation, n.typeAnnotation && path.call(print, "typeAnnotation"), options);

          parts.push("type ", path.call(print, "id"), path.call(print, "typeParameters"), " =", _printed, semi);
          return group$b(concat$d(parts));
        }

      case "VariableDeclarator":
        return printAssignment(n.id, path.call(print, "id"), " =", n.init, n.init && path.call(print, "init"), options);

      case "WithStatement":
        return group$b(concat$d(["with (", path.call(print, "object"), ")", adjustClause(n.body, path.call(print, "body"))]));

      case "IfStatement":
        {
          var con = adjustClause(n.consequent, path.call(print, "consequent"));
          var opening = group$b(concat$d(["if (", group$b(concat$d([indent$7(concat$d([softline$6, path.call(print, "test")])), softline$6])), ")", con]));
          parts.push(opening);

          if (n.alternate) {
            var commentOnOwnLine = hasTrailingComment$1(n.consequent) && n.consequent.comments.some(function (comment) {
              return comment.trailing && !comments$1.isBlockComment(comment);
            }) || needsHardlineAfterDanglingComment$1(n);
            var elseOnSameLine = n.consequent.type === "BlockStatement" && !commentOnOwnLine;
            parts.push(elseOnSameLine ? " " : hardline$9);

            if (hasDanglingComments$1(n)) {
              parts.push(comments.printDanglingComments(path, options, true), commentOnOwnLine ? hardline$9 : " ");
            }

            parts.push("else", group$b(adjustClause(n.alternate, path.call(print, "alternate"), n.alternate.type === "IfStatement")));
          }

          return concat$d(parts);
        }

      case "ForStatement":
        {
          var _body = adjustClause(n.body, path.call(print, "body")); // We want to keep dangling comments above the loop to stay consistent.
          // Any comment positioned between the for statement and the parentheses
          // is going to be printed before the statement.


          var _dangling = comments.printDanglingComments(path, options,
          /* sameLine */
          true);

          var printedComments = _dangling ? concat$d([_dangling, softline$6]) : "";

          if (!n.init && !n.test && !n.update) {
            return concat$d([printedComments, group$b(concat$d(["for (;;)", _body]))]);
          }

          return concat$d([printedComments, group$b(concat$d(["for (", group$b(concat$d([indent$7(concat$d([softline$6, path.call(print, "init"), ";", line$7, path.call(print, "test"), ";", line$7, path.call(print, "update")])), softline$6])), ")", _body]))]);
        }

      case "WhileStatement":
        return group$b(concat$d(["while (", group$b(concat$d([indent$7(concat$d([softline$6, path.call(print, "test")])), softline$6])), ")", adjustClause(n.body, path.call(print, "body"))]));

      case "ForInStatement":
        // Note: esprima can't actually parse "for each (".
        return group$b(concat$d([n.each ? "for each (" : "for (", path.call(print, "left"), " in ", path.call(print, "right"), ")", adjustClause(n.body, path.call(print, "body"))]));

      case "ForOfStatement":
      case "ForAwaitStatement":
        {
          // Babel 7 removed ForAwaitStatement in favor of ForOfStatement
          // with `"await": true`:
          // https://github.com/estree/estree/pull/138
          var isAwait = n.type === "ForAwaitStatement" || n.await;
          return group$b(concat$d(["for", isAwait ? " await" : "", " (", path.call(print, "left"), " of ", path.call(print, "right"), ")", adjustClause(n.body, path.call(print, "body"))]));
        }

      case "DoWhileStatement":
        {
          var clause = adjustClause(n.body, path.call(print, "body"));
          var doBody = group$b(concat$d(["do", clause]));
          parts = [doBody];

          if (n.body.type === "BlockStatement") {
            parts.push(" ");
          } else {
            parts.push(hardline$9);
          }

          parts.push("while (");
          parts.push(group$b(concat$d([indent$7(concat$d([softline$6, path.call(print, "test")])), softline$6])), ")", semi);
          return concat$d(parts);
        }

      case "DoExpression":
        return concat$d(["do ", path.call(print, "body")]);

      case "BreakStatement":
        parts.push("break");

        if (n.label) {
          parts.push(" ", path.call(print, "label"));
        }

        parts.push(semi);
        return concat$d(parts);

      case "ContinueStatement":
        parts.push("continue");

        if (n.label) {
          parts.push(" ", path.call(print, "label"));
        }

        parts.push(semi);
        return concat$d(parts);

      case "LabeledStatement":
        if (n.body.type === "EmptyStatement") {
          return concat$d([path.call(print, "label"), ":;"]);
        }

        return concat$d([path.call(print, "label"), ": ", path.call(print, "body")]);

      case "TryStatement":
        return concat$d(["try ", path.call(print, "block"), n.handler ? concat$d([" ", path.call(print, "handler")]) : "", n.finalizer ? concat$d([" finally ", path.call(print, "finalizer")]) : ""]);

      case "CatchClause":
        if (n.param) {
          var hasComments = n.param.comments && n.param.comments.some(function (comment) {
            return !comments$1.isBlockComment(comment) || comment.leading && hasNewline$4(options.originalText, options.locEnd(comment)) || comment.trailing && hasNewline$4(options.originalText, options.locStart(comment), {
              backwards: true
            });
          });
          var param = path.call(print, "param");
          return concat$d(["catch ", hasComments ? concat$d(["(", indent$7(concat$d([softline$6, param])), softline$6, ") "]) : concat$d(["(", param, ") "]), path.call(print, "body")]);
        }

        return concat$d(["catch ", path.call(print, "body")]);

      case "ThrowStatement":
        return concat$d(["throw ", path.call(print, "argument"), semi]);
      // Note: ignoring n.lexical because it has no printing consequences.

      case "SwitchStatement":
        return concat$d([group$b(concat$d(["switch (", indent$7(concat$d([softline$6, path.call(print, "discriminant")])), softline$6, ")"])), " {", n.cases.length > 0 ? indent$7(concat$d([hardline$9, join$9(hardline$9, path.map(function (casePath) {
          var caseNode = casePath.getValue();
          return concat$d([casePath.call(print), n.cases.indexOf(caseNode) !== n.cases.length - 1 && isNextLineEmpty$4(options.originalText, caseNode, options) ? hardline$9 : ""]);
        }, "cases"))])) : "", hardline$9, "}"]);

      case "SwitchCase":
        {
          if (n.test) {
            parts.push("case ", path.call(print, "test"), ":");
          } else {
            parts.push("default:");
          }

          var consequent = n.consequent.filter(function (node) {
            return node.type !== "EmptyStatement";
          });

          if (consequent.length > 0) {
            var cons = path.call(function (consequentPath) {
              return printStatementSequence(consequentPath, options, print);
            }, "consequent");
            parts.push(consequent.length === 1 && consequent[0].type === "BlockStatement" ? concat$d([" ", cons]) : indent$7(concat$d([hardline$9, cons])));
          }

          return concat$d(parts);
        }
      // JSX extensions below.

      case "DebuggerStatement":
        return concat$d(["debugger", semi]);

      case "JSXAttribute":
        parts.push(path.call(print, "name"));

        if (n.value) {
          var res;

          if (isStringLiteral$1(n.value)) {
            var raw = rawText$1(n.value); // Unescape all quotes so we get an accurate preferred quote

            var final = raw.replace(/&apos;/g, "'").replace(/&quot;/g, '"');
            var quote = getPreferredQuote$1(final, options.jsxSingleQuote ? "'" : '"');

            var _escape = quote === "'" ? "&apos;" : "&quot;";

            final = final.slice(1, -1).replace(new RegExp(quote, "g"), _escape);
            res = concat$d([quote, final, quote]);
          } else {
            res = path.call(print, "value");
          }

          parts.push("=", res);
        }

        return concat$d(parts);

      case "JSXIdentifier":
        return "" + n.name;

      case "JSXNamespacedName":
        return join$9(":", [path.call(print, "namespace"), path.call(print, "name")]);

      case "JSXMemberExpression":
        return join$9(".", [path.call(print, "object"), path.call(print, "property")]);

      case "TSQualifiedName":
        return join$9(".", [path.call(print, "left"), path.call(print, "right")]);

      case "JSXSpreadAttribute":
      case "JSXSpreadChild":
        {
          return concat$d(["{", path.call(function (p) {
            var printed = concat$d(["...", print(p)]);
            var n = p.getValue();

            if (!n.comments || !n.comments.length) {
              return printed;
            }

            return concat$d([indent$7(concat$d([softline$6, comments.printComments(p, function () {
              return printed;
            }, options)])), softline$6]);
          }, n.type === "JSXSpreadAttribute" ? "argument" : "expression"), "}"]);
        }

      case "JSXExpressionContainer":
        {
          var _parent7 = path.getParentNode(0);

          var preventInline = _parent7.type === "JSXAttribute" && n.expression.comments && n.expression.comments.length > 0;

          var _shouldInline = !preventInline && (n.expression.type === "ArrayExpression" || n.expression.type === "ObjectExpression" || n.expression.type === "ArrowFunctionExpression" || n.expression.type === "CallExpression" || n.expression.type === "OptionalCallExpression" || n.expression.type === "FunctionExpression" || n.expression.type === "JSXEmptyExpression" || n.expression.type === "TemplateLiteral" || n.expression.type === "TaggedTemplateExpression" || n.expression.type === "DoExpression" || isJSXNode$1(_parent7) && (n.expression.type === "ConditionalExpression" || isBinaryish$1(n.expression)));

          if (_shouldInline) {
            return group$b(concat$d(["{", path.call(print, "expression"), lineSuffixBoundary$1, "}"]));
          }

          return group$b(concat$d(["{", indent$7(concat$d([softline$6, path.call(print, "expression")])), softline$6, lineSuffixBoundary$1, "}"]));
        }

      case "JSXFragment":
      case "JSXElement":
        {
          var elem = comments.printComments(path, function () {
            return printJSXElement(path, options, print);
          }, options);
          return maybeWrapJSXElementInParens(path, elem, options);
        }

      case "JSXOpeningElement":
        {
          var _n = path.getValue();

          var nameHasComments = _n.name && _n.name.comments && _n.name.comments.length > 0 || _n.typeParameters && _n.typeParameters.comments && _n.typeParameters.comments.length > 0; // Don't break self-closing elements with no attributes and no comments

          if (_n.selfClosing && !_n.attributes.length && !nameHasComments) {
            return concat$d(["<", path.call(print, "name"), path.call(print, "typeParameters"), " />"]);
          } // don't break up opening elements with a single long text attribute


          if (_n.attributes && _n.attributes.length === 1 && _n.attributes[0].value && isStringLiteral$1(_n.attributes[0].value) && !_n.attributes[0].value.value.includes("\n") && // We should break for the following cases:
          // <div
          //   // comment
          //   attr="value"
          // >
          // <div
          //   attr="value"
          //   // comment
          // >
          !nameHasComments && (!_n.attributes[0].comments || !_n.attributes[0].comments.length)) {
            return group$b(concat$d(["<", path.call(print, "name"), path.call(print, "typeParameters"), " ", concat$d(path.map(print, "attributes")), _n.selfClosing ? " />" : ">"]));
          }

          var lastAttrHasTrailingComments = _n.attributes.length && hasTrailingComment$1(getLast$2(_n.attributes));
          var bracketSameLine = // Simple tags (no attributes and no comment in tag name) should be
          // kept unbroken regardless of `jsxBracketSameLine`
          !_n.attributes.length && !nameHasComments || options.jsxBracketSameLine && ( // We should print the bracket in a new line for the following cases:
          // <div
          //   // comment
          // >
          // <div
          //   attr // comment
          // >
          !nameHasComments || _n.attributes.length) && !lastAttrHasTrailingComments; // We should print the opening element expanded if any prop value is a
          // string literal with newlines

          var _shouldBreak2 = _n.attributes && _n.attributes.some(function (attr) {
            return attr.value && isStringLiteral$1(attr.value) && attr.value.value.includes("\n");
          });

          return group$b(concat$d(["<", path.call(print, "name"), path.call(print, "typeParameters"), concat$d([indent$7(concat$d(path.map(function (attr) {
            return concat$d([line$7, print(attr)]);
          }, "attributes"))), _n.selfClosing ? line$7 : bracketSameLine ? ">" : softline$6]), _n.selfClosing ? "/>" : bracketSameLine ? "" : ">"]), {
            shouldBreak: _shouldBreak2
          });
        }

      case "JSXClosingElement":
        return concat$d(["</", path.call(print, "name"), ">"]);

      case "JSXOpeningFragment":
      case "JSXClosingFragment":
        {
          var hasComment = n.comments && n.comments.length;
          var hasOwnLineComment = hasComment && !n.comments.every(comments$1.isBlockComment);
          var isOpeningFragment = n.type === "JSXOpeningFragment";
          return concat$d([isOpeningFragment ? "<" : "</", indent$7(concat$d([hasOwnLineComment ? hardline$9 : hasComment && !isOpeningFragment ? " " : "", comments.printDanglingComments(path, options, true)])), hasOwnLineComment ? hardline$9 : "", ">"]);
        }

      case "JSXText":
        /* istanbul ignore next */
        throw new Error("JSXTest should be handled by JSXElement");

      case "JSXEmptyExpression":
        {
          var requiresHardline = n.comments && !n.comments.every(comments$1.isBlockComment);
          return concat$d([comments.printDanglingComments(path, options,
          /* sameIndent */
          !requiresHardline), requiresHardline ? hardline$9 : ""]);
        }

      case "ClassBody":
        if (!n.comments && n.body.length === 0) {
          return "{}";
        }

        return concat$d(["{", n.body.length > 0 ? indent$7(concat$d([hardline$9, path.call(function (bodyPath) {
          return printStatementSequence(bodyPath, options, print);
        }, "body")])) : comments.printDanglingComments(path, options), hardline$9, "}"]);

      case "ClassProperty":
      case "TSAbstractClassProperty":
      case "ClassPrivateProperty":
        {
          if (n.decorators && n.decorators.length !== 0) {
            parts.push(printDecorators(path, options, print));
          }

          if (n.accessibility) {
            parts.push(n.accessibility + " ");
          }

          if (n.declare) {
            parts.push("declare ");
          }

          if (n.static) {
            parts.push("static ");
          }

          if (n.type === "TSAbstractClassProperty") {
            parts.push("abstract ");
          }

          if (n.readonly) {
            parts.push("readonly ");
          }

          var variance = getFlowVariance$1(n);

          if (variance) {
            parts.push(variance);
          }

          parts.push(printPropertyKey(path, options, print), printOptionalToken(path), printTypeAnnotation(path, options, print));

          if (n.value) {
            parts.push(" =", printAssignmentRight(n.key, n.value, path.call(print, "value"), options));
          }

          parts.push(semi);
          return group$b(concat$d(parts));
        }

      case "ClassDeclaration":
      case "ClassExpression":
        if (n.declare) {
          parts.push("declare ");
        }

        parts.push(concat$d(printClass(path, options, print)));
        return concat$d(parts);

      case "TSInterfaceHeritage":
        parts.push(path.call(print, "expression"));

        if (n.typeParameters) {
          parts.push(path.call(print, "typeParameters"));
        }

        return concat$d(parts);

      case "TemplateElement":
        return join$9(literalline$4, n.value.raw.split(/\r?\n/g));

      case "TemplateLiteral":
        {
          var expressions = path.map(print, "expressions");

          var _parentNode = path.getParentNode();

          if (isJestEachTemplateLiteral$1(n, _parentNode)) {
            var _printed2 = printJestEachTemplateLiteral(n, expressions, options);

            if (_printed2) {
              return _printed2;
            }
          }

          var isSimple = isSimpleTemplateLiteral$1(n);

          if (isSimple) {
            expressions = expressions.map(function (doc) {
              return printDocToString$1(doc, Object.assign({}, options, {
                printWidth: Infinity
              })).formatted;
            });
          }

          parts.push(lineSuffixBoundary$1, "`");
          path.each(function (childPath) {
            var i = childPath.getName();
            parts.push(print(childPath));

            if (i < expressions.length) {
              // For a template literal of the following form:
              //   `someQuery {
              //     ${call({
              //       a,
              //       b,
              //     })}
              //   }`
              // the expression is on its own line (there is a \n in the previous
              // quasi literal), therefore we want to indent the JavaScript
              // expression inside at the beginning of ${ instead of the beginning
              // of the `.
              var tabWidth = options.tabWidth;
              var quasi = childPath.getValue();
              var indentSize = getIndentSize$1(quasi.value.raw, tabWidth);
              var _printed3 = expressions[i];

              if (!isSimple) {
                // Breaks at the template element boundaries (${ and }) are preferred to breaking
                // in the middle of a MemberExpression
                if (n.expressions[i].comments && n.expressions[i].comments.length || n.expressions[i].type === "MemberExpression" || n.expressions[i].type === "OptionalMemberExpression" || n.expressions[i].type === "ConditionalExpression") {
                  _printed3 = concat$d([indent$7(concat$d([softline$6, _printed3])), softline$6]);
                }
              }

              var aligned = indentSize === 0 && quasi.value.raw.endsWith("\n") ? align$1(-Infinity, _printed3) : addAlignmentToDoc$2(_printed3, indentSize, tabWidth);
              parts.push(group$b(concat$d(["${", aligned, lineSuffixBoundary$1, "}"])));
            }
          }, "quasis");
          parts.push("`");
          return concat$d(parts);
        }
      // These types are unprintable because they serve as abstract
      // supertypes for other (printable) types.

      case "TaggedTemplateExpression":
        return concat$d([path.call(print, "tag"), path.call(print, "typeParameters"), path.call(print, "quasi")]);

      case "Node":
      case "Printable":
      case "SourceLocation":
      case "Position":
      case "Statement":
      case "Function":
      case "Pattern":
      case "Expression":
      case "Declaration":
      case "Specifier":
      case "NamedSpecifier":
      case "Comment":
      case "MemberTypeAnnotation": // Flow

      case "Type":
        /* istanbul ignore next */
        throw new Error("unprintable type: " + JSON.stringify(n.type));
      // Type Annotations for Facebook Flow, typically stripped out or
      // transformed away before printing.

      case "TypeAnnotation":
      case "TSTypeAnnotation":
        if (n.typeAnnotation) {
          return path.call(print, "typeAnnotation");
        }
        /* istanbul ignore next */


        return "";

      case "TSTupleType":
      case "TupleTypeAnnotation":
        {
          var typesField = n.type === "TSTupleType" ? "elementTypes" : "types";
          return group$b(concat$d(["[", indent$7(concat$d([softline$6, printArrayItems(path, options, typesField, print)])), ifBreak$6(shouldPrintComma$1(options, "all") ? "," : ""), comments.printDanglingComments(path, options,
          /* sameIndent */
          true), softline$6, "]"]));
        }

      case "ExistsTypeAnnotation":
        return "*";

      case "EmptyTypeAnnotation":
        return "empty";

      case "AnyTypeAnnotation":
        return "any";

      case "MixedTypeAnnotation":
        return "mixed";

      case "ArrayTypeAnnotation":
        return concat$d([path.call(print, "elementType"), "[]"]);

      case "BooleanTypeAnnotation":
        return "boolean";

      case "BooleanLiteralTypeAnnotation":
        return "" + n.value;

      case "DeclareClass":
        return printFlowDeclaration(path, printClass(path, options, print));

      case "TSDeclareFunction":
        // For TypeScript the TSDeclareFunction node shares the AST
        // structure with FunctionDeclaration
        return concat$d([n.declare ? "declare " : "", printFunctionDeclaration(path, print, options), semi]);

      case "DeclareFunction":
        return printFlowDeclaration(path, ["function ", path.call(print, "id"), n.predicate ? " " : "", path.call(print, "predicate"), semi]);

      case "DeclareModule":
        return printFlowDeclaration(path, ["module ", path.call(print, "id"), " ", path.call(print, "body")]);

      case "DeclareModuleExports":
        return printFlowDeclaration(path, ["module.exports", ": ", path.call(print, "typeAnnotation"), semi]);

      case "DeclareVariable":
        return printFlowDeclaration(path, ["var ", path.call(print, "id"), semi]);

      case "DeclareExportAllDeclaration":
        return concat$d(["declare export * from ", path.call(print, "source")]);

      case "DeclareExportDeclaration":
        return concat$d(["declare ", printExportDeclaration(path, options, print)]);

      case "DeclareOpaqueType":
      case "OpaqueType":
        {
          parts.push("opaque type ", path.call(print, "id"), path.call(print, "typeParameters"));

          if (n.supertype) {
            parts.push(": ", path.call(print, "supertype"));
          }

          if (n.impltype) {
            parts.push(" = ", path.call(print, "impltype"));
          }

          parts.push(semi);

          if (n.type === "DeclareOpaqueType") {
            return printFlowDeclaration(path, parts);
          }

          return concat$d(parts);
        }

      case "EnumDeclaration":
        return concat$d(["enum ", path.call(print, "id"), " ", path.call(print, "body")]);

      case "EnumBooleanBody":
      case "EnumNumberBody":
      case "EnumStringBody":
      case "EnumSymbolBody":
        {
          if (n.type === "EnumSymbolBody" || n.explicitType) {
            var type = null;

            switch (n.type) {
              case "EnumBooleanBody":
                type = "boolean";
                break;

              case "EnumNumberBody":
                type = "number";
                break;

              case "EnumStringBody":
                type = "string";
                break;

              case "EnumSymbolBody":
                type = "symbol";
                break;
            }

            parts.push("of ", type, " ");
          }

          if (n.members.length === 0) {
            parts.push(group$b(concat$d(["{", comments.printDanglingComments(path, options), softline$6, "}"])));
          } else {
            parts.push(group$b(concat$d(["{", indent$7(concat$d([hardline$9, printArrayItems(path, options, "members", print), shouldPrintComma$1(options) ? "," : ""])), comments.printDanglingComments(path, options,
            /* sameIndent */
            true), hardline$9, "}"])));
          }

          return concat$d(parts);
        }

      case "EnumBooleanMember":
      case "EnumNumberMember":
      case "EnumStringMember":
        return concat$d([path.call(print, "id"), " = ", _typeof(n.init) === "object" ? path.call(print, "init") : String(n.init)]);

      case "EnumDefaultedMember":
        return path.call(print, "id");

      case "FunctionTypeAnnotation":
      case "TSFunctionType":
        {
          // FunctionTypeAnnotation is ambiguous:
          // declare function foo(a: B): void; OR
          // var A: (a: B) => void;
          var _parent8 = path.getParentNode(0);

          var _parentParent2 = path.getParentNode(1);

          var _parentParentParent = path.getParentNode(2);

          var isArrowFunctionTypeAnnotation = n.type === "TSFunctionType" || !((_parent8.type === "ObjectTypeProperty" || _parent8.type === "ObjectTypeInternalSlot") && !getFlowVariance$1(_parent8) && !_parent8.optional && options.locStart(_parent8) === options.locStart(n) || _parent8.type === "ObjectTypeCallProperty" || _parentParentParent && _parentParentParent.type === "DeclareFunction");
          var needsColon = isArrowFunctionTypeAnnotation && (_parent8.type === "TypeAnnotation" || _parent8.type === "TSTypeAnnotation"); // Sadly we can't put it inside of FastPath::needsColon because we are
          // printing ":" as part of the expression and it would put parenthesis
          // around :(

          var needsParens = needsColon && isArrowFunctionTypeAnnotation && (_parent8.type === "TypeAnnotation" || _parent8.type === "TSTypeAnnotation") && _parentParent2.type === "ArrowFunctionExpression";

          if (isObjectTypePropertyAFunction$1(_parent8, options)) {
            isArrowFunctionTypeAnnotation = true;
            needsColon = true;
          }

          if (needsParens) {
            parts.push("(");
          }

          parts.push(printFunctionParams(path, print, options,
          /* expandArg */
          false,
          /* printTypeParams */
          true)); // The returnType is not wrapped in a TypeAnnotation, so the colon
          // needs to be added separately.

          if (n.returnType || n.predicate || n.typeAnnotation) {
            parts.push(isArrowFunctionTypeAnnotation ? " => " : ": ", path.call(print, "returnType"), path.call(print, "predicate"), path.call(print, "typeAnnotation"));
          }

          if (needsParens) {
            parts.push(")");
          }

          return group$b(concat$d(parts));
        }

      case "TSRestType":
        return concat$d(["...", path.call(print, "typeAnnotation")]);

      case "TSOptionalType":
        return concat$d([path.call(print, "typeAnnotation"), "?"]);

      case "FunctionTypeParam":
        return concat$d([path.call(print, "name"), printOptionalToken(path), n.name ? ": " : "", path.call(print, "typeAnnotation")]);

      case "GenericTypeAnnotation":
        return concat$d([path.call(print, "id"), path.call(print, "typeParameters")]);

      case "DeclareInterface":
      case "InterfaceDeclaration":
      case "InterfaceTypeAnnotation":
        {
          if (n.type === "DeclareInterface" || n.declare) {
            parts.push("declare ");
          }

          parts.push("interface");

          if (n.type === "DeclareInterface" || n.type === "InterfaceDeclaration") {
            parts.push(" ", path.call(print, "id"), path.call(print, "typeParameters"));
          }

          if (n["extends"].length > 0) {
            parts.push(group$b(indent$7(concat$d([line$7, "extends ", (n.extends.length === 1 ? identity$2 : indent$7)(join$9(concat$d([",", line$7]), path.map(print, "extends")))]))));
          }

          parts.push(" ", path.call(print, "body"));
          return group$b(concat$d(parts));
        }

      case "ClassImplements":
      case "InterfaceExtends":
        return concat$d([path.call(print, "id"), path.call(print, "typeParameters")]);

      case "TSClassImplements":
        return concat$d([path.call(print, "expression"), path.call(print, "typeParameters")]);

      case "TSIntersectionType":
      case "IntersectionTypeAnnotation":
        {
          var types = path.map(print, "types");
          var result = [];
          var wasIndented = false;

          for (var _i = 0; _i < types.length; ++_i) {
            if (_i === 0) {
              result.push(types[_i]);
            } else if (isObjectType$1(n.types[_i - 1]) && isObjectType$1(n.types[_i])) {
              // If both are objects, don't indent
              result.push(concat$d([" & ", wasIndented ? indent$7(types[_i]) : types[_i]]));
            } else if (!isObjectType$1(n.types[_i - 1]) && !isObjectType$1(n.types[_i])) {
              // If no object is involved, go to the next line if it breaks
              result.push(indent$7(concat$d([" &", line$7, types[_i]])));
            } else {
              // If you go from object to non-object or vis-versa, then inline it
              if (_i > 1) {
                wasIndented = true;
              }

              result.push(" & ", _i > 1 ? indent$7(types[_i]) : types[_i]);
            }
          }

          return group$b(concat$d(result));
        }

      case "TSUnionType":
      case "UnionTypeAnnotation":
        {
          // single-line variation
          // A | B | C
          // multi-line variation
          // | A
          // | B
          // | C
          var _parent9 = path.getParentNode(); // If there's a leading comment, the parent is doing the indentation


          var shouldIndent = _parent9.type !== "TypeParameterInstantiation" && _parent9.type !== "TSTypeParameterInstantiation" && _parent9.type !== "GenericTypeAnnotation" && _parent9.type !== "TSTypeReference" && _parent9.type !== "TSTypeAssertion" && _parent9.type !== "TupleTypeAnnotation" && _parent9.type !== "TSTupleType" && !(_parent9.type === "FunctionTypeParam" && !_parent9.name) && !((_parent9.type === "TypeAlias" || _parent9.type === "VariableDeclarator" || _parent9.type === "TSTypeAliasDeclaration") && hasLeadingOwnLineComment$1(options.originalText, n, options)); // {
          //   a: string
          // } | null | void
          // should be inlined and not be printed in the multi-line variant

          var shouldHug = shouldHugType(n); // We want to align the children but without its comment, so it looks like
          // | child1
          // // comment
          // | child2

          var _printed4 = path.map(function (typePath) {
            var printedType = typePath.call(print);

            if (!shouldHug) {
              printedType = align$1(2, printedType);
            }

            return comments.printComments(typePath, function () {
              return printedType;
            }, options);
          }, "types");

          if (shouldHug) {
            return join$9(" | ", _printed4);
          }

          var shouldAddStartLine = shouldIndent && !hasLeadingOwnLineComment$1(options.originalText, n, options);
          var code = concat$d([ifBreak$6(concat$d([shouldAddStartLine ? line$7 : "", "| "])), join$9(concat$d([line$7, "| "]), _printed4)]);

          if (needsParens_1(path, options)) {
            return group$b(concat$d([indent$7(code), softline$6]));
          }

          if (_parent9.type === "TupleTypeAnnotation" && _parent9.types.length > 1 || _parent9.type === "TSTupleType" && _parent9.elementTypes.length > 1) {
            return group$b(concat$d([indent$7(concat$d([ifBreak$6(concat$d(["(", softline$6])), code])), softline$6, ifBreak$6(")")]));
          }

          return group$b(shouldIndent ? indent$7(code) : code);
        }

      case "NullableTypeAnnotation":
        return concat$d(["?", path.call(print, "typeAnnotation")]);

      case "TSNullKeyword":
      case "NullLiteralTypeAnnotation":
        return "null";

      case "ThisTypeAnnotation":
        return "this";

      case "NumberTypeAnnotation":
        return "number";

      case "ObjectTypeCallProperty":
        if (n.static) {
          parts.push("static ");
        }

        parts.push(path.call(print, "value"));
        return concat$d(parts);

      case "ObjectTypeIndexer":
        {
          var _variance = getFlowVariance$1(n);

          return concat$d([_variance || "", "[", path.call(print, "id"), n.id ? ": " : "", path.call(print, "key"), "]: ", path.call(print, "value")]);
        }

      case "ObjectTypeProperty":
        {
          var _variance2 = getFlowVariance$1(n);

          var modifier = "";

          if (n.proto) {
            modifier = "proto ";
          } else if (n.static) {
            modifier = "static ";
          }

          return concat$d([modifier, isGetterOrSetter$1(n) ? n.kind + " " : "", _variance2 || "", printPropertyKey(path, options, print), printOptionalToken(path), isFunctionNotation$1(n, options) ? "" : ": ", path.call(print, "value")]);
        }

      case "QualifiedTypeIdentifier":
        return concat$d([path.call(print, "qualification"), ".", path.call(print, "id")]);

      case "StringLiteralTypeAnnotation":
        return nodeStr(n, options);

      case "NumberLiteralTypeAnnotation":
        assert.strictEqual(_typeof(n.value), "number");

        if (n.extra != null) {
          return printNumber$2(n.extra.raw);
        }

        return printNumber$2(n.raw);

      case "StringTypeAnnotation":
        return "string";

      case "DeclareTypeAlias":
      case "TypeAlias":
        {
          if (n.type === "DeclareTypeAlias" || n.declare) {
            parts.push("declare ");
          }

          var _printed5 = printAssignmentRight(n.id, n.right, path.call(print, "right"), options);

          parts.push("type ", path.call(print, "id"), path.call(print, "typeParameters"), " =", _printed5, semi);
          return group$b(concat$d(parts));
        }

      case "TypeCastExpression":
        {
          var value = path.getValue(); // Flow supports a comment syntax for specifying type annotations: https://flow.org/en/docs/types/comments/.
          // Unfortunately, its parser doesn't differentiate between comment annotations and regular
          // annotations when producing an AST. So to preserve parentheses around type casts that use
          // the comment syntax, we need to hackily read the source itself to see if the code contains
          // a type annotation comment.
          //
          // Note that we're able to use the normal whitespace regex here because the Flow parser has
          // already deemed this AST node to be a type cast. Only the Babel parser needs the
          // non-line-break whitespace regex, which is why hasFlowShorthandAnnotationComment() is
          // implemented differently.

          var commentSyntax = value && value.typeAnnotation && value.typeAnnotation.range && options.originalText.substring(value.typeAnnotation.range[0]).match(/^\/\*\s*:/);
          return concat$d(["(", path.call(print, "expression"), commentSyntax ? " /*" : "", ": ", path.call(print, "typeAnnotation"), commentSyntax ? " */" : "", ")"]);
        }

      case "TypeParameterDeclaration":
      case "TypeParameterInstantiation":
        {
          var _value = path.getValue();

          var commentStart = _value.range ? options.originalText.substring(0, _value.range[0]).lastIndexOf("/*") : -1; // As noted in the TypeCastExpression comments above, we're able to use a normal whitespace regex here
          // because we know for sure that this is a type definition.

          var _commentSyntax = commentStart >= 0 && options.originalText.substring(commentStart).match(/^\/\*\s*::/);

          if (_commentSyntax) {
            return concat$d(["/*:: ", printTypeParameters(path, options, print, "params"), " */"]);
          }

          return printTypeParameters(path, options, print, "params");
        }

      case "TSTypeParameterDeclaration":
      case "TSTypeParameterInstantiation":
        return printTypeParameters(path, options, print, "params");

      case "TSTypeParameter":
      case "TypeParameter":
        {
          var _parent10 = path.getParentNode();

          if (_parent10.type === "TSMappedType") {
            parts.push("[", path.call(print, "name"));

            if (n.constraint) {
              parts.push(" in ", path.call(print, "constraint"));
            }

            parts.push("]");
            return concat$d(parts);
          }

          var _variance3 = getFlowVariance$1(n);

          if (_variance3) {
            parts.push(_variance3);
          }

          parts.push(path.call(print, "name"));

          if (n.bound) {
            parts.push(": ");
            parts.push(path.call(print, "bound"));
          }

          if (n.constraint) {
            parts.push(" extends ", path.call(print, "constraint"));
          }

          if (n["default"]) {
            parts.push(" = ", path.call(print, "default"));
          } // Keep comma if the file extension is .tsx and
          // has one type parameter that isn't extend with any types.
          // Because, otherwise formatted result will be invalid as tsx.


          var _grandParent = path.getNode(2);

          if (_parent10.params && _parent10.params.length === 1 && isTSXFile$1(options) && !n.constraint && _grandParent.type === "ArrowFunctionExpression") {
            parts.push(",");
          }

          return concat$d(parts);
        }

      case "TypeofTypeAnnotation":
        return concat$d(["typeof ", path.call(print, "argument")]);

      case "VoidTypeAnnotation":
        return "void";

      case "InferredPredicate":
        return "%checks";
      // Unhandled types below. If encountered, nodes of these types should
      // be either left alone or desugared into AST types that are fully
      // supported by the pretty-printer.

      case "DeclaredPredicate":
        return concat$d(["%checks(", path.call(print, "value"), ")"]);

      case "TSAbstractKeyword":
        return "abstract";

      case "TSAnyKeyword":
        return "any";

      case "TSAsyncKeyword":
        return "async";

      case "TSBooleanKeyword":
        return "boolean";

      case "TSBigIntKeyword":
        return "bigint";

      case "TSConstKeyword":
        return "const";

      case "TSDeclareKeyword":
        return "declare";

      case "TSExportKeyword":
        return "export";

      case "TSNeverKeyword":
        return "never";

      case "TSNumberKeyword":
        return "number";

      case "TSObjectKeyword":
        return "object";

      case "TSProtectedKeyword":
        return "protected";

      case "TSPrivateKeyword":
        return "private";

      case "TSPublicKeyword":
        return "public";

      case "TSReadonlyKeyword":
        return "readonly";

      case "TSSymbolKeyword":
        return "symbol";

      case "TSStaticKeyword":
        return "static";

      case "TSStringKeyword":
        return "string";

      case "TSUndefinedKeyword":
        return "undefined";

      case "TSUnknownKeyword":
        return "unknown";

      case "TSVoidKeyword":
        return "void";

      case "TSAsExpression":
        return concat$d([path.call(print, "expression"), " as ", path.call(print, "typeAnnotation")]);

      case "TSArrayType":
        return concat$d([path.call(print, "elementType"), "[]"]);

      case "TSPropertySignature":
        {
          if (n.export) {
            parts.push("export ");
          }

          if (n.accessibility) {
            parts.push(n.accessibility + " ");
          }

          if (n.static) {
            parts.push("static ");
          }

          if (n.readonly) {
            parts.push("readonly ");
          }

          parts.push(printPropertyKey(path, options, print), printOptionalToken(path));

          if (n.typeAnnotation) {
            parts.push(": ");
            parts.push(path.call(print, "typeAnnotation"));
          } // This isn't valid semantically, but it's in the AST so we can print it.


          if (n.initializer) {
            parts.push(" = ", path.call(print, "initializer"));
          }

          return concat$d(parts);
        }

      case "TSParameterProperty":
        if (n.accessibility) {
          parts.push(n.accessibility + " ");
        }

        if (n.export) {
          parts.push("export ");
        }

        if (n.static) {
          parts.push("static ");
        }

        if (n.readonly) {
          parts.push("readonly ");
        }

        parts.push(path.call(print, "parameter"));
        return concat$d(parts);

      case "TSTypeReference":
        return concat$d([path.call(print, "typeName"), printTypeParameters(path, options, print, "typeParameters")]);

      case "TSTypeQuery":
        return concat$d(["typeof ", path.call(print, "exprName")]);

      case "TSIndexSignature":
        {
          var _parent11 = path.getParentNode();

          return concat$d([n.export ? "export " : "", n.accessibility ? concat$d([n.accessibility, " "]) : "", n.static ? "static " : "", n.readonly ? "readonly " : "", "[", n.parameters ? concat$d(path.map(print, "parameters")) : "", "]: ", path.call(print, "typeAnnotation"), _parent11.type === "ClassBody" ? semi : ""]);
        }

      case "TSTypePredicate":
        return concat$d([n.asserts ? "asserts " : "", path.call(print, "parameterName"), n.typeAnnotation ? concat$d([" is ", path.call(print, "typeAnnotation")]) : ""]);

      case "TSNonNullExpression":
        return concat$d([path.call(print, "expression"), "!"]);

      case "TSThisType":
        return "this";

      case "TSImportType":
        return concat$d([!n.isTypeOf ? "" : "typeof ", "import(", path.call(print, "parameter"), ")", !n.qualifier ? "" : concat$d([".", path.call(print, "qualifier")]), printTypeParameters(path, options, print, "typeParameters")]);

      case "TSLiteralType":
        return path.call(print, "literal");

      case "TSIndexedAccessType":
        return concat$d([path.call(print, "objectType"), "[", path.call(print, "indexType"), "]"]);

      case "TSConstructSignatureDeclaration":
      case "TSCallSignatureDeclaration":
      case "TSConstructorType":
        {
          if (n.type !== "TSCallSignatureDeclaration") {
            parts.push("new ");
          }

          parts.push(group$b(printFunctionParams(path, print, options,
          /* expandArg */
          false,
          /* printTypeParams */
          true)));

          if (n.returnType) {
            var isType = n.type === "TSConstructorType";
            parts.push(isType ? " => " : ": ", path.call(print, "returnType"));
          }

          return concat$d(parts);
        }

      case "TSTypeOperator":
        return concat$d([n.operator, " ", path.call(print, "typeAnnotation")]);

      case "TSMappedType":
        {
          var _shouldBreak3 = hasNewlineInRange$2(options.originalText, options.locStart(n), options.locEnd(n));

          return group$b(concat$d(["{", indent$7(concat$d([options.bracketSpacing ? line$7 : softline$6, n.readonly ? concat$d([getTypeScriptMappedTypeModifier$1(n.readonly, "readonly"), " "]) : "", printTypeScriptModifiers(path, options, print), path.call(print, "typeParameter"), n.optional ? getTypeScriptMappedTypeModifier$1(n.optional, "?") : "", ": ", path.call(print, "typeAnnotation"), ifBreak$6(semi, "")])), comments.printDanglingComments(path, options,
          /* sameIndent */
          true), options.bracketSpacing ? line$7 : softline$6, "}"]), {
            shouldBreak: _shouldBreak3
          });
        }

      case "TSMethodSignature":
        parts.push(n.accessibility ? concat$d([n.accessibility, " "]) : "", n.export ? "export " : "", n.static ? "static " : "", n.readonly ? "readonly " : "", n.computed ? "[" : "", path.call(print, "key"), n.computed ? "]" : "", printOptionalToken(path), printFunctionParams(path, print, options,
        /* expandArg */
        false,
        /* printTypeParams */
        true));

        if (n.returnType) {
          parts.push(": ", path.call(print, "returnType"));
        }

        return group$b(concat$d(parts));

      case "TSNamespaceExportDeclaration":
        parts.push("export as namespace ", path.call(print, "id"));

        if (options.semi) {
          parts.push(";");
        }

        return group$b(concat$d(parts));

      case "TSEnumDeclaration":
        if (n.declare) {
          parts.push("declare ");
        }

        if (n.modifiers) {
          parts.push(printTypeScriptModifiers(path, options, print));
        }

        if (n.const) {
          parts.push("const ");
        }

        parts.push("enum ", path.call(print, "id"), " ");

        if (n.members.length === 0) {
          parts.push(group$b(concat$d(["{", comments.printDanglingComments(path, options), softline$6, "}"])));
        } else {
          parts.push(group$b(concat$d(["{", indent$7(concat$d([hardline$9, printArrayItems(path, options, "members", print), shouldPrintComma$1(options, "es5") ? "," : ""])), comments.printDanglingComments(path, options,
          /* sameIndent */
          true), hardline$9, "}"])));
        }

        return concat$d(parts);

      case "TSEnumMember":
        parts.push(path.call(print, "id"));

        if (n.initializer) {
          parts.push(" = ", path.call(print, "initializer"));
        }

        return concat$d(parts);

      case "TSImportEqualsDeclaration":
        if (n.isExport) {
          parts.push("export ");
        }

        parts.push("import ", path.call(print, "id"), " = ", path.call(print, "moduleReference"));

        if (options.semi) {
          parts.push(";");
        }

        return group$b(concat$d(parts));

      case "TSExternalModuleReference":
        return concat$d(["require(", path.call(print, "expression"), ")"]);

      case "TSModuleDeclaration":
        {
          var _parent12 = path.getParentNode();

          var isExternalModule = isLiteral$1(n.id);
          var parentIsDeclaration = _parent12.type === "TSModuleDeclaration";
          var bodyIsDeclaration = n.body && n.body.type === "TSModuleDeclaration";

          if (parentIsDeclaration) {
            parts.push(".");
          } else {
            if (n.declare) {
              parts.push("declare ");
            }

            parts.push(printTypeScriptModifiers(path, options, print));
            var textBetweenNodeAndItsId = options.originalText.slice(options.locStart(n), options.locStart(n.id)); // Global declaration looks like this:
            // (declare)? global { ... }

            var isGlobalDeclaration = n.id.type === "Identifier" && n.id.name === "global" && !/namespace|module/.test(textBetweenNodeAndItsId);

            if (!isGlobalDeclaration) {
              parts.push(isExternalModule || /(^|\s)module(\s|$)/.test(textBetweenNodeAndItsId) ? "module " : "namespace ");
            }
          }

          parts.push(path.call(print, "id"));

          if (bodyIsDeclaration) {
            parts.push(path.call(print, "body"));
          } else if (n.body) {
            parts.push(" ", group$b(path.call(print, "body")));
          } else {
            parts.push(semi);
          }

          return concat$d(parts);
        }

      case "PrivateName":
        return concat$d(["#", path.call(print, "id")]);

      case "TSConditionalType":
        return printTernaryOperator(path, options, print, {
          beforeParts: function beforeParts() {
            return [path.call(print, "checkType"), " ", "extends", " ", path.call(print, "extendsType")];
          },
          afterParts: function afterParts() {
            return [];
          },
          shouldCheckJsx: false,
          conditionalNodeType: "TSConditionalType",
          consequentNodePropertyName: "trueType",
          alternateNodePropertyName: "falseType",
          testNodePropertyName: "checkType",
          breakNested: true
        });

      case "TSInferType":
        return concat$d(["infer", " ", path.call(print, "typeParameter")]);

      case "InterpreterDirective":
        parts.push("#!", n.value, hardline$9);

        if (isNextLineEmpty$4(options.originalText, n, options)) {
          parts.push(hardline$9);
        }

        return concat$d(parts);

      case "NGRoot":
        return concat$d([].concat(path.call(print, "node"), !n.node.comments || n.node.comments.length === 0 ? [] : concat$d([" //", n.node.comments[0].value.trimRight()])));

      case "NGChainedExpression":
        return group$b(join$9(concat$d([";", line$7]), path.map(function (childPath) {
          return hasNgSideEffect$1(childPath) ? print(childPath) : concat$d(["(", print(childPath), ")"]);
        }, "expressions")));

      case "NGEmptyExpression":
        return "";

      case "NGQuotedExpression":
        return concat$d([n.prefix, ":", n.value]);

      case "NGMicrosyntax":
        return concat$d(path.map(function (childPath, index) {
          return concat$d([index === 0 ? "" : isNgForOf$1(childPath.getValue(), index, n) ? " " : concat$d([";", line$7]), print(childPath)]);
        }, "body"));

      case "NGMicrosyntaxKey":
        return /^[a-z_$][a-z0-9_$]*(-[a-z_$][a-z0-9_$])*$/i.test(n.name) ? n.name : JSON.stringify(n.name);

      case "NGMicrosyntaxExpression":
        return concat$d([path.call(print, "expression"), n.alias === null ? "" : concat$d([" as ", path.call(print, "alias")])]);

      case "NGMicrosyntaxKeyedExpression":
        {
          var index = path.getName();

          var _parentNode2 = path.getParentNode();

          var shouldNotPrintColon = isNgForOf$1(n, index, _parentNode2) || (index === 1 && (n.key.name === "then" || n.key.name === "else") || index === 2 && n.key.name === "else" && _parentNode2.body[index - 1].type === "NGMicrosyntaxKeyedExpression" && _parentNode2.body[index - 1].key.name === "then") && _parentNode2.body[0].type === "NGMicrosyntaxExpression";
          return concat$d([path.call(print, "key"), shouldNotPrintColon ? " " : ": ", path.call(print, "expression")]);
        }

      case "NGMicrosyntaxLet":
        return concat$d(["let ", path.call(print, "key"), n.value === null ? "" : concat$d([" = ", path.call(print, "value")])]);

      case "NGMicrosyntaxAs":
        return concat$d([path.call(print, "key"), " as ", path.call(print, "alias")]);

      case "ArgumentPlaceholder":
        return "?";

      default:
        /* istanbul ignore next */
        throw new Error("unknown type: " + JSON.stringify(n.type));
    }
  }

  function printStatementSequence(path, options, print) {
    var printed = [];
    var bodyNode = path.getNode();
    var isClass = bodyNode.type === "ClassBody";
    path.map(function (stmtPath, i) {
      var stmt = stmtPath.getValue(); // Just in case the AST has been modified to contain falsy
      // "statements," it's safer simply to skip them.

      /* istanbul ignore if */

      if (!stmt) {
        return;
      } // Skip printing EmptyStatement nodes to avoid leaving stray
      // semicolons lying around.


      if (stmt.type === "EmptyStatement") {
        return;
      }

      var stmtPrinted = print(stmtPath);
      var text = options.originalText;
      var parts = []; // in no-semi mode, prepend statement with semicolon if it might break ASI
      // don't prepend the only JSX element in a program with semicolon

      if (!options.semi && !isClass && !isTheOnlyJSXElementInMarkdown$1(options, stmtPath) && stmtNeedsASIProtection(stmtPath, options)) {
        if (stmt.comments && stmt.comments.some(function (comment) {
          return comment.leading;
        })) {
          parts.push(print(stmtPath, {
            needsSemi: true
          }));
        } else {
          parts.push(";", stmtPrinted);
        }
      } else {
        parts.push(stmtPrinted);
      }

      if (!options.semi && isClass) {
        if (classPropMayCauseASIProblems$1(stmtPath)) {
          parts.push(";");
        } else if (stmt.type === "ClassProperty") {
          var nextChild = bodyNode.body[i + 1];

          if (classChildNeedsASIProtection$1(nextChild)) {
            parts.push(";");
          }
        }
      }

      if (isNextLineEmpty$4(text, stmt, options) && !isLastStatement$1(stmtPath)) {
        parts.push(hardline$9);
      }

      printed.push(concat$d(parts));
    });
    return join$9(hardline$9, printed);
  }

  function printPropertyKey(path, options, print) {
    var node = path.getNode();

    if (node.computed) {
      return concat$d(["[", path.call(print, "key"), "]"]);
    }

    var parent = path.getParentNode();
    var key = node.key;

    if (options.quoteProps === "consistent" && !needsQuoteProps.has(parent)) {
      var objectHasStringProp = (parent.properties || parent.body || parent.members).some(function (prop) {
        return !prop.computed && prop.key && isStringLiteral$1(prop.key) && !isStringPropSafeToCoerceToIdentifier$1(prop, options);
      });
      needsQuoteProps.set(parent, objectHasStringProp);
    }

    if (key.type === "Identifier" && (options.parser === "json" || options.quoteProps === "consistent" && needsQuoteProps.get(parent))) {
      // a -> "a"
      var prop = printString$2(JSON.stringify(key.name), options);
      return path.call(function (keyPath) {
        return comments.printComments(keyPath, function () {
          return prop;
        }, options);
      }, "key");
    }

    if (isStringPropSafeToCoerceToIdentifier$1(node, options) && (options.quoteProps === "as-needed" || options.quoteProps === "consistent" && !needsQuoteProps.get(parent))) {
      // 'a' -> a
      return path.call(function (keyPath) {
        return comments.printComments(keyPath, function () {
          return key.value;
        }, options);
      }, "key");
    }

    return path.call(print, "key");
  }

  function printMethod(path, options, print) {
    var node = path.getNode();
    var kind = node.kind;
    var value = node.value || node;
    var parts = [];

    if (!kind || kind === "init" || kind === "method" || kind === "constructor") {
      if (value.async) {
        parts.push("async ");
      }

      if (value.generator) {
        parts.push("*");
      }
    } else {
      assert.ok(kind === "get" || kind === "set");
      parts.push(kind, " ");
    }

    parts.push(printPropertyKey(path, options, print), node.optional || node.key.optional ? "?" : "", node === value ? printMethodInternal(path, options, print) : path.call(function (path) {
      return printMethodInternal(path, options, print);
    }, "value"));
    return concat$d(parts);
  }

  function printMethodInternal(path, options, print) {
    var parts = [printFunctionTypeParameters(path, options, print), group$b(concat$d([printFunctionParams(path, print, options), printReturnType(path, print, options)]))];

    if (path.getNode().body) {
      parts.push(" ", path.call(print, "body"));
    } else {
      parts.push(options.semi ? ";" : "");
    }

    return concat$d(parts);
  }

  function couldGroupArg(arg) {
    return arg.type === "ObjectExpression" && (arg.properties.length > 0 || arg.comments) || arg.type === "ArrayExpression" && (arg.elements.length > 0 || arg.comments) || arg.type === "TSTypeAssertion" && couldGroupArg(arg.expression) || arg.type === "TSAsExpression" && couldGroupArg(arg.expression) || arg.type === "FunctionExpression" || arg.type === "ArrowFunctionExpression" && ( // we want to avoid breaking inside composite return types but not simple keywords
    // https://github.com/prettier/prettier/issues/4070
    // export class Thing implements OtherThing {
    //   do: (type: Type) => Provider<Prop> = memoize(
    //     (type: ObjectType): Provider<Opts> => {}
    //   );
    // }
    // https://github.com/prettier/prettier/issues/6099
    // app.get("/", (req, res): void => {
    //   res.send("Hello World!");
    // });
    !arg.returnType || !arg.returnType.typeAnnotation || arg.returnType.typeAnnotation.type !== "TSTypeReference") && (arg.body.type === "BlockStatement" || arg.body.type === "ArrowFunctionExpression" || arg.body.type === "ObjectExpression" || arg.body.type === "ArrayExpression" || arg.body.type === "CallExpression" || arg.body.type === "OptionalCallExpression" || arg.body.type === "ConditionalExpression" || isJSXNode$1(arg.body));
  }

  function shouldGroupLastArg(args) {
    var lastArg = getLast$2(args);
    var penultimateArg = getPenultimate$1(args);
    return !hasLeadingComment$3(lastArg) && !hasTrailingComment$1(lastArg) && couldGroupArg(lastArg) && ( // If the last two arguments are of the same type,
    // disable last element expansion.
    !penultimateArg || penultimateArg.type !== lastArg.type);
  }

  function shouldGroupFirstArg(args) {
    if (args.length !== 2) {
      return false;
    }

    var firstArg = args[0];
    var secondArg = args[1];
    return (!firstArg.comments || !firstArg.comments.length) && (firstArg.type === "FunctionExpression" || firstArg.type === "ArrowFunctionExpression" && firstArg.body.type === "BlockStatement") && secondArg.type !== "FunctionExpression" && secondArg.type !== "ArrowFunctionExpression" && secondArg.type !== "ConditionalExpression" && !couldGroupArg(secondArg);
  }

  function printJestEachTemplateLiteral(node, expressions, options) {
    /**
     * a    | b    | expected
     * ${1} | ${1} | ${2}
     * ${1} | ${2} | ${3}
     * ${2} | ${1} | ${3}
     */
    var headerNames = node.quasis[0].value.raw.trim().split(/\s*\|\s*/);

    if (headerNames.length > 1 || headerNames.some(function (headerName) {
      return headerName.length !== 0;
    })) {
      var parts = [];
      var stringifiedExpressions = expressions.map(function (doc) {
        return "${" + printDocToString$1(doc, Object.assign({}, options, {
          printWidth: Infinity,
          endOfLine: "lf"
        })).formatted + "}";
      });
      var tableBody = [{
        hasLineBreak: false,
        cells: []
      }];

      for (var i = 1; i < node.quasis.length; i++) {
        var row = tableBody[tableBody.length - 1];
        var correspondingExpression = stringifiedExpressions[i - 1];
        row.cells.push(correspondingExpression);

        if (correspondingExpression.indexOf("\n") !== -1) {
          row.hasLineBreak = true;
        }

        if (node.quasis[i].value.raw.indexOf("\n") !== -1) {
          tableBody.push({
            hasLineBreak: false,
            cells: []
          });
        }
      }

      var maxColumnCount = tableBody.reduce(function (maxColumnCount, row) {
        return Math.max(maxColumnCount, row.cells.length);
      }, headerNames.length);
      var maxColumnWidths = Array.from(new Array(maxColumnCount), function () {
        return 0;
      });
      var table = [{
        cells: headerNames
      }].concat(tableBody.filter(function (row) {
        return row.cells.length !== 0;
      }));
      table.filter(function (row) {
        return !row.hasLineBreak;
      }).forEach(function (row) {
        row.cells.forEach(function (cell, index) {
          maxColumnWidths[index] = Math.max(maxColumnWidths[index], getStringWidth$2(cell));
        });
      });
      parts.push(lineSuffixBoundary$1, "`", indent$7(concat$d([hardline$9, join$9(hardline$9, table.map(function (row) {
        return join$9(" | ", row.cells.map(function (cell, index) {
          return row.hasLineBreak ? cell : cell + " ".repeat(maxColumnWidths[index] - getStringWidth$2(cell));
        }));
      }))])), hardline$9, "`");
      return concat$d(parts);
    }
  }

  function printArgumentsList(path, options, print) {
    var node = path.getValue();
    var args = node.arguments;

    if (args.length === 0) {
      return concat$d(["(", comments.printDanglingComments(path, options,
      /* sameIndent */
      true), ")"]);
    } // useEffect(() => { ... }, [foo, bar, baz])


    if (args.length === 2 && args[0].type === "ArrowFunctionExpression" && args[0].params.length === 0 && args[0].body.type === "BlockStatement" && args[1].type === "ArrayExpression" && !args.find(function (arg) {
      return arg.comments;
    })) {
      return concat$d(["(", path.call(print, "arguments", 0), ", ", path.call(print, "arguments", 1), ")"]);
    } // func(
    //   ({
    //     a,
    //     b
    //   }) => {}
    // );


    function shouldBreakForArrowFunctionInArguments(arg, argPath) {
      if (!arg || arg.type !== "ArrowFunctionExpression" || !arg.body || arg.body.type !== "BlockStatement" || !arg.params || arg.params.length < 1) {
        return false;
      }

      var shouldBreak = false;
      argPath.each(function (paramPath) {
        var printed = concat$d([print(paramPath)]);
        shouldBreak = shouldBreak || willBreak$1(printed);
      }, "params");
      return shouldBreak;
    }

    var anyArgEmptyLine = false;
    var shouldBreakForArrowFunction = false;
    var hasEmptyLineFollowingFirstArg = false;
    var lastArgIndex = args.length - 1;
    var printedArguments = path.map(function (argPath, index) {
      var arg = argPath.getNode();
      var parts = [print(argPath)];

      if (index === lastArgIndex) ; else if (isNextLineEmpty$4(options.originalText, arg, options)) {
        if (index === 0) {
          hasEmptyLineFollowingFirstArg = true;
        }

        anyArgEmptyLine = true;
        parts.push(",", hardline$9, hardline$9);
      } else {
        parts.push(",", line$7);
      }

      shouldBreakForArrowFunction = shouldBreakForArrowFunctionInArguments(arg, argPath);
      return concat$d(parts);
    }, "arguments");
    var maybeTrailingComma = // Dynamic imports cannot have trailing commas
    !(node.callee && node.callee.type === "Import") && shouldPrintComma$1(options, "all") ? "," : "";

    function allArgsBrokenOut() {
      return group$b(concat$d(["(", indent$7(concat$d([line$7, concat$d(printedArguments)])), maybeTrailingComma, line$7, ")"]), {
        shouldBreak: true
      });
    }

    if (isFunctionCompositionArgs$1(args)) {
      return allArgsBrokenOut();
    }

    var shouldGroupFirst = shouldGroupFirstArg(args);
    var shouldGroupLast = shouldGroupLastArg(args);

    if (shouldGroupFirst || shouldGroupLast) {
      var shouldBreak = (shouldGroupFirst ? printedArguments.slice(1).some(willBreak$1) : printedArguments.slice(0, -1).some(willBreak$1)) || anyArgEmptyLine || shouldBreakForArrowFunction; // We want to print the last argument with a special flag

      var printedExpanded;
      var i = 0;
      path.each(function (argPath) {
        if (shouldGroupFirst && i === 0) {
          printedExpanded = [concat$d([argPath.call(function (p) {
            return print(p, {
              expandFirstArg: true
            });
          }), printedArguments.length > 1 ? "," : "", hasEmptyLineFollowingFirstArg ? hardline$9 : line$7, hasEmptyLineFollowingFirstArg ? hardline$9 : ""])].concat(printedArguments.slice(1));
        }

        if (shouldGroupLast && i === args.length - 1) {
          printedExpanded = printedArguments.slice(0, -1).concat(argPath.call(function (p) {
            return print(p, {
              expandLastArg: true
            });
          }));
        }

        i++;
      }, "arguments");
      var somePrintedArgumentsWillBreak = printedArguments.some(willBreak$1);
      var simpleConcat = concat$d(["(", concat$d(printedExpanded), ")"]);
      return concat$d([somePrintedArgumentsWillBreak ? breakParent$3 : "", conditionalGroup$1([!somePrintedArgumentsWillBreak && !node.typeArguments && !node.typeParameters ? simpleConcat : ifBreak$6(allArgsBrokenOut(), simpleConcat), shouldGroupFirst ? concat$d(["(", group$b(printedExpanded[0], {
        shouldBreak: true
      }), concat$d(printedExpanded.slice(1)), ")"]) : concat$d(["(", concat$d(printedArguments.slice(0, -1)), group$b(getLast$2(printedExpanded), {
        shouldBreak: true
      }), ")"]), allArgsBrokenOut()], {
        shouldBreak: shouldBreak
      })]);
    }

    var contents = concat$d(["(", indent$7(concat$d([softline$6, concat$d(printedArguments)])), ifBreak$6(maybeTrailingComma), softline$6, ")"]);

    if (isLongCurriedCallExpression$1(path)) {
      // By not wrapping the arguments in a group, the printer prioritizes
      // breaking up these arguments rather than the args of the parent call.
      return contents;
    }

    return group$b(contents, {
      shouldBreak: printedArguments.some(willBreak$1) || anyArgEmptyLine
    });
  }

  function printTypeAnnotation(path, options, print) {
    var node = path.getValue();

    if (!node.typeAnnotation) {
      return "";
    }

    var parentNode = path.getParentNode();
    var isDefinite = node.definite || parentNode && parentNode.type === "VariableDeclarator" && parentNode.definite;
    var isFunctionDeclarationIdentifier = parentNode.type === "DeclareFunction" && parentNode.id === node;

    if (isFlowAnnotationComment$1(options.originalText, node.typeAnnotation, options)) {
      return concat$d([" /*: ", path.call(print, "typeAnnotation"), " */"]);
    }

    return concat$d([isFunctionDeclarationIdentifier ? "" : isDefinite ? "!: " : ": ", path.call(print, "typeAnnotation")]);
  }

  function printFunctionTypeParameters(path, options, print) {
    var fun = path.getValue();

    if (fun.typeArguments) {
      return path.call(print, "typeArguments");
    }

    if (fun.typeParameters) {
      return path.call(print, "typeParameters");
    }

    return "";
  }

  function printFunctionParams(path, print, options, expandArg, printTypeParams) {
    var fun = path.getValue();
    var parent = path.getParentNode();
    var paramsField = fun.parameters ? "parameters" : "params";
    var isParametersInTestCall = isTestCall$1(parent);
    var shouldHugParameters = shouldHugArguments(fun);
    var shouldExpandParameters = expandArg && !(fun[paramsField] && fun[paramsField].some(function (n) {
      return n.comments;
    }));
    var typeParams = printTypeParams ? printFunctionTypeParameters(path, options, print) : "";
    var printed = [];

    if (fun[paramsField]) {
      var lastArgIndex = fun[paramsField].length - 1;
      printed = path.map(function (childPath, index) {
        var parts = [];
        var param = childPath.getValue();
        parts.push(print(childPath));

        if (index === lastArgIndex) {
          if (fun.rest) {
            parts.push(",", line$7);
          }
        } else if (isParametersInTestCall || shouldHugParameters || shouldExpandParameters) {
          parts.push(", ");
        } else if (isNextLineEmpty$4(options.originalText, param, options)) {
          parts.push(",", hardline$9, hardline$9);
        } else {
          parts.push(",", line$7);
        }

        return concat$d(parts);
      }, paramsField);
    }

    if (fun.rest) {
      printed.push(concat$d(["...", path.call(print, "rest")]));
    }

    if (printed.length === 0) {
      return concat$d([typeParams, "(", comments.printDanglingComments(path, options,
      /* sameIndent */
      true, function (comment) {
        return getNextNonSpaceNonCommentCharacter$1(options.originalText, comment, options.locEnd) === ")";
      }), ")"]);
    }

    var lastParam = getLast$2(fun[paramsField]); // If the parent is a call with the first/last argument expansion and this is the
    // params of the first/last argument, we don't want the arguments to break and instead
    // want the whole expression to be on a new line.
    //
    // Good:                 Bad:
    //   verylongcall(         verylongcall((
    //     (a, b) => {           a,
    //     }                     b,
    //   })                    ) => {
    //                         })

    if (shouldExpandParameters) {
      return group$b(concat$d([removeLines$2(typeParams), "(", concat$d(printed.map(removeLines$2)), ")"]));
    } // Single object destructuring should hug
    //
    // function({
    //   a,
    //   b,
    //   c
    // }) {}


    var hasNotParameterDecorator = fun[paramsField].every(function (param) {
      return !param.decorators;
    });

    if (shouldHugParameters && hasNotParameterDecorator) {
      return concat$d([typeParams, "(", concat$d(printed), ")"]);
    } // don't break in specs, eg; `it("should maintain parens around done even when long", (done) => {})`


    if (isParametersInTestCall) {
      return concat$d([typeParams, "(", concat$d(printed), ")"]);
    }

    var isFlowShorthandWithOneArg = (isObjectTypePropertyAFunction$1(parent, options) || isTypeAnnotationAFunction$1(parent, options) || parent.type === "TypeAlias" || parent.type === "UnionTypeAnnotation" || parent.type === "TSUnionType" || parent.type === "IntersectionTypeAnnotation" || parent.type === "FunctionTypeAnnotation" && parent.returnType === fun) && fun[paramsField].length === 1 && fun[paramsField][0].name === null && fun[paramsField][0].typeAnnotation && fun.typeParameters === null && isSimpleFlowType$1(fun[paramsField][0].typeAnnotation) && !fun.rest;

    if (isFlowShorthandWithOneArg) {
      if (options.arrowParens === "always") {
        return concat$d(["(", concat$d(printed), ")"]);
      }

      return concat$d(printed);
    }

    var canHaveTrailingComma = !(lastParam && lastParam.type === "RestElement") && !fun.rest;
    return concat$d([typeParams, "(", indent$7(concat$d([softline$6, concat$d(printed)])), ifBreak$6(canHaveTrailingComma && shouldPrintComma$1(options, "all") ? "," : ""), softline$6, ")"]);
  }

  function shouldPrintParamsWithoutParens(path, options) {
    if (options.arrowParens === "always") {
      return false;
    }

    if (options.arrowParens === "avoid") {
      var node = path.getValue();
      return canPrintParamsWithoutParens(node);
    } // Fallback default; should be unreachable


    return false;
  }

  function canPrintParamsWithoutParens(node) {
    return node.params.length === 1 && !node.rest && !node.typeParameters && !hasDanglingComments$1(node) && node.params[0].type === "Identifier" && !node.params[0].typeAnnotation && !node.params[0].comments && !node.params[0].optional && !node.predicate && !node.returnType;
  }

  function printFunctionDeclaration(path, print, options) {
    var n = path.getValue();
    var parts = [];

    if (n.async) {
      parts.push("async ");
    }

    parts.push("function");

    if (n.generator) {
      parts.push("*");
    }

    if (n.id) {
      parts.push(" ", path.call(print, "id"));
    }

    parts.push(printFunctionTypeParameters(path, options, print), group$b(concat$d([printFunctionParams(path, print, options), printReturnType(path, print, options)])), n.body ? " " : "", path.call(print, "body"));
    return concat$d(parts);
  }

  function printReturnType(path, print, options) {
    var n = path.getValue();
    var returnType = path.call(print, "returnType");

    if (n.returnType && isFlowAnnotationComment$1(options.originalText, n.returnType, options)) {
      return concat$d([" /*: ", returnType, " */"]);
    }

    var parts = [returnType]; // prepend colon to TypeScript type annotation

    if (n.returnType && n.returnType.typeAnnotation) {
      parts.unshift(": ");
    }

    if (n.predicate) {
      // The return type will already add the colon, but otherwise we
      // need to do it ourselves
      parts.push(n.returnType ? " " : ": ", path.call(print, "predicate"));
    }

    return concat$d(parts);
  }

  function printExportDeclaration(path, options, print) {
    var decl = path.getValue();
    var semi = options.semi ? ";" : "";
    var parts = ["export "];
    var isDefault = decl["default"] || decl.type === "ExportDefaultDeclaration";

    if (isDefault) {
      parts.push("default ");
    }

    parts.push(comments.printDanglingComments(path, options,
    /* sameIndent */
    true));

    if (needsHardlineAfterDanglingComment$1(decl)) {
      parts.push(hardline$9);
    }

    if (decl.declaration) {
      parts.push(path.call(print, "declaration"));

      if (isDefault && decl.declaration.type !== "ClassDeclaration" && decl.declaration.type !== "FunctionDeclaration" && decl.declaration.type !== "TSInterfaceDeclaration" && decl.declaration.type !== "DeclareClass" && decl.declaration.type !== "DeclareFunction" && decl.declaration.type !== "TSDeclareFunction") {
        parts.push(semi);
      }
    } else {
      if (decl.specifiers && decl.specifiers.length > 0) {
        var specifiers = [];
        var defaultSpecifiers = [];
        var namespaceSpecifiers = [];
        path.each(function (specifierPath) {
          var specifierType = path.getValue().type;

          if (specifierType === "ExportSpecifier") {
            specifiers.push(print(specifierPath));
          } else if (specifierType === "ExportDefaultSpecifier") {
            defaultSpecifiers.push(print(specifierPath));
          } else if (specifierType === "ExportNamespaceSpecifier") {
            namespaceSpecifiers.push(concat$d(["* as ", print(specifierPath)]));
          }
        }, "specifiers");
        var isNamespaceFollowed = namespaceSpecifiers.length !== 0 && specifiers.length !== 0;
        var isDefaultFollowed = defaultSpecifiers.length !== 0 && (namespaceSpecifiers.length !== 0 || specifiers.length !== 0);
        var canBreak = specifiers.length > 1 || defaultSpecifiers.length > 0 || decl.specifiers && decl.specifiers.some(function (node) {
          return node.comments;
        });
        var printed = "";

        if (specifiers.length !== 0) {
          if (canBreak) {
            printed = group$b(concat$d(["{", indent$7(concat$d([options.bracketSpacing ? line$7 : softline$6, join$9(concat$d([",", line$7]), specifiers)])), ifBreak$6(shouldPrintComma$1(options) ? "," : ""), options.bracketSpacing ? line$7 : softline$6, "}"]));
          } else {
            printed = concat$d(["{", options.bracketSpacing ? " " : "", concat$d(specifiers), options.bracketSpacing ? " " : "", "}"]);
          }
        }

        parts.push(decl.exportKind === "type" ? "type " : "", concat$d(defaultSpecifiers), concat$d([isDefaultFollowed ? ", " : ""]), concat$d(namespaceSpecifiers), concat$d([isNamespaceFollowed ? ", " : ""]), printed);
      } else {
        parts.push("{}");
      }

      if (decl.source) {
        parts.push(" from ", path.call(print, "source"));
      }

      parts.push(semi);
    }

    return concat$d(parts);
  }

  function printFlowDeclaration(path, parts) {
    var parentExportDecl = getParentExportDeclaration$1(path);

    if (parentExportDecl) {
      assert.strictEqual(parentExportDecl.type, "DeclareExportDeclaration");
    } else {
      // If the parent node has type DeclareExportDeclaration, then it
      // will be responsible for printing the "declare" token. Otherwise
      // it needs to be printed with this non-exported declaration node.
      parts.unshift("declare ");
    }

    return concat$d(parts);
  }

  function printTypeScriptModifiers(path, options, print) {
    var n = path.getValue();

    if (!n.modifiers || !n.modifiers.length) {
      return "";
    }

    return concat$d([join$9(" ", path.map(print, "modifiers")), " "]);
  }

  function printTypeParameters(path, options, print, paramsKey) {
    var n = path.getValue();

    if (!n[paramsKey]) {
      return "";
    } // for TypeParameterDeclaration typeParameters is a single node


    if (!Array.isArray(n[paramsKey])) {
      return path.call(print, paramsKey);
    }

    var grandparent = path.getNode(2);
    var greatGreatGrandParent = path.getNode(4);
    var isParameterInTestCall = grandparent != null && isTestCall$1(grandparent);
    var shouldInline = isParameterInTestCall || n[paramsKey].length === 0 || n[paramsKey].length === 1 && (shouldHugType(n[paramsKey][0]) || n[paramsKey][0].type === "GenericTypeAnnotation" && shouldHugType(n[paramsKey][0].id) || n[paramsKey][0].type === "TSTypeReference" && shouldHugType(n[paramsKey][0].typeName) || n[paramsKey][0].type === "NullableTypeAnnotation" || // See https://github.com/prettier/prettier/pull/6467 for the context.
    greatGreatGrandParent && greatGreatGrandParent.type === "VariableDeclarator" && grandparent && grandparent.type === "TSTypeAnnotation" && n[paramsKey][0].type !== "TSUnionType" && n[paramsKey][0].type !== "UnionTypeAnnotation" && n[paramsKey][0].type !== "TSConditionalType" && n[paramsKey][0].type !== "TSMappedType");

    if (shouldInline) {
      return concat$d(["<", join$9(", ", path.map(print, paramsKey)), ">"]);
    }

    return group$b(concat$d(["<", indent$7(concat$d([softline$6, join$9(concat$d([",", line$7]), path.map(print, paramsKey))])), ifBreak$6(options.parser !== "typescript" && shouldPrintComma$1(options, "all") ? "," : ""), softline$6, ">"]));
  }

  function printClass(path, options, print) {
    var n = path.getValue();
    var parts = [];

    if (n.abstract) {
      parts.push("abstract ");
    }

    parts.push("class");

    if (n.id) {
      parts.push(" ", path.call(print, "id"));
    }

    parts.push(path.call(print, "typeParameters"));
    var partsGroup = [];

    if (n.superClass) {
      var printed = concat$d(["extends ", path.call(print, "superClass"), path.call(print, "superTypeParameters")]); // Keep old behaviour of extends in same line
      // If there is only on extends and there are not comments

      if ((!n.implements || n.implements.length === 0) && (!n.superClass.comments || n.superClass.comments.length === 0)) {
        parts.push(concat$d([" ", path.call(function (superClass) {
          return comments.printComments(superClass, function () {
            return printed;
          }, options);
        }, "superClass")]));
      } else {
        partsGroup.push(group$b(concat$d([line$7, path.call(function (superClass) {
          return comments.printComments(superClass, function () {
            return printed;
          }, options);
        }, "superClass")])));
      }
    } else if (n.extends && n.extends.length > 0) {
      parts.push(" extends ", join$9(", ", path.map(print, "extends")));
    }

    if (n["mixins"] && n["mixins"].length > 0) {
      partsGroup.push(line$7, "mixins ", group$b(indent$7(join$9(concat$d([",", line$7]), path.map(print, "mixins")))));
    }

    if (n["implements"] && n["implements"].length > 0) {
      partsGroup.push(line$7, "implements", group$b(indent$7(concat$d([line$7, join$9(concat$d([",", line$7]), path.map(print, "implements"))]))));
    }

    if (partsGroup.length > 0) {
      parts.push(group$b(indent$7(concat$d(partsGroup))));
    }

    if (n.body && n.body.comments && hasLeadingOwnLineComment$1(options.originalText, n.body, options)) {
      parts.push(hardline$9);
    } else {
      parts.push(" ");
    }

    parts.push(path.call(print, "body"));
    return parts;
  }

  function printOptionalToken(path) {
    var node = path.getValue();

    if (!node.optional || // It's an optional computed method parsed by typescript-estree.
    // "?" is printed in `printMethod`.
    node.type === "Identifier" && node === path.getParentNode().key) {
      return "";
    }

    if (node.type === "OptionalCallExpression" || node.type === "OptionalMemberExpression" && node.computed) {
      return "?.";
    }

    return "?";
  }

  function printMemberLookup(path, options, print) {
    var property = path.call(print, "property");
    var n = path.getValue();
    var optional = printOptionalToken(path);

    if (!n.computed) {
      return concat$d([optional, ".", property]);
    }

    if (!n.property || isNumericLiteral$1(n.property)) {
      return concat$d([optional, "[", property, "]"]);
    }

    return group$b(concat$d([optional, "[", indent$7(concat$d([softline$6, property])), softline$6, "]"]));
  }

  function printBindExpressionCallee(path, options, print) {
    return concat$d(["::", path.call(print, "callee")]);
  } // We detect calls on member expressions specially to format a
  // common pattern better. The pattern we are looking for is this:
  //
  // arr
  //   .map(x => x + 1)
  //   .filter(x => x > 10)
  //   .some(x => x % 2)
  //
  // The way it is structured in the AST is via a nested sequence of
  // MemberExpression and CallExpression. We need to traverse the AST
  // and make groups out of it to print it in the desired way.


  function printMemberChain(path, options, print) {
    // The first phase is to linearize the AST by traversing it down.
    //
    //   a().b()
    // has the following AST structure:
    //   CallExpression(MemberExpression(CallExpression(Identifier)))
    // and we transform it into
    //   [Identifier, CallExpression, MemberExpression, CallExpression]
    var printedNodes = []; // Here we try to retain one typed empty line after each call expression or
    // the first group whether it is in parentheses or not

    function shouldInsertEmptyLineAfter(node) {
      var originalText = options.originalText;
      var nextCharIndex = getNextNonSpaceNonCommentCharacterIndex$2(originalText, node, options);
      var nextChar = originalText.charAt(nextCharIndex); // if it is cut off by a parenthesis, we only account for one typed empty
      // line after that parenthesis

      if (nextChar == ")") {
        return isNextLineEmptyAfterIndex$1(originalText, nextCharIndex + 1, options);
      }

      return isNextLineEmpty$4(originalText, node, options);
    }

    function rec(path) {
      var node = path.getValue();

      if ((node.type === "CallExpression" || node.type === "OptionalCallExpression") && (isMemberish$1(node.callee) || node.callee.type === "CallExpression" || node.callee.type === "OptionalCallExpression")) {
        printedNodes.unshift({
          node: node,
          printed: concat$d([comments.printComments(path, function () {
            return concat$d([printOptionalToken(path), printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)]);
          }, options), shouldInsertEmptyLineAfter(node) ? hardline$9 : ""])
        });
        path.call(function (callee) {
          return rec(callee);
        }, "callee");
      } else if (isMemberish$1(node)) {
        printedNodes.unshift({
          node: node,
          needsParens: needsParens_1(path, options),
          printed: comments.printComments(path, function () {
            return node.type === "OptionalMemberExpression" || node.type === "MemberExpression" ? printMemberLookup(path, options, print) : printBindExpressionCallee(path, options, print);
          }, options)
        });
        path.call(function (object) {
          return rec(object);
        }, "object");
      } else if (node.type === "TSNonNullExpression") {
        printedNodes.unshift({
          node: node,
          printed: comments.printComments(path, function () {
            return "!";
          }, options)
        });
        path.call(function (expression) {
          return rec(expression);
        }, "expression");
      } else {
        printedNodes.unshift({
          node: node,
          printed: path.call(print)
        });
      }
    } // Note: the comments of the root node have already been printed, so we
    // need to extract this first call without printing them as they would
    // if handled inside of the recursive call.


    var node = path.getValue();
    printedNodes.unshift({
      node: node,
      printed: concat$d([printOptionalToken(path), printFunctionTypeParameters(path, options, print), printArgumentsList(path, options, print)])
    });
    path.call(function (callee) {
      return rec(callee);
    }, "callee"); // Once we have a linear list of printed nodes, we want to create groups out
    // of it.
    //
    //   a().b.c().d().e
    // will be grouped as
    //   [
    //     [Identifier, CallExpression],
    //     [MemberExpression, MemberExpression, CallExpression],
    //     [MemberExpression, CallExpression],
    //     [MemberExpression],
    //   ]
    // so that we can print it as
    //   a()
    //     .b.c()
    //     .d()
    //     .e
    // The first group is the first node followed by
    //   - as many CallExpression as possible
    //       < fn()()() >.something()
    //   - as many array accessors as possible
    //       < fn()[0][1][2] >.something()
    //   - then, as many MemberExpression as possible but the last one
    //       < this.items >.something()

    var groups = [];
    var currentGroup = [printedNodes[0]];
    var i = 1;

    for (; i < printedNodes.length; ++i) {
      if (printedNodes[i].node.type === "TSNonNullExpression" || printedNodes[i].node.type === "OptionalCallExpression" || printedNodes[i].node.type === "CallExpression" || (printedNodes[i].node.type === "MemberExpression" || printedNodes[i].node.type === "OptionalMemberExpression") && printedNodes[i].node.computed && isNumericLiteral$1(printedNodes[i].node.property)) {
        currentGroup.push(printedNodes[i]);
      } else {
        break;
      }
    }

    if (printedNodes[0].node.type !== "CallExpression" && printedNodes[0].node.type !== "OptionalCallExpression") {
      for (; i + 1 < printedNodes.length; ++i) {
        if (isMemberish$1(printedNodes[i].node) && isMemberish$1(printedNodes[i + 1].node)) {
          currentGroup.push(printedNodes[i]);
        } else {
          break;
        }
      }
    }

    groups.push(currentGroup);
    currentGroup = []; // Then, each following group is a sequence of MemberExpression followed by
    // a sequence of CallExpression. To compute it, we keep adding things to the
    // group until we has seen a CallExpression in the past and reach a
    // MemberExpression

    var hasSeenCallExpression = false;

    for (; i < printedNodes.length; ++i) {
      if (hasSeenCallExpression && isMemberish$1(printedNodes[i].node)) {
        // [0] should be appended at the end of the group instead of the
        // beginning of the next one
        if (printedNodes[i].node.computed && isNumericLiteral$1(printedNodes[i].node.property)) {
          currentGroup.push(printedNodes[i]);
          continue;
        }

        groups.push(currentGroup);
        currentGroup = [];
        hasSeenCallExpression = false;
      }

      if (printedNodes[i].node.type === "CallExpression" || printedNodes[i].node.type === "OptionalCallExpression") {
        hasSeenCallExpression = true;
      }

      currentGroup.push(printedNodes[i]);

      if (printedNodes[i].node.comments && printedNodes[i].node.comments.some(function (comment) {
        return comment.trailing;
      })) {
        groups.push(currentGroup);
        currentGroup = [];
        hasSeenCallExpression = false;
      }
    }

    if (currentGroup.length > 0) {
      groups.push(currentGroup);
    } // There are cases like Object.keys(), Observable.of(), _.values() where
    // they are the subject of all the chained calls and therefore should
    // be kept on the same line:
    //
    //   Object.keys(items)
    //     .filter(x => x)
    //     .map(x => x)
    //
    // In order to detect those cases, we use an heuristic: if the first
    // node is an identifier with the name starting with a capital
    // letter or just a sequence of _$. The rationale is that they are
    // likely to be factories.


    function isFactory(name) {
      return /^[A-Z]|^[_$]+$/.test(name);
    } // In case the Identifier is shorter than tab width, we can keep the
    // first call in a single line, if it's an ExpressionStatement.
    //
    //   d3.scaleLinear()
    //     .domain([0, 100])
    //     .range([0, width]);
    //


    function isShort(name) {
      return name.length <= options.tabWidth;
    }

    function shouldNotWrap(groups) {
      var parent = path.getParentNode();
      var isExpression = parent && parent.type === "ExpressionStatement";
      var hasComputed = groups[1].length && groups[1][0].node.computed;

      if (groups[0].length === 1) {
        var firstNode = groups[0][0].node;
        return firstNode.type === "ThisExpression" || firstNode.type === "Identifier" && (isFactory(firstNode.name) || isExpression && isShort(firstNode.name) || hasComputed);
      }

      var lastNode = getLast$2(groups[0]).node;
      return (lastNode.type === "MemberExpression" || lastNode.type === "OptionalMemberExpression") && lastNode.property.type === "Identifier" && (isFactory(lastNode.property.name) || hasComputed);
    }

    var shouldMerge = groups.length >= 2 && !groups[1][0].node.comments && shouldNotWrap(groups);

    function printGroup(printedGroup) {
      var printed = printedGroup.map(function (tuple) {
        return tuple.printed;
      }); // Checks if the last node (i.e. the parent node) needs parens and print
      // accordingly

      if (printedGroup.length > 0 && printedGroup[printedGroup.length - 1].needsParens) {
        return concat$d(["("].concat(_toConsumableArray(printed), [")"]));
      }

      return concat$d(printed);
    }

    function printIndentedGroup(groups) {
      if (groups.length === 0) {
        return "";
      }

      return indent$7(group$b(concat$d([hardline$9, join$9(hardline$9, groups.map(printGroup))])));
    }

    var printedGroups = groups.map(printGroup);
    var oneLine = concat$d(printedGroups);
    var cutoff = shouldMerge ? 3 : 2;
    var flatGroups = groups.slice(0, cutoff).reduce(function (res, group) {
      return res.concat(group);
    }, []);
    var hasComment = flatGroups.slice(1, -1).some(function (node) {
      return hasLeadingComment$3(node.node);
    }) || flatGroups.slice(0, -1).some(function (node) {
      return hasTrailingComment$1(node.node);
    }) || groups[cutoff] && hasLeadingComment$3(groups[cutoff][0].node); // If we only have a single `.`, we shouldn't do anything fancy and just
    // render everything concatenated together.

    if (groups.length <= cutoff && !hasComment) {
      if (isLongCurriedCallExpression$1(path)) {
        return oneLine;
      }

      return group$b(oneLine);
    } // Find out the last node in the first group and check if it has an
    // empty line after


    var lastNodeBeforeIndent = getLast$2(shouldMerge ? groups.slice(1, 2)[0] : groups[0]).node;
    var shouldHaveEmptyLineBeforeIndent = lastNodeBeforeIndent.type !== "CallExpression" && lastNodeBeforeIndent.type !== "OptionalCallExpression" && shouldInsertEmptyLineAfter(lastNodeBeforeIndent);
    var expanded = concat$d([printGroup(groups[0]), shouldMerge ? concat$d(groups.slice(1, 2).map(printGroup)) : "", shouldHaveEmptyLineBeforeIndent ? hardline$9 : "", printIndentedGroup(groups.slice(shouldMerge ? 2 : 1))]);
    var callExpressions = printedNodes.map(function (_ref) {
      var node = _ref.node;
      return node;
    }).filter(isCallOrOptionalCallExpression$1); // We don't want to print in one line if there's:
    //  * A comment.
    //  * 3 or more chained calls.
    //  * Any group but the last one has a hard line.
    // If the last group is a function it's okay to inline if it fits.

    if (hasComment || callExpressions.length >= 3 || printedGroups.slice(0, -1).some(willBreak$1) ||
    /**
     *     scopes.filter(scope => scope.value !== '').map((scope, i) => {
     *       // multi line content
     *     })
     */
    function (lastGroupDoc, lastGroupNode) {
      return isCallOrOptionalCallExpression$1(lastGroupNode) && willBreak$1(lastGroupDoc);
    }(getLast$2(printedGroups), getLast$2(getLast$2(groups)).node) && callExpressions.slice(0, -1).some(function (n) {
      return n.arguments.some(isFunctionOrArrowExpression$1);
    })) {
      return group$b(expanded);
    }

    return concat$d([// We only need to check `oneLine` because if `expanded` is chosen
    // that means that the parent group has already been broken
    // naturally
    willBreak$1(oneLine) || shouldHaveEmptyLineBeforeIndent ? breakParent$3 : "", conditionalGroup$1([oneLine, expanded])]);
  }

  function separatorNoWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {
    if (isFacebookTranslationTag) {
      return "";
    }

    if (childNode.type === "JSXElement" && !childNode.closingElement || nextNode && nextNode.type === "JSXElement" && !nextNode.closingElement) {
      return child.length === 1 ? softline$6 : hardline$9;
    }

    return softline$6;
  }

  function separatorWithWhitespace(isFacebookTranslationTag, child, childNode, nextNode) {
    if (isFacebookTranslationTag) {
      return hardline$9;
    }

    if (child.length === 1) {
      return childNode.type === "JSXElement" && !childNode.closingElement || nextNode && nextNode.type === "JSXElement" && !nextNode.closingElement ? hardline$9 : softline$6;
    }

    return hardline$9;
  } // JSX Children are strange, mostly for two reasons:
  // 1. JSX reads newlines into string values, instead of skipping them like JS
  // 2. up to one whitespace between elements within a line is significant,
  //    but not between lines.
  //
  // Leading, trailing, and lone whitespace all need to
  // turn themselves into the rather ugly `{' '}` when breaking.
  //
  // We print JSX using the `fill` doc primitive.
  // This requires that we give it an array of alternating
  // content and whitespace elements.
  // To ensure this we add dummy `""` content elements as needed.


  function printJSXChildren(path, options, print, jsxWhitespace, isFacebookTranslationTag) {
    var n = path.getValue();
    var children = []; // using `map` instead of `each` because it provides `i`

    path.map(function (childPath, i) {
      var child = childPath.getValue();

      if (isLiteral$1(child)) {
        var text = rawText$1(child); // Contains a non-whitespace character

        if (isMeaningfulJSXText$1(child)) {
          var words = text.split(matchJsxWhitespaceRegex$1); // Starts with whitespace

          if (words[0] === "") {
            children.push("");
            words.shift();

            if (/\n/.test(words[0])) {
              var next = n.children[i + 1];
              children.push(separatorWithWhitespace(isFacebookTranslationTag, words[1], child, next));
            } else {
              children.push(jsxWhitespace);
            }

            words.shift();
          }

          var endWhitespace; // Ends with whitespace

          if (getLast$2(words) === "") {
            words.pop();
            endWhitespace = words.pop();
          } // This was whitespace only without a new line.


          if (words.length === 0) {
            return;
          }

          words.forEach(function (word, i) {
            if (i % 2 === 1) {
              children.push(line$7);
            } else {
              children.push(word);
            }
          });

          if (endWhitespace !== undefined) {
            if (/\n/.test(endWhitespace)) {
              var _next = n.children[i + 1];
              children.push(separatorWithWhitespace(isFacebookTranslationTag, getLast$2(children), child, _next));
            } else {
              children.push(jsxWhitespace);
            }
          } else {
            var _next2 = n.children[i + 1];
            children.push(separatorNoWhitespace(isFacebookTranslationTag, getLast$2(children), child, _next2));
          }
        } else if (/\n/.test(text)) {
          // Keep (up to one) blank line between tags/expressions/text.
          // Note: We don't keep blank lines between text elements.
          if (text.match(/\n/g).length > 1) {
            children.push("");
            children.push(hardline$9);
          }
        } else {
          children.push("");
          children.push(jsxWhitespace);
        }
      } else {
        var printedChild = print(childPath);
        children.push(printedChild);
        var _next3 = n.children[i + 1];

        var directlyFollowedByMeaningfulText = _next3 && isMeaningfulJSXText$1(_next3);

        if (directlyFollowedByMeaningfulText) {
          var firstWord = rawText$1(_next3).trim().split(matchJsxWhitespaceRegex$1)[0];
          children.push(separatorNoWhitespace(isFacebookTranslationTag, firstWord, child, _next3));
        } else {
          children.push(hardline$9);
        }
      }
    }, "children");
    return children;
  } // JSX expands children from the inside-out, instead of the outside-in.
  // This is both to break children before attributes,
  // and to ensure that when children break, their parents do as well.
  //
  // Any element that is written without any newlines and fits on a single line
  // is left that way.
  // Not only that, any user-written-line containing multiple JSX siblings
  // should also be kept on one line if possible,
  // so each user-written-line is wrapped in its own group.
  //
  // Elements that contain newlines or don't fit on a single line (recursively)
  // are fully-split, using hardline and shouldBreak: true.
  //
  // To support that case properly, all leading and trailing spaces
  // are stripped from the list of children, and replaced with a single hardline.


  function printJSXElement(path, options, print) {
    var n = path.getValue();

    if (n.type === "JSXElement" && isEmptyJSXElement$1(n)) {
      return concat$d([path.call(print, "openingElement"), path.call(print, "closingElement")]);
    }

    var openingLines = n.type === "JSXElement" ? path.call(print, "openingElement") : path.call(print, "openingFragment");
    var closingLines = n.type === "JSXElement" ? path.call(print, "closingElement") : path.call(print, "closingFragment");

    if (n.children.length === 1 && n.children[0].type === "JSXExpressionContainer" && (n.children[0].expression.type === "TemplateLiteral" || n.children[0].expression.type === "TaggedTemplateExpression")) {
      return concat$d([openingLines, concat$d(path.map(print, "children")), closingLines]);
    } // Convert `{" "}` to text nodes containing a space.
    // This makes it easy to turn them into `jsxWhitespace` which
    // can then print as either a space or `{" "}` when breaking.


    n.children = n.children.map(function (child) {
      if (isJSXWhitespaceExpression$1(child)) {
        return {
          type: "JSXText",
          value: " ",
          raw: " "
        };
      }

      return child;
    });
    var containsTag = n.children.filter(isJSXNode$1).length > 0;
    var containsMultipleExpressions = n.children.filter(function (child) {
      return child.type === "JSXExpressionContainer";
    }).length > 1;
    var containsMultipleAttributes = n.type === "JSXElement" && n.openingElement.attributes.length > 1; // Record any breaks. Should never go from true to false, only false to true.

    var forcedBreak = willBreak$1(openingLines) || containsTag || containsMultipleAttributes || containsMultipleExpressions;
    var rawJsxWhitespace = options.singleQuote ? "{' '}" : '{" "}';
    var jsxWhitespace = ifBreak$6(concat$d([rawJsxWhitespace, softline$6]), " ");
    var isFacebookTranslationTag = n.openingElement && n.openingElement.name && n.openingElement.name.name === "fbt";
    var children = printJSXChildren(path, options, print, jsxWhitespace, isFacebookTranslationTag);
    var containsText = n.children.filter(function (child) {
      return isMeaningfulJSXText$1(child);
    }).length > 0; // We can end up we multiple whitespace elements with empty string
    // content between them.
    // We need to remove empty whitespace and softlines before JSX whitespace
    // to get the correct output.

    for (var i = children.length - 2; i >= 0; i--) {
      var isPairOfEmptyStrings = children[i] === "" && children[i + 1] === "";
      var isPairOfHardlines = children[i] === hardline$9 && children[i + 1] === "" && children[i + 2] === hardline$9;
      var isLineFollowedByJSXWhitespace = (children[i] === softline$6 || children[i] === hardline$9) && children[i + 1] === "" && children[i + 2] === jsxWhitespace;
      var isJSXWhitespaceFollowedByLine = children[i] === jsxWhitespace && children[i + 1] === "" && (children[i + 2] === softline$6 || children[i + 2] === hardline$9);
      var isDoubleJSXWhitespace = children[i] === jsxWhitespace && children[i + 1] === "" && children[i + 2] === jsxWhitespace;
      var isPairOfHardOrSoftLines = children[i] === softline$6 && children[i + 1] === "" && children[i + 2] === hardline$9 || children[i] === hardline$9 && children[i + 1] === "" && children[i + 2] === softline$6;

      if (isPairOfHardlines && containsText || isPairOfEmptyStrings || isLineFollowedByJSXWhitespace || isDoubleJSXWhitespace || isPairOfHardOrSoftLines) {
        children.splice(i, 2);
      } else if (isJSXWhitespaceFollowedByLine) {
        children.splice(i + 1, 2);
      }
    } // Trim trailing lines (or empty strings)


    while (children.length && (isLineNext$1(getLast$2(children)) || isEmpty$1(getLast$2(children)))) {
      children.pop();
    } // Trim leading lines (or empty strings)


    while (children.length && (isLineNext$1(children[0]) || isEmpty$1(children[0])) && (isLineNext$1(children[1]) || isEmpty$1(children[1]))) {
      children.shift();
      children.shift();
    } // Tweak how we format children if outputting this element over multiple lines.
    // Also detect whether we will force this element to output over multiple lines.


    var multilineChildren = [];
    children.forEach(function (child, i) {
      // There are a number of situations where we need to ensure we display
      // whitespace as `{" "}` when outputting this element over multiple lines.
      if (child === jsxWhitespace) {
        if (i === 1 && children[i - 1] === "") {
          if (children.length === 2) {
            // Solitary whitespace
            multilineChildren.push(rawJsxWhitespace);
            return;
          } // Leading whitespace


          multilineChildren.push(concat$d([rawJsxWhitespace, hardline$9]));
          return;
        } else if (i === children.length - 1) {
          // Trailing whitespace
          multilineChildren.push(rawJsxWhitespace);
          return;
        } else if (children[i - 1] === "" && children[i - 2] === hardline$9) {
          // Whitespace after line break
          multilineChildren.push(rawJsxWhitespace);
          return;
        }
      }

      multilineChildren.push(child);

      if (willBreak$1(child)) {
        forcedBreak = true;
      }
    }); // If there is text we use `fill` to fit as much onto each line as possible.
    // When there is no text (just tags and expressions) we use `group`
    // to output each on a separate line.

    var content = containsText ? fill$4(multilineChildren) : group$b(concat$d(multilineChildren), {
      shouldBreak: true
    });
    var multiLineElem = group$b(concat$d([openingLines, indent$7(concat$d([hardline$9, content])), hardline$9, closingLines]));

    if (forcedBreak) {
      return multiLineElem;
    }

    return conditionalGroup$1([group$b(concat$d([openingLines, concat$d(children), closingLines])), multiLineElem]);
  }

  function maybeWrapJSXElementInParens(path, elem, options) {
    var parent = path.getParentNode();

    if (!parent) {
      return elem;
    }

    var NO_WRAP_PARENTS = {
      ArrayExpression: true,
      JSXAttribute: true,
      JSXElement: true,
      JSXExpressionContainer: true,
      JSXFragment: true,
      ExpressionStatement: true,
      CallExpression: true,
      OptionalCallExpression: true,
      ConditionalExpression: true,
      JsExpressionRoot: true
    };

    if (NO_WRAP_PARENTS[parent.type]) {
      return elem;
    }

    var shouldBreak = matchAncestorTypes$1(path, ["ArrowFunctionExpression", "CallExpression", "JSXExpressionContainer"]) || matchAncestorTypes$1(path, ["ArrowFunctionExpression", "OptionalCallExpression", "JSXExpressionContainer"]);
    var needsParens = needsParens_1(path, options);
    return group$b(concat$d([needsParens ? "" : ifBreak$6("("), indent$7(concat$d([softline$6, elem])), softline$6, needsParens ? "" : ifBreak$6(")")]), {
      shouldBreak: shouldBreak
    });
  }

  function shouldInlineLogicalExpression(node) {
    if (node.type !== "LogicalExpression") {
      return false;
    }

    if (node.right.type === "ObjectExpression" && node.right.properties.length !== 0) {
      return true;
    }

    if (node.right.type === "ArrayExpression" && node.right.elements.length !== 0) {
      return true;
    }

    if (isJSXNode$1(node.right)) {
      return true;
    }

    return false;
  } // For binary expressions to be consistent, we need to group
  // subsequent operators with the same precedence level under a single
  // group. Otherwise they will be nested such that some of them break
  // onto new lines but not all. Operators with the same precedence
  // level should either all break or not. Because we group them by
  // precedence level and the AST is structured based on precedence
  // level, things are naturally broken up correctly, i.e. `&&` is
  // broken before `+`.


  function printBinaryishExpressions(path, print, options, isNested, isInsideParenthesis) {
    var parts = [];
    var node = path.getValue(); // We treat BinaryExpression and LogicalExpression nodes the same.

    if (isBinaryish$1(node)) {
      // Put all operators with the same precedence level in the same
      // group. The reason we only need to do this with the `left`
      // expression is because given an expression like `1 + 2 - 3`, it
      // is always parsed like `((1 + 2) - 3)`, meaning the `left` side
      // is where the rest of the expression will exist. Binary
      // expressions on the right side mean they have a difference
      // precedence level and should be treated as a separate group, so
      // print them normally. (This doesn't hold for the `**` operator,
      // which is unique in that it is right-associative.)
      if (shouldFlatten$1(node.operator, node.left.operator)) {
        // Flatten them out by recursively calling this function.
        parts = parts.concat(path.call(function (left) {
          return printBinaryishExpressions(left, print, options,
          /* isNested */
          true, isInsideParenthesis);
        }, "left"));
      } else {
        parts.push(path.call(print, "left"));
      }

      var shouldInline = shouldInlineLogicalExpression(node);
      var lineBeforeOperator = (node.operator === "|>" || node.type === "NGPipeExpression" || node.operator === "|" && options.parser === "__vue_expression") && !hasLeadingOwnLineComment$1(options.originalText, node.right, options);
      var operator = node.type === "NGPipeExpression" ? "|" : node.operator;
      var rightSuffix = node.type === "NGPipeExpression" && node.arguments.length !== 0 ? group$b(indent$7(concat$d([softline$6, ": ", join$9(concat$d([softline$6, ":", ifBreak$6(" ")]), path.map(print, "arguments").map(function (arg) {
        return align$1(2, group$b(arg));
      }))]))) : "";
      var right = shouldInline ? concat$d([operator, " ", path.call(print, "right"), rightSuffix]) : concat$d([lineBeforeOperator ? softline$6 : "", operator, lineBeforeOperator ? " " : line$7, path.call(print, "right"), rightSuffix]); // If there's only a single binary expression, we want to create a group
      // in order to avoid having a small right part like -1 be on its own line.

      var parent = path.getParentNode();
      var shouldGroup = !(isInsideParenthesis && node.type === "LogicalExpression") && parent.type !== node.type && node.left.type !== node.type && node.right.type !== node.type;
      parts.push(" ", shouldGroup ? group$b(right) : right); // The root comments are already printed, but we need to manually print
      // the other ones since we don't call the normal print on BinaryExpression,
      // only for the left and right parts

      if (isNested && node.comments) {
        parts = comments.printComments(path, function () {
          return concat$d(parts);
        }, options);
      }
    } else {
      // Our stopping case. Simply print the node normally.
      parts.push(path.call(print));
    }

    return parts;
  }

  function printAssignmentRight(leftNode, rightNode, printedRight, options) {
    if (hasLeadingOwnLineComment$1(options.originalText, rightNode, options)) {
      return indent$7(concat$d([hardline$9, printedRight]));
    }

    var canBreak = isBinaryish$1(rightNode) && !shouldInlineLogicalExpression(rightNode) || rightNode.type === "ConditionalExpression" && isBinaryish$1(rightNode.test) && !shouldInlineLogicalExpression(rightNode.test) || rightNode.type === "StringLiteralTypeAnnotation" || rightNode.type === "ClassExpression" && rightNode.decorators && rightNode.decorators.length || (leftNode.type === "Identifier" || isStringLiteral$1(leftNode) || leftNode.type === "MemberExpression") && (isStringLiteral$1(rightNode) || isMemberExpressionChain$1(rightNode)) && // do not put values on a separate line from the key in json
    options.parser !== "json" && options.parser !== "json5" || rightNode.type === "SequenceExpression";

    if (canBreak) {
      return group$b(indent$7(concat$d([line$7, printedRight])));
    }

    return concat$d([" ", printedRight]);
  }

  function printAssignment(leftNode, printedLeft, operator, rightNode, printedRight, options) {
    if (!rightNode) {
      return printedLeft;
    }

    var printed = printAssignmentRight(leftNode, rightNode, printedRight, options);
    return group$b(concat$d([printedLeft, operator, printed]));
  }

  function adjustClause(node, clause, forceSpace) {
    if (node.type === "EmptyStatement") {
      return ";";
    }

    if (node.type === "BlockStatement" || forceSpace) {
      return concat$d([" ", clause]);
    }

    return indent$7(concat$d([line$7, clause]));
  }

  function nodeStr(node, options, isFlowOrTypeScriptDirectiveLiteral) {
    var raw = rawText$1(node);
    var isDirectiveLiteral = isFlowOrTypeScriptDirectiveLiteral || node.type === "DirectiveLiteral";
    return printString$2(raw, options, isDirectiveLiteral);
  }

  function printRegex(node) {
    var flags = node.flags.split("").sort().join("");
    return "/".concat(node.pattern, "/").concat(flags);
  }

  function exprNeedsASIProtection(path, options) {
    var node = path.getValue();
    var maybeASIProblem = needsParens_1(path, options) || node.type === "ParenthesizedExpression" || node.type === "TypeCastExpression" || node.type === "ArrowFunctionExpression" && !shouldPrintParamsWithoutParens(path, options) || node.type === "ArrayExpression" || node.type === "ArrayPattern" || node.type === "UnaryExpression" && node.prefix && (node.operator === "+" || node.operator === "-") || node.type === "TemplateLiteral" || node.type === "TemplateElement" || isJSXNode$1(node) || node.type === "BindExpression" && !node.object || node.type === "RegExpLiteral" || node.type === "Literal" && node.pattern || node.type === "Literal" && node.regex;

    if (maybeASIProblem) {
      return true;
    }

    if (!hasNakedLeftSide$2(node)) {
      return false;
    }

    return path.call.apply(path, [function (childPath) {
      return exprNeedsASIProtection(childPath, options);
    }].concat(getLeftSidePathName$2(path, node)));
  }

  function stmtNeedsASIProtection(path, options) {
    var node = path.getNode();

    if (node.type !== "ExpressionStatement") {
      return false;
    }

    return path.call(function (childPath) {
      return exprNeedsASIProtection(childPath, options);
    }, "expression");
  }

  function shouldHugType(node) {
    if (isSimpleFlowType$1(node) || isObjectType$1(node)) {
      return true;
    }

    if (node.type === "UnionTypeAnnotation" || node.type === "TSUnionType") {
      var voidCount = node.types.filter(function (n) {
        return n.type === "VoidTypeAnnotation" || n.type === "TSVoidKeyword" || n.type === "NullLiteralTypeAnnotation" || n.type === "TSNullKeyword";
      }).length;
      var objectCount = node.types.filter(function (n) {
        return n.type === "ObjectTypeAnnotation" || n.type === "TSTypeLiteral" || // This is a bit aggressive but captures Array<{x}>
        n.type === "GenericTypeAnnotation" || n.type === "TSTypeReference";
      }).length;

      if (node.types.length - 1 === voidCount && objectCount > 0) {
        return true;
      }
    }

    return false;
  }

  function shouldHugArguments(fun) {
    return fun && fun.params && fun.params.length === 1 && !fun.params[0].comments && (fun.params[0].type === "ObjectPattern" || fun.params[0].type === "ArrayPattern" || fun.params[0].type === "Identifier" && fun.params[0].typeAnnotation && (fun.params[0].typeAnnotation.type === "TypeAnnotation" || fun.params[0].typeAnnotation.type === "TSTypeAnnotation") && isObjectType$1(fun.params[0].typeAnnotation.typeAnnotation) || fun.params[0].type === "FunctionTypeParam" && isObjectType$1(fun.params[0].typeAnnotation) || fun.params[0].type === "AssignmentPattern" && (fun.params[0].left.type === "ObjectPattern" || fun.params[0].left.type === "ArrayPattern") && (fun.params[0].right.type === "Identifier" || fun.params[0].right.type === "ObjectExpression" && fun.params[0].right.properties.length === 0 || fun.params[0].right.type === "ArrayExpression" && fun.params[0].right.elements.length === 0)) && !fun.rest;
  }

  function printArrayItems(path, options, printPath, print) {
    var printedElements = [];
    var separatorParts = [];
    path.each(function (childPath) {
      printedElements.push(concat$d(separatorParts));
      printedElements.push(group$b(print(childPath)));
      separatorParts = [",", line$7];

      if (childPath.getValue() && isNextLineEmpty$4(options.originalText, childPath.getValue(), options)) {
        separatorParts.push(softline$6);
      }
    }, printPath);
    return concat$d(printedElements);
  }

  function willPrintOwnComments(path
  /*, options */
  ) {
    var node = path.getValue();
    var parent = path.getParentNode();
    return (node && (isJSXNode$1(node) || hasFlowShorthandAnnotationComment$2(node) || parent && (parent.type === "CallExpression" || parent.type === "OptionalCallExpression") && (hasFlowAnnotationComment$1(node.leadingComments) || hasFlowAnnotationComment$1(node.trailingComments))) || parent && (parent.type === "JSXSpreadAttribute" || parent.type === "JSXSpreadChild" || parent.type === "UnionTypeAnnotation" || parent.type === "TSUnionType" || (parent.type === "ClassDeclaration" || parent.type === "ClassExpression") && parent.superClass === node)) && !hasIgnoreComment$4(path);
  }

  function canAttachComment$1(node) {
    return node.type && node.type !== "CommentBlock" && node.type !== "CommentLine" && node.type !== "Line" && node.type !== "Block" && node.type !== "EmptyStatement" && node.type !== "TemplateElement" && node.type !== "Import";
  }

  function printComment$2(commentPath, options) {
    var comment = commentPath.getValue();

    switch (comment.type) {
      case "CommentBlock":
      case "Block":
        {
          if (isIndentableBlockComment(comment)) {
            var printed = printIndentableBlockComment(comment); // We need to prevent an edge case of a previous trailing comment
            // printed as a `lineSuffix` which causes the comments to be
            // interleaved. See https://github.com/prettier/prettier/issues/4412

            if (comment.trailing && !hasNewline$4(options.originalText, options.locStart(comment), {
              backwards: true
            })) {
              return concat$d([hardline$9, printed]);
            }

            return printed;
          }

          var isInsideFlowComment = options.originalText.substr(options.locEnd(comment) - 3, 3) === "*-/";
          return "/*" + comment.value + (isInsideFlowComment ? "*-/" : "*/");
        }

      case "CommentLine":
      case "Line":
        // Print shebangs with the proper comment characters
        if (options.originalText.slice(options.locStart(comment)).startsWith("#!")) {
          return "#!" + comment.value.trimRight();
        }

        return "//" + comment.value.trimRight();

      default:
        throw new Error("Not a comment: " + JSON.stringify(comment));
    }
  }

  function isIndentableBlockComment(comment) {
    // If the comment has multiple lines and every line starts with a star
    // we can fix the indentation of each line. The stars in the `/*` and
    // `*/` delimiters are not included in the comment value, so add them
    // back first.
    var lines = "*".concat(comment.value, "*").split("\n");
    return lines.length > 1 && lines.every(function (line) {
      return line.trim()[0] === "*";
    });
  }

  function printIndentableBlockComment(comment) {
    var lines = comment.value.split("\n");
    return concat$d(["/*", join$9(hardline$9, lines.map(function (line, index) {
      return index === 0 ? line.trimRight() : " " + (index < lines.length - 1 ? line.trim() : line.trimLeft());
    })), "*/"]);
  }

  var printerEstree = {
    preprocess: preprocess_1$1,
    print: genericPrint$3,
    embed: embed_1$1,
    insertPragma: insertPragma$7,
    massageAstNode: clean_1$1,
    hasPrettierIgnore: hasPrettierIgnore$3,
    willPrintOwnComments: willPrintOwnComments,
    canAttachComment: canAttachComment$1,
    printComment: printComment$2,
    isBlockComment: comments$1.isBlockComment,
    handleComments: {
      ownLine: comments$1.handleOwnLineComment,
      endOfLine: comments$1.handleEndOfLineComment,
      remaining: comments$1.handleRemainingComment
    }
  };

  var _require$$0$builders$7 = doc.builders,
      concat$e = _require$$0$builders$7.concat,
      hardline$a = _require$$0$builders$7.hardline,
      indent$8 = _require$$0$builders$7.indent,
      join$a = _require$$0$builders$7.join;

  function genericPrint$4(path, options, print) {
    var node = path.getValue();

    switch (node.type) {
      case "JsonRoot":
        return concat$e([path.call(print, "node"), hardline$a]);

      case "ArrayExpression":
        return node.elements.length === 0 ? "[]" : concat$e(["[", indent$8(concat$e([hardline$a, join$a(concat$e([",", hardline$a]), path.map(print, "elements"))])), hardline$a, "]"]);

      case "ObjectExpression":
        return node.properties.length === 0 ? "{}" : concat$e(["{", indent$8(concat$e([hardline$a, join$a(concat$e([",", hardline$a]), path.map(print, "properties"))])), hardline$a, "}"]);

      case "ObjectProperty":
        return concat$e([path.call(print, "key"), ": ", path.call(print, "value")]);

      case "UnaryExpression":
        return concat$e([node.operator === "+" ? "" : node.operator, path.call(print, "argument")]);

      case "NullLiteral":
        return "null";

      case "BooleanLiteral":
        return node.value ? "true" : "false";

      case "StringLiteral":
      case "NumericLiteral":
        return JSON.stringify(node.value);

      case "Identifier":
        return JSON.stringify(node.name);

      default:
        /* istanbul ignore next */
        throw new Error("unknown type: " + JSON.stringify(node.type));
    }
  }

  function clean$5(node, newNode
  /*, parent*/
  ) {
    delete newNode.start;
    delete newNode.end;
    delete newNode.extra;
    delete newNode.loc;
    delete newNode.comments;
    delete newNode.errors;

    if (node.type === "Identifier") {
      return {
        type: "StringLiteral",
        value: node.name
      };
    }

    if (node.type === "UnaryExpression" && node.operator === "+") {
      return newNode.argument;
    }
  }

  var printerEstreeJson = {
    preprocess: preprocess_1$1,
    print: genericPrint$4,
    massageAstNode: clean$5
  };

  var CATEGORY_JAVASCRIPT = "JavaScript"; // format based on https://github.com/prettier/prettier/blob/master/src/main/core-options.js

  var options$5 = {
    arrowParens: {
      since: "1.9.0",
      category: CATEGORY_JAVASCRIPT,
      type: "choice",
      default: "avoid",
      description: "Include parentheses around a sole arrow function parameter.",
      choices: [{
        value: "avoid",
        description: "Omit parens when possible. Example: `x => x`"
      }, {
        value: "always",
        description: "Always include parens. Example: `(x) => x`"
      }]
    },
    bracketSpacing: commonOptions.bracketSpacing,
    jsxBracketSameLine: {
      since: "0.17.0",
      category: CATEGORY_JAVASCRIPT,
      type: "boolean",
      default: false,
      description: "Put > on the last line instead of at a new line."
    },
    semi: {
      since: "1.0.0",
      category: CATEGORY_JAVASCRIPT,
      type: "boolean",
      default: true,
      description: "Print semicolons.",
      oppositeDescription: "Do not print semicolons, except at the beginning of lines which may need them."
    },
    singleQuote: commonOptions.singleQuote,
    jsxSingleQuote: {
      since: "1.15.0",
      category: CATEGORY_JAVASCRIPT,
      type: "boolean",
      default: false,
      description: "Use single quotes in JSX."
    },
    quoteProps: {
      since: "1.17.0",
      category: CATEGORY_JAVASCRIPT,
      type: "choice",
      default: "as-needed",
      description: "Change when properties in objects are quoted.",
      choices: [{
        value: "as-needed",
        description: "Only add quotes around object properties where required."
      }, {
        value: "consistent",
        description: "If at least one property in an object requires quotes, quote all properties."
      }, {
        value: "preserve",
        description: "Respect the input use of quotes in object properties."
      }]
    },
    trailingComma: {
      since: "0.0.0",
      category: CATEGORY_JAVASCRIPT,
      type: "choice",
      default: [{
        since: "0.0.0",
        value: false
      }, {
        since: "0.19.0",
        value: "none"
      }],
      description: "Print trailing commas wherever possible when multi-line.",
      choices: [{
        value: "none",
        description: "No trailing commas."
      }, {
        value: "es5",
        description: "Trailing commas where valid in ES5 (objects, arrays, etc.)"
      }, {
        value: "all",
        description: "Trailing commas wherever possible (including function arguments)."
      }, {
        value: true,
        deprecated: "0.19.0",
        redirect: "es5"
      }, {
        value: false,
        deprecated: "0.19.0",
        redirect: "none"
      }]
    }
  };

  var name$9 = "JavaScript";
  var type$8 = "programming";
  var tmScope$8 = "source.js";
  var aceMode$8 = "javascript";
  var codemirrorMode$4 = "javascript";
  var codemirrorMimeType$4 = "text/javascript";
  var color$3 = "#f1e05a";
  var aliases$2 = [
  	"js",
  	"node"
  ];
  var extensions$8 = [
  	".js",
  	"._js",
  	".bones",
  	".es",
  	".es6",
  	".frag",
  	".gs",
  	".jake",
  	".jsb",
  	".jscad",
  	".jsfl",
  	".jsm",
  	".jss",
  	".mjs",
  	".njs",
  	".pac",
  	".sjs",
  	".ssjs",
  	".xsjs",
  	".xsjslib"
  ];
  var filenames = [
  	"Jakefile"
  ];
  var interpreters = [
  	"chakra",
  	"d8",
  	"js",
  	"node",
  	"rhino",
  	"v8",
  	"v8-shell"
  ];
  var languageId$8 = 183;
  var JavaScript = {
  	name: name$9,
  	type: type$8,
  	tmScope: tmScope$8,
  	aceMode: aceMode$8,
  	codemirrorMode: codemirrorMode$4,
  	codemirrorMimeType: codemirrorMimeType$4,
  	color: color$3,
  	aliases: aliases$2,
  	extensions: extensions$8,
  	filenames: filenames,
  	interpreters: interpreters,
  	languageId: languageId$8
  };

  var JavaScript$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$9,
    type: type$8,
    tmScope: tmScope$8,
    aceMode: aceMode$8,
    codemirrorMode: codemirrorMode$4,
    codemirrorMimeType: codemirrorMimeType$4,
    color: color$3,
    aliases: aliases$2,
    extensions: extensions$8,
    filenames: filenames,
    interpreters: interpreters,
    languageId: languageId$8,
    'default': JavaScript
  });

  var name$a = "JSX";
  var type$9 = "programming";
  var group$c = "JavaScript";
  var extensions$9 = [
  	".jsx"
  ];
  var tmScope$9 = "source.js.jsx";
  var aceMode$9 = "javascript";
  var codemirrorMode$5 = "jsx";
  var codemirrorMimeType$5 = "text/jsx";
  var languageId$9 = 178;
  var JSX = {
  	name: name$a,
  	type: type$9,
  	group: group$c,
  	extensions: extensions$9,
  	tmScope: tmScope$9,
  	aceMode: aceMode$9,
  	codemirrorMode: codemirrorMode$5,
  	codemirrorMimeType: codemirrorMimeType$5,
  	languageId: languageId$9
  };

  var JSX$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$a,
    type: type$9,
    group: group$c,
    extensions: extensions$9,
    tmScope: tmScope$9,
    aceMode: aceMode$9,
    codemirrorMode: codemirrorMode$5,
    codemirrorMimeType: codemirrorMimeType$5,
    languageId: languageId$9,
    'default': JSX
  });

  var name$b = "TypeScript";
  var type$a = "programming";
  var color$4 = "#2b7489";
  var aliases$3 = [
  	"ts"
  ];
  var interpreters$1 = [
  	"deno",
  	"ts-node"
  ];
  var extensions$a = [
  	".ts"
  ];
  var tmScope$a = "source.ts";
  var aceMode$a = "typescript";
  var codemirrorMode$6 = "javascript";
  var codemirrorMimeType$6 = "application/typescript";
  var languageId$a = 378;
  var TypeScript = {
  	name: name$b,
  	type: type$a,
  	color: color$4,
  	aliases: aliases$3,
  	interpreters: interpreters$1,
  	extensions: extensions$a,
  	tmScope: tmScope$a,
  	aceMode: aceMode$a,
  	codemirrorMode: codemirrorMode$6,
  	codemirrorMimeType: codemirrorMimeType$6,
  	languageId: languageId$a
  };

  var TypeScript$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$b,
    type: type$a,
    color: color$4,
    aliases: aliases$3,
    interpreters: interpreters$1,
    extensions: extensions$a,
    tmScope: tmScope$a,
    aceMode: aceMode$a,
    codemirrorMode: codemirrorMode$6,
    codemirrorMimeType: codemirrorMimeType$6,
    languageId: languageId$a,
    'default': TypeScript
  });

  var name$c = "TSX";
  var type$b = "programming";
  var group$d = "TypeScript";
  var extensions$b = [
  	".tsx"
  ];
  var tmScope$b = "source.tsx";
  var aceMode$b = "javascript";
  var codemirrorMode$7 = "jsx";
  var codemirrorMimeType$7 = "text/jsx";
  var languageId$b = 94901924;
  var TSX = {
  	name: name$c,
  	type: type$b,
  	group: group$d,
  	extensions: extensions$b,
  	tmScope: tmScope$b,
  	aceMode: aceMode$b,
  	codemirrorMode: codemirrorMode$7,
  	codemirrorMimeType: codemirrorMimeType$7,
  	languageId: languageId$b
  };

  var TSX$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$c,
    type: type$b,
    group: group$d,
    extensions: extensions$b,
    tmScope: tmScope$b,
    aceMode: aceMode$b,
    codemirrorMode: codemirrorMode$7,
    codemirrorMimeType: codemirrorMimeType$7,
    languageId: languageId$b,
    'default': TSX
  });

  var name$d = "JSON";
  var type$c = "data";
  var tmScope$c = "source.json";
  var aceMode$c = "json";
  var codemirrorMode$8 = "javascript";
  var codemirrorMimeType$8 = "application/json";
  var searchable = false;
  var extensions$c = [
  	".json",
  	".avsc",
  	".geojson",
  	".gltf",
  	".har",
  	".ice",
  	".JSON-tmLanguage",
  	".jsonl",
  	".mcmeta",
  	".tfstate",
  	".tfstate.backup",
  	".topojson",
  	".webapp",
  	".webmanifest",
  	".yy",
  	".yyp"
  ];
  var filenames$1 = [
  	".arcconfig",
  	".htmlhintrc",
  	".tern-config",
  	".tern-project",
  	".watchmanconfig",
  	"composer.lock",
  	"mcmod.info"
  ];
  var languageId$c = 174;
  var _JSON = {
  	name: name$d,
  	type: type$c,
  	tmScope: tmScope$c,
  	aceMode: aceMode$c,
  	codemirrorMode: codemirrorMode$8,
  	codemirrorMimeType: codemirrorMimeType$8,
  	searchable: searchable,
  	extensions: extensions$c,
  	filenames: filenames$1,
  	languageId: languageId$c
  };

  var _JSON$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$d,
    type: type$c,
    tmScope: tmScope$c,
    aceMode: aceMode$c,
    codemirrorMode: codemirrorMode$8,
    codemirrorMimeType: codemirrorMimeType$8,
    searchable: searchable,
    extensions: extensions$c,
    filenames: filenames$1,
    languageId: languageId$c,
    'default': _JSON
  });

  var name$e = "JSON with Comments";
  var type$d = "data";
  var group$e = "JSON";
  var tmScope$d = "source.js";
  var aceMode$d = "javascript";
  var codemirrorMode$9 = "javascript";
  var codemirrorMimeType$9 = "text/javascript";
  var aliases$4 = [
  	"jsonc"
  ];
  var extensions$d = [
  	".sublime-build",
  	".sublime-commands",
  	".sublime-completions",
  	".sublime-keymap",
  	".sublime-macro",
  	".sublime-menu",
  	".sublime-mousemap",
  	".sublime-project",
  	".sublime-settings",
  	".sublime-theme",
  	".sublime-workspace",
  	".sublime_metrics",
  	".sublime_session"
  ];
  var filenames$2 = [
  	".babelrc",
  	".eslintrc.json",
  	".jscsrc",
  	".jshintrc",
  	".jslintrc",
  	"jsconfig.json",
  	"language-configuration.json",
  	"tsconfig.json"
  ];
  var languageId$d = 423;
  var JSON_with_Comments = {
  	name: name$e,
  	type: type$d,
  	group: group$e,
  	tmScope: tmScope$d,
  	aceMode: aceMode$d,
  	codemirrorMode: codemirrorMode$9,
  	codemirrorMimeType: codemirrorMimeType$9,
  	aliases: aliases$4,
  	extensions: extensions$d,
  	filenames: filenames$2,
  	languageId: languageId$d
  };

  var JSON_with_Comments$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$e,
    type: type$d,
    group: group$e,
    tmScope: tmScope$d,
    aceMode: aceMode$d,
    codemirrorMode: codemirrorMode$9,
    codemirrorMimeType: codemirrorMimeType$9,
    aliases: aliases$4,
    extensions: extensions$d,
    filenames: filenames$2,
    languageId: languageId$d,
    'default': JSON_with_Comments
  });

  var name$f = "JSON5";
  var type$e = "data";
  var extensions$e = [
  	".json5"
  ];
  var tmScope$e = "source.js";
  var aceMode$e = "javascript";
  var codemirrorMode$a = "javascript";
  var codemirrorMimeType$a = "application/json";
  var languageId$e = 175;
  var JSON5 = {
  	name: name$f,
  	type: type$e,
  	extensions: extensions$e,
  	tmScope: tmScope$e,
  	aceMode: aceMode$e,
  	codemirrorMode: codemirrorMode$a,
  	codemirrorMimeType: codemirrorMimeType$a,
  	languageId: languageId$e
  };

  var JSON5$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$f,
    type: type$e,
    extensions: extensions$e,
    tmScope: tmScope$e,
    aceMode: aceMode$e,
    codemirrorMode: codemirrorMode$a,
    codemirrorMimeType: codemirrorMimeType$a,
    languageId: languageId$e,
    'default': JSON5
  });

  var require$$0$6 = getCjsExportFromNamespace(JavaScript$1);

  var require$$1$2 = getCjsExportFromNamespace(JSX$1);

  var require$$2$1 = getCjsExportFromNamespace(TypeScript$1);

  var require$$3$1 = getCjsExportFromNamespace(TSX$1);

  var require$$4 = getCjsExportFromNamespace(_JSON$1);

  var require$$5 = getCjsExportFromNamespace(JSON_with_Comments$1);

  var require$$6 = getCjsExportFromNamespace(JSON5$1);

  var languages$4 = [createLanguage(require$$0$6, function (data) {
    return Object.assign(data, {
      since: "0.0.0",
      parsers: ["babel", "flow"],
      vscodeLanguageIds: ["javascript", "mongo"],
      interpreters: data.interpreters.concat(["nodejs"])
    });
  }), createLanguage(require$$0$6, function (data) {
    return Object.assign(data, {
      name: "Flow",
      since: "0.0.0",
      parsers: ["babel", "flow"],
      vscodeLanguageIds: ["javascript"],
      aliases: [],
      filenames: [],
      extensions: [".js.flow"]
    });
  }), createLanguage(require$$1$2, function (data) {
    return Object.assign(data, {
      since: "0.0.0",
      parsers: ["babel", "flow"],
      vscodeLanguageIds: ["javascriptreact"]
    });
  }), createLanguage(require$$2$1, function (data) {
    return Object.assign(data, {
      since: "1.4.0",
      parsers: ["typescript"],
      vscodeLanguageIds: ["typescript"]
    });
  }), createLanguage(require$$3$1, function (data) {
    return Object.assign(data, {
      since: "1.4.0",
      parsers: ["typescript"],
      vscodeLanguageIds: ["typescriptreact"]
    });
  }), createLanguage(require$$4, function (data) {
    return Object.assign(data, {
      name: "JSON.stringify",
      since: "1.13.0",
      parsers: ["json-stringify"],
      vscodeLanguageIds: ["json"],
      extensions: [],
      // .json file defaults to json instead of json-stringify
      filenames: ["package.json", "package-lock.json", "composer.json"]
    });
  }), createLanguage(require$$4, function (data) {
    return Object.assign(data, {
      since: "1.5.0",
      parsers: ["json"],
      vscodeLanguageIds: ["json"],
      filenames: data.filenames.concat([".prettierrc"])
    });
  }), createLanguage(require$$5, function (data) {
    return Object.assign(data, {
      since: "1.5.0",
      parsers: ["json"],
      vscodeLanguageIds: ["jsonc"],
      filenames: data.filenames.concat([".eslintrc"])
    });
  }), createLanguage(require$$6, function (data) {
    return Object.assign(data, {
      since: "1.13.0",
      parsers: ["json5"],
      vscodeLanguageIds: ["json5"]
    });
  })];
  var printers$4 = {
    estree: printerEstree,
    "estree-json": printerEstreeJson
  };
  var languageJs = {
    languages: languages$4,
    options: options$5,
    printers: printers$4
  };

  var json$1 = {
    "cjkPattern": "[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u3000-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d]",
    "kPattern": "[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]",
    "punctuationPattern": "[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]"
  };

  var cjkPattern = json$1.cjkPattern,
      kPattern = json$1.kPattern,
      punctuationPattern = json$1.punctuationPattern;
  var getLast$3 = util.getLast;
  var INLINE_NODE_TYPES = ["liquidNode", "inlineCode", "emphasis", "strong", "delete", "link", "linkReference", "image", "imageReference", "footnote", "footnoteReference", "sentence", "whitespace", "word", "break", "inlineMath"];
  var INLINE_NODE_WRAPPER_TYPES = INLINE_NODE_TYPES.concat(["tableCell", "paragraph", "heading"]);
  var kRegex = new RegExp(kPattern);
  var punctuationRegex = new RegExp(punctuationPattern);
  /**
   * split text into whitespaces and words
   * @param {string} text
   * @return {Array<{ type: "whitespace", value: " " | "\n" | "" } | { type: "word", value: string }>}
   */

  function splitText(text, options) {
    var KIND_NON_CJK = "non-cjk";
    var KIND_CJ_LETTER = "cj-letter";
    var KIND_K_LETTER = "k-letter";
    var KIND_CJK_PUNCTUATION = "cjk-punctuation";
    var nodes = [];
    (options.proseWrap === "preserve" ? text : text.replace(new RegExp("(".concat(cjkPattern, ")\n(").concat(cjkPattern, ")"), "g"), "$1$2")).split(/([ \t\n]+)/).forEach(function (token, index, tokens) {
      // whitespace
      if (index % 2 === 1) {
        nodes.push({
          type: "whitespace",
          value: /\n/.test(token) ? "\n" : " "
        });
        return;
      } // word separated by whitespace


      if ((index === 0 || index === tokens.length - 1) && token === "") {
        return;
      }

      token.split(new RegExp("(".concat(cjkPattern, ")"))).forEach(function (innerToken, innerIndex, innerTokens) {
        if ((innerIndex === 0 || innerIndex === innerTokens.length - 1) && innerToken === "") {
          return;
        } // non-CJK word


        if (innerIndex % 2 === 0) {
          if (innerToken !== "") {
            appendNode({
              type: "word",
              value: innerToken,
              kind: KIND_NON_CJK,
              hasLeadingPunctuation: punctuationRegex.test(innerToken[0]),
              hasTrailingPunctuation: punctuationRegex.test(getLast$3(innerToken))
            });
          }

          return;
        } // CJK character


        appendNode(punctuationRegex.test(innerToken) ? {
          type: "word",
          value: innerToken,
          kind: KIND_CJK_PUNCTUATION,
          hasLeadingPunctuation: true,
          hasTrailingPunctuation: true
        } : {
          type: "word",
          value: innerToken,
          kind: kRegex.test(innerToken) ? KIND_K_LETTER : KIND_CJ_LETTER,
          hasLeadingPunctuation: false,
          hasTrailingPunctuation: false
        });
      });
    });
    return nodes;

    function appendNode(node) {
      var lastNode = getLast$3(nodes);

      if (lastNode && lastNode.type === "word") {
        if (lastNode.kind === KIND_NON_CJK && node.kind === KIND_CJ_LETTER && !lastNode.hasTrailingPunctuation || lastNode.kind === KIND_CJ_LETTER && node.kind === KIND_NON_CJK && !node.hasLeadingPunctuation) {
          nodes.push({
            type: "whitespace",
            value: " "
          });
        } else if (!isBetween(KIND_NON_CJK, KIND_CJK_PUNCTUATION) && // disallow leading/trailing full-width whitespace
        ![lastNode.value, node.value].some(function (value) {
          return /\u3000/.test(value);
        })) {
          nodes.push({
            type: "whitespace",
            value: ""
          });
        }
      }

      nodes.push(node);

      function isBetween(kind1, kind2) {
        return lastNode.kind === kind1 && node.kind === kind2 || lastNode.kind === kind2 && node.kind === kind1;
      }
    }
  }

  function getOrderedListItemInfo(orderListItem, originalText) {
    var _originalText$slice$m = originalText.slice(orderListItem.position.start.offset, orderListItem.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/),
        _originalText$slice$m2 = _slicedToArray(_originalText$slice$m, 4),
        numberText = _originalText$slice$m2[1],
        marker = _originalText$slice$m2[2],
        leadingSpaces = _originalText$slice$m2[3];

    return {
      numberText: numberText,
      marker: marker,
      leadingSpaces: leadingSpaces
    };
  } // workaround for https://github.com/remarkjs/remark/issues/351
  // leading and trailing newlines are stripped by remark


  function getFencedCodeBlockValue(node, originalText) {
    var text = originalText.slice(node.position.start.offset, node.position.end.offset);
    var leadingSpaceCount = text.match(/^\s*/)[0].length;
    var replaceRegex = new RegExp("^\\s{0,".concat(leadingSpaceCount, "}"));
    var lineContents = text.split("\n");
    var markerStyle = text[leadingSpaceCount]; // ` or ~

    var marker = text.slice(leadingSpaceCount).match(new RegExp("^[".concat(markerStyle, "]+")))[0]; // https://spec.commonmark.org/0.28/#example-104: Closing fences may be indented by 0-3 spaces
    // https://spec.commonmark.org/0.28/#example-93: The closing code fence must be at least as long as the opening fence

    var hasEndMarker = new RegExp("^\\s{0,3}".concat(marker)).test(lineContents[lineContents.length - 1].slice(getIndent(lineContents.length - 1)));
    return lineContents.slice(1, hasEndMarker ? -1 : undefined).map(function (x, i) {
      return x.slice(getIndent(i + 1)).replace(replaceRegex, "");
    }).join("\n");

    function getIndent(lineIndex) {
      return node.position.indent[lineIndex - 1] - 1;
    }
  }

  function mapAst(ast, handler) {
    return function preorder(node, index, parentStack) {
      parentStack = parentStack || [];
      var newNode = handler(node, index, parentStack);

      if (Array.isArray(newNode)) {
        return newNode;
      }

      newNode = Object.assign({}, newNode);

      if (newNode.children) {
        newNode.children = newNode.children.reduce(function (nodes, child, index) {
          var newNodes = preorder(child, index, [newNode].concat(parentStack));

          if (!Array.isArray(newNodes)) {
            newNodes = [newNodes];
          }

          nodes.push.apply(nodes, newNodes);
          return nodes;
        }, []);
      }

      return newNode;
    }(ast, null, null);
  }

  var utils$5 = {
    mapAst: mapAst,
    splitText: splitText,
    punctuationPattern: punctuationPattern,
    getFencedCodeBlockValue: getFencedCodeBlockValue,
    getOrderedListItemInfo: getOrderedListItemInfo,
    INLINE_NODE_TYPES: INLINE_NODE_TYPES,
    INLINE_NODE_WRAPPER_TYPES: INLINE_NODE_WRAPPER_TYPES
  };

  var _require$$0$builders$8 = doc.builders,
      hardline$b = _require$$0$builders$8.hardline,
      literalline$5 = _require$$0$builders$8.literalline,
      concat$f = _require$$0$builders$8.concat,
      markAsRoot$3 = _require$$0$builders$8.markAsRoot,
      mapDoc$6 = doc.utils.mapDoc;
  var getFencedCodeBlockValue$1 = utils$5.getFencedCodeBlockValue;

  function embed$4(path, print, textToDoc, options) {
    var node = path.getValue();

    if (node.type === "code" && node.lang !== null) {
      // only look for the first string so as to support [markdown-preview-enhanced](https://shd101wyy.github.io/markdown-preview-enhanced/#/code-chunk)
      var langMatch = node.lang.match(/^[A-Za-z0-9_-]+/);
      var lang = langMatch ? langMatch[0] : "";
      var parser = getParserName(lang);

      if (parser) {
        var styleUnit = options.__inJsTemplate ? "~" : "`";
        var style = styleUnit.repeat(Math.max(3, util.getMaxContinuousCount(node.value, styleUnit) + 1));
        var doc = textToDoc(getFencedCodeBlockValue$1(node, options.originalText), {
          parser: parser
        });
        return markAsRoot$3(concat$f([style, node.lang, hardline$b, replaceNewlinesWithLiterallines(doc), style]));
      }
    }

    if (node.type === "yaml") {
      return markAsRoot$3(concat$f(["---", hardline$b, node.value && node.value.trim() ? replaceNewlinesWithLiterallines(textToDoc(node.value, {
        parser: "yaml"
      })) : "", "---"]));
    } // MDX


    switch (node.type) {
      case "importExport":
        return textToDoc(node.value, {
          parser: "babel"
        });

      case "jsx":
        return textToDoc(node.value, {
          parser: "__js_expression"
        });
    }

    return null;

    function getParserName(lang) {
      var supportInfo = support.getSupportInfo(null, {
        plugins: options.plugins
      });
      var language = supportInfo.languages.find(function (language) {
        return language.name.toLowerCase() === lang || language.aliases && language.aliases.indexOf(lang) !== -1 || language.extensions && language.extensions.find(function (ext) {
          return ext.substring(1) === lang;
        });
      });

      if (language) {
        return language.parsers[0];
      }

      return null;
    }

    function replaceNewlinesWithLiterallines(doc) {
      return mapDoc$6(doc, function (currentDoc) {
        return typeof currentDoc === "string" && currentDoc.includes("\n") ? concat$f(currentDoc.split(/(\n)/g).map(function (v, i) {
          return i % 2 === 0 ? v : literalline$5;
        })) : currentDoc;
      });
    }
  }

  var embed_1$2 = embed$4;

  var pragmas = ["format", "prettier"];

  function startWithPragma(text) {
    var pragma = "@(".concat(pragmas.join("|"), ")");
    var regex = new RegExp(["<!--\\s*".concat(pragma, "\\s*-->"), "<!--.*\r?\n[\\s\\S]*(^|\n)[^\\S\n]*".concat(pragma, "[^\\S\n]*($|\n)[\\s\\S]*\n.*-->")].join("|"), "m");
    var matched = text.match(regex);
    return matched && matched.index === 0;
  }

  var pragma$4 = {
    startWithPragma: startWithPragma,
    hasPragma: function hasPragma(text) {
      return startWithPragma(frontMatter(text).content.trimLeft());
    },
    insertPragma: function insertPragma(text) {
      var extracted = frontMatter(text);
      var pragma = "<!-- @".concat(pragmas[0], " -->");
      return extracted.frontMatter ? "".concat(extracted.frontMatter.raw, "\n\n").concat(pragma, "\n\n").concat(extracted.content) : "".concat(pragma, "\n\n").concat(extracted.content);
    }
  };

  var getOrderedListItemInfo$1 = utils$5.getOrderedListItemInfo,
      mapAst$1 = utils$5.mapAst,
      splitText$1 = utils$5.splitText; // 0x0 ~ 0x10ffff
  // eslint-disable-next-line no-control-regex

  var isSingleCharRegex = /^([\u0000-\uffff]|[\ud800-\udbff][\udc00-\udfff])$/;

  function preprocess$2(ast, options) {
    ast = restoreUnescapedCharacter(ast, options);
    ast = mergeContinuousTexts(ast);
    ast = transformInlineCode(ast);
    ast = transformIndentedCodeblockAndMarkItsParentList(ast, options);
    ast = markAlignedList(ast, options);
    ast = splitTextIntoSentences(ast, options);
    ast = transformImportExport(ast);
    ast = mergeContinuousImportExport(ast);
    return ast;
  }

  function transformImportExport(ast) {
    return mapAst$1(ast, function (node) {
      if (node.type !== "import" && node.type !== "export") {
        return node;
      }

      return Object.assign({}, node, {
        type: "importExport"
      });
    });
  }

  function transformInlineCode(ast) {
    return mapAst$1(ast, function (node) {
      if (node.type !== "inlineCode") {
        return node;
      }

      return Object.assign({}, node, {
        value: node.value.replace(/\s+/g, " ")
      });
    });
  }

  function restoreUnescapedCharacter(ast, options) {
    return mapAst$1(ast, function (node) {
      return node.type !== "text" ? node : Object.assign({}, node, {
        value: node.value !== "*" && node.value !== "_" && node.value !== "$" && // handle these cases in printer
        isSingleCharRegex.test(node.value) && node.position.end.offset - node.position.start.offset !== node.value.length ? options.originalText.slice(node.position.start.offset, node.position.end.offset) : node.value
      });
    });
  }

  function mergeContinuousImportExport(ast) {
    return mergeChildren(ast, function (prevNode, node) {
      return prevNode.type === "importExport" && node.type === "importExport";
    }, function (prevNode, node) {
      return {
        type: "importExport",
        value: prevNode.value + "\n\n" + node.value,
        position: {
          start: prevNode.position.start,
          end: node.position.end
        }
      };
    });
  }

  function mergeChildren(ast, shouldMerge, mergeNode) {
    return mapAst$1(ast, function (node) {
      if (!node.children) {
        return node;
      }

      var children = node.children.reduce(function (current, child) {
        var lastChild = current[current.length - 1];

        if (lastChild && shouldMerge(lastChild, child)) {
          current.splice(-1, 1, mergeNode(lastChild, child));
        } else {
          current.push(child);
        }

        return current;
      }, []);
      return Object.assign({}, node, {
        children: children
      });
    });
  }

  function mergeContinuousTexts(ast) {
    return mergeChildren(ast, function (prevNode, node) {
      return prevNode.type === "text" && node.type === "text";
    }, function (prevNode, node) {
      return {
        type: "text",
        value: prevNode.value + node.value,
        position: {
          start: prevNode.position.start,
          end: node.position.end
        }
      };
    });
  }

  function splitTextIntoSentences(ast, options) {
    return mapAst$1(ast, function (node, index, _ref) {
      var _ref2 = _slicedToArray(_ref, 1),
          parentNode = _ref2[0];

      if (node.type !== "text") {
        return node;
      }

      var value = node.value;

      if (parentNode.type === "paragraph") {
        if (index === 0) {
          value = value.trimLeft();
        }

        if (index === parentNode.children.length - 1) {
          value = value.trimRight();
        }
      }

      return {
        type: "sentence",
        position: node.position,
        children: splitText$1(value, options)
      };
    });
  }

  function transformIndentedCodeblockAndMarkItsParentList(ast, options) {
    return mapAst$1(ast, function (node, index, parentStack) {
      if (node.type === "code") {
        // the first char may point to `\n`, e.g. `\n\t\tbar`, just ignore it
        var isIndented = /^\n?( {4,}|\t)/.test(options.originalText.slice(node.position.start.offset, node.position.end.offset));
        node.isIndented = isIndented;

        if (isIndented) {
          for (var i = 0; i < parentStack.length; i++) {
            var parent = parentStack[i]; // no need to check checked items

            if (parent.hasIndentedCodeblock) {
              break;
            }

            if (parent.type === "list") {
              parent.hasIndentedCodeblock = true;
            }
          }
        }
      }

      return node;
    });
  }

  function markAlignedList(ast, options) {
    return mapAst$1(ast, function (node, index, parentStack) {
      if (node.type === "list" && node.children.length !== 0) {
        // if one of its parents is not aligned, it's not possible to be aligned in sub-lists
        for (var i = 0; i < parentStack.length; i++) {
          var parent = parentStack[i];

          if (parent.type === "list" && !parent.isAligned) {
            node.isAligned = false;
            return node;
          }
        }

        node.isAligned = isAligned(node);
      }

      return node;
    });

    function getListItemStart(listItem) {
      return listItem.children.length === 0 ? -1 : listItem.children[0].position.start.column - 1;
    }

    function isAligned(list) {
      if (!list.ordered) {
        /**
         * - 123
         * - 123
         */
        return true;
      }

      var _list$children = _slicedToArray(list.children, 2),
          firstItem = _list$children[0],
          secondItem = _list$children[1];

      var firstInfo = getOrderedListItemInfo$1(firstItem, options.originalText);

      if (firstInfo.leadingSpaces.length > 1) {
        /**
         * 1.   123
         *
         * 1.   123
         * 1. 123
         */
        return true;
      }

      var firstStart = getListItemStart(firstItem);

      if (firstStart === -1) {
        /**
         * 1.
         *
         * 1.
         * 1.
         */
        return false;
      }

      if (list.children.length === 1) {
        /**
         * aligned:
         *
         * 11. 123
         *
         * not aligned:
         *
         * 1. 123
         */
        return firstStart % options.tabWidth === 0;
      }

      var secondStart = getListItemStart(secondItem);

      if (firstStart !== secondStart) {
        /**
         * 11. 123
         * 1. 123
         *
         * 1. 123
         * 11. 123
         */
        return false;
      }

      if (firstStart % options.tabWidth === 0) {
        /**
         * 11. 123
         * 12. 123
         */
        return true;
      }
      /**
       * aligned:
       *
       * 11. 123
       * 1.  123
       *
       * not aligned:
       *
       * 1. 123
       * 2. 123
       */


      var secondInfo = getOrderedListItemInfo$1(secondItem, options.originalText);
      return secondInfo.leadingSpaces.length > 1;
    }
  }

  var preprocess_1$2 = preprocess$2;

  var _require$$0$builders$9 = doc.builders,
      breakParent$4 = _require$$0$builders$9.breakParent,
      concat$g = _require$$0$builders$9.concat,
      join$b = _require$$0$builders$9.join,
      line$8 = _require$$0$builders$9.line,
      literalline$6 = _require$$0$builders$9.literalline,
      markAsRoot$4 = _require$$0$builders$9.markAsRoot,
      hardline$c = _require$$0$builders$9.hardline,
      softline$7 = _require$$0$builders$9.softline,
      ifBreak$7 = _require$$0$builders$9.ifBreak,
      fill$5 = _require$$0$builders$9.fill,
      align$2 = _require$$0$builders$9.align,
      indent$9 = _require$$0$builders$9.indent,
      group$f = _require$$0$builders$9.group,
      mapDoc$7 = doc.utils.mapDoc,
      printDocToString$2 = doc.printer.printDocToString;
  var getFencedCodeBlockValue$2 = utils$5.getFencedCodeBlockValue,
      getOrderedListItemInfo$2 = utils$5.getOrderedListItemInfo,
      splitText$2 = utils$5.splitText,
      punctuationPattern$1 = utils$5.punctuationPattern,
      INLINE_NODE_TYPES$1 = utils$5.INLINE_NODE_TYPES,
      INLINE_NODE_WRAPPER_TYPES$1 = utils$5.INLINE_NODE_WRAPPER_TYPES;
  var replaceEndOfLineWith$2 = util.replaceEndOfLineWith;
  var TRAILING_HARDLINE_NODES = ["importExport"];
  var SINGLE_LINE_NODE_TYPES = ["heading", "tableCell", "link"];
  var SIBLING_NODE_TYPES = ["listItem", "definition", "footnoteDefinition", "jsx"];

  function genericPrint$5(path, options, print) {
    var node = path.getValue();

    if (shouldRemainTheSameContent(path)) {
      return concat$g(splitText$2(options.originalText.slice(node.position.start.offset, node.position.end.offset), options).map(function (node) {
        return node.type === "word" ? node.value : node.value === "" ? "" : printLine(path, node.value, options);
      }));
    }

    switch (node.type) {
      case "root":
        if (node.children.length === 0) {
          return "";
        }

        return concat$g([normalizeDoc(printRoot(path, options, print)), TRAILING_HARDLINE_NODES.indexOf(getLastDescendantNode(node).type) === -1 ? hardline$c : ""]);

      case "paragraph":
        return printChildren$2(path, options, print, {
          postprocessor: fill$5
        });

      case "sentence":
        return printChildren$2(path, options, print);

      case "word":
        return node.value.replace(/[*$]/g, "\\$&") // escape all `*` and `$` (math)
        .replace(new RegExp(["(^|".concat(punctuationPattern$1, ")(_+)"), "(_+)(".concat(punctuationPattern$1, "|$)")].join("|"), "g"), function (_, text1, underscore1, underscore2, text2) {
          return (underscore1 ? "".concat(text1).concat(underscore1) : "".concat(underscore2).concat(text2)).replace(/_/g, "\\_");
        });
      // escape all `_` except concating with non-punctuation, e.g. `1_2_3` is not considered emphasis

      case "whitespace":
        {
          var parentNode = path.getParentNode();
          var index = parentNode.children.indexOf(node);
          var nextNode = parentNode.children[index + 1];
          var proseWrap = // leading char that may cause different syntax
          nextNode && /^>|^([-+*]|#{1,6}|[0-9]+[.)])$/.test(nextNode.value) ? "never" : options.proseWrap;
          return printLine(path, node.value, {
            proseWrap: proseWrap
          });
        }

      case "emphasis":
        {
          var _parentNode = path.getParentNode();

          var _index = _parentNode.children.indexOf(node);

          var prevNode = _parentNode.children[_index - 1];
          var _nextNode = _parentNode.children[_index + 1];
          var hasPrevOrNextWord = // `1*2*3` is considered emphasis but `1_2_3` is not
          prevNode && prevNode.type === "sentence" && prevNode.children.length > 0 && util.getLast(prevNode.children).type === "word" && !util.getLast(prevNode.children).hasTrailingPunctuation || _nextNode && _nextNode.type === "sentence" && _nextNode.children.length > 0 && _nextNode.children[0].type === "word" && !_nextNode.children[0].hasLeadingPunctuation;
          var style = hasPrevOrNextWord || getAncestorNode$2(path, "emphasis") ? "*" : "_";
          return concat$g([style, printChildren$2(path, options, print), style]);
        }

      case "strong":
        return concat$g(["**", printChildren$2(path, options, print), "**"]);

      case "delete":
        return concat$g(["~~", printChildren$2(path, options, print), "~~"]);

      case "inlineCode":
        {
          var backtickCount = util.getMinNotPresentContinuousCount(node.value, "`");

          var _style = "`".repeat(backtickCount || 1);

          var gap = backtickCount ? " " : "";
          return concat$g([_style, gap, node.value, gap, _style]);
        }

      case "link":
        switch (options.originalText[node.position.start.offset]) {
          case "<":
            {
              var mailto = "mailto:";
              var url = // <hello@example.com> is parsed as { url: "mailto:hello@example.com" }
              node.url.startsWith(mailto) && options.originalText.slice(node.position.start.offset + 1, node.position.start.offset + 1 + mailto.length) !== mailto ? node.url.slice(mailto.length) : node.url;
              return concat$g(["<", url, ">"]);
            }

          case "[":
            return concat$g(["[", printChildren$2(path, options, print), "](", printUrl(node.url, ")"), printTitle(node.title, options), ")"]);

          default:
            return options.originalText.slice(node.position.start.offset, node.position.end.offset);
        }

      case "image":
        return concat$g(["![", node.alt || "", "](", printUrl(node.url, ")"), printTitle(node.title, options), ")"]);

      case "blockquote":
        return concat$g(["> ", align$2("> ", printChildren$2(path, options, print))]);

      case "heading":
        return concat$g(["#".repeat(node.depth) + " ", printChildren$2(path, options, print)]);

      case "code":
        {
          if (node.isIndented) {
            // indented code block
            var alignment = " ".repeat(4);
            return align$2(alignment, concat$g([alignment, concat$g(replaceEndOfLineWith$2(node.value, hardline$c))]));
          } // fenced code block


          var styleUnit = options.__inJsTemplate ? "~" : "`";

          var _style2 = styleUnit.repeat(Math.max(3, util.getMaxContinuousCount(node.value, styleUnit) + 1));

          return concat$g([_style2, node.lang || "", hardline$c, concat$g(replaceEndOfLineWith$2(getFencedCodeBlockValue$2(node, options.originalText), hardline$c)), hardline$c, _style2]);
        }

      case "yaml":
      case "toml":
        return options.originalText.slice(node.position.start.offset, node.position.end.offset);

      case "html":
        {
          var _parentNode2 = path.getParentNode();

          var value = _parentNode2.type === "root" && util.getLast(_parentNode2.children) === node ? node.value.trimRight() : node.value;
          var isHtmlComment = /^<!--[\s\S]*-->$/.test(value);
          return concat$g(replaceEndOfLineWith$2(value, isHtmlComment ? hardline$c : markAsRoot$4(literalline$6)));
        }

      case "list":
        {
          var nthSiblingIndex = getNthListSiblingIndex(node, path.getParentNode());
          var isGitDiffFriendlyOrderedList = node.ordered && node.children.length > 1 && +getOrderedListItemInfo$2(node.children[1], options.originalText).numberText === 1;
          return printChildren$2(path, options, print, {
            processor: function processor(childPath, index) {
              var prefix = getPrefix();
              return concat$g([prefix, align$2(" ".repeat(prefix.length), printListItem(childPath, options, print, prefix))]);

              function getPrefix() {
                var rawPrefix = node.ordered ? (index === 0 ? node.start : isGitDiffFriendlyOrderedList ? 1 : node.start + index) + (nthSiblingIndex % 2 === 0 ? ". " : ") ") : nthSiblingIndex % 2 === 0 ? "- " : "* ";
                return node.isAligned ||
                /* workaround for https://github.com/remarkjs/remark/issues/315 */
                node.hasIndentedCodeblock ? alignListPrefix(rawPrefix, options) : rawPrefix;
              }
            }
          });
        }

      case "thematicBreak":
        {
          var counter = getAncestorCounter$1(path, "list");

          if (counter === -1) {
            return "---";
          }

          var _nthSiblingIndex = getNthListSiblingIndex(path.getParentNode(counter), path.getParentNode(counter + 1));

          return _nthSiblingIndex % 2 === 0 ? "***" : "---";
        }

      case "linkReference":
        return concat$g(["[", printChildren$2(path, options, print), "]", node.referenceType === "full" ? concat$g(["[", node.identifier, "]"]) : node.referenceType === "collapsed" ? "[]" : ""]);

      case "imageReference":
        switch (node.referenceType) {
          case "full":
            return concat$g(["![", node.alt || "", "][", node.identifier, "]"]);

          default:
            return concat$g(["![", node.alt, "]", node.referenceType === "collapsed" ? "[]" : ""]);
        }

      case "definition":
        {
          var lineOrSpace = options.proseWrap === "always" ? line$8 : " ";
          return group$f(concat$g([concat$g(["[", node.identifier, "]:"]), indent$9(concat$g([lineOrSpace, printUrl(node.url), node.title === null ? "" : concat$g([lineOrSpace, printTitle(node.title, options, false)])]))]));
        }

      case "footnote":
        return concat$g(["[^", printChildren$2(path, options, print), "]"]);

      case "footnoteReference":
        return concat$g(["[^", node.identifier, "]"]);

      case "footnoteDefinition":
        {
          var _nextNode2 = path.getParentNode().children[path.getName() + 1];
          var shouldInlineFootnote = node.children.length === 1 && node.children[0].type === "paragraph" && (options.proseWrap === "never" || options.proseWrap === "preserve" && node.children[0].position.start.line === node.children[0].position.end.line);
          return concat$g(["[^", node.identifier, "]: ", shouldInlineFootnote ? printChildren$2(path, options, print) : group$f(concat$g([align$2(" ".repeat(options.tabWidth), printChildren$2(path, options, print, {
            processor: function processor(childPath, index) {
              return index === 0 ? group$f(concat$g([softline$7, softline$7, childPath.call(print)])) : childPath.call(print);
            }
          })), _nextNode2 && _nextNode2.type === "footnoteDefinition" ? softline$7 : ""]))]);
        }

      case "table":
        return printTable(path, options, print);

      case "tableCell":
        return printChildren$2(path, options, print);

      case "break":
        return /\s/.test(options.originalText[node.position.start.offset]) ? concat$g(["  ", markAsRoot$4(literalline$6)]) : concat$g(["\\", hardline$c]);

      case "liquidNode":
        return concat$g(replaceEndOfLineWith$2(node.value, hardline$c));
      // MDX

      case "importExport":
      case "jsx":
        return node.value;
      // fallback to the original text if multiparser failed

      case "math":
        return concat$g(["$$", hardline$c, node.value ? concat$g([concat$g(replaceEndOfLineWith$2(node.value, hardline$c)), hardline$c]) : "", "$$"]);

      case "inlineMath":
        {
          // remark-math trims content but we don't want to remove whitespaces
          // since it's very possible that it's recognized as math accidentally
          return options.originalText.slice(options.locStart(node), options.locEnd(node));
        }

      case "tableRow": // handled in "table"

      case "listItem": // handled in "list"

      default:
        throw new Error("Unknown markdown type ".concat(JSON.stringify(node.type)));
    }
  }

  function printListItem(path, options, print, listPrefix) {
    var node = path.getValue();
    var prefix = node.checked === null ? "" : node.checked ? "[x] " : "[ ] ";
    return concat$g([prefix, printChildren$2(path, options, print, {
      processor: function processor(childPath, index) {
        if (index === 0 && childPath.getValue().type !== "list") {
          return align$2(" ".repeat(prefix.length), childPath.call(print));
        }

        var alignment = " ".repeat(clamp(options.tabWidth - listPrefix.length, 0, 3) // 4+ will cause indented code block
        );
        return concat$g([alignment, align$2(alignment, childPath.call(print))]);
      }
    })]);
  }

  function alignListPrefix(prefix, options) {
    var additionalSpaces = getAdditionalSpaces();
    return prefix + " ".repeat(additionalSpaces >= 4 ? 0 : additionalSpaces // 4+ will cause indented code block
    );

    function getAdditionalSpaces() {
      var restSpaces = prefix.length % options.tabWidth;
      return restSpaces === 0 ? 0 : options.tabWidth - restSpaces;
    }
  }

  function getNthListSiblingIndex(node, parentNode) {
    return getNthSiblingIndex(node, parentNode, function (siblingNode) {
      return siblingNode.ordered === node.ordered;
    });
  }

  function getNthSiblingIndex(node, parentNode, condition) {
    condition = condition || function () {
      return true;
    };

    var index = -1;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = parentNode.children[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var childNode = _step.value;

        if (childNode.type === node.type && condition(childNode)) {
          index++;
        } else {
          index = -1;
        }

        if (childNode === node) {
          return index;
        }
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }
  }

  function getAncestorCounter$1(path, typeOrTypes) {
    var types = [].concat(typeOrTypes);
    var counter = -1;
    var ancestorNode;

    while (ancestorNode = path.getParentNode(++counter)) {
      if (types.indexOf(ancestorNode.type) !== -1) {
        return counter;
      }
    }

    return -1;
  }

  function getAncestorNode$2(path, typeOrTypes) {
    var counter = getAncestorCounter$1(path, typeOrTypes);
    return counter === -1 ? null : path.getParentNode(counter);
  }

  function printLine(path, value, options) {
    if (options.proseWrap === "preserve" && value === "\n") {
      return hardline$c;
    }

    var isBreakable = options.proseWrap === "always" && !getAncestorNode$2(path, SINGLE_LINE_NODE_TYPES);
    return value !== "" ? isBreakable ? line$8 : " " : isBreakable ? softline$7 : "";
  }

  function printTable(path, options, print) {
    var hardlineWithoutBreakParent = hardline$c.parts[0];
    var node = path.getValue();
    var contents = []; // { [rowIndex: number]: { [columnIndex: number]: string } }

    path.map(function (rowPath) {
      var rowContents = [];
      rowPath.map(function (cellPath) {
        rowContents.push(printDocToString$2(cellPath.call(print), options).formatted);
      }, "children");
      contents.push(rowContents);
    }, "children"); // Get the width of each column

    var columnMaxWidths = contents.reduce(function (currentWidths, rowContents) {
      return currentWidths.map(function (width, columnIndex) {
        return Math.max(width, util.getStringWidth(rowContents[columnIndex]));
      });
    }, contents[0].map(function () {
      return 3;
    }) // minimum width = 3 (---, :--, :-:, --:)
    );
    var alignedTable = join$b(hardlineWithoutBreakParent, [printRow(contents[0]), printSeparator(), join$b(hardlineWithoutBreakParent, contents.slice(1).map(function (rowContents) {
      return printRow(rowContents);
    }))]);

    if (options.proseWrap !== "never") {
      return concat$g([breakParent$4, alignedTable]);
    } // Only if the --prose-wrap never is set and it exceeds the print width.


    var compactTable = join$b(hardlineWithoutBreakParent, [printRow(contents[0],
    /* isCompact */
    true), printSeparator(
    /* isCompact */
    true), join$b(hardlineWithoutBreakParent, contents.slice(1).map(function (rowContents) {
      return printRow(rowContents,
      /* isCompact */
      true);
    }))]);
    return concat$g([breakParent$4, group$f(ifBreak$7(compactTable, alignedTable))]);

    function printSeparator(isCompact) {
      return concat$g(["| ", join$b(" | ", columnMaxWidths.map(function (width, index) {
        var spaces = isCompact ? 3 : width;

        switch (node.align[index]) {
          case "left":
            return ":" + "-".repeat(spaces - 1);

          case "right":
            return "-".repeat(spaces - 1) + ":";

          case "center":
            return ":" + "-".repeat(spaces - 2) + ":";

          default:
            return "-".repeat(spaces);
        }
      })), " |"]);
    }

    function printRow(rowContents, isCompact) {
      return concat$g(["| ", join$b(" | ", isCompact ? rowContents : rowContents.map(function (rowContent, columnIndex) {
        switch (node.align[columnIndex]) {
          case "right":
            return alignRight(rowContent, columnMaxWidths[columnIndex]);

          case "center":
            return alignCenter(rowContent, columnMaxWidths[columnIndex]);

          default:
            return alignLeft(rowContent, columnMaxWidths[columnIndex]);
        }
      })), " |"]);
    }

    function alignLeft(text, width) {
      var spaces = width - util.getStringWidth(text);
      return concat$g([text, " ".repeat(spaces)]);
    }

    function alignRight(text, width) {
      var spaces = width - util.getStringWidth(text);
      return concat$g([" ".repeat(spaces), text]);
    }

    function alignCenter(text, width) {
      var spaces = width - util.getStringWidth(text);
      var left = Math.floor(spaces / 2);
      var right = spaces - left;
      return concat$g([" ".repeat(left), text, " ".repeat(right)]);
    }
  }

  function printRoot(path, options, print) {
    /** @typedef {{ index: number, offset: number }} IgnorePosition */

    /** @type {Array<{start: IgnorePosition, end: IgnorePosition}>} */
    var ignoreRanges = [];
    /** @type {IgnorePosition | null} */

    var ignoreStart = null;
    var children = path.getValue().children;
    children.forEach(function (childNode, index) {
      switch (isPrettierIgnore$1(childNode)) {
        case "start":
          if (ignoreStart === null) {
            ignoreStart = {
              index: index,
              offset: childNode.position.end.offset
            };
          }

          break;

        case "end":
          if (ignoreStart !== null) {
            ignoreRanges.push({
              start: ignoreStart,
              end: {
                index: index,
                offset: childNode.position.start.offset
              }
            });
            ignoreStart = null;
          }

          break;
      }
    });
    return printChildren$2(path, options, print, {
      processor: function processor(childPath, index) {
        if (ignoreRanges.length !== 0) {
          var ignoreRange = ignoreRanges[0];

          if (index === ignoreRange.start.index) {
            return concat$g([children[ignoreRange.start.index].value, options.originalText.slice(ignoreRange.start.offset, ignoreRange.end.offset), children[ignoreRange.end.index].value]);
          }

          if (ignoreRange.start.index < index && index < ignoreRange.end.index) {
            return false;
          }

          if (index === ignoreRange.end.index) {
            ignoreRanges.shift();
            return false;
          }
        }

        return childPath.call(print);
      }
    });
  }

  function printChildren$2(path, options, print, events) {
    events = events || {};
    var postprocessor = events.postprocessor || concat$g;

    var processor = events.processor || function (childPath) {
      return childPath.call(print);
    };

    var node = path.getValue();
    var parts = [];
    var lastChildNode;
    path.map(function (childPath, index) {
      var childNode = childPath.getValue();
      var result = processor(childPath, index);

      if (result !== false) {
        var data = {
          parts: parts,
          prevNode: lastChildNode,
          parentNode: node,
          options: options
        };

        if (!shouldNotPrePrintHardline(childNode, data)) {
          parts.push(hardline$c);

          if (lastChildNode && TRAILING_HARDLINE_NODES.indexOf(lastChildNode.type) !== -1) {
            if (shouldPrePrintTripleHardline(childNode, data)) {
              parts.push(hardline$c);
            }
          } else {
            if (shouldPrePrintDoubleHardline(childNode, data) || shouldPrePrintTripleHardline(childNode, data)) {
              parts.push(hardline$c);
            }

            if (shouldPrePrintTripleHardline(childNode, data)) {
              parts.push(hardline$c);
            }
          }
        }

        parts.push(result);
        lastChildNode = childNode;
      }
    }, "children");
    return postprocessor(parts);
  }

  function getLastDescendantNode(node) {
    var current = node;

    while (current.children && current.children.length !== 0) {
      current = current.children[current.children.length - 1];
    }

    return current;
  }
  /** @return {false | 'next' | 'start' | 'end'} */


  function isPrettierIgnore$1(node) {
    if (node.type !== "html") {
      return false;
    }

    var match = node.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);
    return match === null ? false : match[1] ? match[1] : "next";
  }

  function isInlineNode(node) {
    return node && INLINE_NODE_TYPES$1.indexOf(node.type) !== -1;
  }

  function isEndsWithHardLine(node) {
    return node && /\n+$/.test(node.value);
  }

  function last(nodes) {
    return nodes && nodes[nodes.length - 1];
  }

  function shouldNotPrePrintHardline(node, _ref) {
    var parentNode = _ref.parentNode,
        parts = _ref.parts,
        prevNode = _ref.prevNode;
    var isFirstNode = parts.length === 0;
    var isInlineHTML = node.type === "html" && INLINE_NODE_WRAPPER_TYPES$1.indexOf(parentNode.type) !== -1;
    var isAfterHardlineNode = prevNode && (isEndsWithHardLine(prevNode) || isEndsWithHardLine(last(prevNode.children)));
    return isFirstNode || isInlineNode(node) || isInlineHTML || isAfterHardlineNode;
  }

  function shouldPrePrintDoubleHardline(node, _ref2) {
    var parentNode = _ref2.parentNode,
        prevNode = _ref2.prevNode;
    var prevNodeType = prevNode && prevNode.type;
    var nodeType = node.type;
    var isSequence = prevNodeType === nodeType;
    var isSiblingNode = isSequence && SIBLING_NODE_TYPES.indexOf(nodeType) !== -1;
    var isInTightListItem = parentNode.type === "listItem" && !parentNode.loose;
    var isPrevNodeLooseListItem = prevNodeType === "listItem" && prevNode.loose;
    var isPrevNodePrettierIgnore = isPrettierIgnore$1(prevNode) === "next";
    var isBlockHtmlWithoutBlankLineBetweenPrevHtml = nodeType === "html" && prevNodeType === "html" && prevNode.position.end.line + 1 === node.position.start.line;
    var isJsxInlineSibling = prevNodeType === "jsx" && isInlineNode(node) || nodeType === "jsx" && isInlineNode(prevNode);
    return isPrevNodeLooseListItem || !(isSiblingNode || isInTightListItem || isPrevNodePrettierIgnore || isBlockHtmlWithoutBlankLineBetweenPrevHtml || isJsxInlineSibling);
  }

  function shouldPrePrintTripleHardline(node, data) {
    var isPrevNodeList = data.prevNode && data.prevNode.type === "list";
    var isIndentedCode = node.type === "code" && node.isIndented;
    return isPrevNodeList && isIndentedCode;
  }

  function shouldRemainTheSameContent(path) {
    var ancestorNode = getAncestorNode$2(path, ["linkReference", "imageReference"]);
    return ancestorNode && (ancestorNode.type !== "linkReference" || ancestorNode.referenceType !== "full");
  }

  function normalizeDoc(doc) {
    return mapDoc$7(doc, function (currentDoc) {
      if (!currentDoc.parts) {
        return currentDoc;
      }

      if (currentDoc.type === "concat" && currentDoc.parts.length === 1) {
        return currentDoc.parts[0];
      }

      var parts = [];
      currentDoc.parts.forEach(function (part) {
        if (part.type === "concat") {
          parts.push.apply(parts, part.parts);
        } else if (part !== "") {
          parts.push(part);
        }
      });
      return Object.assign({}, currentDoc, {
        parts: normalizeParts$2(parts)
      });
    });
  }

  function printUrl(url, dangerousCharOrChars) {
    var dangerousChars = [" "].concat(dangerousCharOrChars || []);
    return new RegExp(dangerousChars.map(function (x) {
      return "\\".concat(x);
    }).join("|")).test(url) ? "<".concat(url, ">") : url;
  }

  function printTitle(title, options, printSpace) {
    if (printSpace == null) {
      printSpace = true;
    }

    if (!title) {
      return "";
    }

    if (printSpace) {
      return " " + printTitle(title, options, false);
    }

    if (title.includes('"') && title.includes("'") && !title.includes(")")) {
      return "(".concat(title, ")"); // avoid escaped quotes
    } // faster than using RegExps: https://jsperf.com/performance-of-match-vs-split


    var singleCount = title.split("'").length - 1;
    var doubleCount = title.split('"').length - 1;
    var quote = singleCount > doubleCount ? '"' : doubleCount > singleCount ? "'" : options.singleQuote ? "'" : '"';
    title = title.replace(new RegExp("(".concat(quote, ")"), "g"), "\\$1");
    return "".concat(quote).concat(title).concat(quote);
  }

  function normalizeParts$2(parts) {
    return parts.reduce(function (current, part) {
      var lastPart = util.getLast(current);

      if (typeof lastPart === "string" && typeof part === "string") {
        current.splice(-1, 1, lastPart + part);
      } else {
        current.push(part);
      }

      return current;
    }, []);
  }

  function clamp(value, min, max) {
    return value < min ? min : value > max ? max : value;
  }

  function clean$6(ast, newObj, parent) {
    delete newObj.position;
    delete newObj.raw; // front-matter
    // for codeblock

    if (ast.type === "code" || ast.type === "yaml" || ast.type === "import" || ast.type === "export" || ast.type === "jsx") {
      delete newObj.value;
    }

    if (ast.type === "list") {
      delete newObj.isAligned;
    } // texts can be splitted or merged


    if (ast.type === "text") {
      return null;
    }

    if (ast.type === "inlineCode") {
      newObj.value = ast.value.replace(/[ \t\n]+/g, " ");
    } // for insert pragma


    if (parent && parent.type === "root" && parent.children.length > 0 && (parent.children[0] === ast || (parent.children[0].type === "yaml" || parent.children[0].type === "toml") && parent.children[1] === ast) && ast.type === "html" && pragma$4.startWithPragma(ast.value)) {
      return null;
    }
  }

  function hasPrettierIgnore$4(path) {
    var index = +path.getName();

    if (index === 0) {
      return false;
    }

    var prevNode = path.getParentNode().children[index - 1];
    return isPrettierIgnore$1(prevNode) === "next";
  }

  var printerMarkdown = {
    preprocess: preprocess_1$2,
    print: genericPrint$5,
    embed: embed_1$2,
    massageAstNode: clean$6,
    hasPrettierIgnore: hasPrettierIgnore$4,
    insertPragma: pragma$4.insertPragma
  };

  var options$6 = {
    proseWrap: commonOptions.proseWrap,
    singleQuote: commonOptions.singleQuote
  };

  var name$g = "Markdown";
  var type$f = "prose";
  var aliases$5 = [
  	"pandoc"
  ];
  var aceMode$f = "markdown";
  var codemirrorMode$b = "gfm";
  var codemirrorMimeType$b = "text/x-gfm";
  var wrap = true;
  var extensions$f = [
  	".md",
  	".markdown",
  	".mdown",
  	".mdwn",
  	".mdx",
  	".mkd",
  	".mkdn",
  	".mkdown",
  	".ronn",
  	".workbook"
  ];
  var filenames$3 = [
  	"contents.lr"
  ];
  var tmScope$f = "source.gfm";
  var languageId$f = 222;
  var Markdown = {
  	name: name$g,
  	type: type$f,
  	aliases: aliases$5,
  	aceMode: aceMode$f,
  	codemirrorMode: codemirrorMode$b,
  	codemirrorMimeType: codemirrorMimeType$b,
  	wrap: wrap,
  	extensions: extensions$f,
  	filenames: filenames$3,
  	tmScope: tmScope$f,
  	languageId: languageId$f
  };

  var Markdown$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$g,
    type: type$f,
    aliases: aliases$5,
    aceMode: aceMode$f,
    codemirrorMode: codemirrorMode$b,
    codemirrorMimeType: codemirrorMimeType$b,
    wrap: wrap,
    extensions: extensions$f,
    filenames: filenames$3,
    tmScope: tmScope$f,
    languageId: languageId$f,
    'default': Markdown
  });

  var require$$0$7 = getCjsExportFromNamespace(Markdown$1);

  var languages$5 = [createLanguage(require$$0$7, function (data) {
    return Object.assign(data, {
      since: "1.8.0",
      parsers: ["remark"],
      vscodeLanguageIds: ["markdown"],
      filenames: data.filenames.concat(["README"]),
      extensions: data.extensions.filter(function (extension) {
        return extension !== ".mdx";
      })
    });
  }), createLanguage(require$$0$7, function (data) {
    return Object.assign(data, {
      name: "MDX",
      since: "1.15.0",
      parsers: ["mdx"],
      vscodeLanguageIds: ["mdx"],
      filenames: [],
      extensions: [".mdx"]
    });
  })];
  var printers$5 = {
    mdast: printerMarkdown
  };
  var languageMarkdown = {
    languages: languages$5,
    options: options$6,
    printers: printers$5
  };

  function isPragma(text) {
    return /^\s*@(prettier|format)\s*$/.test(text);
  }

  function hasPragma$4(text) {
    return /^\s*#[^\n\S]*@(prettier|format)\s*?(\n|$)/.test(text);
  }

  function insertPragma$8(text) {
    return "# @format\n\n".concat(text);
  }

  var pragma$5 = {
    isPragma: isPragma,
    hasPragma: hasPragma$4,
    insertPragma: insertPragma$8
  };

  var getLast$4 = util.getLast;

  function getAncestorCount(path, filter) {
    var counter = 0;
    var pathStackLength = path.stack.length - 1;

    for (var i = 0; i < pathStackLength; i++) {
      var value = path.stack[i];

      if (isNode(value) && filter(value)) {
        counter++;
      }
    }

    return counter;
  }
  /**
   * @param {any} value
   * @param {string[]=} types
   */


  function isNode(value, types) {
    return value && typeof value.type === "string" && (!types || types.indexOf(value.type) !== -1);
  }

  function mapNode(node, callback, parent) {
    return callback("children" in node ? Object.assign({}, node, {
      children: node.children.map(function (childNode) {
        return mapNode(childNode, callback, node);
      })
    }) : node, parent);
  }

  function defineShortcut(x, key, getter) {
    Object.defineProperty(x, key, {
      get: getter,
      enumerable: false
    });
  }

  function isNextLineEmpty$5(node, text) {
    var newlineCount = 0;
    var textLength = text.length;

    for (var i = node.position.end.offset - 1; i < textLength; i++) {
      var char = text[i];

      if (char === "\n") {
        newlineCount++;
      }

      if (newlineCount === 1 && /\S/.test(char)) {
        return false;
      }

      if (newlineCount === 2) {
        return true;
      }
    }

    return false;
  }

  function isLastDescendantNode(path) {
    var node = path.getValue();

    switch (node.type) {
      case "tag":
      case "anchor":
      case "comment":
        return false;
    }

    var pathStackLength = path.stack.length;

    for (var i = 1; i < pathStackLength; i++) {
      var item = path.stack[i];
      var parentItem = path.stack[i - 1];

      if (Array.isArray(parentItem) && typeof item === "number" && item !== parentItem.length - 1) {
        return false;
      }
    }

    return true;
  }

  function getLastDescendantNode$1(node) {
    return "children" in node && node.children.length !== 0 ? getLastDescendantNode$1(getLast$4(node.children)) : node;
  }

  function isPrettierIgnore$2(comment) {
    return comment.value.trim() === "prettier-ignore";
  }

  function hasPrettierIgnore$5(path) {
    var node = path.getValue();

    if (node.type === "documentBody") {
      var document = path.getParentNode();
      return hasEndComments(document.head) && isPrettierIgnore$2(getLast$4(document.head.endComments));
    }

    return hasLeadingComments(node) && isPrettierIgnore$2(getLast$4(node.leadingComments));
  }

  function isEmptyNode(node) {
    return (!node.children || node.children.length === 0) && !hasComments(node);
  }

  function hasComments(node) {
    return hasLeadingComments(node) || hasMiddleComments(node) || hasIndicatorComment(node) || hasTrailingComment$2(node) || hasEndComments(node);
  }

  function hasLeadingComments(node) {
    return node && node.leadingComments && node.leadingComments.length !== 0;
  }

  function hasMiddleComments(node) {
    return node && node.middleComments && node.middleComments.length !== 0;
  }

  function hasIndicatorComment(node) {
    return node && node.indicatorComment;
  }

  function hasTrailingComment$2(node) {
    return node && node.trailingComment;
  }

  function hasEndComments(node) {
    return node && node.endComments && node.endComments.length !== 0;
  }
  /**
   * " a   b c   d e   f " -> [" a   b", "c   d", "e   f "]
   */


  function splitWithSingleSpace(text) {
    var parts = [];
    var lastPart = undefined;
    var _iteratorNormalCompletion = true;
    var _didIteratorError = false;
    var _iteratorError = undefined;

    try {
      for (var _iterator = text.split(/( +)/g)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
        var part = _step.value;

        if (part !== " ") {
          if (lastPart === " ") {
            parts.push(part);
          } else {
            parts.push((parts.pop() || "") + part);
          }
        } else if (lastPart === undefined) {
          parts.unshift("");
        }

        lastPart = part;
      }
    } catch (err) {
      _didIteratorError = true;
      _iteratorError = err;
    } finally {
      try {
        if (!_iteratorNormalCompletion && _iterator.return != null) {
          _iterator.return();
        }
      } finally {
        if (_didIteratorError) {
          throw _iteratorError;
        }
      }
    }

    if (lastPart === " ") {
      parts.push((parts.pop() || "") + " ");
    }

    if (parts[0] === "") {
      parts.shift();
      parts.unshift(" " + (parts.shift() || ""));
    }

    return parts;
  }

  function getFlowScalarLineContents(nodeType, content, options) {
    var rawLineContents = content.split("\n").map(function (lineContent, index, lineContents) {
      return index === 0 && index === lineContents.length - 1 ? lineContent : index !== 0 && index !== lineContents.length - 1 ? lineContent.trim() : index === 0 ? lineContent.trimRight() : lineContent.trimLeft();
    });

    if (options.proseWrap === "preserve") {
      return rawLineContents.map(function (lineContent) {
        return lineContent.length === 0 ? [] : [lineContent];
      });
    }

    return rawLineContents.map(function (lineContent) {
      return lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent);
    }).reduce(function (reduced, lineContentWords, index) {
      return index !== 0 && rawLineContents[index - 1].length !== 0 && lineContentWords.length !== 0 && !( // trailing backslash in quoteDouble should be preserved
      nodeType === "quoteDouble" && getLast$4(getLast$4(reduced)).endsWith("\\")) ? reduced.concat([reduced.pop().concat(lineContentWords)]) : reduced.concat([lineContentWords]);
    }, []).map(function (lineContentWords) {
      return options.proseWrap === "never" ? [lineContentWords.join(" ")] : lineContentWords;
    });
  }

  function getBlockValueLineContents(node, _ref) {
    var parentIndent = _ref.parentIndent,
        isLastDescendant = _ref.isLastDescendant,
        options = _ref.options;
    var content = node.position.start.line === node.position.end.line ? "" : options.originalText.slice(node.position.start.offset, node.position.end.offset) // exclude open line `>` or `|`
    .match(/^[^\n]*?\n([\s\S]*)$/)[1];
    var leadingSpaceCount = node.indent === null ? function (match) {
      return match ? match[1].length : Infinity;
    }(content.match(/^( *)\S/m)) : node.indent - 1 + parentIndent;
    var rawLineContents = content.split("\n").map(function (lineContent) {
      return lineContent.slice(leadingSpaceCount);
    });

    if (options.proseWrap === "preserve" || node.type === "blockLiteral") {
      return removeUnnecessaryTrailingNewlines(rawLineContents.map(function (lineContent) {
        return lineContent.length === 0 ? [] : [lineContent];
      }));
    }

    return removeUnnecessaryTrailingNewlines(rawLineContents.map(function (lineContent) {
      return lineContent.length === 0 ? [] : splitWithSingleSpace(lineContent);
    }).reduce(function (reduced, lineContentWords, index) {
      return index !== 0 && rawLineContents[index - 1].length !== 0 && lineContentWords.length !== 0 && !/^\s/.test(lineContentWords[0]) && !/^\s|\s$/.test(getLast$4(reduced)) ? reduced.concat([reduced.pop().concat(lineContentWords)]) : reduced.concat([lineContentWords]);
    }, []).map(function (lineContentWords) {
      return lineContentWords.reduce(function (reduced, word) {
        return (// disallow trailing spaces
          reduced.length !== 0 && /\s$/.test(getLast$4(reduced)) ? reduced.concat(reduced.pop() + " " + word) : reduced.concat(word)
        );
      }, []);
    }).map(function (lineContentWords) {
      return options.proseWrap === "never" ? [lineContentWords.join(" ")] : lineContentWords;
    }));

    function removeUnnecessaryTrailingNewlines(lineContents) {
      if (node.chomping === "keep") {
        return getLast$4(lineContents).length === 0 ? lineContents.slice(0, -1) : lineContents;
      }

      var trailingNewlineCount = 0;

      for (var i = lineContents.length - 1; i >= 0; i--) {
        if (lineContents[i].length === 0) {
          trailingNewlineCount++;
        } else {
          break;
        }
      }

      return trailingNewlineCount === 0 ? lineContents : trailingNewlineCount >= 2 && !isLastDescendant ? // next empty line
      lineContents.slice(0, -(trailingNewlineCount - 1)) : lineContents.slice(0, -trailingNewlineCount);
    }
  }

  var utils$6 = {
    getLast: getLast$4,
    getAncestorCount: getAncestorCount,
    isNode: isNode,
    isEmptyNode: isEmptyNode,
    mapNode: mapNode,
    defineShortcut: defineShortcut,
    isNextLineEmpty: isNextLineEmpty$5,
    isLastDescendantNode: isLastDescendantNode,
    getBlockValueLineContents: getBlockValueLineContents,
    getFlowScalarLineContents: getFlowScalarLineContents,
    getLastDescendantNode: getLastDescendantNode$1,
    hasPrettierIgnore: hasPrettierIgnore$5,
    hasLeadingComments: hasLeadingComments,
    hasMiddleComments: hasMiddleComments,
    hasIndicatorComment: hasIndicatorComment,
    hasTrailingComment: hasTrailingComment$2,
    hasEndComments: hasEndComments
  };

  var insertPragma$9 = pragma$5.insertPragma,
      isPragma$1 = pragma$5.isPragma;
  var getAncestorCount$1 = utils$6.getAncestorCount,
      getBlockValueLineContents$1 = utils$6.getBlockValueLineContents,
      getFlowScalarLineContents$1 = utils$6.getFlowScalarLineContents,
      getLast$5 = utils$6.getLast,
      getLastDescendantNode$2 = utils$6.getLastDescendantNode,
      hasLeadingComments$1 = utils$6.hasLeadingComments,
      hasMiddleComments$1 = utils$6.hasMiddleComments,
      hasIndicatorComment$1 = utils$6.hasIndicatorComment,
      hasTrailingComment$3 = utils$6.hasTrailingComment,
      hasEndComments$1 = utils$6.hasEndComments,
      hasPrettierIgnore$6 = utils$6.hasPrettierIgnore,
      isLastDescendantNode$1 = utils$6.isLastDescendantNode,
      isNextLineEmpty$6 = utils$6.isNextLineEmpty,
      isNode$1 = utils$6.isNode,
      isEmptyNode$1 = utils$6.isEmptyNode,
      defineShortcut$1 = utils$6.defineShortcut,
      mapNode$1 = utils$6.mapNode;
  var docBuilders$2 = doc.builders;
  var conditionalGroup$2 = docBuilders$2.conditionalGroup,
      breakParent$5 = docBuilders$2.breakParent,
      concat$h = docBuilders$2.concat,
      dedent$3 = docBuilders$2.dedent,
      dedentToRoot$3 = docBuilders$2.dedentToRoot,
      fill$6 = docBuilders$2.fill,
      group$g = docBuilders$2.group,
      hardline$d = docBuilders$2.hardline,
      ifBreak$8 = docBuilders$2.ifBreak,
      join$c = docBuilders$2.join,
      line$9 = docBuilders$2.line,
      lineSuffix$2 = docBuilders$2.lineSuffix,
      literalline$7 = docBuilders$2.literalline,
      markAsRoot$5 = docBuilders$2.markAsRoot,
      softline$8 = docBuilders$2.softline;
  var replaceEndOfLineWith$3 = util.replaceEndOfLineWith;

  function preprocess$3(ast) {
    return mapNode$1(ast, defineShortcuts);
  }

  function defineShortcuts(node) {
    switch (node.type) {
      case "document":
        defineShortcut$1(node, "head", function () {
          return node.children[0];
        });
        defineShortcut$1(node, "body", function () {
          return node.children[1];
        });
        break;

      case "documentBody":
      case "sequenceItem":
      case "flowSequenceItem":
      case "mappingKey":
      case "mappingValue":
        defineShortcut$1(node, "content", function () {
          return node.children[0];
        });
        break;

      case "mappingItem":
      case "flowMappingItem":
        defineShortcut$1(node, "key", function () {
          return node.children[0];
        });
        defineShortcut$1(node, "value", function () {
          return node.children[1];
        });
        break;
    }

    return node;
  }

  function genericPrint$6(path, options, print) {
    var node = path.getValue();
    var parentNode = path.getParentNode();
    var tag = !node.tag ? "" : path.call(print, "tag");
    var anchor = !node.anchor ? "" : path.call(print, "anchor");
    var nextEmptyLine = isNode$1(node, ["mapping", "sequence", "comment", "directive", "mappingItem", "sequenceItem"]) && !isLastDescendantNode$1(path) ? printNextEmptyLine(path, options.originalText) : "";
    return concat$h([node.type !== "mappingValue" && hasLeadingComments$1(node) ? concat$h([join$c(hardline$d, path.map(print, "leadingComments")), hardline$d]) : "", tag, tag && anchor ? " " : "", anchor, tag || anchor ? isNode$1(node, ["sequence", "mapping"]) && !hasMiddleComments$1(node) ? hardline$d : " " : "", hasMiddleComments$1(node) ? concat$h([node.middleComments.length === 1 ? "" : hardline$d, join$c(hardline$d, path.map(print, "middleComments")), hardline$d]) : "", hasPrettierIgnore$6(path) ? concat$h(replaceEndOfLineWith$3(options.originalText.slice(node.position.start.offset, node.position.end.offset), literalline$7)) : group$g(_print(node, parentNode, path, options, print)), hasTrailingComment$3(node) && !isNode$1(node, ["document", "documentHead"]) ? lineSuffix$2(concat$h([node.type === "mappingValue" && !node.content ? "" : " ", parentNode.type === "mappingKey" && path.getParentNode(2).type === "mapping" && isInlineNode$1(node) ? "" : breakParent$5, path.call(print, "trailingComment")])) : "", nextEmptyLine, hasEndComments$1(node) && !isNode$1(node, ["documentHead", "documentBody"]) ? align$3(node.type === "sequenceItem" ? 2 : 0, concat$h([hardline$d, join$c(hardline$d, path.map(print, "endComments"))])) : ""]);
  }

  function _print(node, parentNode, path, options, print) {
    switch (node.type) {
      case "root":
        return concat$h([join$c(hardline$d, path.map(function (childPath, index) {
          var document = node.children[index];
          var nextDocument = node.children[index + 1];
          return concat$h([print(childPath), shouldPrintDocumentEndMarker(document, nextDocument) ? concat$h([hardline$d, "...", hasTrailingComment$3(document) ? concat$h([" ", path.call(print, "trailingComment")]) : ""]) : !nextDocument || hasTrailingComment$3(nextDocument.head) ? "" : concat$h([hardline$d, "---"])]);
        }, "children")), node.children.length === 0 || function (lastDescendantNode) {
          return isNode$1(lastDescendantNode, ["blockLiteral", "blockFolded"]) && lastDescendantNode.chomping === "keep";
        }(getLastDescendantNode$2(node)) ? "" : hardline$d]);

      case "document":
        {
          var nextDocument = parentNode.children[path.getName() + 1];
          return join$c(hardline$d, [shouldPrintDocumentHeadEndMarker(node, nextDocument, parentNode, options) === "head" ? join$c(hardline$d, [node.head.children.length === 0 && node.head.endComments.length === 0 ? "" : path.call(print, "head"), concat$h(["---", hasTrailingComment$3(node.head) ? concat$h([" ", path.call(print, "head", "trailingComment")]) : ""])].filter(Boolean)) : "", shouldPrintDocumentBody(node) ? path.call(print, "body") : ""].filter(Boolean));
        }

      case "documentHead":
        return join$c(hardline$d, [].concat(path.map(print, "children"), path.map(print, "endComments")));

      case "documentBody":
        {
          var children = join$c(hardline$d, path.map(print, "children")).parts;
          var endComments = join$c(hardline$d, path.map(print, "endComments")).parts;
          var separator = children.length === 0 || endComments.length === 0 ? "" : function (lastDescendantNode) {
            return isNode$1(lastDescendantNode, ["blockFolded", "blockLiteral"]) ? lastDescendantNode.chomping === "keep" ? // there's already a newline printed at the end of blockValue (chomping=keep, lastDescendant=true)
            "" : // an extra newline for better readability
            concat$h([hardline$d, hardline$d]) : hardline$d;
          }(getLastDescendantNode$2(node));
          return concat$h([].concat(children, separator, endComments));
        }

      case "directive":
        return concat$h(["%", join$c(" ", [node.name].concat(node.parameters))]);

      case "comment":
        return concat$h(["#", node.value]);

      case "alias":
        return concat$h(["*", node.value]);

      case "tag":
        return options.originalText.slice(node.position.start.offset, node.position.end.offset);

      case "anchor":
        return concat$h(["&", node.value]);

      case "plain":
        return printFlowScalarContent(node.type, options.originalText.slice(node.position.start.offset, node.position.end.offset), options);

      case "quoteDouble":
      case "quoteSingle":
        {
          var singleQuote = "'";
          var doubleQuote = '"';
          var raw = options.originalText.slice(node.position.start.offset + 1, node.position.end.offset - 1);

          if (node.type === "quoteSingle" && raw.includes("\\") || node.type === "quoteDouble" && /\\[^"]/.test(raw)) {
            // only quoteDouble can use escape chars
            // and quoteSingle do not need to escape backslashes
            var originalQuote = node.type === "quoteDouble" ? doubleQuote : singleQuote;
            return concat$h([originalQuote, printFlowScalarContent(node.type, raw, options), originalQuote]);
          } else if (raw.includes(doubleQuote)) {
            return concat$h([singleQuote, printFlowScalarContent(node.type, node.type === "quoteDouble" ? raw // double quote needs to be escaped by backslash in quoteDouble
            .replace(/\\"/g, doubleQuote).replace(/'/g, singleQuote.repeat(2)) : raw, options), singleQuote]);
          }

          if (raw.includes(singleQuote)) {
            return concat$h([doubleQuote, printFlowScalarContent(node.type, node.type === "quoteSingle" ? // single quote needs to be escaped by 2 single quotes in quoteSingle
            raw.replace(/''/g, singleQuote) : raw, options), doubleQuote]);
          }

          var quote = options.singleQuote ? singleQuote : doubleQuote;
          return concat$h([quote, printFlowScalarContent(node.type, raw, options), quote]);
        }

      case "blockFolded":
      case "blockLiteral":
        {
          var parentIndent = getAncestorCount$1(path, function (ancestorNode) {
            return isNode$1(ancestorNode, ["sequence", "mapping"]);
          });
          var isLastDescendant = isLastDescendantNode$1(path);
          return concat$h([node.type === "blockFolded" ? ">" : "|", node.indent === null ? "" : node.indent.toString(), node.chomping === "clip" ? "" : node.chomping === "keep" ? "+" : "-", hasIndicatorComment$1(node) ? concat$h([" ", path.call(print, "indicatorComment")]) : "", (node.indent === null ? dedent$3 : dedentToRoot$3)(align$3(node.indent === null ? options.tabWidth : node.indent - 1 + parentIndent, concat$h(getBlockValueLineContents$1(node, {
            parentIndent: parentIndent,
            isLastDescendant: isLastDescendant,
            options: options
          }).reduce(function (reduced, lineWords, index, lineContents) {
            return reduced.concat(index === 0 ? hardline$d : "", fill$6(join$c(line$9, lineWords).parts), index !== lineContents.length - 1 ? lineWords.length === 0 ? hardline$d : markAsRoot$5(literalline$7) : node.chomping === "keep" && isLastDescendant ? lineWords.length === 0 ? dedentToRoot$3(hardline$d) : dedentToRoot$3(literalline$7) : "");
          }, []))))]);
        }

      case "sequence":
        return join$c(hardline$d, path.map(print, "children"));

      case "sequenceItem":
        return concat$h(["- ", align$3(2, !node.content ? "" : path.call(print, "content"))]);

      case "mappingKey":
        return !node.content ? "" : path.call(print, "content");

      case "mappingValue":
        return !node.content ? "" : path.call(print, "content");

      case "mapping":
        return join$c(hardline$d, path.map(print, "children"));

      case "mappingItem":
      case "flowMappingItem":
        {
          var isEmptyMappingKey = isEmptyNode$1(node.key);
          var isEmptyMappingValue = isEmptyNode$1(node.value);

          if (isEmptyMappingKey && isEmptyMappingValue) {
            return concat$h([": "]);
          }

          var key = path.call(print, "key");
          var value = path.call(print, "value");

          if (isEmptyMappingValue) {
            return node.type === "flowMappingItem" && parentNode.type === "flowMapping" ? key : node.type === "mappingItem" && isAbsolutelyPrintedAsSingleLineNode(node.key.content, options) && !hasTrailingComment$3(node.key.content) && (!parentNode.tag || parentNode.tag.value !== "tag:yaml.org,2002:set") ? concat$h([key, needsSpaceInFrontOfMappingValue(node) ? " " : "", ":"]) : concat$h(["? ", align$3(2, key)]);
          }

          if (isEmptyMappingKey) {
            return concat$h([": ", align$3(2, value)]);
          }

          var groupId = Symbol("mappingKey");
          var forceExplicitKey = hasLeadingComments$1(node.value) || !isInlineNode$1(node.key.content);
          return forceExplicitKey ? concat$h(["? ", align$3(2, key), hardline$d, join$c("", path.map(print, "value", "leadingComments").map(function (comment) {
            return concat$h([comment, hardline$d]);
          })), ": ", align$3(2, value)]) : // force singleline
          isSingleLineNode(node.key.content) && !hasLeadingComments$1(node.key.content) && !hasMiddleComments$1(node.key.content) && !hasTrailingComment$3(node.key.content) && !hasEndComments$1(node.key) && !hasLeadingComments$1(node.value.content) && !hasMiddleComments$1(node.value.content) && !hasEndComments$1(node.value) && isAbsolutelyPrintedAsSingleLineNode(node.value.content, options) ? concat$h([key, needsSpaceInFrontOfMappingValue(node) ? " " : "", ": ", value]) : conditionalGroup$2([concat$h([group$g(concat$h([ifBreak$8("? "), group$g(align$3(2, key), {
            id: groupId
          })])), ifBreak$8(concat$h([hardline$d, ": ", align$3(2, value)]), indent(concat$h([needsSpaceInFrontOfMappingValue(node) ? " " : "", ":", hasLeadingComments$1(node.value.content) || hasEndComments$1(node.value) && node.value.content && !isNode$1(node.value.content, ["mapping", "sequence"]) || parentNode.type === "mapping" && hasTrailingComment$3(node.key.content) && isInlineNode$1(node.value.content) || isNode$1(node.value.content, ["mapping", "sequence"]) && node.value.content.tag === null && node.value.content.anchor === null ? hardline$d : !node.value.content ? "" : line$9, value])), {
            groupId: groupId
          })])]);
        }

      case "flowMapping":
      case "flowSequence":
        {
          var openMarker = node.type === "flowMapping" ? "{" : "[";
          var closeMarker = node.type === "flowMapping" ? "}" : "]";
          var bracketSpacing = node.type === "flowMapping" && node.children.length !== 0 && options.bracketSpacing ? line$9 : softline$8;

          var isLastItemEmptyMappingItem = node.children.length !== 0 && function (lastItem) {
            return lastItem.type === "flowMappingItem" && isEmptyNode$1(lastItem.key) && isEmptyNode$1(lastItem.value);
          }(getLast$5(node.children));

          return concat$h([openMarker, indent(concat$h([bracketSpacing, concat$h(path.map(function (childPath, index) {
            return concat$h([print(childPath), index === node.children.length - 1 ? "" : concat$h([",", line$9, node.children[index].position.start.line !== node.children[index + 1].position.start.line ? printNextEmptyLine(childPath, options.originalText) : ""])]);
          }, "children")), ifBreak$8(",", "")])), isLastItemEmptyMappingItem ? "" : bracketSpacing, closeMarker]);
        }

      case "flowSequenceItem":
        return path.call(print, "content");
      // istanbul ignore next

      default:
        throw new Error("Unexpected node type ".concat(node.type));
    }

    function indent(doc) {
      return docBuilders$2.align(" ".repeat(options.tabWidth), doc);
    }
  }

  function align$3(n, doc) {
    return typeof n === "number" && n > 0 ? docBuilders$2.align(" ".repeat(n), doc) : docBuilders$2.align(n, doc);
  }

  function isInlineNode$1(node) {
    if (!node) {
      return true;
    }

    switch (node.type) {
      case "plain":
      case "quoteDouble":
      case "quoteSingle":
      case "alias":
      case "flowMapping":
      case "flowSequence":
        return true;

      default:
        return false;
    }
  }

  function isSingleLineNode(node) {
    if (!node) {
      return true;
    }

    switch (node.type) {
      case "plain":
      case "quoteDouble":
      case "quoteSingle":
        return node.position.start.line === node.position.end.line;

      case "alias":
        return true;

      default:
        return false;
    }
  }

  function shouldPrintDocumentBody(document) {
    return document.body.children.length !== 0 || hasEndComments$1(document.body);
  }

  function shouldPrintDocumentEndMarker(document, nextDocument) {
    return (
      /**
       *... # trailingComment
       */
      hasTrailingComment$3(document) || nextDocument && (
      /**
       * ...
       * %DIRECTIVE
       * ---
       */
      nextDocument.head.children.length !== 0 ||
      /**
       * ...
       * # endComment
       * ---
       */
      hasEndComments$1(nextDocument.head))
    );
  }

  function shouldPrintDocumentHeadEndMarker(document, nextDocument, root, options) {
    if (
    /**
     * ---
     * preserve the first document head end marker
     */
    root.children[0] === document && /---(\s|$)/.test(options.originalText.slice(options.locStart(document), options.locStart(document) + 4)) ||
    /**
     * %DIRECTIVE
     * ---
     */
    document.head.children.length !== 0 ||
    /**
     * # end comment
     * ---
     */
    hasEndComments$1(document.head) ||
    /**
     * --- # trailing comment
     */
    hasTrailingComment$3(document.head)) {
      return "head";
    }

    if (shouldPrintDocumentEndMarker(document, nextDocument)) {
      return false;
    }

    return nextDocument ? "root" : false;
  }

  function isAbsolutelyPrintedAsSingleLineNode(node, options) {
    if (!node) {
      return true;
    }

    switch (node.type) {
      case "plain":
      case "quoteSingle":
      case "quoteDouble":
        break;

      case "alias":
        return true;

      default:
        return false;
    }

    if (options.proseWrap === "preserve") {
      return node.position.start.line === node.position.end.line;
    }

    if ( // backslash-newline
    /\\$/m.test(options.originalText.slice(node.position.start.offset, node.position.end.offset))) {
      return false;
    }

    switch (options.proseWrap) {
      case "never":
        return node.value.indexOf("\n") === -1;

      case "always":
        return !/[\n ]/.test(node.value);
      // istanbul ignore next

      default:
        return false;
    }
  }

  function needsSpaceInFrontOfMappingValue(node) {
    return node.key.content && node.key.content.type === "alias";
  }

  function printNextEmptyLine(path, originalText) {
    var node = path.getValue();
    var root = path.stack[0];
    root.isNextEmptyLinePrintedChecklist = root.isNextEmptyLinePrintedChecklist || [];

    if (!root.isNextEmptyLinePrintedChecklist[node.position.end.line]) {
      if (isNextLineEmpty$6(node, originalText)) {
        root.isNextEmptyLinePrintedChecklist[node.position.end.line] = true;
        return softline$8;
      }
    }

    return "";
  }

  function printFlowScalarContent(nodeType, content, options) {
    var lineContents = getFlowScalarLineContents$1(nodeType, content, options);
    return join$c(hardline$d, lineContents.map(function (lineContentWords) {
      return fill$6(join$c(line$9, lineContentWords).parts);
    }));
  }

  function clean$7(node, newNode
  /*, parent */
  ) {
    if (isNode$1(newNode)) {
      delete newNode.position;

      switch (newNode.type) {
        case "comment":
          // insert pragma
          if (isPragma$1(newNode.value)) {
            return null;
          }

          break;

        case "quoteDouble":
        case "quoteSingle":
          newNode.type = "quote";
          break;
      }
    }
  }

  var printerYaml = {
    preprocess: preprocess$3,
    print: genericPrint$6,
    massageAstNode: clean$7,
    insertPragma: insertPragma$9
  };

  var options$7 = {
    bracketSpacing: commonOptions.bracketSpacing,
    singleQuote: commonOptions.singleQuote,
    proseWrap: commonOptions.proseWrap
  };

  var name$h = "YAML";
  var type$g = "data";
  var tmScope$g = "source.yaml";
  var aliases$6 = [
  	"yml"
  ];
  var extensions$g = [
  	".yml",
  	".mir",
  	".reek",
  	".rviz",
  	".sublime-syntax",
  	".syntax",
  	".yaml",
  	".yaml-tmlanguage",
  	".yml.mysql"
  ];
  var filenames$4 = [
  	".clang-format",
  	".clang-tidy",
  	".gemrc",
  	"glide.lock"
  ];
  var aceMode$g = "yaml";
  var codemirrorMode$c = "yaml";
  var codemirrorMimeType$c = "text/x-yaml";
  var languageId$g = 407;
  var YAML = {
  	name: name$h,
  	type: type$g,
  	tmScope: tmScope$g,
  	aliases: aliases$6,
  	extensions: extensions$g,
  	filenames: filenames$4,
  	aceMode: aceMode$g,
  	codemirrorMode: codemirrorMode$c,
  	codemirrorMimeType: codemirrorMimeType$c,
  	languageId: languageId$g
  };

  var YAML$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    name: name$h,
    type: type$g,
    tmScope: tmScope$g,
    aliases: aliases$6,
    extensions: extensions$g,
    filenames: filenames$4,
    aceMode: aceMode$g,
    codemirrorMode: codemirrorMode$c,
    codemirrorMimeType: codemirrorMimeType$c,
    languageId: languageId$g,
    'default': YAML
  });

  var require$$0$8 = getCjsExportFromNamespace(YAML$1);

  var languages$6 = [createLanguage(require$$0$8, function (data) {
    return Object.assign(data, {
      since: "1.14.0",
      parsers: ["yaml"],
      vscodeLanguageIds: ["yaml"]
    });
  })];
  var languageYaml = {
    languages: languages$6,
    printers: {
      yaml: printerYaml
    },
    options: options$7
  };

  var version$2 = require$$0.version;
  var getSupportInfo$2 = support.getSupportInfo;
  var internalPlugins = [languageCss, languageGraphql, languageHandlebars, languageHtml, languageJs, languageMarkdown, languageYaml];

  var isArray$1 = Array.isArray || function (arr) {
    return Object.prototype.toString.call(arr) === "[object Array]";
  }; // Luckily `opts` is always the 2nd argument


  function withPlugins(fn) {
    return function () {
      var args = Array.from(arguments);
      var plugins = args[1] && args[1].plugins || [];

      if (!isArray$1(plugins)) {
        plugins = Object.values(plugins);
      }

      args[1] = Object.assign({}, args[1], {
        plugins: internalPlugins.concat(plugins)
      });
      return fn.apply(null, args);
    };
  }

  var formatWithCursor = withPlugins(core.formatWithCursor);
  var standalone = {
    formatWithCursor: formatWithCursor,
    format: function format(text, opts) {
      return formatWithCursor(text, opts).formatted;
    },
    check: function check(text, opts) {
      var formatted = formatWithCursor(text, opts).formatted;
      return formatted === text;
    },
    doc: doc,
    getSupportInfo: withPlugins(getSupportInfo$2),
    version: version$2,
    util: utilShared,
    __debug: {
      parse: withPlugins(core.parse),
      formatAST: withPlugins(core.formatAST),
      formatDoc: withPlugins(core.formatDoc),
      printToDoc: withPlugins(core.printToDoc),
      printDocToString: withPlugins(core.printDocToString)
    }
  };

  var standalone$1 = standalone;

  return standalone$1;

})));


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

!function(e,t){ true?t(exports):undefined}(this,(function(e){"use strict";var t=function(e,t){var n=new SyntaxError(e+" ("+t.start.line+":"+t.start.column+")");return n.loc=t,n};var n=function(e){return/^\s*#[^\n\S]*@(prettier|format)\s*?(\n|$)/.test(e)},r="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:{};function a(e){return e&&e.__esModule&&Object.prototype.hasOwnProperty.call(e,"default")?e.default:e}function o(e,t){return e(t={exports:{}},t.exports),t.exports}function i(e){return(i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function s(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}function u(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}function f(e,t,n){return t&&u(e.prototype,t),n&&u(e,n),e}function l(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function");e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,writable:!0,configurable:!0}}),t&&d(e,t)}function c(e){return(c=Object.setPrototypeOf?Object.getPrototypeOf:function(e){return e.__proto__||Object.getPrototypeOf(e)})(e)}function d(e,t){return(d=Object.setPrototypeOf||function(e,t){return e.__proto__=t,e})(e,t)}function h(e,t,n){return(h=function(){if("undefined"==typeof Reflect||!Reflect.construct)return!1;if(Reflect.construct.sham)return!1;if("function"==typeof Proxy)return!0;try{return Date.prototype.toString.call(Reflect.construct(Date,[],(function(){}))),!0}catch(e){return!1}}()?Reflect.construct:function(e,t,n){var r=[null];r.push.apply(r,t);var a=new(Function.bind.apply(e,r));return n&&d(a,n.prototype),a}).apply(null,arguments)}function p(e){var t="function"==typeof Map?new Map:void 0;return(p=function(e){if(null===e||(n=e,-1===Function.toString.call(n).indexOf("[native code]")))return e;var n;if("function"!=typeof e)throw new TypeError("Super expression must either be null or a function");if(void 0!==t){if(t.has(e))return t.get(e);t.set(e,r)}function r(){return h(e,arguments,c(this).constructor)}return r.prototype=Object.create(e.prototype,{constructor:{value:r,enumerable:!1,writable:!0,configurable:!0}}),d(r,e)})(e)}function v(e){if(void 0===e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return e}function g(e,t){return!t||"object"!=typeof t&&"function"!=typeof t?v(e):t}function m(e,t,n){return(m="undefined"!=typeof Reflect&&Reflect.get?Reflect.get:function(e,t,n){var r=function(e,t){for(;!Object.prototype.hasOwnProperty.call(e,t)&&null!==(e=c(e)););return e}(e,t);if(r){var a=Object.getOwnPropertyDescriptor(r,t);return a.get?a.get.call(n):a.value}})(e,t,n||e)}function y(e,t){return b(e)||function(e,t){if(!(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e)))return;var n=[],r=!0,a=!1,o=void 0;try{for(var i,s=e[Symbol.iterator]();!(r=(i=s.next()).done)&&(n.push(i.value),!t||n.length!==t);r=!0);}catch(e){a=!0,o=e}finally{try{r||null==s.return||s.return()}finally{if(a)throw o}}return n}(e,t)||w()}function _(e){return b(e)||function(e){if(Symbol.iterator in Object(e)||"[object Arguments]"===Object.prototype.toString.call(e))return Array.from(e)}(e)||w()}function b(e){if(Array.isArray(e))return e}function w(){throw new TypeError("Invalid attempt to destructure non-iterable instance")}
/*! *****************************************************************************
  Copyright (c) Microsoft Corporation. All rights reserved.
  Licensed under the Apache License, Version 2.0 (the "License"); you may not use
  this file except in compliance with the License. You may obtain a copy of the
  License at http://www.apache.org/licenses/LICENSE-2.0

  THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
  KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
  WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
  MERCHANTABLITY OR NON-INFRINGEMENT.

  See the Apache Version 2.0 License for specific language governing permissions
  and limitations under the License.
  ***************************************************************************** */var E=function(e,t){return(E=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(e,t)};var O=function(){return(O=Object.assign||function(e){for(var t,n=1,r=arguments.length;n<r;n++)for(var a in t=arguments[n])Object.prototype.hasOwnProperty.call(t,a)&&(e[a]=t[a]);return e}).apply(this,arguments)};function M(e){var t="function"==typeof Symbol&&e[Symbol.iterator],n=0;return t?t.call(e):{next:function(){return e&&n>=e.length&&(e=void 0),{value:e&&e[n++],done:!e}}}}function S(e,t){var n="function"==typeof Symbol&&e[Symbol.iterator];if(!n)return e;var r,a,o=n.call(e),i=[];try{for(;(void 0===t||t-- >0)&&!(r=o.next()).done;)i.push(r.value)}catch(e){a={error:e}}finally{try{r&&!r.done&&(n=o.return)&&n.call(o)}finally{if(a)throw a.error}}return i}function A(e){return this instanceof A?(this.v=e,this):new A(e)}var k=Object.freeze({__proto__:null,__extends:function(e,t){function n(){this.constructor=e}E(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)},get __assign(){return O},__rest:function(e,t){var n={};for(var r in e)Object.prototype.hasOwnProperty.call(e,r)&&t.indexOf(r)<0&&(n[r]=e[r]);if(null!=e&&"function"==typeof Object.getOwnPropertySymbols){var a=0;for(r=Object.getOwnPropertySymbols(e);a<r.length;a++)t.indexOf(r[a])<0&&Object.prototype.propertyIsEnumerable.call(e,r[a])&&(n[r[a]]=e[r[a]])}return n},__decorate:function(e,t,n,r){var a,o=arguments.length,s=o<3?t:null===r?r=Object.getOwnPropertyDescriptor(t,n):r;if("object"===("undefined"==typeof Reflect?"undefined":i(Reflect))&&"function"==typeof Reflect.decorate)s=Reflect.decorate(e,t,n,r);else for(var u=e.length-1;u>=0;u--)(a=e[u])&&(s=(o<3?a(s):o>3?a(t,n,s):a(t,n))||s);return o>3&&s&&Object.defineProperty(t,n,s),s},__param:function(e,t){return function(n,r){t(n,r,e)}},__metadata:function(e,t){if("object"===("undefined"==typeof Reflect?"undefined":i(Reflect))&&"function"==typeof Reflect.metadata)return Reflect.metadata(e,t)},__awaiter:function(e,t,n,r){return new(n||(n=Promise))((function(a,o){function i(e){try{u(r.next(e))}catch(e){o(e)}}function s(e){try{u(r.throw(e))}catch(e){o(e)}}function u(e){e.done?a(e.value):new n((function(t){t(e.value)})).then(i,s)}u((r=r.apply(e,t||[])).next())}))},__generator:function(e,t){var n,r,a,o,i={label:0,sent:function(){if(1&a[0])throw a[1];return a[1]},trys:[],ops:[]};return o={next:s(0),throw:s(1),return:s(2)},"function"==typeof Symbol&&(o[Symbol.iterator]=function(){return this}),o;function s(o){return function(s){return function(o){if(n)throw new TypeError("Generator is already executing.");for(;i;)try{if(n=1,r&&(a=2&o[0]?r.return:o[0]?r.throw||((a=r.return)&&a.call(r),0):r.next)&&!(a=a.call(r,o[1])).done)return a;switch(r=0,a&&(o=[2&o[0],a.value]),o[0]){case 0:case 1:a=o;break;case 4:return i.label++,{value:o[1],done:!1};case 5:i.label++,r=o[1],o=[0];continue;case 7:o=i.ops.pop(),i.trys.pop();continue;default:if(!(a=(a=i.trys).length>0&&a[a.length-1])&&(6===o[0]||2===o[0])){i=0;continue}if(3===o[0]&&(!a||o[1]>a[0]&&o[1]<a[3])){i.label=o[1];break}if(6===o[0]&&i.label<a[1]){i.label=a[1],a=o;break}if(a&&i.label<a[2]){i.label=a[2],i.ops.push(o);break}a[2]&&i.ops.pop(),i.trys.pop();continue}o=t.call(e,i)}catch(e){o=[6,e],r=0}finally{n=a=0}if(5&o[0])throw o[1];return{value:o[0]?o[1]:void 0,done:!0}}([o,s])}}},__exportStar:function(e,t){for(var n in e)t.hasOwnProperty(n)||(t[n]=e[n])},__values:M,__read:S,__spread:function(){for(var e=[],t=0;t<arguments.length;t++)e=e.concat(S(arguments[t]));return e},__spreadArrays:function(){for(var e=0,t=0,n=arguments.length;t<n;t++)e+=arguments[t].length;var r=Array(e),a=0;for(t=0;t<n;t++)for(var o=arguments[t],i=0,s=o.length;i<s;i++,a++)r[a]=o[i];return r},__await:A,__asyncGenerator:function(e,t,n){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var r,a=n.apply(e,t||[]),o=[];return r={},i("next"),i("throw"),i("return"),r[Symbol.asyncIterator]=function(){return this},r;function i(e){a[e]&&(r[e]=function(t){return new Promise((function(n,r){o.push([e,t,n,r])>1||s(e,t)}))})}function s(e,t){try{(n=a[e](t)).value instanceof A?Promise.resolve(n.value.v).then(u,f):l(o[0][2],n)}catch(e){l(o[0][3],e)}var n}function u(e){s("next",e)}function f(e){s("throw",e)}function l(e,t){e(t),o.shift(),o.length&&s(o[0][0],o[0][1])}},__asyncDelegator:function(e){var t,n;return t={},r("next"),r("throw",(function(e){throw e})),r("return"),t[Symbol.iterator]=function(){return this},t;function r(r,a){t[r]=e[r]?function(t){return(n=!n)?{value:A(e[r](t)),done:"return"===r}:a?a(t):t}:a}},__asyncValues:function(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var t,n=e[Symbol.asyncIterator];return n?n.call(e):(e=M(e),t={},r("next"),r("throw"),r("return"),t[Symbol.asyncIterator]=function(){return this},t);function r(n){t[n]=e[n]&&function(t){return new Promise((function(r,a){(function(e,t,n,r){Promise.resolve(r).then((function(t){e({value:t,done:n})}),t)})(r,a,(t=e[n](t)).done,t.value)}))}}},__makeTemplateObject:function(e,t){return Object.defineProperty?Object.defineProperty(e,"raw",{value:t}):e.raw=t,e},__importStar:function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)Object.hasOwnProperty.call(e,n)&&(t[n]=e[n]);return t.default=e,t},__importDefault:function(e){return e&&e.__esModule?e:{default:e}}}),L=o((function(e,t){var n="\n",r="\r",a=function(){function e(e){this.string=e;for(var t=[0],a=0;a<e.length;)switch(e[a]){case n:a+=n.length,t.push(a);break;case r:e[a+=r.length]===n&&(a+=n.length),t.push(a);break;default:a++}this.offsets=t}return e.prototype.locationForIndex=function(e){if(e<0||e>this.string.length)return null;for(var t=0,n=this.offsets;n[t+1]<=e;)t++;return{line:t,column:e-n[t]}},e.prototype.indexForLocation=function(e){var t=e.line,n=e.column;return t<0||t>=this.offsets.length?null:n<0||n>this.lengthOfLine(t)?null:this.offsets[t]+n},e.prototype.lengthOfLine=function(e){var t=this.offsets[e];return(e===this.offsets.length-1?this.string.length:this.offsets[e+1])-t},e}();t.__esModule=!0,t.default=a}));a(L);var T=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.Type=t.Char=void 0;t.Char={ANCHOR:"&",COMMENT:"#",TAG:"!",DIRECTIVES_END:"-",DOCUMENT_END:"."};t.Type={ALIAS:"ALIAS",BLANK_LINE:"BLANK_LINE",BLOCK_FOLDED:"BLOCK_FOLDED",BLOCK_LITERAL:"BLOCK_LITERAL",COMMENT:"COMMENT",DIRECTIVE:"DIRECTIVE",DOCUMENT:"DOCUMENT",FLOW_MAP:"FLOW_MAP",FLOW_SEQ:"FLOW_SEQ",MAP:"MAP",MAP_KEY:"MAP_KEY",MAP_VALUE:"MAP_VALUE",PLAIN:"PLAIN",QUOTE_DOUBLE:"QUOTE_DOUBLE",QUOTE_SINGLE:"QUOTE_SINGLE",SEQ:"SEQ",SEQ_ITEM:"SEQ_ITEM"}}));a(T);T.Type,T.Char;var P=o((function(e,t){function n(e){for(var t=[0],n=e.indexOf("\n");-1!==n;)n+=1,t.push(n),n=e.indexOf("\n",n);return t}function r(e){var t,r;return"string"==typeof e?(t=n(e),r=e):(Array.isArray(e)&&(e=e[0]),e&&e.context&&(e.lineStarts||(e.lineStarts=n(e.context.src)),t=e.lineStarts,r=e.context.src)),{lineStarts:t,src:r}}function a(e,t){var n=r(t),a=n.lineStarts,o=n.src;if(!a||!(e>=1)||e>a.length)return null;for(var i=a[e-1],s=a[e];s&&s>i&&"\n"===o[s-1];)--s;return o.slice(i,s)}Object.defineProperty(t,"__esModule",{value:!0}),t.getLinePos=function(e,t){if("number"!=typeof e||e<0)return null;var n=r(t),a=n.lineStarts,o=n.src;if(!a||!o||e>o.length)return null;for(var i=0;i<a.length;++i){var s=a[i];if(e<s)return{line:i,col:e-a[i-1]+1};if(e===s)return{line:i+1,col:1}}var u=a.length;return{line:u,col:e-a[u-1]+1}},t.getLine=a,t.getPrettyContext=function(e,t){var n=e.start,r=e.end,o=arguments.length>2&&void 0!==arguments[2]?arguments[2]:80,i=a(n.line,t);if(!i)return null;var s=n.col;if(i.length>o)if(s<=o-10)i=i.substr(0,o-1)+"";else{var u=Math.round(o/2);i.length>s+u&&(i=i.substr(0,s+u-1)+""),s-=i.length-o,i=""+i.substr(1-o)}var f=1,l="";r&&(r.line===n.line&&s+(r.col-n.col)<=o+1?f=r.col-n.col:(f=Math.min(i.length+1,o)-s,l=""));var c=s>1?" ".repeat(s-1):"",d="^".repeat(f);return"".concat(i,"\n").concat(c).concat(d).concat(l)}}));a(P);P.getLinePos,P.getLine,P.getPrettyContext;var C=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=function(){function e(t,n){s(this,e),this.start=t,this.end=n||t}return f(e,null,[{key:"copy",value:function(t){return new e(t.start,t.end)}}]),f(e,[{key:"isEmpty",value:function(){return"number"!=typeof this.start||!this.end||this.end<=this.start}},{key:"setOrigRange",value:function(e,t){var n=this.start,r=this.end;if(0===e.length||r<=e[0])return this.origStart=n,this.origEnd=r,t;for(var a=t;a<e.length&&!(e[a]>n);)++a;this.origStart=n+a;for(var o=a;a<e.length&&!(e[a]>=r);)++a;return this.origEnd=r+a,o}}]),e}();t.default=n}));a(C);var N=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n,r=(n=C)&&n.__esModule?n:{default:n};var a=function(){function e(t,n,r){s(this,e),Object.defineProperty(this,"context",{value:r||null,writable:!0}),this.error=null,this.range=null,this.valueRange=null,this.props=n||[],this.type=t,this.value=null}return f(e,null,[{key:"addStringTerminator",value:function(t,n,r){if("\n"===r[r.length-1])return r;var a=e.endOfWhiteSpace(t,n);return a>=t.length||"\n"===t[a]?r+"\n":r}},{key:"atDocumentBoundary",value:function(e,t,n){var r=e[t];if(!r)return!0;var a=e[t-1];if(a&&"\n"!==a)return!1;if(n){if(r!==n)return!1}else if(r!==T.Char.DIRECTIVES_END&&r!==T.Char.DOCUMENT_END)return!1;var o=e[t+1],i=e[t+2];if(o!==r||i!==r)return!1;var s=e[t+3];return!s||"\n"===s||"\t"===s||" "===s}},{key:"endOfIdentifier",value:function(e,t){for(var n=e[t],r="<"===n,a=r?["\n","\t"," ",">"]:["\n","\t"," ","[","]","{","}",","];n&&-1===a.indexOf(n);)n=e[t+=1];return r&&">"===n&&(t+=1),t}},{key:"endOfIndent",value:function(e,t){for(var n=e[t];" "===n;)n=e[t+=1];return t}},{key:"endOfLine",value:function(e,t){for(var n=e[t];n&&"\n"!==n;)n=e[t+=1];return t}},{key:"endOfWhiteSpace",value:function(e,t){for(var n=e[t];"\t"===n||" "===n;)n=e[t+=1];return t}},{key:"startOfLine",value:function(e,t){var n=e[t-1];if("\n"===n)return t;for(;n&&"\n"!==n;)n=e[t-=1];return t+1}},{key:"endOfBlockIndent",value:function(t,n,r){var a=e.endOfIndent(t,r);if(a>r+n)return a;var o=e.endOfWhiteSpace(t,a),i=t[o];return i&&"\n"!==i?null:o}},{key:"atBlank",value:function(e,t,n){var r=e[t];return"\n"===r||"\t"===r||" "===r||n&&!r}},{key:"atCollectionItem",value:function(t,n){var r=t[n];return("?"===r||":"===r||"-"===r)&&e.atBlank(t,n+1,!0)}},{key:"nextNodeIsIndented",value:function(e,t,n){return!(!e||t<0)&&(t>0||n&&"-"===e)}},{key:"normalizeOffset",value:function(t,n){var r=t[n];return r?"\n"!==r&&"\n"===t[n-1]?n-1:e.endOfWhiteSpace(t,n):n}},{key:"foldNewline",value:function(t,n,r){for(var a=0,o=!1,i="",s=t[n+1];" "===s||"\t"===s||"\n"===s;){switch(s){case"\n":a=0,n+=1,i+="\n";break;case"\t":a<=r&&(o=!0),n=e.endOfWhiteSpace(t,n+2)-1;break;case" ":a+=1,n+=1}s=t[n+1]}return i||(i=" "),s&&a<=r&&(o=!0),{fold:i,offset:n,error:o}}}]),f(e,[{key:"getPropValue",value:function(e,t,n){if(!this.context)return null;var r=this.context.src,a=this.props[e];return a&&r[a.start]===t?r.slice(a.start+(n?1:0),a.end):null}},{key:"commentHasRequiredWhitespace",value:function(t){var n=this.context.src;if(this.header&&t===this.header.end)return!1;if(!this.valueRange)return!1;var r=this.valueRange.end;return t!==r||e.atBlank(n,r-1)}},{key:"parseComment",value:function(t){var n=this.context.src;if(n[t]===T.Char.COMMENT){var a=e.endOfLine(n,t+1),o=new r.default(t,a);return this.props.push(o),a}return t}},{key:"setOrigRanges",value:function(e,t){return this.range&&(t=this.range.setOrigRange(e,t)),this.valueRange&&this.valueRange.setOrigRange(e,t),this.props.forEach((function(n){return n.setOrigRange(e,t)})),t}},{key:"toString",value:function(){var t=this.context.src,n=this.range,r=this.value;if(null!=r)return r;var a=t.slice(n.start,n.end);return e.addStringTerminator(t,n.end,a)}},{key:"anchor",get:function(){for(var e=0;e<this.props.length;++e){var t=this.getPropValue(e,T.Char.ANCHOR,!0);if(null!=t)return t}return null}},{key:"comment",get:function(){for(var e=[],t=0;t<this.props.length;++t){var n=this.getPropValue(t,T.Char.COMMENT,!0);null!=n&&e.push(n)}return e.length>0?e.join("\n"):null}},{key:"hasComment",get:function(){if(this.context)for(var e=this.context.src,t=0;t<this.props.length;++t)if(e[this.props[t].start]===T.Char.COMMENT)return!0;return!1}},{key:"hasProps",get:function(){if(this.context)for(var e=this.context.src,t=0;t<this.props.length;++t)if(e[this.props[t].start]!==T.Char.COMMENT)return!0;return!1}},{key:"includesTrailingLines",get:function(){return!1}},{key:"jsonLike",get:function(){return-1!==[T.Type.FLOW_MAP,T.Type.FLOW_SEQ,T.Type.QUOTE_DOUBLE,T.Type.QUOTE_SINGLE].indexOf(this.type)}},{key:"rangeAsLinePos",get:function(){if(this.range&&this.context){var e=(0,P.getLinePos)(this.range.start,this.context.root);if(e)return{start:e,end:(0,P.getLinePos)(this.range.end,this.context.root)}}}},{key:"rawValue",get:function(){if(!this.valueRange||!this.context)return null;var e=this.valueRange,t=e.start,n=e.end;return this.context.src.slice(t,n)}},{key:"tag",get:function(){for(var e=0;e<this.props.length;++e){var t=this.getPropValue(e,T.Char.TAG,!1);if(null!=t){if("<"===t[1])return{verbatim:t.slice(2,-1)};var n=y(t.match(/^(.*!)([^!]*)$/),3);n[0];return{handle:n[1],suffix:n[2]}}}return null}},{key:"valueRangeContainsNewline",get:function(){if(!this.valueRange||!this.context)return!1;for(var e=this.valueRange,t=e.start,n=e.end,r=this.context.src,a=t;a<n;++a)if("\n"===r[a])return!0;return!1}}]),e}();t.default=a}));a(N);var x=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.YAMLWarning=t.YAMLSyntaxError=t.YAMLSemanticError=t.YAMLReferenceError=t.YAMLError=void 0;var n=a(N),r=a(C);function a(e){return e&&e.__esModule?e:{default:e}}var o=function(e){function t(e,r,a){var o;if(s(this,t),!(a&&r instanceof n.default))throw new Error("Invalid arguments for new ".concat(e));return(o=g(this,c(t).call(this))).name=e,o.message=a,o.source=r,o}return l(t,e),f(t,[{key:"makePretty",value:function(){if(this.source){this.nodeType=this.source.type;var e=this.source.context&&this.source.context.root;if("number"==typeof this.offset){this.range=new r.default(this.offset,this.offset+1);var t=e&&(0,P.getLinePos)(this.offset,e);if(t){var n={line:t.line,col:t.col+1};this.linePos={start:t,end:n}}delete this.offset}else this.range=this.source.range,this.linePos=this.source.rangeAsLinePos;if(this.linePos){var a=this.linePos.start,o=a.line,i=a.col;this.message+=" at line ".concat(o,", column ").concat(i);var s=e&&(0,P.getPrettyContext)(this.linePos,e);s&&(this.message+=":\n\n".concat(s,"\n"))}delete this.source}}}]),t}(p(Error));t.YAMLError=o;var i=function(e){function t(e,n){return s(this,t),g(this,c(t).call(this,"YAMLReferenceError",e,n))}return l(t,e),t}(o);t.YAMLReferenceError=i;var u=function(e){function t(e,n){return s(this,t),g(this,c(t).call(this,"YAMLSemanticError",e,n))}return l(t,e),t}(o);t.YAMLSemanticError=u;var d=function(e){function t(e,n){return s(this,t),g(this,c(t).call(this,"YAMLSyntaxError",e,n))}return l(t,e),t}(o);t.YAMLSyntaxError=d;var h=function(e){function t(e,n){return s(this,t),g(this,c(t).call(this,"YAMLWarning",e,n))}return l(t,e),t}(o);t.YAMLWarning=h}));a(x);x.YAMLWarning,x.YAMLSyntaxError,x.YAMLSemanticError,x.YAMLReferenceError,x.YAMLError;var R=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=a(N),r=a(C);function a(e){return e&&e.__esModule?e:{default:e}}var o=function(e){function t(){return s(this,t),g(this,c(t).call(this,T.Type.BLANK_LINE))}return l(t,e),f(t,[{key:"parse",value:function(e,t){this.context=e;for(var a=e.src,o=t+1;n.default.atBlank(a,o);){var i=n.default.endOfWhiteSpace(a,o);if("\n"!==i)break;o=i+1}return this.range=new r.default(t,o),o}},{key:"includesTrailingLines",get:function(){return!0}}]),t}(n.default);t.default=o}));a(R);var I=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=o(R),r=o(N),a=o(C);function o(e){return e&&e.__esModule?e:{default:e}}var i=function(e){function t(e,n){var r;return s(this,t),(r=g(this,c(t).call(this,e,n))).node=null,r}return l(t,e),f(t,[{key:"parse",value:function(e,t){this.context=e;var o=e.parseNode,i=e.src,s=e.atLineStart,u=e.lineStart;s||this.type!==T.Type.SEQ_ITEM||(this.error=new x.YAMLSemanticError(this,"Sequence items must not have preceding content on the same line"));for(var f=s?t-u:e.indent,l=r.default.endOfWhiteSpace(i,t+1),c=i[l],d="#"===c,h=[],p=null;"\n"===c||"#"===c;){if("#"===c){var v=r.default.endOfLine(i,l+1);h.push(new a.default(l,v)),l=v}else{s=!0,u=l+1,"\n"===i[r.default.endOfWhiteSpace(i,u)]&&0===h.length&&(u=(p=new n.default).parse({src:i},u)),l=r.default.endOfIndent(i,u)}c=i[l]}if(r.default.nextNodeIsIndented(c,l-(u+f),this.type!==T.Type.SEQ_ITEM)?this.node=o({atLineStart:s,inCollection:!1,indent:f,lineStart:u,parent:this},l):c&&u>t+1&&(l=u-1),this.node){if(p){var g=e.parent.items||e.parent.contents;g&&g.push(p)}h.length&&Array.prototype.push.apply(this.props,h),l=this.node.range.end}else if(d){var m=h[0];this.props.push(m),l=m.end}else l=r.default.endOfLine(i,t+1);var y=this.node?this.node.valueRange.end:l;return this.valueRange=new a.default(t,y),l}},{key:"setOrigRanges",value:function(e,n){return n=m(c(t.prototype),"setOrigRanges",this).call(this,e,n),this.node?this.node.setOrigRanges(e,n):n}},{key:"toString",value:function(){var e=this.context.src,t=this.node,n=this.range,a=this.value;if(null!=a)return a;var o=t?e.slice(n.start,t.range.start)+String(t):e.slice(n.start,n.end);return r.default.addStringTerminator(e,n.end,o)}},{key:"includesTrailingLines",get:function(){return!!this.node&&this.node.includesTrailingLines}}]),t}(r.default);t.default=i}));a(I);var B=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=a(N),r=a(C);function a(e){return e&&e.__esModule?e:{default:e}}var o=function(e){function t(){return s(this,t),g(this,c(t).call(this,T.Type.COMMENT))}return l(t,e),f(t,[{key:"parse",value:function(e,t){this.context=e;var n=this.parseComment(t);return this.range=new r.default(t,n),n}}]),t}(n.default);t.default=o}));a(B);var D=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.grabCollectionEndComments=d,t.default=void 0;var n=u(R),r=u(I),a=u(B),o=u(N),i=u(C);function u(e){return e&&e.__esModule?e:{default:e}}function d(e){for(var t=e;t instanceof r.default;)t=t.node;if(!(t instanceof h))return null;for(var n=t.items.length,a=-1,o=n-1;o>=0;--o){var i=t.items[o];if(i.type===T.Type.COMMENT){var s=i.context,u=s.indent,f=s.lineStart;if(u>0&&i.range.start>=f+u)break;a=o}else{if(i.type!==T.Type.BLANK_LINE)break;a=o}}if(-1===a)return null;for(var l=t.items.splice(a,n-a),c=l[0].range.start;t.range.end=c,t.valueRange&&t.valueRange.end>c&&(t.valueRange.end=c),t!==e;)t=t.context.parent;return l}var h=function(e){function t(e){var n;s(this,t),n=g(this,c(t).call(this,e.type===T.Type.SEQ_ITEM?T.Type.SEQ:T.Type.MAP));for(var r=e.props.length-1;r>=0;--r)if(e.props[r].start<e.context.lineStart){n.props=e.props.slice(0,r+1),e.props=e.props.slice(r+1);var a=e.props[0]||e.valueRange;e.range.start=a.start;break}n.items=[e];var o=d(e);return o&&Array.prototype.push.apply(n.items,o),n}return l(t,e),f(t,null,[{key:"nextContentHasIndent",value:function(e,n,r){var a=o.default.endOfLine(e,n)+1,i=e[n=o.default.endOfWhiteSpace(e,a)];return!!i&&(n>=a+r||("#"===i||"\n"===i)&&t.nextContentHasIndent(e,n,r))}}]),f(t,[{key:"parse",value:function(e,r){this.context=e;var s=e.parseNode,u=e.src,f=o.default.startOfLine(u,r),l=this.items[0];l.context.parent=this,this.valueRange=i.default.copy(l.valueRange);for(var c=l.range.start-l.context.lineStart,h=r,p=u[h=o.default.normalizeOffset(u,h)],v=o.default.endOfWhiteSpace(u,f)===h,g=!1;p;){for(;"\n"===p||"#"===p;){if(v&&"\n"===p&&!g){var m=new n.default;if(h=m.parse({src:u},h),this.valueRange.end=h,h>=u.length){p=null;break}this.items.push(m),h-=1}else if("#"===p){if(h<f+c&&!t.nextContentHasIndent(u,h,c))return h;var y=new a.default;if(h=y.parse({indent:c,lineStart:f,src:u},h),this.items.push(y),this.valueRange.end=h,h>=u.length){p=null;break}}if(f=h+1,h=o.default.endOfIndent(u,f),o.default.atBlank(u,h)){var _=o.default.endOfWhiteSpace(u,h),b=u[_];b&&"\n"!==b&&"#"!==b||(h=_)}p=u[h],v=!0}if(!p)break;if(h!==f+c&&(v||":"!==p)){f>r&&(h=f);break}if(l.type===T.Type.SEQ_ITEM!=("-"===p)){var w=!0;if("-"===p){var E=u[h+1];w=!E||"\n"===E||"\t"===E||" "===E}if(w){f>r&&(h=f);break}}var O=s({atLineStart:v,inCollection:!0,indent:c,lineStart:f,parent:this},h);if(!O)return h;if(this.items.push(O),this.valueRange.end=O.valueRange.end,p=u[h=o.default.normalizeOffset(u,O.range.end)],v=!1,g=O.includesTrailingLines,p){for(var M=h-1,S=u[M];" "===S||"\t"===S;)S=u[--M];"\n"===S&&(f=M+1,v=!0)}var A=d(O);A&&Array.prototype.push.apply(this.items,A)}return h}},{key:"setOrigRanges",value:function(e,n){return n=m(c(t.prototype),"setOrigRanges",this).call(this,e,n),this.items.forEach((function(t){n=t.setOrigRanges(e,n)})),n}},{key:"toString",value:function(){var e=this.context.src,t=this.items,n=this.range,r=this.value;if(null!=r)return r;for(var a=e.slice(n.start,t[0].range.start)+String(t[0]),i=1;i<t.length;++i){var s=t[i],u=s.context,f=u.atLineStart,l=u.indent;if(f)for(var c=0;c<l;++c)a+=" ";a+=String(s)}return o.default.addStringTerminator(e,n.end,a)}},{key:"includesTrailingLines",get:function(){return this.items.length>0}}]),t}(o.default);t.default=h}));a(D);D.grabCollectionEndComments;var j=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=a(N),r=a(C);function a(e){return e&&e.__esModule?e:{default:e}}var o=function(e){function t(){var e;return s(this,t),(e=g(this,c(t).call(this,T.Type.DIRECTIVE))).name=null,e}return l(t,e),f(t,null,[{key:"endOfDirective",value:function(e,t){for(var n=e[t];n&&"\n"!==n&&"#"!==n;)n=e[t+=1];for(n=e[t-1];" "===n||"\t"===n;)n=e[(t-=1)-1];return t}}]),f(t,[{key:"parseName",value:function(e){for(var t=this.context.src,n=e,r=t[n];r&&"\n"!==r&&"\t"!==r&&" "!==r;)r=t[n+=1];return this.name=t.slice(e,n),n}},{key:"parseParameters",value:function(e){for(var t=this.context.src,n=e,a=t[n];a&&"\n"!==a&&"#"!==a;)a=t[n+=1];return this.valueRange=new r.default(e,n),n}},{key:"parse",value:function(e,t){this.context=e;var n=this.parseName(t+1);return n=this.parseParameters(n),n=this.parseComment(n),this.range=new r.default(t,n),n}},{key:"parameters",get:function(){var e=this.rawValue;return e?e.trim().split(/[ \t]+/):[]}}]),t}(n.default);t.default=o}));a(j);var Y=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=u(R),r=u(B),a=u(j),o=u(N),i=u(C);function u(e){return e&&e.__esModule?e:{default:e}}var d=function(e){function t(){var e;return s(this,t),(e=g(this,c(t).call(this,T.Type.DOCUMENT))).directives=null,e.contents=null,e.directivesEndMarker=null,e.documentEndMarker=null,e}return l(t,e),f(t,null,[{key:"startCommentOrEndBlankLine",value:function(e,t){var n=o.default.endOfWhiteSpace(e,t),r=e[n];return"#"===r||"\n"===r?n:t}}]),f(t,[{key:"parseDirectives",value:function(e){var s=this.context.src;this.directives=[];for(var u=!0,f=!1,l=e;!o.default.atDocumentBoundary(s,l,T.Char.DIRECTIVES_END);)switch(s[l=t.startCommentOrEndBlankLine(s,l)]){case"\n":if(u){var c=new n.default;(l=c.parse({src:s},l))<s.length&&this.directives.push(c)}else l+=1,u=!0;break;case"#":var d=new r.default;l=d.parse({src:s},l),this.directives.push(d),u=!1;break;case"%":var h=new a.default;l=h.parse({parent:this,src:s},l),this.directives.push(h),f=!0,u=!1;break;default:return f?this.error=new x.YAMLSemanticError(this,"Missing directives-end indicator line"):this.directives.length>0&&(this.contents=this.directives,this.directives=[]),l}return s[l]?(this.directivesEndMarker=new i.default(l,l+3),l+3):(f?this.error=new x.YAMLSemanticError(this,"Missing directives-end indicator line"):this.directives.length>0&&(this.contents=this.directives,this.directives=[]),l)}},{key:"parseContents",value:function(e){var a=this.context,s=a.parseNode,u=a.src;this.contents||(this.contents=[]);for(var f=e;"-"===u[f-1];)f-=1;var l=o.default.endOfWhiteSpace(u,e),c=f===e;for(this.valueRange=new i.default(l);!o.default.atDocumentBoundary(u,l,T.Char.DOCUMENT_END);){switch(u[l]){case"\n":if(c){var d=new n.default;(l=d.parse({src:u},l))<u.length&&this.contents.push(d)}else l+=1,c=!0;f=l;break;case"#":var h=new r.default;l=h.parse({src:u},l),this.contents.push(h),c=!1;break;default:var p=o.default.endOfIndent(u,l),v=s({atLineStart:c,indent:-1,inFlow:!1,inCollection:!1,lineStart:f,parent:this},p);if(!v)return this.valueRange.end=p;this.contents.push(v),l=v.range.end,c=!1;var g=(0,D.grabCollectionEndComments)(v);g&&Array.prototype.push.apply(this.contents,g)}l=t.startCommentOrEndBlankLine(u,l)}if(this.valueRange.end=l,u[l]&&(this.documentEndMarker=new i.default(l,l+3),u[l+=3])){if("#"===u[l=o.default.endOfWhiteSpace(u,l)]){var m=new r.default;l=m.parse({src:u},l),this.contents.push(m)}switch(u[l]){case"\n":l+=1;break;case void 0:break;default:this.error=new x.YAMLSyntaxError(this,"Document end marker line cannot have a non-comment suffix")}}return l}},{key:"parse",value:function(e,t){e.root=this,this.context=e;var n=65279===e.src.charCodeAt(t)?t+1:t;return n=this.parseDirectives(n),n=this.parseContents(n)}},{key:"setOrigRanges",value:function(e,n){return n=m(c(t.prototype),"setOrigRanges",this).call(this,e,n),this.directives.forEach((function(t){n=t.setOrigRanges(e,n)})),this.directivesEndMarker&&(n=this.directivesEndMarker.setOrigRange(e,n)),this.contents.forEach((function(t){n=t.setOrigRanges(e,n)})),this.documentEndMarker&&(n=this.documentEndMarker.setOrigRange(e,n)),n}},{key:"toString",value:function(){var e=this.contents,t=this.directives,n=this.value;if(null!=n)return n;var r=t.join("");return e.length>0&&((t.length>0||e[0].type===T.Type.COMMENT)&&(r+="---\n"),r+=e.join("")),"\n"!==r[r.length-1]&&(r+="\n"),r}}]),t}(o.default);t.default=d}));a(Y);var F=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=a(N),r=a(C);function a(e){return e&&e.__esModule?e:{default:e}}var o=function(e){function t(){return s(this,t),g(this,c(t).apply(this,arguments))}return l(t,e),f(t,[{key:"parse",value:function(e,t){this.context=e;var a=e.src,o=n.default.endOfIdentifier(a,t+1);return this.valueRange=new r.default(t+1,o),o=n.default.endOfWhiteSpace(a,o),o=this.parseComment(o)}}]),t}(n.default);t.default=o}));a(F);var U=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=t.Chomp=void 0;var n=a(N),r=a(C);function a(e){return e&&e.__esModule?e:{default:e}}var o={CLIP:"CLIP",KEEP:"KEEP",STRIP:"STRIP"};t.Chomp=o;var i=function(e){function t(e,n){var r;return s(this,t),(r=g(this,c(t).call(this,e,n))).blockIndent=null,r.chomping=o.CLIP,r.header=null,r}return l(t,e),f(t,[{key:"parseBlockHeader",value:function(e){for(var t=this.context.src,n=e+1,a="";;){var i=t[n];switch(i){case"-":this.chomping=o.STRIP;break;case"+":this.chomping=o.KEEP;break;case"0":case"1":case"2":case"3":case"4":case"5":case"6":case"7":case"8":case"9":a+=i;break;default:return this.blockIndent=Number(a)||null,this.header=new r.default(e,n),n}n+=1}}},{key:"parseBlockValue",value:function(e){for(var t=this.context,a=t.indent,i=t.src,s=e,u=e,f=this.blockIndent?a+this.blockIndent-1:a,l=1,c=i[s];"\n"===c&&(s+=1,!n.default.atDocumentBoundary(i,s));c=i[s]){var d=n.default.endOfBlockIndent(i,f,s);if(null===d)break;if(!this.blockIndent){var h=d-(s+a);if("\n"!==i[d]){if(h<l){s-=1;break}this.blockIndent=h,f=a+this.blockIndent-1}else h>l&&(l=h)}s="\n"===i[d]?d:u=n.default.endOfLine(i,d)}return this.chomping!==o.KEEP&&(s=i[u]?u+1:u),this.valueRange=new r.default(e+1,s),s}},{key:"parse",value:function(e,t){this.context=e;var r=e.src,a=this.parseBlockHeader(t);return a=n.default.endOfWhiteSpace(r,a),a=this.parseComment(a),a=this.parseBlockValue(a)}},{key:"setOrigRanges",value:function(e,n){return n=m(c(t.prototype),"setOrigRanges",this).call(this,e,n),this.header?this.header.setOrigRange(e,n):n}},{key:"includesTrailingLines",get:function(){return this.chomping===o.KEEP}},{key:"strValue",get:function(){if(!this.valueRange||!this.context)return null;var e=this.valueRange,t=e.start,r=e.end,a=this.context,i=a.indent,s=a.src;if(this.valueRange.isEmpty())return"";for(var u=null,f=s[r-1];"\n"===f||"\t"===f||" "===f;){if((r-=1)<=t){if(this.chomping===o.KEEP)break;return""}"\n"===f&&(u=r),f=s[r-1]}var l=r+1;u&&(this.chomping===o.KEEP?(l=u,r=this.valueRange.end):r=u);for(var c=i+this.blockIndent,d=this.type===T.Type.BLOCK_FOLDED,h=!0,p="",v="",g=!1,m=t;m<r;++m){for(var y=0;y<c&&" "===s[m];++y)m+=1;var _=s[m];if("\n"===_)"\n"===v?p+="\n":v="\n";else{var b=n.default.endOfLine(s,m),w=s.slice(m,b);m=b,d&&(" "===_||"\t"===_)&&m<l?(" "===v?v="\n":g||h||"\n"!==v||(v="\n\n"),p+=v+w,v=b<r&&s[b]||"",g=!0):(p+=v+w,v=d&&m<l?" ":"\n",g=!1),h&&""!==w&&(h=!1)}}return this.chomping===o.STRIP?p:p+"\n"}}]),t}(n.default);t.default=i}));a(U);U.Chomp;var K=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=i(R),r=i(B),a=i(N),o=i(C);function i(e){return e&&e.__esModule?e:{default:e}}var u=function(e){function t(e,n){var r;return s(this,t),(r=g(this,c(t).call(this,e,n))).items=null,r}return l(t,e),f(t,[{key:"prevNodeIsJsonLike",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:this.items.length,t=this.items[e-1];return!!t&&(t.jsonLike||t.type===T.Type.COMMENT&&this.nodeIsJsonLike(e-1))}},{key:"parse",value:function(e,t){this.context=e;var i=e.parseNode,s=e.src,u=e.indent,f=e.lineStart,l=s[t];this.items=[{char:l,offset:t}];var c=a.default.endOfWhiteSpace(s,t+1);for(l=s[c];l&&"]"!==l&&"}"!==l;){switch(l){case"\n":if(f=c+1,"\n"===s[a.default.endOfWhiteSpace(s,f)]){var d=new n.default;f=d.parse({src:s},f),this.items.push(d)}if((c=a.default.endOfIndent(s,f))<=f+u&&(l=s[c],c<f+u||"]"!==l&&"}"!==l)){this.error=new x.YAMLSemanticError(this,"Insufficient indentation in flow collection")}break;case",":this.items.push({char:l,offset:c}),c+=1;break;case"#":var h=new r.default;c=h.parse({src:s},c),this.items.push(h);break;case"?":case":":var p=s[c+1];if("\n"===p||"\t"===p||" "===p||","===p||":"===l&&this.prevNodeIsJsonLike()){this.items.push({char:l,offset:c}),c+=1;break}default:var v=i({atLineStart:!1,inCollection:!1,inFlow:!0,indent:-1,lineStart:f,parent:this},c);if(!v)return this.valueRange=new o.default(t,c),c;this.items.push(v),c=a.default.normalizeOffset(s,v.range.end)}l=s[c=a.default.endOfWhiteSpace(s,c)]}return this.valueRange=new o.default(t,c+1),l&&(this.items.push({char:l,offset:c}),c=a.default.endOfWhiteSpace(s,c+1),c=this.parseComment(c)),c}},{key:"setOrigRanges",value:function(e,n){return n=m(c(t.prototype),"setOrigRanges",this).call(this,e,n),this.items.forEach((function(t){if(t instanceof a.default)n=t.setOrigRanges(e,n);else if(0===e.length)t.origOffset=t.offset;else{for(var r=n;r<e.length&&!(e[r]>t.offset);)++r;t.origOffset=t.offset+r,n=r}})),n}},{key:"toString",value:function(){var e=this.context.src,t=this.items,n=this.range,r=this.value;if(null!=r)return r;var o=t.filter((function(e){return e instanceof a.default})),i="",s=n.start;return o.forEach((function(t){var n=e.slice(s,t.range.start);s=t.range.end,"\n"===(i+=n+String(t))[i.length-1]&&"\n"!==e[s-1]&&"\n"===e[s]&&(s+=1)})),i+=e.slice(s,n.end),a.default.addStringTerminator(e,n.end,i)}}]),t}(a.default);t.default=u}));a(K);var W=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=a(N),r=a(C);function a(e){return e&&e.__esModule?e:{default:e}}var o=function(e){function t(){return s(this,t),g(this,c(t).apply(this,arguments))}return l(t,e),f(t,[{key:"parseBlockValue",value:function(e){for(var r=this.context,a=r.indent,o=r.inFlow,i=r.src,s=e,u=e,f=i[s];"\n"===f&&!n.default.atDocumentBoundary(i,s+1);f=i[s]){var l=n.default.endOfBlockIndent(i,a,s+1);if(null===l||"#"===i[l])break;s="\n"===i[l]?l:u=t.endOfLine(i,l,o)}return this.valueRange.isEmpty()&&(this.valueRange.start=e),this.valueRange.end=u,u}},{key:"parse",value:function(e,a){this.context=e;var o=e.inFlow,i=e.src,s=a,u=i[s];return u&&"#"!==u&&"\n"!==u&&(s=t.endOfLine(i,a,o)),this.valueRange=new r.default(a,s),s=n.default.endOfWhiteSpace(i,s),s=this.parseComment(s),this.hasComment&&!this.valueRange.isEmpty()||(s=this.parseBlockValue(s)),s}},{key:"strValue",get:function(){if(!this.valueRange||!this.context)return null;for(var e=this.valueRange,t=e.start,r=e.end,a=this.context.src,o=a[r-1];t<r&&("\n"===o||"\t"===o||" "===o);)o=a[--r-1];for(o=a[t];t<r&&("\n"===o||"\t"===o||" "===o);)o=a[++t];for(var i="",s=t;s<r;++s){var u=a[s];if("\n"===u){var f=n.default.foldNewline(a,s,-1);i+=f.fold,s=f.offset}else if(" "===u||"\t"===u){for(var l=s,c=a[s+1];s<r&&(" "===c||"\t"===c);)c=a[(s+=1)+1];"\n"!==c&&(i+=s>l?a.slice(l,s+1):u)}else i+=u}return i}}],[{key:"endOfLine",value:function(e,t,n){for(var r=e[t],a=t;r&&"\n"!==r&&(!n||"["!==r&&"]"!==r&&"{"!==r&&"}"!==r&&","!==r);){var o=e[a+1];if(":"===r&&(!o||"\n"===o||"\t"===o||" "===o||n&&","===o))break;if((" "===r||"\t"===r)&&"#"===o)break;a+=1,r=o}return a}}]),t}(n.default);t.default=o}));a(W);var Q=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=a(N),r=a(C);function a(e){return e&&e.__esModule?e:{default:e}}var o=function(e){function t(){return s(this,t),g(this,c(t).apply(this,arguments))}return l(t,e),f(t,[{key:"parseCharCode",value:function(e,t,n){var r=this.context.src,a=r.substr(e,t),o=a.length===t&&/^[0-9a-fA-F]+$/.test(a)?parseInt(a,16):NaN;return isNaN(o)?(n.push(new x.YAMLSyntaxError(this,"Invalid escape sequence ".concat(r.substr(e-2,t+2)))),r.substr(e-2,t+2)):String.fromCodePoint(o)}},{key:"parse",value:function(e,a){this.context=e;var o=e.src,i=t.endOfQuote(o,a+1);return this.valueRange=new r.default(a,i),i=n.default.endOfWhiteSpace(o,i),i=this.parseComment(i)}},{key:"strValue",get:function(){if(!this.valueRange||!this.context)return null;var e=[],t=this.valueRange,r=t.start,a=t.end,o=this.context,i=o.indent,s=o.src;'"'!==s[a-1]&&e.push(new x.YAMLSyntaxError(this,'Missing closing "quote'));for(var u="",f=r+1;f<a-1;++f){var l=s[f];if("\n"===l){n.default.atDocumentBoundary(s,f+1)&&e.push(new x.YAMLSemanticError(this,"Document boundary indicators are not allowed within string values"));var c=n.default.foldNewline(s,f,i);u+=c.fold,f=c.offset,c.error&&e.push(new x.YAMLSemanticError(this,"Multi-line double-quoted string needs to be sufficiently indented"))}else if("\\"===l)switch(s[f+=1]){case"0":u+="\0";break;case"a":u+="";break;case"b":u+="\b";break;case"e":u+="";break;case"f":u+="\f";break;case"n":u+="\n";break;case"r":u+="\r";break;case"t":u+="\t";break;case"v":u+="\v";break;case"N":u+="";break;case"_":u+="";break;case"L":u+="\u2028";break;case"P":u+="\u2029";break;case" ":u+=" ";break;case'"':u+='"';break;case"/":u+="/";break;case"\\":u+="\\";break;case"\t":u+="\t";break;case"x":u+=this.parseCharCode(f+1,2,e),f+=2;break;case"u":u+=this.parseCharCode(f+1,4,e),f+=4;break;case"U":u+=this.parseCharCode(f+1,8,e),f+=8;break;case"\n":for(;" "===s[f+1]||"\t"===s[f+1];)f+=1;break;default:e.push(new x.YAMLSyntaxError(this,"Invalid escape sequence ".concat(s.substr(f-1,2)))),u+="\\"+s[f]}else if(" "===l||"\t"===l){for(var d=f,h=s[f+1];" "===h||"\t"===h;)h=s[(f+=1)+1];"\n"!==h&&(u+=f>d?s.slice(d,f+1):l)}else u+=l}return e.length>0?{errors:e,str:u}:u}}],[{key:"endOfQuote",value:function(e,t){for(var n=e[t];n&&'"'!==n;)n=e[t+="\\"===n?2:1];return t+1}}]),t}(n.default);t.default=o}));a(Q);var V=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=a(N),r=a(C);function a(e){return e&&e.__esModule?e:{default:e}}var o=function(e){function t(){return s(this,t),g(this,c(t).apply(this,arguments))}return l(t,e),f(t,[{key:"parse",value:function(e,a){this.context=e;var o=e.src,i=t.endOfQuote(o,a+1);return this.valueRange=new r.default(a,i),i=n.default.endOfWhiteSpace(o,i),i=this.parseComment(i)}},{key:"strValue",get:function(){if(!this.valueRange||!this.context)return null;var e=[],t=this.valueRange,r=t.start,a=t.end,o=this.context,i=o.indent,s=o.src;"'"!==s[a-1]&&e.push(new x.YAMLSyntaxError(this,"Missing closing 'quote"));for(var u="",f=r+1;f<a-1;++f){var l=s[f];if("\n"===l){n.default.atDocumentBoundary(s,f+1)&&e.push(new x.YAMLSemanticError(this,"Document boundary indicators are not allowed within string values"));var c=n.default.foldNewline(s,f,i);u+=c.fold,f=c.offset,c.error&&e.push(new x.YAMLSemanticError(this,"Multi-line single-quoted string needs to be sufficiently indented"))}else if("'"===l)u+=l,"'"!==s[f+=1]&&e.push(new x.YAMLSyntaxError(this,"Unescaped single quote? This should not happen."));else if(" "===l||"\t"===l){for(var d=f,h=s[f+1];" "===h||"\t"===h;)h=s[(f+=1)+1];"\n"!==h&&(u+=f>d?s.slice(d,f+1):l)}else u+=l}return e.length>0?{errors:e,str:u}:u}}],[{key:"endOfQuote",value:function(e,t){for(var n=e[t];n;)if("'"===n){if("'"!==e[t+1])break;n=e[t+=2]}else n=e[t+=1];return t+1}}]),t}(n.default);t.default=o}));a(V);var $=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=p(F),r=p(U),a=p(D),o=p(I),i=p(K),u=p(N),l=p(W),c=p(Q),d=p(V),h=p(C);function p(e){return e&&e.__esModule?e:{default:e}}var v=function(){function e(){var t,f,p,v=this,g=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},m=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},y=m.atLineStart,_=m.inCollection,b=m.inFlow,w=m.indent,E=m.lineStart,O=m.parent;s(this,e),p=function(t,s){if(u.default.atDocumentBoundary(v.src,s))return null;var f,p=new e(v,t),g=p.parseProps(s),m=g.props,y=g.type,_=g.valueStart;switch(y){case T.Type.ALIAS:f=new n.default(y,m);break;case T.Type.BLOCK_FOLDED:case T.Type.BLOCK_LITERAL:f=new r.default(y,m);break;case T.Type.FLOW_MAP:case T.Type.FLOW_SEQ:f=new i.default(y,m);break;case T.Type.MAP_KEY:case T.Type.MAP_VALUE:case T.Type.SEQ_ITEM:f=new o.default(y,m);break;case T.Type.COMMENT:case T.Type.PLAIN:f=new l.default(y,m);break;case T.Type.QUOTE_DOUBLE:f=new c.default(y,m);break;case T.Type.QUOTE_SINGLE:f=new d.default(y,m);break;default:return f.error=new x.YAMLSyntaxError(f,"Unknown node type: ".concat(JSON.stringify(y))),f.range=new h.default(s,s+1),f}var b=f.parse(p,_);if(f.range=new h.default(s,b),b<=s&&(f.error=new Error("Node#parse consumed no characters"),f.error.parseEnd=b,f.error.source=f,f.range.end=s+1),p.nodeStartsCollection(f)){f.error||p.atLineStart||p.parent.type!==T.Type.DOCUMENT||(f.error=new x.YAMLSyntaxError(f,"Block collection must not have preceding content here (e.g. directives-end indicator)"));var w=new a.default(f);return b=w.parse(new e(p),b),w.range=new h.default(s,b),w}return f},(f="parseNode")in(t=this)?Object.defineProperty(t,f,{value:p,enumerable:!0,configurable:!0,writable:!0}):t[f]=p,this.atLineStart=null!=y?y:g.atLineStart||!1,this.inCollection=null!=_?_:g.inCollection||!1,this.inFlow=null!=b?b:g.inFlow||!1,this.indent=null!=w?w:g.indent,this.lineStart=null!=E?E:g.lineStart,this.parent=null!=O?O:g.parent||{},this.root=g.root,this.src=g.src}return f(e,null,[{key:"parseType",value:function(e,t,n){switch(e[t]){case"*":return T.Type.ALIAS;case">":return T.Type.BLOCK_FOLDED;case"|":return T.Type.BLOCK_LITERAL;case"{":return T.Type.FLOW_MAP;case"[":return T.Type.FLOW_SEQ;case"?":return!n&&u.default.atBlank(e,t+1,!0)?T.Type.MAP_KEY:T.Type.PLAIN;case":":return!n&&u.default.atBlank(e,t+1,!0)?T.Type.MAP_VALUE:T.Type.PLAIN;case"-":return!n&&u.default.atBlank(e,t+1,!0)?T.Type.SEQ_ITEM:T.Type.PLAIN;case'"':return T.Type.QUOTE_DOUBLE;case"'":return T.Type.QUOTE_SINGLE;default:return T.Type.PLAIN}}}]),f(e,[{key:"nodeStartsCollection",value:function(e){var t=this.inCollection,n=this.inFlow,r=this.src;if(t||n)return!1;if(e instanceof o.default)return!0;var a=e.range.end;return"\n"!==r[a]&&"\n"!==r[a-1]&&":"===r[a=u.default.endOfWhiteSpace(r,a)]}},{key:"parseProps",value:function(t){for(var n=this.inFlow,r=this.parent,a=this.src,o=[],i=!1,s=a[t=u.default.endOfWhiteSpace(a,t)];s===T.Char.ANCHOR||s===T.Char.COMMENT||s===T.Char.TAG||"\n"===s;){if("\n"===s){var f=t+1,l=u.default.endOfIndent(a,f),c=l-(f+this.indent),d=r.type===T.Type.SEQ_ITEM&&r.context.atLineStart;if(!u.default.nextNodeIsIndented(a[l],c,!d))break;this.atLineStart=!0,this.lineStart=f,i=!1,t=l}else if(s===T.Char.COMMENT){var p=u.default.endOfLine(a,t+1);o.push(new h.default(t,p)),t=p}else{var v=u.default.endOfIdentifier(a,t+1);s===T.Char.TAG&&","===a[v]&&/^[a-zA-Z0-9-]+\.[a-zA-Z0-9-]+,\d\d\d\d(-\d\d){0,2}\/\S/.test(a.slice(t+1,v+13))&&(v=u.default.endOfIdentifier(a,v+5)),o.push(new h.default(t,v)),i=!0,t=u.default.endOfWhiteSpace(a,v)}s=a[t]}return i&&":"===s&&u.default.atBlank(a,t+1,!0)&&(t-=1),{props:o,type:e.parseType(a,t,n),valueStart:t}}},{key:"pretty",get:function(){var e={start:"".concat(this.lineStart," + ").concat(this.indent),in:[],parent:this.parent.type};return this.atLineStart||(e.start+=" + N"),this.inCollection&&e.in.push("collection"),this.inFlow&&e.in.push("flow"),e}}]),e}();t.default=v}));a($);var q=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e){var t=[];-1!==e.indexOf("\r")&&(e=e.replace(/\r\n?/g,(function(e,n){return e.length>1&&t.push(n),"\n"})));var a=[],o=0;do{var i=new n.default,s=new r.default({src:e});o=i.parse(s,o),a.push(i)}while(o<e.length);return a.setOrigRanges=function(){if(0===t.length)return!1;for(var e=1;e<t.length;++e)t[e]-=e;for(var n=0,r=0;r<a.length;++r)n=a[r].setOrigRanges(t,n);return t.splice(0,t.length),!0},a.toString=function(){return a.join("...\n")},a};var n=a(Y),r=a($);function a(e){return e&&e.__esModule?e:{default:e}}}));a(q);var J=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.addCommentBefore=function(e,t,n){if(!n)return e;var r=n.replace(/[\s\S]^/gm,"$&".concat(t,"#"));return"#".concat(r,"\n").concat(t).concat(e)},t.default=function(e,t,n){return n?-1===n.indexOf("\n")?"".concat(e," #").concat(n):"".concat(e,"\n")+n.replace(/^/gm,"".concat(t||"","#")):e}}));a(J);J.addCommentBefore;var G=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=function e(t,n,r){if(Array.isArray(t))return t.map((function(t,n){return e(t,String(n),r)}));if(t&&"function"==typeof t.toJSON){var a=r&&r.anchors&&r.anchors.find((function(e){return e.node===t}));a&&(r.onCreate=function(e){a.res=e,delete r.onCreate});var o=t.toJSON(n,r);return a&&r.onCreate&&r.onCreate(o),o}return t}}));a(G);var H=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;t.default=function e(){s(this,e)}}));a(H);var z=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=r(G);function r(e){return e&&e.__esModule?e:{default:e}}var a=function(e){function t(e){var n;return s(this,t),(n=g(this,c(t).call(this))).value=e,n}return l(t,e),f(t,[{key:"toJSON",value:function(e,t){return t&&t.keep?this.value:(0,n.default)(this.value,e,t)}},{key:"toString",value:function(){return String(this.value)}}]),t}(r(H).default);t.default=a}));a(z);var Z=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=d(J),r=d(G),a=d(X),o=d(H),u=d(z);function d(e){return e&&e.__esModule?e:{default:e}}var h=function(e){function t(e){var n,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return s(this,t),(n=g(this,c(t).call(this))).key=e,n.value=r,n.type="PAIR",n}return l(t,e),f(t,[{key:"addToJSMap",value:function(e,t){var n=(0,r.default)(this.key,"",e);if(t instanceof Map){var a=(0,r.default)(this.value,n,e);t.set(n,a)}else if(t instanceof Set)t.add(n);else{var s=function(e,t,n){return null===t?"":"object"!==i(t)?String(t):e instanceof o.default&&n&&n.doc?e.toString({anchors:{},doc:n.doc,indent:"",inFlow:!0,inStringifyKey:!0}):JSON.stringify(t)}(this.key,n,e);t[s]=(0,r.default)(this.value,s,e)}return t}},{key:"toJSON",value:function(e,t){var n=t&&t.mapAsMap?new Map:{};return this.addToJSMap(t,n)}},{key:"toString",value:function(e,t,r){if(!e||!e.doc)return JSON.stringify(this);var s=e.doc.options.simpleKeys,u=this.key,f=this.value,l=u instanceof o.default&&u.comment;if(s){if(l)throw new Error("With simple keys, key nodes cannot have comments");if(u instanceof a.default){throw new Error("With simple keys, collection cannot be used as a key value")}}var c=!s&&(!u||l||u instanceof a.default||u.type===T.Type.BLOCK_FOLDED||u.type===T.Type.BLOCK_LITERAL),d=e,h=d.doc,p=d.indent;e=Object.assign({},e,{implicitKey:!c,indent:p+"  "});var v=!1,g=h.schema.stringify(u,e,(function(){return l=null}),(function(){return v=!0}));if(g=(0,n.default)(g,e.indent,l),e.allNullValues&&!s)return this.comment?(g=(0,n.default)(g,e.indent,this.comment),t&&t()):v&&!l&&r&&r(),e.inFlow?g:"? ".concat(g);g=c?"? ".concat(g,"\n").concat(p,":"):"".concat(g,":"),this.comment&&(g=(0,n.default)(g,e.indent,this.comment),t&&t());var m="",y=null;if(f instanceof o.default){if(f.spaceBefore&&(m="\n"),f.commentBefore){var _=f.commentBefore.replace(/^/gm,"".concat(e.indent,"#"));m+="\n".concat(_)}y=f.comment}else f&&"object"===i(f)&&(f=h.schema.createNode(f,!0));e.implicitKey=!1,v=!1;var b=h.schema.stringify(f,e,(function(){return y=null}),(function(){return v=!0})),w=" ";if(m||this.comment)w="".concat(m,"\n").concat(e.indent);else if(!c&&f instanceof a.default){("["===b[0]||"{"===b[0])&&!b.includes("\n")||(w="\n".concat(e.indent))}return v&&!y&&r&&r(),(0,n.default)(g+w+b,e.indent,y)}},{key:"commentBefore",get:function(){return this.key&&this.key.commentBefore},set:function(e){null==this.key&&(this.key=new u.default(null)),this.key.commentBefore=e}}]),t}(o.default);t.default=h}));a(Z);var X=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=t.isEmptyPath=void 0;var n=u(J),r=u(H),a=u(Z),o=u(z);function u(e){return e&&e.__esModule?e:{default:e}}function d(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var h=function(e){return null==e||"object"===i(e)&&e[Symbol.iterator]().next().done};t.isEmptyPath=h;var p=function(e){function t(){var e,n;s(this,t);for(var r=arguments.length,a=new Array(r),o=0;o<r;o++)a[o]=arguments[o];return d(v(n=g(this,(e=c(t)).call.apply(e,[this].concat(a)))),"items",[]),n}return l(t,e),f(t,[{key:"addIn",value:function(e,n){if(h(e))this.add(n);else{var r=_(e),a=r[0],o=r.slice(1),i=this.get(a,!0);if(!(i instanceof t))throw new Error("Expected YAML collection at ".concat(a,". Remaining path: ").concat(o));i.addIn(o,n)}}},{key:"deleteIn",value:function(e){var n=_(e),r=n[0],a=n.slice(1);if(0===a.length)return this.delete(r);var o=this.get(r,!0);if(o instanceof t)return o.deleteIn(a);throw new Error("Expected YAML collection at ".concat(r,". Remaining path: ").concat(a))}},{key:"getIn",value:function(e,n){var r=_(e),a=r[0],i=r.slice(1),s=this.get(a,!0);return 0===i.length?!n&&s instanceof o.default?s.value:s:s instanceof t?s.getIn(i,n):void 0}},{key:"hasAllNullValues",value:function(){return this.items.every((function(e){if(!(e instanceof a.default))return!1;var t=e.value;return null==t||t instanceof o.default&&null==t.value&&!t.commentBefore&&!t.comment&&!t.tag}))}},{key:"hasIn",value:function(e){var n=_(e),r=n[0],a=n.slice(1);if(0===a.length)return this.has(r);var o=this.get(r,!0);return o instanceof t&&o.hasIn(a)}},{key:"setIn",value:function(e,n){var r=_(e),a=r[0],o=r.slice(1);if(0===o.length)this.set(a,n);else{var i=this.get(a,!0);if(!(i instanceof t))throw new Error("Expected YAML collection at ".concat(a,". Remaining path: ").concat(o));i.setIn(o,n)}}},{key:"toJSON",value:function(){return null}},{key:"toString",value:function(e,r,a,o){var i=this,s=r.blockItem,u=r.flowChars,f=r.isMap,l=r.itemIndent,c=e,d=c.doc,h=c.indent,p=this.type&&"FLOW"===this.type.substr(0,4)||e.inFlow;p&&(l+="  ");var v=f&&this.hasAllNullValues();e=Object.assign({},e,{allNullValues:v,indent:l,inFlow:p,type:null});var g,m=!1,y=!1,_=this.items.reduce((function(t,r,a){var o;r&&(!m&&r.spaceBefore&&t.push({type:"comment",str:""}),r.commentBefore&&r.commentBefore.match(/^.*$/gm).forEach((function(e){t.push({type:"comment",str:"#".concat(e)})})),r.comment&&(o=r.comment),p&&(!m&&r.spaceBefore||r.commentBefore||r.comment||r.key&&(r.key.commentBefore||r.key.comment)||r.value&&(r.value.commentBefore||r.value.comment))&&(y=!0)),m=!1;var s=d.schema.stringify(r,e,(function(){return o=null}),(function(){return m=!0}));return p&&!y&&s.includes("\n")&&(y=!0),p&&a<i.items.length-1&&(s+=","),s=(0,n.default)(s,l,o),m&&(o||p)&&(m=!1),t.push({type:"item",str:s}),t}),[]);if(0===_.length)g=u.start+u.end;else if(p){var b=u.start,w=u.end,E=_.map((function(e){return e.str}));if(y||E.reduce((function(e,t){return e+t.length+2}),2)>t.maxFlowStringSingleLineLength){g=b;var O=!0,M=!1,S=void 0;try{for(var A,k=E[Symbol.iterator]();!(O=(A=k.next()).done);O=!0){var L=A.value;g+=L?"\n  ".concat(h).concat(L):"\n"}}catch(e){M=!0,S=e}finally{try{O||null==k.return||k.return()}finally{if(M)throw S}}g+="\n".concat(h).concat(w)}else g="".concat(b," ").concat(E.join(" ")," ").concat(w)}else{var T=_.map(s);g=T.shift();var P=!0,C=!1,N=void 0;try{for(var x,R=T[Symbol.iterator]();!(P=(x=R.next()).done);P=!0){var I=x.value;g+=I?"\n".concat(h).concat(I):"\n"}}catch(e){C=!0,N=e}finally{try{P||null==R.return||R.return()}finally{if(C)throw N}}}return this.comment?(g+="\n"+this.comment.replace(/^/gm,"".concat(h,"#")),a&&a()):m&&o&&o(),g}}]),t}(r.default);t.default=p,d(p,"maxFlowStringSingleLineLength",60)}));a(X);X.isEmptyPath;var ee=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=i(G),r=i(X),a=i(H),o=i(Z);function i(e){return e&&e.__esModule?e:{default:e}}var u,d,h,p=function e(t,n){if(t instanceof v){var a=n.find((function(e){return e.node===t.source}));return a.count*a.aliasCount}if(t instanceof r.default){var i=0,s=!0,u=!1,f=void 0;try{for(var l,c=t.items[Symbol.iterator]();!(s=(l=c.next()).done);s=!0){var d=e(l.value,n);d>i&&(i=d)}}catch(e){u=!0,f=e}finally{try{s||null==c.return||c.return()}finally{if(u)throw f}}return i}if(t instanceof o.default){var h=e(t.key,n),p=e(t.value,n);return Math.max(h,p)}return 1},v=function(e){function t(e){var n;return s(this,t),(n=g(this,c(t).call(this))).source=e,n.type=T.Type.ALIAS,n}return l(t,e),f(t,null,[{key:"stringify",value:function(e,t){var n=e.range,r=e.source,a=t.anchors,o=t.doc,i=t.implicitKey,s=t.inStringifyKey,u=Object.keys(a).find((function(e){return a[e]===r}));if(!u&&s&&(u=o.anchors.getName(r)||o.anchors.newName()),u)return"*".concat(u).concat(i?" ":"");var f=o.anchors.getName(r)?"Alias node must be after source node":"Source node not found for alias node";throw new Error("".concat(f," [").concat(n,"]"))}}]),f(t,[{key:"toJSON",value:function(e,t){var r=this;if(!t)return(0,n.default)(this.source,e,t);var a=t.anchors,o=t.maxAliasCount,i=a.find((function(e){return e.node===r.source}));if(!i||void 0===i.res){var s="This should not happen: Alias anchor was not resolved?";throw this.cstNode?new x.YAMLReferenceError(this.cstNode,s):new ReferenceError(s)}if(o>=0&&(i.count+=1,0===i.aliasCount&&(i.aliasCount=p(this.source,a)),i.count*i.aliasCount>o)){var u="Excessive alias count indicates a resource exhaustion attack";throw this.cstNode?new x.YAMLReferenceError(this.cstNode,u):new ReferenceError(u)}return i.res}},{key:"toString",value:function(e){return t.stringify(this,e)}},{key:"tag",set:function(e){throw new Error("Alias nodes cannot have tags")}}]),t}(a.default);t.default=v,h=!0,(d="default")in(u=v)?Object.defineProperty(u,d,{value:h,enumerable:!0,configurable:!0,writable:!0}):u[d]=h}));a(ee);var te=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.findPair=i,t.default=void 0;var n=o(X),r=o(Z),a=o(z);function o(e){return e&&e.__esModule?e:{default:e}}function i(e,t){var n=t instanceof a.default?t.value:t,o=!0,i=!1,s=void 0;try{for(var u,f=e[Symbol.iterator]();!(o=(u=f.next()).done);o=!0){var l=u.value;if(l instanceof r.default){if(l.key===t||l.key===n)return l;if(l.key&&l.key.value===n)return l}}}catch(e){i=!0,s=e}finally{try{o||null==f.return||f.return()}finally{if(i)throw s}}}var u=function(e){function t(){return s(this,t),g(this,c(t).apply(this,arguments))}return l(t,e),f(t,[{key:"add",value:function(e){if(e?e instanceof r.default||(e=new r.default(e.key||e,e.value)):e=new r.default(e),i(this.items,e.key))throw new Error("Key ".concat(e.key," already set"));this.items.push(e)}},{key:"delete",value:function(e){var t=i(this.items,e);return!!t&&this.items.splice(this.items.indexOf(t),1).length>0}},{key:"get",value:function(e,t){var n=i(this.items,e),r=n&&n.value;return!t&&r instanceof a.default?r.value:r}},{key:"has",value:function(e){return!!i(this.items,e)}},{key:"set",value:function(e,t){var n=i(this.items,e);n?n.value=t:this.items.push(new r.default(e,t))}},{key:"toJSON",value:function(e,t,n){var r=n?new n:t&&t.mapAsMap?new Map:{};t&&t.onCreate&&t.onCreate(r);var a=!0,o=!1,i=void 0;try{for(var s,u=this.items[Symbol.iterator]();!(a=(s=u.next()).done);a=!0){s.value.addToJSMap(t,r)}}catch(e){o=!0,i=e}finally{try{a||null==u.return||u.return()}finally{if(o)throw i}}return r}},{key:"toString",value:function(e,n,a){if(!e)return JSON.stringify(this);var o=!0,i=!1,s=void 0;try{for(var u,f=this.items[Symbol.iterator]();!(o=(u=f.next()).done);o=!0){var l=u.value;if(!(l instanceof r.default))throw new Error("Map items must all be pairs; found ".concat(JSON.stringify(l)," instead"))}}catch(e){i=!0,s=e}finally{try{o||null==f.return||f.return()}finally{if(i)throw s}}return m(c(t.prototype),"toString",this).call(this,e,{blockItem:function(e){return e.str},flowChars:{start:"{",end:"}"},isMap:!0,itemIndent:e.indent||""},n,a)}}]),t}(n.default);t.default=u}));a(te);te.findPair;var ne=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=o(G),r=o(X),a=o(z);function o(e){return e&&e.__esModule?e:{default:e}}function i(e){var t=e instanceof a.default?e.value:e;return t&&"string"==typeof t&&(t=Number(t)),Number.isInteger(t)&&t>=0?t:null}var u=function(e){function t(){return s(this,t),g(this,c(t).apply(this,arguments))}return l(t,e),f(t,[{key:"add",value:function(e){this.items.push(e)}},{key:"delete",value:function(e){var t=i(e);return"number"==typeof t&&this.items.splice(t,1).length>0}},{key:"get",value:function(e,t){var n=i(e);if("number"==typeof n){var r=this.items[n];return!t&&r instanceof a.default?r.value:r}}},{key:"has",value:function(e){var t=i(e);return"number"==typeof t&&t<this.items.length}},{key:"set",value:function(e,t){var n=i(e);if("number"!=typeof n)throw new Error("Expected a valid index, not ".concat(e,"."));this.items[n]=t}},{key:"toJSON",value:function(e,t){var r=[];t&&t.onCreate&&t.onCreate(r);var a=0,o=!0,i=!1,s=void 0;try{for(var u,f=this.items[Symbol.iterator]();!(o=(u=f.next()).done);o=!0){var l=u.value;r.push((0,n.default)(l,String(a++),t))}}catch(e){i=!0,s=e}finally{try{o||null==f.return||f.return()}finally{if(i)throw s}}return r}},{key:"toString",value:function(e,n,r){return e?m(c(t.prototype),"toString",this).call(this,e,{blockItem:function(e){return"comment"===e.type?e.str:"- ".concat(e.str)},flowChars:{start:"[",end:"]"},isMap:!1,itemIndent:(e.indent||"")+"  "},n,r):JSON.stringify(this)}}]),t}(r.default);t.default=u}));a(ne);var re=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=t.MERGE_KEY=void 0;var n=i(te),r=i(Z),a=i(z),o=i(ne);function i(e){return e&&e.__esModule?e:{default:e}}var u="<<";t.MERGE_KEY=u;var d=function(e){function t(e){var n;if(s(this,t),e instanceof r.default){var i=e.value;i instanceof o.default||((i=new o.default).items.push(e.value),i.range=e.value.range),(n=g(this,c(t).call(this,e.key,i))).range=e.range}else n=g(this,c(t).call(this,new a.default(u),new o.default));return n.type="MERGE_PAIR",g(n)}return l(t,e),f(t,[{key:"addToJSMap",value:function(e,t){var r=!0,a=!1,o=void 0;try{for(var i,s=this.value.items[Symbol.iterator]();!(r=(i=s.next()).done);r=!0){var u=i.value.source;if(!(u instanceof n.default))throw new Error("Merge sources must be maps");var f=u.toJSON(null,e,Map),l=!0,c=!1,d=void 0;try{for(var h,p=f[Symbol.iterator]();!(l=(h=p.next()).done);l=!0){var v=y(h.value,2),g=v[0],m=v[1];t instanceof Map?t.has(g)||t.set(g,m):t instanceof Set?t.add(g):Object.prototype.hasOwnProperty.call(t,g)||(t[g]=m)}}catch(e){c=!0,d=e}finally{try{l||null==p.return||p.return()}finally{if(c)throw d}}}}catch(e){a=!0,o=e}finally{try{r||null==s.return||s.return()}finally{if(a)throw o}}return t}},{key:"toString",value:function(e,n){var r=this.value;if(r.items.length>1)return m(c(t.prototype),"toString",this).call(this,e,n);this.value=r.items[0];var a=m(c(t.prototype),"toString",this).call(this,e,n);return this.value=r,a}}]),t}(r.default);t.default=d}));a(re);re.MERGE_KEY;var ae=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=u(ee),r=u(te),a=u(re),o=u(z),i=u(ne);function u(e){return e&&e.__esModule?e:{default:e}}var l=function(){function e(t){var n,r,a;s(this,e),a={},(r="map")in(n=this)?Object.defineProperty(n,r,{value:a,enumerable:!0,configurable:!0,writable:!0}):n[r]=a,this.prefix=t}return f(e,null,[{key:"validAnchorNode",value:function(e){return e instanceof o.default||e instanceof i.default||e instanceof r.default}}]),f(e,[{key:"createAlias",value:function(e,t){return this.setAnchor(e,t),new n.default(e)}},{key:"createMergePair",value:function(){for(var e=this,t=new a.default,o=arguments.length,i=new Array(o),s=0;s<o;s++)i[s]=arguments[s];return t.value.items=i.map((function(t){if(t instanceof n.default){if(t.source instanceof r.default)return t}else if(t instanceof r.default)return e.createAlias(t);throw new Error("Merge sources must be Map nodes or their Aliases")})),t}},{key:"getName",value:function(e){var t=this.map;return Object.keys(t).find((function(n){return t[n]===e}))}},{key:"getNode",value:function(e){return this.map[e]}},{key:"newName",value:function(e){e||(e=this.prefix);for(var t=Object.keys(this.map),n=1;;++n){var r="".concat(e).concat(n);if(-1===t.indexOf(r))return r}}},{key:"resolveNodes",value:function(){var e=this.map,t=this._cstAliases;Object.keys(e).forEach((function(t){e[t]=e[t].resolved})),t.forEach((function(e){e.source=e.source.resolved})),delete this._cstAliases}},{key:"setAnchor",value:function(t,n){if(null!=t&&!e.validAnchorNode(t))throw new Error("Anchors may only be set for Scalar, Seq and Map nodes");if(n&&/[\x00-\x19\s,[\]{}]/.test(n))throw new Error("Anchor names must not contain whitespace or control characters");var r=this.map,a=t&&Object.keys(r).find((function(e){return r[e]===t}));if(a){if(!n)return a;a!==n&&(delete r[a],r[n]=t)}else{if(!n){if(!t)return null;n=this.newName()}r[n]=t}return n}}]),e}();t.default=l}));a(ae);var oe=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=o(X),r=o(Z),a=o(z);function o(e){return e&&e.__esModule?e:{default:e}}t.default=function(e){return Object.keys(function e(t,o){if(t&&"object"===i(t)){var s=t.tag;t instanceof n.default?(s&&(o[s]=!0),t.items.forEach((function(t){return e(t,o)}))):t instanceof r.default?(e(t.key,o),e(t.value,o)):t instanceof a.default&&s&&(o[s]=!0)}return o}(e,{}))}}));a(oe);var ie=o((function(e,t){function n(e,t){if(!r||!r._YAML_SILENCE_WARNINGS){var n=(r&&r.process).emitWarning;n?n(e,t):console.warn(t?"".concat(t,": ").concat(e):e)}}Object.defineProperty(t,"__esModule",{value:!0}),t.warn=n,t.warnFileDeprecation=function(e){if(r&&r._YAML_SILENCE_DEPRECATION_WARNINGS)return;var t=e.replace(/.*yaml[/\\]/i,"").replace(/\.js$/,"").replace(/\\/g,"/");n("The endpoint 'yaml/".concat(t,"' will be removed in a future release."),"DeprecationWarning")},t.warnOptionDeprecation=function(e,t){if(r&&r._YAML_SILENCE_DEPRECATION_WARNINGS)return;if(a[e])return;a[e]=!0;var o="The option '".concat(e,"' will be removed in a future release");n(o+=t?", use '".concat(t,"' instead."):".","DeprecationWarning")};var a={}}));a(ie);ie.warn,ie.warnFileDeprecation,ie.warnOptionDeprecation;var se=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t,o,i){var s=i.indentAtStart,u=i.lineWidth,f=void 0===u?80:u,l=i.minContentWidth,c=void 0===l?20:l,d=i.onFold,h=i.onOverflow;if(!f||f<0)return e;var p=Math.max(1+c,1+f-t.length);if(e.length<=p)return e;var v,g=[],m={},y=f-("number"==typeof s?s:t.length),_=void 0,b=void 0,w=!1,E=-1;o===n&&-1!==(E=a(e,E))&&(y=E+p);for(;v=e[E+=1];){if(o===r&&"\\"===v)switch(e[E+1]){case"x":E+=3;break;case"u":E+=5;break;case"U":E+=9;break;default:E+=1}if("\n"===v)o===n&&(E=a(e,E)),y=E+p,_=void 0;else{if(" "===v&&b&&" "!==b&&"\n"!==b&&"\t"!==b){var O=e[E+1];O&&" "!==O&&"\n"!==O&&"\t"!==O&&(_=E)}if(E>=y)if(_)g.push(_),y=_+p,_=void 0;else if(o===r){for(;" "===b||"\t"===b;)b=v,v=e[E+=1],w=!0;g.push(E-2),m[E-2]=!0,y=E-2+p,_=void 0}else w=!0}b=v}w&&h&&h();if(0===g.length)return e;d&&d();for(var M=e.slice(0,g[0]),S=0;S<g.length;++S){var A=g[S],k=g[S+1]||e.length;o===r&&m[A]&&(M+="".concat(e[A],"\\")),M+="\n".concat(t).concat(e.slice(A+1,k))}return M},t.FOLD_QUOTED=t.FOLD_BLOCK=t.FOLD_FLOW=void 0;t.FOLD_FLOW="flow";var n="block";t.FOLD_BLOCK=n;var r="quoted";t.FOLD_QUOTED=r;var a=function(e,t){for(var n=e[t+1];" "===n||"\t"===n;){do{n=e[t+=1]}while(n&&"\n"!==n);n=e[t+1]}return t}}));a(se);se.FOLD_QUOTED,se.FOLD_BLOCK,se.FOLD_FLOW;var ue=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.strOptions=t.nullOptions=t.boolOptions=t.binaryOptions=void 0;var n={defaultType:T.Type.BLOCK_LITERAL,lineWidth:76};t.binaryOptions=n;t.boolOptions={trueStr:"true",falseStr:"false"};t.nullOptions={nullStr:"null"};var r={defaultType:T.Type.PLAIN,doubleQuoted:{jsonEncoding:!1,minMultiLineLength:40},fold:{lineWidth:80,minContentWidth:20}};t.strOptions=r}));a(ue);ue.strOptions,ue.nullOptions,ue.boolOptions,ue.binaryOptions;var fe=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.stringifyNumber=function(e){var t=e.format,n=e.minFractionDigits,r=e.tag,a=e.value;if(!isFinite(a))return isNaN(a)?".nan":a<0?"-.inf":".inf";var o=JSON.stringify(a);if(!t&&n&&(!r||"tag:yaml.org,2002:float"===r)&&/^\d/.test(o)){var i=o.indexOf(".");i<0&&(i=o.length,o+=".");for(var s=n-(o.length-i-1);s-- >0;)o+="0"}return o},t.stringifyString=function(e,t,i,s){var u=ue.strOptions.defaultType,f=t.implicitKey,l=t.inFlow,c=e,d=c.type,h=c.value;"string"!=typeof h&&(h=String(h),e=Object.assign({},e,{value:h}));var p=function(u){switch(u){case T.Type.BLOCK_FOLDED:case T.Type.BLOCK_LITERAL:return o(e,t,i,s);case T.Type.QUOTE_DOUBLE:return r(h,t);case T.Type.QUOTE_SINGLE:return a(h,t);case T.Type.PLAIN:return function(e,t,i,s){var u=e.comment,f=e.type,l=e.value,c=t.actualString,d=t.implicitKey,h=t.indent,p=t.inFlow,v=t.tags;if(d&&/[\n[\]{},]/.test(l)||p&&/[[\]{},]/.test(l))return r(l,t);if(!l||/^[\n\t ,[\]{}#&*!|>'"%@`]|^[?-]$|^[?-][ \t]|[\n:][ \t]|[ \t]\n|[\n\t ]#|[\n\t :]$/.test(l))return d||p||-1===l.indexOf("\n")?-1!==l.indexOf('"')&&-1===l.indexOf("'")?a(l,t):r(l,t):o(e,t,i,s);if(!d&&!p&&f!==T.Type.PLAIN&&-1!==l.indexOf("\n"))return o(e,t,i,s);var g=l.replace(/\n+/g,"$&\n".concat(h));if(c&&"string"!=typeof v.resolveScalar(g).value)return r(l,t);var m=d?g:(0,n.default)(g,h,n.FOLD_FLOW,ue.strOptions.fold);if(u&&!p&&(-1!==m.indexOf("\n")||-1!==u.indexOf("\n")))return i&&i(),(0,J.addCommentBefore)(m,h,u);return m}(e,t,i,s);default:return null}};d!==T.Type.QUOTE_DOUBLE&&/[\x00-\x08\x0b-\x1f\x7f-\x9f]/.test(h)?d=T.Type.QUOTE_DOUBLE:!f&&!l||d!==T.Type.BLOCK_FOLDED&&d!==T.Type.BLOCK_LITERAL||(d=T.Type.QUOTE_DOUBLE);var v=p(d);if(null===v&&null===(v=p(u)))throw new Error("Unsupported default string type ".concat(u));return v};var n=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)if(Object.prototype.hasOwnProperty.call(e,n)){var r=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(e,n):{};r.get||r.set?Object.defineProperty(t,n,r):t[n]=e[n]}return t.default=e,t}(se);function r(e,t){var r=t.implicitKey,a=t.indent,o=ue.strOptions.doubleQuoted,i=o.jsonEncoding,s=o.minMultiLineLength,u=JSON.stringify(e);if(i)return u;for(var f="",l=0,c=0,d=u[c];d;d=u[++c])if(" "===d&&"\\"===u[c+1]&&"n"===u[c+2]&&(f+=u.slice(l,c)+"\\ ",l=c+=1,d="\\"),"\\"===d)switch(u[c+1]){case"u":f+=u.slice(l,c);var h=u.substr(c+2,4);switch(h){case"0000":f+="\\0";break;case"0007":f+="\\a";break;case"000b":f+="\\v";break;case"001b":f+="\\e";break;case"0085":f+="\\N";break;case"00a0":f+="\\_";break;case"2028":f+="\\L";break;case"2029":f+="\\P";break;default:"00"===h.substr(0,2)?f+="\\x"+h.substr(2):f+=u.substr(c,6)}l=(c+=5)+1;break;case"n":if(r||'"'===u[c+2]||u.length<s)c+=1;else{for(f+=u.slice(l,c)+"\n\n";"\\"===u[c+2]&&"n"===u[c+3]&&'"'!==u[c+4];)f+="\n",c+=2;f+=a," "===u[c+2]&&(f+="\\"),l=(c+=1)+1}break;default:c+=1}return f=l?f+u.slice(l):u,r?f:(0,n.default)(f,a,n.FOLD_QUOTED,ue.strOptions.fold)}function a(e,t){var a=t.indent,o=t.implicitKey;if(o){if(/\n/.test(e))return r(e,t)}else if(/[ \t]\n|\n[ \t]/.test(e))return r(e,t);var i="'"+e.replace(/'/g,"''").replace(/\n+/g,"$&\n".concat(a))+"'";return o?i:(0,n.default)(i,a,n.FOLD_FLOW,ue.strOptions.fold)}function o(e,t,a,o){var i=e.comment,s=e.type,u=e.value;if(/\n[\t ]+$/.test(u)||/^\s*$/.test(u))return r(u,t);var f=t.indent||(t.forceBlockIndent?" ":""),l=f?"2":"1",c=s!==T.Type.BLOCK_FOLDED&&(s===T.Type.BLOCK_LITERAL||!function(e,t){var n=e.length;if(n<=t)return!1;for(var r=0,a=0;r<n;++r)if("\n"===e[r]){if(r-a>t)return!0;if(n-(a=r+1)<=t)return!1}return!0}(u,ue.strOptions.fold.lineWidth-f.length)),d=c?"|":">";if(!u)return d+"\n";var h="",p="";if(u=u.replace(/[\n\t ]*$/,(function(e){var t=e.indexOf("\n");return-1===t?d+="-":u!==e&&t===e.length-1||(d+="+",o&&o()),p=e.replace(/\n$/,""),""})).replace(/^[\n ]*/,(function(e){-1!==e.indexOf(" ")&&(d+=l);var t=e.match(/ +$/);return t?(h=e.slice(0,-t[0].length),t[0]):(h=e,"")})),p&&(p=p.replace(/\n+(?!\n|$)/g,"$&".concat(f))),h&&(h=h.replace(/\n+/g,"$&".concat(f))),i&&(d+=" #"+i.replace(/ ?[\r\n]+/g," "),a&&a()),!u)return"".concat(d).concat(l,"\n").concat(f).concat(p);if(c)return u=u.replace(/\n+/g,"$&".concat(f)),"".concat(d,"\n").concat(f).concat(h).concat(u).concat(p);u=u.replace(/\n+/g,"\n$&").replace(/(?:^|\n)([\t ].*)(?:([\n\t ]*)\n(?![\n\t ]))?/g,"$1$2").replace(/\n+/g,"$&".concat(f));var v=(0,n.default)("".concat(h).concat(u).concat(p),f,n.FOLD_BLOCK,ue.strOptions.fold);return"".concat(d,"\n").concat(f).concat(v)}}));a(fe);fe.stringifyNumber,fe.stringifyString;var le=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.checkFlowCollectionEnd=function(e,t){var n,r,a;switch(t.type){case T.Type.FLOW_MAP:n="}",r="flow map";break;case T.Type.FLOW_SEQ:n="]",r="flow sequence";break;default:return void e.push(new x.YAMLSemanticError(t,"Not a flow collection!?"))}for(var o=t.items.length-1;o>=0;--o){var i=t.items[o];if(!i||i.type!==T.Type.COMMENT){a=i;break}}if(a&&a.char!==n){var s,u="Expected ".concat(r," to end with ").concat(n);"number"==typeof a.offset?(s=new x.YAMLSemanticError(t,u)).offset=a.offset+1:(s=new x.YAMLSemanticError(a,u),a.range&&a.range.end&&(s.offset=a.range.end-a.range.start)),e.push(s)}},t.checkKeyLength=function(e,t,n,r,a){if(!r||"number"!=typeof a)return;var o=t.items[n],i=o&&o.range&&o.range.start;if(!i)for(var s=n-1;s>=0;--s){var u=t.items[s];if(u&&u.range){i=u.range.end+2*(n-s);break}}if(i>a+1024){var f=String(r).substr(0,8)+"..."+String(r).substr(-8);e.push(new x.YAMLSemanticError(t,'The "'.concat(f,'" key is too long')))}},t.resolveComments=function(e,t){var n=!0,r=!1,a=void 0;try{for(var o,i=t[Symbol.iterator]();!(n=(o=i.next()).done);n=!0){var s=o.value,u=s.afterKey,f=s.before,l=s.comment,c=e.items[f];c?(u&&c.value&&(c=c.value),void 0===l?!u&&c.commentBefore||(c.spaceBefore=!0):c.commentBefore?c.commentBefore+="\n"+l:c.commentBefore=l):void 0!==l&&(e.comment?e.comment+="\n"+l:e.comment=l)}}catch(e){r=!0,a=e}finally{try{n||null==i.return||i.return()}finally{if(r)throw a}}}}));a(le);le.checkFlowCollectionEnd,le.checkKeyLength,le.resolveComments;var ce=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(t.type!==T.Type.MAP&&t.type!==T.Type.FLOW_MAP){var u="A ".concat(t.type," node cannot be resolved as a mapping");return e.errors.push(new x.YAMLSyntaxError(t,u)),null}var f=t.type===T.Type.FLOW_MAP?function(e,t){for(var n=[],r=[],a=void 0,i=null,s=!1,u="{",f=0;f<t.items.length;++f){(0,le.checkKeyLength)(e.errors,t,f,a,i);var l=t.items[f];if("string"==typeof l.char){var c=l.char,d=l.offset;if("?"===c&&void 0===a&&!s){s=!0,u=":";continue}if(":"===c){if(void 0===a&&(a=null),":"===u){u=",";continue}}else if(s&&(void 0===a&&","!==c&&(a=null),s=!1),void 0!==a&&(r.push(new o.default(a)),a=void 0,i=null,","===c)){u=":";continue}if("}"===c){if(f===t.items.length-1)continue}else if(c===u){u=":";continue}var h="Flow map contains an unexpected ".concat(c),p=new x.YAMLSyntaxError(t,h);p.offset=d,e.errors.push(p)}else l.type===T.Type.BLANK_LINE?n.push({afterKey:!!a,before:r.length}):l.type===T.Type.COMMENT?n.push({afterKey:!!a,before:r.length,comment:l.comment}):void 0===a?(","===u&&e.errors.push(new x.YAMLSemanticError(l,"Separator , missing in flow map")),a=e.resolveNode(l),i=s?null:l.range.start):(","!==u&&e.errors.push(new x.YAMLSemanticError(l,"Indicator : missing in flow map entry")),r.push(new o.default(a,e.resolveNode(l))),a=void 0,s=!1)}(0,le.checkFlowCollectionEnd)(e.errors,t),void 0!==a&&r.push(new o.default(a));return{comments:n,items:r}}(e,t):function(e,t){for(var r=[],a=[],i=void 0,s=null,u=0;u<t.items.length;++u){var f=t.items[u];switch(f.type){case T.Type.BLANK_LINE:r.push({afterKey:!!i,before:a.length});break;case T.Type.COMMENT:r.push({afterKey:!!i,before:a.length,comment:f.comment});break;case T.Type.MAP_KEY:void 0!==i&&a.push(new o.default(i)),f.error&&e.errors.push(f.error),i=e.resolveNode(f.node),s=null;break;case T.Type.MAP_VALUE:if(void 0===i&&(i=null),f.error&&e.errors.push(f.error),!f.context.atLineStart&&f.node&&f.node.type===T.Type.MAP&&!f.node.context.atLineStart){e.errors.push(new x.YAMLSemanticError(f.node,"Nested mappings are not allowed in compact mappings"))}var c=f.node;if(!c&&f.props.length>0){(c=new n.default(T.Type.PLAIN,[])).context={parent:f,src:f.context.src};var d=f.range.start+1;if(c.range={start:d,end:d},c.valueRange={start:d,end:d},"number"==typeof f.range.origStart){var h=f.range.origStart+1;c.range.origStart=c.range.origEnd=h,c.valueRange.origStart=c.valueRange.origEnd=h}}var p=new o.default(i,e.resolveNode(c));l(f,p),a.push(p),(0,le.checkKeyLength)(e.errors,t,u,i,s),i=void 0,s=null;break;default:void 0!==i&&a.push(new o.default(i)),i=e.resolveNode(f),s=f.range.start,f.error&&e.errors.push(f.error);e:for(var v=u+1;;++v){var g=t.items[v];switch(g&&g.type){case T.Type.BLANK_LINE:case T.Type.COMMENT:continue e;case T.Type.MAP_VALUE:break e;default:e.errors.push(new x.YAMLSemanticError(f,"Implicit map keys need to be followed by map values"));break e}}if(f.valueRangeContainsNewline){e.errors.push(new x.YAMLSemanticError(f,"Implicit map keys need to be on a single line"))}}}void 0!==i&&a.push(new o.default(i));return{comments:r,items:a}}(e,t),c=f.comments,d=f.items,h=new r.default;h.items=d,(0,le.resolveComments)(h,c);for(var p=!1,v=0;v<d.length;++v){var g=d[v].key;if(g instanceof s.default&&(p=!0),e.schema.merge&&g&&g.value===a.MERGE_KEY){d[v]=new a.default(d[v]);var m=d[v].value.items,y=null;m.some((function(e){if(e instanceof i.default){var t=e.source.type;return t!==T.Type.MAP&&t!==T.Type.FLOW_MAP&&(y="Merge nodes aliases can only point to maps")}return y="Merge nodes can only have Alias nodes as values"})),y&&e.errors.push(new x.YAMLSemanticError(t,y))}else for(var _=v+1;_<d.length;++_){var b=d[_].key;if(g===b||g&&b&&Object.prototype.hasOwnProperty.call(g,"value")&&g.value===b.value){var w='Map keys must be unique; "'.concat(g,'" is repeated');e.errors.push(new x.YAMLSemanticError(t,w));break}}}if(p&&!e.options.mapAsMap){e.warnings.push(new x.YAMLWarning(t,"Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this."))}return t.resolved=h,h};var n=u(W),r=u(te),a=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)if(Object.prototype.hasOwnProperty.call(e,n)){var r=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(e,n):{};r.get||r.set?Object.defineProperty(t,n,r):t[n]=e[n]}return t.default=e,t}(re),o=u(Z),i=u(ee),s=u(X);function u(e){return e&&e.__esModule?e:{default:e}}var f=function(e){var t=e.context,n=t.lineStart,r=t.node,a=t.src,o=e.props;if(0===o.length)return!1;var i=o[0].start;if(r&&i>r.valueRange.start)return!1;if(a[i]!==T.Char.COMMENT)return!1;for(var s=n;s<i;++s)if("\n"===a[s])return!1;return!0};function l(e,t){if(f(e)){var n=e.getPropValue(0,T.Char.COMMENT,!0),r=!1,a=t.value.commentBefore;if(a&&a.startsWith(n))t.value.commentBefore=a.substr(n.length+1),r=!0;else{var o=t.value.comment;!e.node&&o&&o.startsWith(n)&&(t.value.comment=o.substr(n.length+1),r=!0)}r&&(t.comment=n)}}}));a(ce);var de=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=a(te),r=a(ce);function a(e){return e&&e.__esModule?e:{default:e}}var o={createNode:function(e,t,r){var a=new n.default;if(t instanceof Map){var o=!0,s=!1,u=void 0;try{for(var f,l=t[Symbol.iterator]();!(o=(f=l.next()).done);o=!0){var c=y(f.value,2),d=c[0],h=c[1];a.items.push(e.createPair(d,h,r))}}catch(e){s=!0,u=e}finally{try{o||null==l.return||l.return()}finally{if(s)throw u}}}else if(t&&"object"===i(t))for(var p=0,v=Object.keys(t);p<v.length;p++){var g=v[p];a.items.push(e.createPair(g,t[g],r))}return a},default:!0,nodeClass:n.default,tag:"tag:yaml.org,2002:map",resolve:r.default};t.default=o}));a(de);var he=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=function(e,t){if(t.type!==T.Type.SEQ&&t.type!==T.Type.FLOW_SEQ){var o="A ".concat(t.type," node cannot be resolved as a sequence");return e.errors.push(new x.YAMLSyntaxError(t,o)),null}var i=t.type===T.Type.FLOW_SEQ?function(e,t){for(var r=[],a=[],o=!1,i=void 0,s=null,u="[",f=0;f<t.items.length;++f){var l=t.items[f];if("string"==typeof l.char){var c=l.char,d=l.offset;if(":"===c||!o&&void 0===i||(o&&void 0===i&&(i=u?a.pop():null),a.push(new n.default(i)),o=!1,i=void 0,s=null),c===u)u=null;else if(u||"?"!==c){if("["!==u&&":"===c&&void 0===i){if(","===u){if((i=a.pop())instanceof n.default){var h=new x.YAMLSemanticError(t,"Chaining flow sequence pairs is invalid");h.offset=d,e.errors.push(h)}o||(0,le.checkKeyLength)(e.errors,t,f,i,s)}else i=null;s=null,o=!1,u=null}else if("["===u||"]"!==c||f<t.items.length-1){var p="Flow sequence contains an unexpected ".concat(c),v=new x.YAMLSyntaxError(t,p);v.offset=d,e.errors.push(v)}}else o=!0}else if(l.type===T.Type.BLANK_LINE)r.push({before:a.length});else if(l.type===T.Type.COMMENT)r.push({comment:l.comment,before:a.length});else{if(u){var g="Expected a ".concat(u," in flow sequence");e.errors.push(new x.YAMLSemanticError(l,g))}var m=e.resolveNode(l);void 0===i?a.push(m):(a.push(new n.default(i,m)),i=void 0),s=l.range.start,u=","}}(0,le.checkFlowCollectionEnd)(e.errors,t),void 0!==i&&a.push(new n.default(i));return{comments:r,items:a}}(e,t):function(e,t){for(var n=[],r=[],a=0;a<t.items.length;++a){var o=t.items[a];switch(o.type){case T.Type.BLANK_LINE:n.push({before:r.length});break;case T.Type.COMMENT:n.push({comment:o.comment,before:r.length});break;case T.Type.SEQ_ITEM:if(o.error&&e.errors.push(o.error),r.push(e.resolveNode(o.node)),o.hasProps){e.errors.push(new x.YAMLSemanticError(o,"Sequence items cannot have tags or anchors before the - indicator"))}break;default:o.error&&e.errors.push(o.error),e.errors.push(new x.YAMLSyntaxError(o,"Unexpected ".concat(o.type," node in sequence")))}}return{comments:n,items:r}}(e,t),s=i.comments,u=i.items,f=new r.default;if(f.items=u,(0,le.resolveComments)(f,s),!e.options.mapAsMap&&u.some((function(e){return e instanceof n.default&&e.key instanceof a.default}))){e.warnings.push(new x.YAMLWarning(t,"Keys with collection values will be stringified as YAML due to JS Object restrictions. Use mapAsMap: true to avoid this."))}return t.resolved=f,f};var n=o(Z),r=o(ne),a=o(X);function o(e){return e&&e.__esModule?e:{default:e}}}));a(he);var pe=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=a(he),r=a(ne);function a(e){return e&&e.__esModule?e:{default:e}}var o={createNode:function(e,t,n){var a=new r.default;if(t&&t[Symbol.iterator]){var o=!0,i=!1,s=void 0;try{for(var u,f=t[Symbol.iterator]();!(o=(u=f.next()).done);o=!0){var l=u.value,c=e.createNode(l,n.wrapScalars,null,n);a.items.push(c)}}catch(e){i=!0,s=e}finally{try{o||null==f.return||f.return()}finally{if(i)throw s}}}return a},default:!0,nodeClass:r.default,tag:"tag:yaml.org,2002:seq",resolve:n.default};t.default=o}));a(pe);var ve=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=t.resolveString=void 0;var n=function(e,t){var n=t.strValue;return n?"string"==typeof n?n:(n.errors.forEach((function(n){n.source||(n.source=t),e.errors.push(n)})),n.str):""};t.resolveString=n;var r={identify:function(e){return"string"==typeof e},default:!0,tag:"tag:yaml.org,2002:str",resolve:n,stringify:function(e,t,n,r){return t=Object.assign({actualString:!0},t),(0,fe.stringifyString)(e,t,n,r)},options:ue.strOptions};t.default=r}));a(ve);ve.resolveString;var ge=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=o(de),r=o(pe),a=o(ve);function o(e){return e&&e.__esModule?e:{default:e}}var i=[n.default,r.default,a.default];t.default=i}));a(ge);var me=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=r(z);function r(e){return e&&e.__esModule?e:{default:e}}var a=r(ge).default.concat([{identify:function(e){return null==e},createNode:function(e,t,r){return r.wrapScalars?new n.default(null):null},default:!0,tag:"tag:yaml.org,2002:null",test:/^(?:~|[Nn]ull|NULL)?$/,resolve:function(){return null},options:ue.nullOptions,stringify:function(){return ue.nullOptions.nullStr}},{identify:function(e){return"boolean"==typeof e},default:!0,tag:"tag:yaml.org,2002:bool",test:/^(?:[Tt]rue|TRUE|[Ff]alse|FALSE)$/,resolve:function(e){return"t"===e[0]||"T"===e[0]},options:ue.boolOptions,stringify:function(e){return e.value?ue.boolOptions.trueStr:ue.boolOptions.falseStr}},{identify:function(e){return"number"==typeof e},default:!0,tag:"tag:yaml.org,2002:int",format:"OCT",test:/^0o([0-7]+)$/,resolve:function(e,t){return parseInt(t,8)},stringify:function(e){return"0o"+e.value.toString(8)}},{identify:function(e){return"number"==typeof e},default:!0,tag:"tag:yaml.org,2002:int",test:/^[-+]?[0-9]+$/,resolve:function(e){return parseInt(e,10)},stringify:fe.stringifyNumber},{identify:function(e){return"number"==typeof e},default:!0,tag:"tag:yaml.org,2002:int",format:"HEX",test:/^0x([0-9a-fA-F]+)$/,resolve:function(e,t){return parseInt(t,16)},stringify:function(e){return"0x"+e.value.toString(16)}},{identify:function(e){return"number"==typeof e},default:!0,tag:"tag:yaml.org,2002:float",test:/^(?:[-+]?\.inf|(\.nan))$/i,resolve:function(e,t){return t?NaN:"-"===e[0]?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY},stringify:fe.stringifyNumber},{identify:function(e){return"number"==typeof e},default:!0,tag:"tag:yaml.org,2002:float",format:"EXP",test:/^[-+]?(?:0|[1-9][0-9]*)(\.[0-9]*)?[eE][-+]?[0-9]+$/,resolve:function(e){return parseFloat(e)},stringify:function(e){var t=e.value;return Number(t).toExponential()}},{identify:function(e){return"number"==typeof e},default:!0,tag:"tag:yaml.org,2002:float",test:/^[-+]?(?:0|[1-9][0-9]*)\.([0-9]*)$/,resolve:function(e,t){var r=new n.default(parseFloat(e));return t&&"0"===t[t.length-1]&&(r.minFractionDigits=t.length),r},stringify:fe.stringifyNumber}]);t.default=a}));a(me);var ye=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=o(de),r=o(pe),a=o(z);function o(e){return e&&e.__esModule?e:{default:e}}var i=[n.default,r.default,{identify:function(e){return"string"==typeof e},default:!0,tag:"tag:yaml.org,2002:str",resolve:ve.resolveString,stringify:function(e){return JSON.stringify(e)}},{identify:function(e){return null==e},createNode:function(e,t,n){return n.wrapScalars?new a.default(null):null},default:!0,tag:"tag:yaml.org,2002:null",test:/^null$/,resolve:function(){return null},stringify:function(e){return JSON.stringify(e)}},{identify:function(e){return"boolean"==typeof e},default:!0,tag:"tag:yaml.org,2002:bool",test:/^true$/,resolve:function(){return!0},stringify:function(e){return JSON.stringify(e)}},{identify:function(e){return"boolean"==typeof e},default:!0,tag:"tag:yaml.org,2002:bool",test:/^false$/,resolve:function(){return!1},stringify:function(e){return JSON.stringify(e)}},{identify:function(e){return"number"==typeof e},default:!0,tag:"tag:yaml.org,2002:int",test:/^-?(?:0|[1-9][0-9]*)$/,resolve:function(e){return parseInt(e,10)},stringify:function(e){return JSON.stringify(e)}},{identify:function(e){return"number"==typeof e},default:!0,tag:"tag:yaml.org,2002:float",test:/^-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][-+]?[0-9]+)?$/,resolve:function(e){return parseFloat(e)},stringify:function(e){return JSON.stringify(e)}}];i.scalarFallback=function(e){throw new SyntaxError("Unresolved plain scalar ".concat(JSON.stringify(e)))};var s=i;t.default=s}));a(ye);var _e="undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{},be=[],we=[],Ee="undefined"!=typeof Uint8Array?Uint8Array:Array,Oe=!1;function Me(){Oe=!0;for(var e="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",t=0,n=e.length;t<n;++t)be[t]=e[t],we[e.charCodeAt(t)]=t;we["-".charCodeAt(0)]=62,we["_".charCodeAt(0)]=63}function Se(e,t,n){for(var r,a,o=[],i=t;i<n;i+=3)r=(e[i]<<16)+(e[i+1]<<8)+e[i+2],o.push(be[(a=r)>>18&63]+be[a>>12&63]+be[a>>6&63]+be[63&a]);return o.join("")}function Ae(e){var t;Oe||Me();for(var n=e.length,r=n%3,a="",o=[],i=0,s=n-r;i<s;i+=16383)o.push(Se(e,i,i+16383>s?s:i+16383));return 1===r?(t=e[n-1],a+=be[t>>2],a+=be[t<<4&63],a+="=="):2===r&&(t=(e[n-2]<<8)+e[n-1],a+=be[t>>10],a+=be[t>>4&63],a+=be[t<<2&63],a+="="),o.push(a),o.join("")}function ke(e,t,n,r,a){var o,i,s=8*a-r-1,u=(1<<s)-1,f=u>>1,l=-7,c=n?a-1:0,d=n?-1:1,h=e[t+c];for(c+=d,o=h&(1<<-l)-1,h>>=-l,l+=s;l>0;o=256*o+e[t+c],c+=d,l-=8);for(i=o&(1<<-l)-1,o>>=-l,l+=r;l>0;i=256*i+e[t+c],c+=d,l-=8);if(0===o)o=1-f;else{if(o===u)return i?NaN:1/0*(h?-1:1);i+=Math.pow(2,r),o-=f}return(h?-1:1)*i*Math.pow(2,o-r)}function Le(e,t,n,r,a,o){var i,s,u,f=8*o-a-1,l=(1<<f)-1,c=l>>1,d=23===a?Math.pow(2,-24)-Math.pow(2,-77):0,h=r?0:o-1,p=r?1:-1,v=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(s=isNaN(t)?1:0,i=l):(i=Math.floor(Math.log(t)/Math.LN2),t*(u=Math.pow(2,-i))<1&&(i--,u*=2),(t+=i+c>=1?d/u:d*Math.pow(2,1-c))*u>=2&&(i++,u/=2),i+c>=l?(s=0,i=l):i+c>=1?(s=(t*u-1)*Math.pow(2,a),i+=c):(s=t*Math.pow(2,c-1)*Math.pow(2,a),i=0));a>=8;e[n+h]=255&s,h+=p,s/=256,a-=8);for(i=i<<a|s,f+=a;f>0;e[n+h]=255&i,h+=p,i/=256,f-=8);e[n+h-p]|=128*v}var Te={}.toString,Pe=Array.isArray||function(e){return"[object Array]"==Te.call(e)};function Ce(){return xe.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function Ne(e,t){if(Ce()<t)throw new RangeError("Invalid typed array length");return xe.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(t)).__proto__=xe.prototype:(null===e&&(e=new xe(t)),e.length=t),e}function xe(e,t,n){if(!(xe.TYPED_ARRAY_SUPPORT||this instanceof xe))return new xe(e,t,n);if("number"==typeof e){if("string"==typeof t)throw new Error("If encoding is specified then the first argument must be a string");return Be(this,e)}return Re(this,e,t,n)}function Re(e,t,n,r){if("number"==typeof t)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer?function(e,t,n,r){if(t.byteLength,n<0||t.byteLength<n)throw new RangeError("'offset' is out of bounds");if(t.byteLength<n+(r||0))throw new RangeError("'length' is out of bounds");t=void 0===n&&void 0===r?new Uint8Array(t):void 0===r?new Uint8Array(t,n):new Uint8Array(t,n,r);xe.TYPED_ARRAY_SUPPORT?(e=t).__proto__=xe.prototype:e=De(e,t);return e}(e,t,n,r):"string"==typeof t?function(e,t,n){"string"==typeof n&&""!==n||(n="utf8");if(!xe.isEncoding(n))throw new TypeError('"encoding" must be a valid string encoding');var r=0|Fe(t,n),a=(e=Ne(e,r)).write(t,n);a!==r&&(e=e.slice(0,a));return e}(e,t,n):function(e,t){if(Ye(t)){var n=0|je(t.length);return 0===(e=Ne(e,n)).length?e:(t.copy(e,0,0,n),e)}if(t){if("undefined"!=typeof ArrayBuffer&&t.buffer instanceof ArrayBuffer||"length"in t)return"number"!=typeof t.length||(r=t.length)!=r?Ne(e,0):De(e,t);if("Buffer"===t.type&&Pe(t.data))return De(e,t.data)}var r;throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(e,t)}function Ie(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function Be(e,t){if(Ie(t),e=Ne(e,t<0?0:0|je(t)),!xe.TYPED_ARRAY_SUPPORT)for(var n=0;n<t;++n)e[n]=0;return e}function De(e,t){var n=t.length<0?0:0|je(t.length);e=Ne(e,n);for(var r=0;r<n;r+=1)e[r]=255&t[r];return e}function je(e){if(e>=Ce())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+Ce().toString(16)+" bytes");return 0|e}function Ye(e){return!(null==e||!e._isBuffer)}function Fe(e,t){if(Ye(e))return e.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;"string"!=typeof e&&(e=""+e);var n=e.length;if(0===n)return 0;for(var r=!1;;)switch(t){case"ascii":case"latin1":case"binary":return n;case"utf8":case"utf-8":case void 0:return ht(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*n;case"hex":return n>>>1;case"base64":return pt(e).length;default:if(r)return ht(e).length;t=(""+t).toLowerCase(),r=!0}}function Ue(e,t,n){var r=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===n||n>this.length)&&(n=this.length),n<=0)return"";if((n>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return nt(this,t,n);case"utf8":case"utf-8":return Ze(this,t,n);case"ascii":return et(this,t,n);case"latin1":case"binary":return tt(this,t,n);case"base64":return ze(this,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return rt(this,t,n);default:if(r)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),r=!0}}function Ke(e,t,n){var r=e[t];e[t]=e[n],e[n]=r}function We(e,t,n,r,a){if(0===e.length)return-1;if("string"==typeof n?(r=n,n=0):n>2147483647?n=2147483647:n<-2147483648&&(n=-2147483648),n=+n,isNaN(n)&&(n=a?0:e.length-1),n<0&&(n=e.length+n),n>=e.length){if(a)return-1;n=e.length-1}else if(n<0){if(!a)return-1;n=0}if("string"==typeof t&&(t=xe.from(t,r)),Ye(t))return 0===t.length?-1:Qe(e,t,n,r,a);if("number"==typeof t)return t&=255,xe.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?a?Uint8Array.prototype.indexOf.call(e,t,n):Uint8Array.prototype.lastIndexOf.call(e,t,n):Qe(e,[t],n,r,a);throw new TypeError("val must be string, number or Buffer")}function Qe(e,t,n,r,a){var o,i=1,s=e.length,u=t.length;if(void 0!==r&&("ucs2"===(r=String(r).toLowerCase())||"ucs-2"===r||"utf16le"===r||"utf-16le"===r)){if(e.length<2||t.length<2)return-1;i=2,s/=2,u/=2,n/=2}function f(e,t){return 1===i?e[t]:e.readUInt16BE(t*i)}if(a){var l=-1;for(o=n;o<s;o++)if(f(e,o)===f(t,-1===l?0:o-l)){if(-1===l&&(l=o),o-l+1===u)return l*i}else-1!==l&&(o-=o-l),l=-1}else for(n+u>s&&(n=s-u),o=n;o>=0;o--){for(var c=!0,d=0;d<u;d++)if(f(e,o+d)!==f(t,d)){c=!1;break}if(c)return o}return-1}function Ve(e,t,n,r){n=Number(n)||0;var a=e.length-n;r?(r=Number(r))>a&&(r=a):r=a;var o=t.length;if(o%2!=0)throw new TypeError("Invalid hex string");r>o/2&&(r=o/2);for(var i=0;i<r;++i){var s=parseInt(t.substr(2*i,2),16);if(isNaN(s))return i;e[n+i]=s}return i}function $e(e,t,n,r){return vt(ht(t,e.length-n),e,n,r)}function qe(e,t,n,r){return vt(function(e){for(var t=[],n=0;n<e.length;++n)t.push(255&e.charCodeAt(n));return t}(t),e,n,r)}function Je(e,t,n,r){return qe(e,t,n,r)}function Ge(e,t,n,r){return vt(pt(t),e,n,r)}function He(e,t,n,r){return vt(function(e,t){for(var n,r,a,o=[],i=0;i<e.length&&!((t-=2)<0);++i)n=e.charCodeAt(i),r=n>>8,a=n%256,o.push(a),o.push(r);return o}(t,e.length-n),e,n,r)}function ze(e,t,n){return 0===t&&n===e.length?Ae(e):Ae(e.slice(t,n))}function Ze(e,t,n){n=Math.min(e.length,n);for(var r=[],a=t;a<n;){var o,i,s,u,f=e[a],l=null,c=f>239?4:f>223?3:f>191?2:1;if(a+c<=n)switch(c){case 1:f<128&&(l=f);break;case 2:128==(192&(o=e[a+1]))&&(u=(31&f)<<6|63&o)>127&&(l=u);break;case 3:o=e[a+1],i=e[a+2],128==(192&o)&&128==(192&i)&&(u=(15&f)<<12|(63&o)<<6|63&i)>2047&&(u<55296||u>57343)&&(l=u);break;case 4:o=e[a+1],i=e[a+2],s=e[a+3],128==(192&o)&&128==(192&i)&&128==(192&s)&&(u=(15&f)<<18|(63&o)<<12|(63&i)<<6|63&s)>65535&&u<1114112&&(l=u)}null===l?(l=65533,c=1):l>65535&&(l-=65536,r.push(l>>>10&1023|55296),l=56320|1023&l),r.push(l),a+=c}return function(e){var t=e.length;if(t<=Xe)return String.fromCharCode.apply(String,e);var n="",r=0;for(;r<t;)n+=String.fromCharCode.apply(String,e.slice(r,r+=Xe));return n}(r)}xe.TYPED_ARRAY_SUPPORT=void 0===_e.TYPED_ARRAY_SUPPORT||_e.TYPED_ARRAY_SUPPORT,xe.poolSize=8192,xe._augment=function(e){return e.__proto__=xe.prototype,e},xe.from=function(e,t,n){return Re(null,e,t,n)},xe.TYPED_ARRAY_SUPPORT&&(xe.prototype.__proto__=Uint8Array.prototype,xe.__proto__=Uint8Array),xe.alloc=function(e,t,n){return function(e,t,n,r){return Ie(t),t<=0?Ne(e,t):void 0!==n?"string"==typeof r?Ne(e,t).fill(n,r):Ne(e,t).fill(n):Ne(e,t)}(null,e,t,n)},xe.allocUnsafe=function(e){return Be(null,e)},xe.allocUnsafeSlow=function(e){return Be(null,e)},xe.isBuffer=function(e){return null!=e&&(!!e._isBuffer||gt(e)||function(e){return"function"==typeof e.readFloatLE&&"function"==typeof e.slice&&gt(e.slice(0,0))}(e))},xe.compare=function(e,t){if(!Ye(e)||!Ye(t))throw new TypeError("Arguments must be Buffers");if(e===t)return 0;for(var n=e.length,r=t.length,a=0,o=Math.min(n,r);a<o;++a)if(e[a]!==t[a]){n=e[a],r=t[a];break}return n<r?-1:r<n?1:0},xe.isEncoding=function(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},xe.concat=function(e,t){if(!Pe(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return xe.alloc(0);var n;if(void 0===t)for(t=0,n=0;n<e.length;++n)t+=e[n].length;var r=xe.allocUnsafe(t),a=0;for(n=0;n<e.length;++n){var o=e[n];if(!Ye(o))throw new TypeError('"list" argument must be an Array of Buffers');o.copy(r,a),a+=o.length}return r},xe.byteLength=Fe,xe.prototype._isBuffer=!0,xe.prototype.swap16=function(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<e;t+=2)Ke(this,t,t+1);return this},xe.prototype.swap32=function(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<e;t+=4)Ke(this,t,t+3),Ke(this,t+1,t+2);return this},xe.prototype.swap64=function(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<e;t+=8)Ke(this,t,t+7),Ke(this,t+1,t+6),Ke(this,t+2,t+5),Ke(this,t+3,t+4);return this},xe.prototype.toString=function(){var e=0|this.length;return 0===e?"":0===arguments.length?Ze(this,0,e):Ue.apply(this,arguments)},xe.prototype.equals=function(e){if(!Ye(e))throw new TypeError("Argument must be a Buffer");return this===e||0===xe.compare(this,e)},xe.prototype.inspect=function(){var e="";return this.length>0&&(e=this.toString("hex",0,50).match(/.{2}/g).join(" "),this.length>50&&(e+=" ... ")),"<Buffer "+e+">"},xe.prototype.compare=function(e,t,n,r,a){if(!Ye(e))throw new TypeError("Argument must be a Buffer");if(void 0===t&&(t=0),void 0===n&&(n=e?e.length:0),void 0===r&&(r=0),void 0===a&&(a=this.length),t<0||n>e.length||r<0||a>this.length)throw new RangeError("out of range index");if(r>=a&&t>=n)return 0;if(r>=a)return-1;if(t>=n)return 1;if(this===e)return 0;for(var o=(a>>>=0)-(r>>>=0),i=(n>>>=0)-(t>>>=0),s=Math.min(o,i),u=this.slice(r,a),f=e.slice(t,n),l=0;l<s;++l)if(u[l]!==f[l]){o=u[l],i=f[l];break}return o<i?-1:i<o?1:0},xe.prototype.includes=function(e,t,n){return-1!==this.indexOf(e,t,n)},xe.prototype.indexOf=function(e,t,n){return We(this,e,t,n,!0)},xe.prototype.lastIndexOf=function(e,t,n){return We(this,e,t,n,!1)},xe.prototype.write=function(e,t,n,r){if(void 0===t)r="utf8",n=this.length,t=0;else if(void 0===n&&"string"==typeof t)r=t,n=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t|=0,isFinite(n)?(n|=0,void 0===r&&(r="utf8")):(r=n,n=void 0)}var a=this.length-t;if((void 0===n||n>a)&&(n=a),e.length>0&&(n<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");r||(r="utf8");for(var o=!1;;)switch(r){case"hex":return Ve(this,e,t,n);case"utf8":case"utf-8":return $e(this,e,t,n);case"ascii":return qe(this,e,t,n);case"latin1":case"binary":return Je(this,e,t,n);case"base64":return Ge(this,e,t,n);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return He(this,e,t,n);default:if(o)throw new TypeError("Unknown encoding: "+r);r=(""+r).toLowerCase(),o=!0}},xe.prototype.toJSON=function(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var Xe=4096;function et(e,t,n){var r="";n=Math.min(e.length,n);for(var a=t;a<n;++a)r+=String.fromCharCode(127&e[a]);return r}function tt(e,t,n){var r="";n=Math.min(e.length,n);for(var a=t;a<n;++a)r+=String.fromCharCode(e[a]);return r}function nt(e,t,n){var r=e.length;(!t||t<0)&&(t=0),(!n||n<0||n>r)&&(n=r);for(var a="",o=t;o<n;++o)a+=dt(e[o]);return a}function rt(e,t,n){for(var r=e.slice(t,n),a="",o=0;o<r.length;o+=2)a+=String.fromCharCode(r[o]+256*r[o+1]);return a}function at(e,t,n){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>n)throw new RangeError("Trying to access beyond buffer length")}function ot(e,t,n,r,a,o){if(!Ye(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>a||t<o)throw new RangeError('"value" argument is out of bounds');if(n+r>e.length)throw new RangeError("Index out of range")}function it(e,t,n,r){t<0&&(t=65535+t+1);for(var a=0,o=Math.min(e.length-n,2);a<o;++a)e[n+a]=(t&255<<8*(r?a:1-a))>>>8*(r?a:1-a)}function st(e,t,n,r){t<0&&(t=4294967295+t+1);for(var a=0,o=Math.min(e.length-n,4);a<o;++a)e[n+a]=t>>>8*(r?a:3-a)&255}function ut(e,t,n,r,a,o){if(n+r>e.length)throw new RangeError("Index out of range");if(n<0)throw new RangeError("Index out of range")}function ft(e,t,n,r,a){return a||ut(e,0,n,4),Le(e,t,n,r,23,4),n+4}function lt(e,t,n,r,a){return a||ut(e,0,n,8),Le(e,t,n,r,52,8),n+8}xe.prototype.slice=function(e,t){var n,r=this.length;if((e=~~e)<0?(e+=r)<0&&(e=0):e>r&&(e=r),(t=void 0===t?r:~~t)<0?(t+=r)<0&&(t=0):t>r&&(t=r),t<e&&(t=e),xe.TYPED_ARRAY_SUPPORT)(n=this.subarray(e,t)).__proto__=xe.prototype;else{var a=t-e;n=new xe(a,void 0);for(var o=0;o<a;++o)n[o]=this[o+e]}return n},xe.prototype.readUIntLE=function(e,t,n){e|=0,t|=0,n||at(e,t,this.length);for(var r=this[e],a=1,o=0;++o<t&&(a*=256);)r+=this[e+o]*a;return r},xe.prototype.readUIntBE=function(e,t,n){e|=0,t|=0,n||at(e,t,this.length);for(var r=this[e+--t],a=1;t>0&&(a*=256);)r+=this[e+--t]*a;return r},xe.prototype.readUInt8=function(e,t){return t||at(e,1,this.length),this[e]},xe.prototype.readUInt16LE=function(e,t){return t||at(e,2,this.length),this[e]|this[e+1]<<8},xe.prototype.readUInt16BE=function(e,t){return t||at(e,2,this.length),this[e]<<8|this[e+1]},xe.prototype.readUInt32LE=function(e,t){return t||at(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},xe.prototype.readUInt32BE=function(e,t){return t||at(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},xe.prototype.readIntLE=function(e,t,n){e|=0,t|=0,n||at(e,t,this.length);for(var r=this[e],a=1,o=0;++o<t&&(a*=256);)r+=this[e+o]*a;return r>=(a*=128)&&(r-=Math.pow(2,8*t)),r},xe.prototype.readIntBE=function(e,t,n){e|=0,t|=0,n||at(e,t,this.length);for(var r=t,a=1,o=this[e+--r];r>0&&(a*=256);)o+=this[e+--r]*a;return o>=(a*=128)&&(o-=Math.pow(2,8*t)),o},xe.prototype.readInt8=function(e,t){return t||at(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},xe.prototype.readInt16LE=function(e,t){t||at(e,2,this.length);var n=this[e]|this[e+1]<<8;return 32768&n?4294901760|n:n},xe.prototype.readInt16BE=function(e,t){t||at(e,2,this.length);var n=this[e+1]|this[e]<<8;return 32768&n?4294901760|n:n},xe.prototype.readInt32LE=function(e,t){return t||at(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},xe.prototype.readInt32BE=function(e,t){return t||at(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},xe.prototype.readFloatLE=function(e,t){return t||at(e,4,this.length),ke(this,e,!0,23,4)},xe.prototype.readFloatBE=function(e,t){return t||at(e,4,this.length),ke(this,e,!1,23,4)},xe.prototype.readDoubleLE=function(e,t){return t||at(e,8,this.length),ke(this,e,!0,52,8)},xe.prototype.readDoubleBE=function(e,t){return t||at(e,8,this.length),ke(this,e,!1,52,8)},xe.prototype.writeUIntLE=function(e,t,n,r){(e=+e,t|=0,n|=0,r)||ot(this,e,t,n,Math.pow(2,8*n)-1,0);var a=1,o=0;for(this[t]=255&e;++o<n&&(a*=256);)this[t+o]=e/a&255;return t+n},xe.prototype.writeUIntBE=function(e,t,n,r){(e=+e,t|=0,n|=0,r)||ot(this,e,t,n,Math.pow(2,8*n)-1,0);var a=n-1,o=1;for(this[t+a]=255&e;--a>=0&&(o*=256);)this[t+a]=e/o&255;return t+n},xe.prototype.writeUInt8=function(e,t,n){return e=+e,t|=0,n||ot(this,e,t,1,255,0),xe.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[t]=255&e,t+1},xe.prototype.writeUInt16LE=function(e,t,n){return e=+e,t|=0,n||ot(this,e,t,2,65535,0),xe.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):it(this,e,t,!0),t+2},xe.prototype.writeUInt16BE=function(e,t,n){return e=+e,t|=0,n||ot(this,e,t,2,65535,0),xe.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):it(this,e,t,!1),t+2},xe.prototype.writeUInt32LE=function(e,t,n){return e=+e,t|=0,n||ot(this,e,t,4,4294967295,0),xe.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):st(this,e,t,!0),t+4},xe.prototype.writeUInt32BE=function(e,t,n){return e=+e,t|=0,n||ot(this,e,t,4,4294967295,0),xe.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):st(this,e,t,!1),t+4},xe.prototype.writeIntLE=function(e,t,n,r){if(e=+e,t|=0,!r){var a=Math.pow(2,8*n-1);ot(this,e,t,n,a-1,-a)}var o=0,i=1,s=0;for(this[t]=255&e;++o<n&&(i*=256);)e<0&&0===s&&0!==this[t+o-1]&&(s=1),this[t+o]=(e/i>>0)-s&255;return t+n},xe.prototype.writeIntBE=function(e,t,n,r){if(e=+e,t|=0,!r){var a=Math.pow(2,8*n-1);ot(this,e,t,n,a-1,-a)}var o=n-1,i=1,s=0;for(this[t+o]=255&e;--o>=0&&(i*=256);)e<0&&0===s&&0!==this[t+o+1]&&(s=1),this[t+o]=(e/i>>0)-s&255;return t+n},xe.prototype.writeInt8=function(e,t,n){return e=+e,t|=0,n||ot(this,e,t,1,127,-128),xe.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[t]=255&e,t+1},xe.prototype.writeInt16LE=function(e,t,n){return e=+e,t|=0,n||ot(this,e,t,2,32767,-32768),xe.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):it(this,e,t,!0),t+2},xe.prototype.writeInt16BE=function(e,t,n){return e=+e,t|=0,n||ot(this,e,t,2,32767,-32768),xe.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):it(this,e,t,!1),t+2},xe.prototype.writeInt32LE=function(e,t,n){return e=+e,t|=0,n||ot(this,e,t,4,2147483647,-2147483648),xe.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):st(this,e,t,!0),t+4},xe.prototype.writeInt32BE=function(e,t,n){return e=+e,t|=0,n||ot(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),xe.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):st(this,e,t,!1),t+4},xe.prototype.writeFloatLE=function(e,t,n){return ft(this,e,t,!0,n)},xe.prototype.writeFloatBE=function(e,t,n){return ft(this,e,t,!1,n)},xe.prototype.writeDoubleLE=function(e,t,n){return lt(this,e,t,!0,n)},xe.prototype.writeDoubleBE=function(e,t,n){return lt(this,e,t,!1,n)},xe.prototype.copy=function(e,t,n,r){if(n||(n=0),r||0===r||(r=this.length),t>=e.length&&(t=e.length),t||(t=0),r>0&&r<n&&(r=n),r===n)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(n<0||n>=this.length)throw new RangeError("sourceStart out of bounds");if(r<0)throw new RangeError("sourceEnd out of bounds");r>this.length&&(r=this.length),e.length-t<r-n&&(r=e.length-t+n);var a,o=r-n;if(this===e&&n<t&&t<r)for(a=o-1;a>=0;--a)e[a+t]=this[a+n];else if(o<1e3||!xe.TYPED_ARRAY_SUPPORT)for(a=0;a<o;++a)e[a+t]=this[a+n];else Uint8Array.prototype.set.call(e,this.subarray(n,n+o),t);return o},xe.prototype.fill=function(e,t,n,r){if("string"==typeof e){if("string"==typeof t?(r=t,t=0,n=this.length):"string"==typeof n&&(r=n,n=this.length),1===e.length){var a=e.charCodeAt(0);a<256&&(e=a)}if(void 0!==r&&"string"!=typeof r)throw new TypeError("encoding must be a string");if("string"==typeof r&&!xe.isEncoding(r))throw new TypeError("Unknown encoding: "+r)}else"number"==typeof e&&(e&=255);if(t<0||this.length<t||this.length<n)throw new RangeError("Out of range index");if(n<=t)return this;var o;if(t>>>=0,n=void 0===n?this.length:n>>>0,e||(e=0),"number"==typeof e)for(o=t;o<n;++o)this[o]=e;else{var i=Ye(e)?e:ht(new xe(e,r).toString()),s=i.length;for(o=0;o<n-t;++o)this[o+t]=i[o%s]}return this};var ct=/[^+\/0-9A-Za-z-_]/g;function dt(e){return e<16?"0"+e.toString(16):e.toString(16)}function ht(e,t){var n;t=t||1/0;for(var r=e.length,a=null,o=[],i=0;i<r;++i){if((n=e.charCodeAt(i))>55295&&n<57344){if(!a){if(n>56319){(t-=3)>-1&&o.push(239,191,189);continue}if(i+1===r){(t-=3)>-1&&o.push(239,191,189);continue}a=n;continue}if(n<56320){(t-=3)>-1&&o.push(239,191,189),a=n;continue}n=65536+(a-55296<<10|n-56320)}else a&&(t-=3)>-1&&o.push(239,191,189);if(a=null,n<128){if((t-=1)<0)break;o.push(n)}else if(n<2048){if((t-=2)<0)break;o.push(n>>6|192,63&n|128)}else if(n<65536){if((t-=3)<0)break;o.push(n>>12|224,n>>6&63|128,63&n|128)}else{if(!(n<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;o.push(n>>18|240,n>>12&63|128,n>>6&63|128,63&n|128)}}return o}function pt(e){return function(e){var t,n,r,a,o,i;Oe||Me();var s=e.length;if(s%4>0)throw new Error("Invalid string. Length must be a multiple of 4");o="="===e[s-2]?2:"="===e[s-1]?1:0,i=new Ee(3*s/4-o),r=o>0?s-4:s;var u=0;for(t=0,n=0;t<r;t+=4,n+=3)a=we[e.charCodeAt(t)]<<18|we[e.charCodeAt(t+1)]<<12|we[e.charCodeAt(t+2)]<<6|we[e.charCodeAt(t+3)],i[u++]=a>>16&255,i[u++]=a>>8&255,i[u++]=255&a;return 2===o?(a=we[e.charCodeAt(t)]<<2|we[e.charCodeAt(t+1)]>>4,i[u++]=255&a):1===o&&(a=we[e.charCodeAt(t)]<<10|we[e.charCodeAt(t+1)]<<4|we[e.charCodeAt(t+2)]>>2,i[u++]=a>>8&255,i[u++]=255&a),i}(function(e){if((e=function(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}(e).replace(ct,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function vt(e,t,n,r){for(var a=0;a<r&&!(a+n>=t.length||a>=e.length);++a)t[a+n]=e[a];return a}function gt(e){return!!e.constructor&&"function"==typeof e.constructor.isBuffer&&e.constructor.isBuffer(e)}var mt=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n={identify:function(e){return e instanceof Uint8Array},default:!1,tag:"tag:yaml.org,2002:binary",resolve:function(e,t){var n=(0,ve.resolveString)(e,t);return xe.from(n,"base64")},options:ue.binaryOptions,stringify:function(e,t,n,r){var a,o=e.comment,i=e.type,s=e.value;if(a=s instanceof xe?s.toString("base64"):xe.from(s.buffer).toString("base64"),i||(i=ue.binaryOptions.defaultType),i===T.Type.QUOTE_DOUBLE)s=a;else{for(var u=ue.binaryOptions.lineWidth,f=Math.ceil(a.length/u),l=new Array(f),c=0,d=0;c<f;++c,d+=u)l[c]=a.substr(d,u);s=l.join(i===T.Type.BLOCK_LITERAL?"\n":" ")}return(0,fe.stringifyString)({comment:o,type:i,value:s},t,n,r)}};t.default=n}));a(mt);var yt=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.parsePairs=s,t.createPairs=u,t.default=void 0;var n=i(te),r=i(Z),a=i(he),o=i(ne);function i(e){return e&&e.__esModule?e:{default:e}}function s(e,t){for(var o=(0,a.default)(e,t),i=0;i<o.items.length;++i){var s=o.items[i];if(!(s instanceof r.default)){if(s instanceof n.default){if(s.items.length>1){throw new x.YAMLSemanticError(t,"Each pair must have its own sequence indicator")}var u=s.items[0]||new r.default;s.commentBefore&&(u.commentBefore=u.commentBefore?"".concat(s.commentBefore,"\n").concat(u.commentBefore):s.commentBefore),s.comment&&(u.comment=u.comment?"".concat(s.comment,"\n").concat(u.comment):s.comment),s=u}o.items[i]=s instanceof r.default?s:new r.default(s)}}return o}function u(e,t,n){var r=new o.default;r.tag="tag:yaml.org,2002:pairs";var a=!0,i=!1,s=void 0;try{for(var u,f=t[Symbol.iterator]();!(a=(u=f.next()).done);a=!0){var l=u.value,c=void 0,d=void 0;if(Array.isArray(l)){if(2!==l.length)throw new TypeError("Expected [key, value] tuple: ".concat(l));c=l[0],d=l[1]}else if(l&&l instanceof Object){var h=Object.keys(l);if(1!==h.length)throw new TypeError("Expected { key: value } tuple: ".concat(l));d=l[c=h[0]]}else c=l;var p=e.createPair(c,d,n);r.items.push(p)}}catch(e){i=!0,s=e}finally{try{a||null==f.return||f.return()}finally{if(i)throw s}}return r}var f={default:!1,tag:"tag:yaml.org,2002:pairs",resolve:s,createNode:u};t.default=f}));a(yt);yt.parsePairs,yt.createPairs;var _t=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=t.YAMLOMap=void 0;var n=i(G),r=i(te),a=i(Z),o=i(z);function i(e){return e&&e.__esModule?e:{default:e}}function u(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var d=function(e){function t(){var e;return s(this,t),u(v(e=g(this,c(t).call(this))),"add",r.default.prototype.add.bind(v(e))),u(v(e),"delete",r.default.prototype.delete.bind(v(e))),u(v(e),"get",r.default.prototype.get.bind(v(e))),u(v(e),"has",r.default.prototype.has.bind(v(e))),u(v(e),"set",r.default.prototype.set.bind(v(e))),e.tag=t.tag,e}return l(t,e),f(t,[{key:"toJSON",value:function(e,t){var r=new Map;t&&t.onCreate&&t.onCreate(r);var o=!0,i=!1,s=void 0;try{for(var u,f=this.items[Symbol.iterator]();!(o=(u=f.next()).done);o=!0){var l=u.value,c=void 0,d=void 0;if(l instanceof a.default?(c=(0,n.default)(l.key,"",t),d=(0,n.default)(l.value,c,t)):c=(0,n.default)(l,"",t),r.has(c))throw new Error("Ordered maps must not include duplicate keys");r.set(c,d)}}catch(e){i=!0,s=e}finally{try{o||null==f.return||f.return()}finally{if(i)throw s}}return r}}]),t}(i(ne).default);t.YAMLOMap=d,u(d,"tag","tag:yaml.org,2002:omap");var h={identify:function(e){return e instanceof Map},nodeClass:d,default:!1,tag:"tag:yaml.org,2002:omap",resolve:function(e,t){var n=(0,yt.parsePairs)(e,t),r=[],a=!0,i=!1,s=void 0;try{for(var u,f=n.items[Symbol.iterator]();!(a=(u=f.next()).done);a=!0){var l=u.value.key;if(l instanceof o.default){if(r.includes(l.value)){throw new x.YAMLSemanticError(t,"Ordered maps must not include duplicate keys")}r.push(l.value)}}}catch(e){i=!0,s=e}finally{try{a||null==f.return||f.return()}finally{if(i)throw s}}return Object.assign(new d,n)},createNode:function(e,t,n){var r=(0,yt.createPairs)(e,t,n),a=new d;return a.items=r.items,a}};t.default=h}));a(_t);_t.YAMLOMap;var bt=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=t.YAMLSet=void 0;var n=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)if(Object.prototype.hasOwnProperty.call(e,n)){var r=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(e,n):{};r.get||r.set?Object.defineProperty(t,n,r):t[n]=e[n]}return t.default=e,t}(te),r=u(Z),a=u(ce),o=u(z);function u(e){return e&&e.__esModule?e:{default:e}}var d,h,p,v=function(e){function t(){var e;return s(this,t),(e=g(this,c(t).call(this))).tag=t.tag,e}return l(t,e),f(t,[{key:"add",value:function(e){var t=e instanceof r.default?e:new r.default(e);(0,n.findPair)(this.items,t.key)||this.items.push(t)}},{key:"get",value:function(e,t){var a=(0,n.findPair)(this.items,e);return!t&&a instanceof r.default?a.key instanceof o.default?a.key.value:a.key:a}},{key:"set",value:function(e,t){if("boolean"!=typeof t)throw new Error("Expected boolean value for set(key, value) in a YAML set, not ".concat(i(t)));var a=(0,n.findPair)(this.items,e);a&&!t?this.items.splice(this.items.indexOf(a),1):!a&&t&&this.items.push(new r.default(e))}},{key:"toJSON",value:function(e,n){return m(c(t.prototype),"toJSON",this).call(this,e,n,Set)}},{key:"toString",value:function(e,n,r){if(!e)return JSON.stringify(this);if(this.hasAllNullValues())return m(c(t.prototype),"toString",this).call(this,e,n,r);throw new Error("Set items must all have null values")}}]),t}(n.default);t.YAMLSet=v,p="tag:yaml.org,2002:set",(h="tag")in(d=v)?Object.defineProperty(d,h,{value:p,enumerable:!0,configurable:!0,writable:!0}):d[h]=p;var y={identify:function(e){return e instanceof Set},nodeClass:v,default:!1,tag:"tag:yaml.org,2002:set",resolve:function(e,t){var n=(0,a.default)(e,t);if(!n.hasAllNullValues())throw new x.YAMLSemanticError(t,"Set items must all have null values");return Object.assign(new v,n)},createNode:function(e,t,n){var r=new v,a=!0,o=!1,i=void 0;try{for(var s,u=t[Symbol.iterator]();!(a=(s=u.next()).done);a=!0){var f=s.value;r.items.push(e.createPair(f,null,n))}}catch(e){o=!0,i=e}finally{try{a||null==u.return||u.return()}finally{if(o)throw i}}return r}};t.default=y}));a(bt);bt.YAMLSet;var wt=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.timestamp=t.floatTime=t.intTime=void 0;var n=function(e,t){var n=t.split(":").reduce((function(e,t){return 60*e+Number(t)}),0);return"-"===e?-n:n},r=function(e){var t=e.value;if(isNaN(t)||!isFinite(t))return(0,fe.stringifyNumber)(t);var n="";t<0&&(n="-",t=Math.abs(t));var r=[t%60];return t<60?r.unshift(0):(t=Math.round((t-r[0])/60),r.unshift(t%60),t>=60&&(t=Math.round((t-r[0])/60),r.unshift(t))),n+r.map((function(e){return e<10?"0"+String(e):String(e)})).join(":").replace(/000000\d*$/,"")},a={identify:function(e){return"number"==typeof e},default:!0,tag:"tag:yaml.org,2002:int",format:"TIME",test:/^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+)$/,resolve:function(e,t,r){return n(t,r.replace(/_/g,""))},stringify:r};t.intTime=a;var o={identify:function(e){return"number"==typeof e},default:!0,tag:"tag:yaml.org,2002:float",format:"TIME",test:/^([-+]?)([0-9][0-9_]*(?::[0-5]?[0-9])+\.[0-9_]*)$/,resolve:function(e,t,r){return n(t,r.replace(/_/g,""))},stringify:r};t.floatTime=o;var i={identify:function(e){return e instanceof Date},default:!0,tag:"tag:yaml.org,2002:timestamp",test:RegExp("^(?:([0-9]{4})-([0-9]{1,2})-([0-9]{1,2})(?:(?:t|T|[ \\t]+)([0-9]{1,2}):([0-9]{1,2}):([0-9]{1,2}(\\.[0-9]+)?)(?:[ \\t]*(Z|[-+][012]?[0-9](?::[0-9]{2})?))?)?)$"),resolve:function(e,t,r,a,o,i,s,u,f){u&&(u=(u+"00").substr(1,3));var l=Date.UTC(t,r-1,a,o||0,i||0,s||0,u||0);if(f&&"Z"!==f){var c=n(f[0],f.slice(1));Math.abs(c)<30&&(c*=60),l-=6e4*c}return new Date(l)},stringify:function(e){return e.value.toISOString().replace(/((T00:00)?:00)?\.000Z$/,"")}};t.timestamp=i}));a(wt);wt.timestamp,wt.floatTime,wt.intTime;var Et=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=u(z),r=u(ge),a=u(mt),o=u(_t),i=u(yt),s=u(bt);function u(e){return e&&e.__esModule?e:{default:e}}var f=r.default.concat([{identify:function(e){return null==e},createNode:function(e,t,r){return r.wrapScalars?new n.default(null):null},default:!0,tag:"tag:yaml.org,2002:null",test:/^(?:~|[Nn]ull|NULL)?$/,resolve:function(){return null},options:ue.nullOptions,stringify:function(){return ue.nullOptions.nullStr}},{identify:function(e){return"boolean"==typeof e},default:!0,tag:"tag:yaml.org,2002:bool",test:/^(?:Y|y|[Yy]es|YES|[Tt]rue|TRUE|[Oo]n|ON)$/,resolve:function(){return!0},options:ue.boolOptions,stringify:function(e){return e.value?ue.boolOptions.trueStr:ue.boolOptions.falseStr}},{identify:function(e){return"boolean"==typeof e},default:!0,tag:"tag:yaml.org,2002:bool",test:/^(?:N|n|[Nn]o|NO|[Ff]alse|FALSE|[Oo]ff|OFF)$/i,resolve:function(){return!1},options:ue.boolOptions,stringify:function(e){return e.value?ue.boolOptions.trueStr:ue.boolOptions.falseStr}},{identify:function(e){return"number"==typeof e},default:!0,tag:"tag:yaml.org,2002:int",format:"BIN",test:/^0b([0-1_]+)$/,resolve:function(e,t){return parseInt(t.replace(/_/g,""),2)},stringify:function(e){return"0b"+e.value.toString(2)}},{identify:function(e){return"number"==typeof e},default:!0,tag:"tag:yaml.org,2002:int",format:"OCT",test:/^[-+]?0([0-7_]+)$/,resolve:function(e,t){return parseInt(t.replace(/_/g,""),8)},stringify:function(e){var t=e.value;return(t<0?"-0":"0")+t.toString(8)}},{identify:function(e){return"number"==typeof e},default:!0,tag:"tag:yaml.org,2002:int",test:/^[-+]?[0-9][0-9_]*$/,resolve:function(e){return parseInt(e.replace(/_/g,""),10)},stringify:fe.stringifyNumber},{identify:function(e){return"number"==typeof e},default:!0,tag:"tag:yaml.org,2002:int",format:"HEX",test:/^0x([0-9a-fA-F_]+)$/,resolve:function(e,t){return parseInt(t.replace(/_/g,""),16)},stringify:function(e){var t=e.value;return(t<0?"-0x":"0x")+t.toString(16)}},{identify:function(e){return"number"==typeof e},default:!0,tag:"tag:yaml.org,2002:float",test:/^(?:[-+]?\.inf|(\.nan))$/i,resolve:function(e,t){return t?NaN:"-"===e[0]?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY},stringify:fe.stringifyNumber},{identify:function(e){return"number"==typeof e},default:!0,tag:"tag:yaml.org,2002:float",format:"EXP",test:/^[-+]?([0-9][0-9_]*)?(\.[0-9_]*)?[eE][-+]?[0-9]+$/,resolve:function(e){return parseFloat(e.replace(/_/g,""))},stringify:function(e){var t=e.value;return Number(t).toExponential()}},{identify:function(e){return"number"==typeof e},default:!0,tag:"tag:yaml.org,2002:float",test:/^[-+]?(?:[0-9][0-9_]*)?\.([0-9_]*)$/,resolve:function(e,t){var r=new n.default(parseFloat(e.replace(/_/g,"")));if(t){var a=t.replace(/_/g,"");"0"===a[a.length-1]&&(r.minFractionDigits=a.length)}return r},stringify:fe.stringifyNumber}],a.default,o.default,i.default,s.default,wt.intTime,wt.floatTime,wt.timestamp);t.default=f}));a(Et);var Ot=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.tags=t.schemas=void 0;var n=d(me),r=d(ge),a=d(ye),o=d(Et),i=d(de),s=d(pe),u=d(mt),f=d(_t),l=d(yt),c=d(bt);function d(e){return e&&e.__esModule?e:{default:e}}var h={core:n.default,failsafe:r.default,json:a.default,yaml11:o.default};t.schemas=h;var p={binary:u.default,floatTime:wt.floatTime,intTime:wt.intTime,map:i.default,omap:f.default,pairs:l.default,seq:s.default,set:c.default,timestamp:wt.timestamp};t.tags=p}));a(Ot);Ot.tags,Ot.schemas;var Mt=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=l(ee),r=l(X),a=l(H),o=l(Z),u=l(z);function l(e){return e&&e.__esModule?e:{default:e}}function c(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}var d=function(){function e(t){var n=t.customTags,r=t.merge,a=t.schema,o=t.tags;if(s(this,e),this.merge=!!r,this.name=a,this.tags=Ot.schemas[a.replace(/\W/g,"")],!this.tags){var i=Object.keys(Ot.schemas).map((function(e){return JSON.stringify(e)})).join(", ");throw new Error('Unknown schema "'.concat(a,'"; use one of ').concat(i))}if(!n&&o&&(n=o,(0,ie.warnOptionDeprecation)("tags","customTags")),Array.isArray(n)){var u=!0,f=!1,l=void 0;try{for(var c,d=n[Symbol.iterator]();!(u=(c=d.next()).done);u=!0){var h=c.value;this.tags=this.tags.concat(h)}}catch(e){f=!0,l=e}finally{try{u||null==d.return||d.return()}finally{if(f)throw l}}}else"function"==typeof n&&(this.tags=n(this.tags.slice()));for(var p=0;p<this.tags.length;++p){var v=this.tags[p];if("string"==typeof v){var g=Ot.tags[v];if(!g){var m=Object.keys(Ot.tags).map((function(e){return JSON.stringify(e)})).join(", ");throw new Error('Unknown custom tag "'.concat(v,'"; use one of ').concat(m))}this.tags[p]=g}}}return f(e,[{key:"createNode",value:function(t,r,a,o){var s;if(a){a.startsWith("!!")&&(a=e.defaultPrefix+a.slice(2));var f=this.tags.filter((function(e){return e.tag===a}));if(!(s=f.find((function(e){return!e.format}))||f[0]))throw new Error("Tag ".concat(a," not found"))}else if(!(s=this.tags.find((function(e){return(e.identify&&e.identify(t)||e.class&&t instanceof e.class)&&!e.format})))){if("function"==typeof t.toJSON&&(t=t.toJSON()),"object"!==i(t))return r?new u.default(t):t;s=t instanceof Map?Ot.tags.map:t[Symbol.iterator]?Ot.tags.seq:Ot.tags.map}o?o.wrapScalars=r:o={wrapScalars:r},o.onTagObj&&(o.onTagObj(s),delete o.onTagObj);var l={};if(t&&"object"===i(t)&&o.prevObjects){var c=o.prevObjects.find((function(e){return e.value===t}));if(c){var d=new n.default(c);return o.aliasNodes.push(d),d}l.value=t,o.prevObjects.push(l)}return l.node=s.createNode?s.createNode(this,t,o):r?new u.default(t):t,l.node}},{key:"createPair",value:function(e,t,n){var r=this.createNode(e,n.wrapScalars,null,n),a=this.createNode(t,n.wrapScalars,null,n);return new o.default(r,a)}},{key:"resolveScalar",value:function(e,t){t||(t=this.tags);for(var n=0;n<t.length;++n){var r=t[n],a=r.format,o=r.test,i=r.resolve;if(o){var s=e.match(o);if(s){var f=i.apply(null,s);return f instanceof u.default||(f=new u.default(f)),a&&(f.format=a),f}}}return this.tags.scalarFallback&&(e=this.tags.scalarFallback(e)),new u.default(e)}},{key:"resolveNode",value:function(e,t,n){var a=this.tags.filter((function(e){return e.tag===n})),o=a.find((function(e){return!e.test}));t.error&&e.errors.push(t.error);try{if(o){var i=o.resolve(e,t);i instanceof r.default||(i=new u.default(i)),t.resolved=i}else{var s=(0,ve.resolveString)(e,t);"string"==typeof s&&a.length>0&&(t.resolved=this.resolveScalar(s,a))}}catch(n){n.source||(n.source=t),e.errors.push(n),t.resolved=null}return t.resolved?(n&&t.tag&&(t.resolved.tag=n),t.resolved):null}},{key:"resolveNodeWithFallback",value:function(t,n,r){var a=this.resolveNode(t,n,r);if(Object.prototype.hasOwnProperty.call(n,"resolved"))return a;var o,i=(o=n.type)===T.Type.FLOW_MAP||o===T.Type.MAP?e.defaultTags.MAP:function(e){var t=e.type;return t===T.Type.FLOW_SEQ||t===T.Type.SEQ}(n)?e.defaultTags.SEQ:e.defaultTags.STR;if(i){t.warnings.push(new x.YAMLWarning(n,"The tag ".concat(r," is unavailable, falling back to ").concat(i)));var s=this.resolveNode(t,n,i);return s.tag=r,s}return t.errors.push(new x.YAMLReferenceError(n,"The tag ".concat(r," is unavailable"))),null}},{key:"getTagObject",value:function(e){if(e instanceof n.default)return n.default;if(e.tag){var t=this.tags.filter((function(t){return t.tag===e.tag}));if(t.length>0)return t.find((function(t){return t.format===e.format}))||t[0]}var r,a;if(e instanceof u.default){a=e.value;var o=this.tags.filter((function(e){return e.identify&&e.identify(a)||e.class&&a instanceof e.class}));r=o.find((function(t){return t.format===e.format}))||o.find((function(e){return!e.format}))}else a=e,r=this.tags.find((function(e){return e.nodeClass&&a instanceof e.nodeClass}));if(!r){var s=a&&a.constructor?a.constructor.name:i(a);throw new Error("Tag not resolved for ".concat(s," value"))}return r}},{key:"stringifyProps",value:function(e,t,n){var r=n.anchors,a=n.doc,o=[],i=a.anchors.getName(e);return i&&(r[i]=e,o.push("&".concat(i))),e.tag?o.push(a.stringifyTag(e.tag)):t.default||o.push(a.stringifyTag(t.tag)),o.join(" ")}},{key:"stringify",value:function(e,t,n,i){var s;if(!(e instanceof a.default)){var u={aliasNodes:[],onTagObj:function(e){return s=e},prevObjects:[]};e=this.createNode(e,!0,null,u);var f=t.doc.anchors,l=!0,c=!1,d=void 0;try{for(var h,p=u.aliasNodes[Symbol.iterator]();!(l=(h=p.next()).done);l=!0){var v=h.value;v.source=v.source.node;var g=f.getName(v.source);g||(g=f.newName(),f.map[g]=v.source)}}catch(e){c=!0,d=e}finally{try{l||null==p.return||p.return()}finally{if(c)throw d}}}if(t.tags=this,e instanceof o.default)return e.toString(t,n,i);s||(s=this.getTagObject(e));var m=this.stringifyProps(e,s,t),y="function"==typeof s.stringify?s.stringify(e,t,n,i):e instanceof r.default?e.toString(t,n,i):(0,fe.stringifyString)(e,t,n,i);return m?e instanceof r.default&&"{"!==y[0]&&"["!==y[0]?"".concat(m,"\n").concat(t.indent).concat(y):"".concat(m," ").concat(y):y}}]),e}();t.default=d,c(d,"defaultPrefix","tag:yaml.org,2002:"),c(d,"defaultTags",{MAP:"tag:yaml.org,2002:map",SEQ:"tag:yaml.org,2002:seq",STR:"tag:yaml.org,2002:str"})}));a(Mt);var St=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=h(J),r=h(ae),a=h(oe),o=h(Mt),i=h(ee),u=function(e){if(e&&e.__esModule)return e;var t={};if(null!=e)for(var n in e)if(Object.prototype.hasOwnProperty.call(e,n)){var r=Object.defineProperty&&Object.getOwnPropertyDescriptor?Object.getOwnPropertyDescriptor(e,n):{};r.get||r.set?Object.defineProperty(t,n,r):t[n]=e[n]}return t.default=e,t}(X),l=h(H),c=h(z),d=h(G);function h(e){return e&&e.__esModule?e:{default:e}}var p,v,g,m=function(){function e(t){s(this,e),this.anchors=new r.default(t.anchorPrefix),this.commentBefore=null,this.comment=null,this.contents=null,this.directivesEndMarker=null,this.errors=[],this.options=t,this.schema=null,this.tagPrefixes=[],this.version=null,this.warnings=[]}return f(e,[{key:"assertCollectionContents",value:function(){if(this.contents instanceof u.default)return!0;throw new Error("Expected a YAML collection as document contents")}},{key:"add",value:function(e){return this.assertCollectionContents(),this.contents.add(e)}},{key:"addIn",value:function(e,t){this.assertCollectionContents(),this.contents.addIn(e,t)}},{key:"delete",value:function(e){return this.assertCollectionContents(),this.contents.delete(e)}},{key:"deleteIn",value:function(e){return(0,u.isEmptyPath)(e)?null!=this.contents&&(this.contents=null,!0):(this.assertCollectionContents(),this.contents.deleteIn(e))}},{key:"getDefaults",value:function(){return e.defaults[this.version]||e.defaults[this.options.version]||{}}},{key:"get",value:function(e,t){return this.contents instanceof u.default?this.contents.get(e,t):void 0}},{key:"getIn",value:function(e,t){return(0,u.isEmptyPath)(e)?!t&&this.contents instanceof c.default?this.contents.value:this.contents:this.contents instanceof u.default?this.contents.getIn(e,t):void 0}},{key:"has",value:function(e){return this.contents instanceof u.default&&this.contents.has(e)}},{key:"hasIn",value:function(e){return(0,u.isEmptyPath)(e)?void 0!==this.contents:this.contents instanceof u.default&&this.contents.hasIn(e)}},{key:"set",value:function(e,t){this.assertCollectionContents(),this.contents.set(e,t)}},{key:"setIn",value:function(e,t){(0,u.isEmptyPath)(e)?this.contents=t:(this.assertCollectionContents(),this.contents.setIn(e,t))}},{key:"setSchema",value:function(e,t){if(e||t||!this.schema){"number"==typeof e&&(e=e.toFixed(1)),"1.0"===e||"1.1"===e||"1.2"===e?(this.version?this.version=e:this.options.version=e,delete this.options.schema):e&&"string"==typeof e&&(this.options.schema=e),Array.isArray(t)&&(this.options.customTags=t);var n=Object.assign({},this.getDefaults(),this.options);this.schema=new o.default(n)}}},{key:"parse",value:function(e,t){this.options.keepCstNodes&&(this.cstNode=e),this.options.keepNodeTypes&&(this.type="DOCUMENT");var n=e.directives,r=void 0===n?[]:n,a=e.contents,o=void 0===a?[]:a,i=e.directivesEndMarker,s=e.error,u=e.valueRange;if(s&&(s.source||(s.source=this),this.errors.push(s)),this.parseDirectives(r,t),i&&(this.directivesEndMarker=!0),this.range=u?[u.start,u.end]:null,this.setSchema(),this.anchors._cstAliases=[],this.parseContents(o),this.anchors.resolveNodes(),this.options.prettyErrors){var f=!0,l=!1,c=void 0;try{for(var d,h=this.errors[Symbol.iterator]();!(f=(d=h.next()).done);f=!0){var p=d.value;p instanceof x.YAMLError&&p.makePretty()}}catch(e){l=!0,c=e}finally{try{f||null==h.return||h.return()}finally{if(l)throw c}}var v=!0,g=!1,m=void 0;try{for(var y,_=this.warnings[Symbol.iterator]();!(v=(y=_.next()).done);v=!0){var b=y.value;b instanceof x.YAMLError&&b.makePretty()}}catch(e){g=!0,m=e}finally{try{v||null==_.return||_.return()}finally{if(g)throw m}}}return this}},{key:"parseDirectives",value:function(e,t){var n=this,r=[],a=!1;if(e.forEach((function(e){var t=e.comment,o=e.name;switch(o){case"TAG":n.resolveTagDirective(e),a=!0;break;case"YAML":case"YAML:1.0":n.resolveYamlDirective(e),a=!0;break;default:if(o){var i="YAML only supports %TAG and %YAML directives, and not %".concat(o);n.warnings.push(new x.YAMLWarning(e,i))}}t&&r.push(t)})),t&&!a&&"1.1"===(this.version||t.version||this.options.version)){this.tagPrefixes=t.tagPrefixes.map((function(e){return{handle:e.handle,prefix:e.prefix}})),this.version=t.version}this.commentBefore=r.join("\n")||null}},{key:"parseContents",value:function(e){var t=this,n={before:[],after:[]},r=[],a=!1;switch(e.forEach((function(e){if(e.valueRange){if(1===r.length){t.errors.push(new x.YAMLSyntaxError(e,"Document is not valid YAML (bad indentation?)"))}var o=t.resolveNode(e);a&&(o.spaceBefore=!0,a=!1),r.push(o)}else if(null!==e.comment){(0===r.length?n.before:n.after).push(e.comment)}else e.type===T.Type.BLANK_LINE&&(a=!0,0===r.length&&n.before.length>0&&!t.commentBefore&&(t.commentBefore=n.before.join("\n"),n.before=[]))})),r.length){case 0:this.contents=null,n.after=n.before;break;case 1:if(this.contents=r[0],this.contents){var o=n.before.join("\n")||null;if(o){var i=this.contents instanceof u.default&&this.contents.items[0]?this.contents.items[0]:this.contents;i.commentBefore=i.commentBefore?"".concat(o,"\n").concat(i.commentBefore):o}}else n.after=n.before.concat(n.after);break;default:this.contents=r,this.contents[0]?this.contents[0].commentBefore=n.before.join("\n")||null:n.after=n.before.concat(n.after)}this.comment=n.after.join("\n")||null}},{key:"resolveTagDirective",value:function(e){var t=y(e.parameters,2),n=t[0],r=t[1];if(n&&r)if(this.tagPrefixes.every((function(e){return e.handle!==n})))this.tagPrefixes.push({handle:n,prefix:r});else{this.errors.push(new x.YAMLSemanticError(e,"The %TAG directive must only be given at most once per handle in the same document."))}else{this.errors.push(new x.YAMLSemanticError(e,"Insufficient parameters given for %TAG directive"))}}},{key:"resolveYamlDirective",value:function(t){var n=y(t.parameters,1)[0];if("YAML:1.0"===t.name&&(n="1.0"),this.version){this.errors.push(new x.YAMLSemanticError(t,"The %YAML directive must only be given at most once per document."))}if(n){if(!e.defaults[n]){var r=this.version||this.options.version,a="Document will be parsed as YAML ".concat(r," rather than YAML ").concat(n);this.warnings.push(new x.YAMLWarning(t,a))}this.version=n}else{this.errors.push(new x.YAMLSemanticError(t,"Insufficient parameters given for %YAML directive"))}}},{key:"resolveTagName",value:function(e){var t=e.tag,n=e.type,r=!1;if(t){var a=t.handle,i=t.suffix,s=t.verbatim;if(s){if("!"!==s&&"!!"!==s)return s;var u="Verbatim tags aren't resolved, so ".concat(s," is invalid.");this.errors.push(new x.YAMLSemanticError(e,u))}else if("!"!==a||i){var f=this.tagPrefixes.find((function(e){return e.handle===a}));if(!f){var l=this.getDefaults().tagPrefixes;l&&(f=l.find((function(e){return e.handle===a})))}if(f){if(i){if("!"===a&&"1.0"===(this.version||this.options.version)){if("^"===i[0])return i;if(/[:/]/.test(i)){var c=i.match(/^([a-z0-9-]+)\/(.*)/i);return c?"tag:".concat(c[1],".yaml.org,2002:").concat(c[2]):"tag:".concat(i)}}return f.prefix+decodeURIComponent(i)}this.errors.push(new x.YAMLSemanticError(e,"The ".concat(a," tag has no suffix.")))}else{var d="The ".concat(a," tag handle is non-default and was not declared.");this.errors.push(new x.YAMLSemanticError(e,d))}}else r=!0}switch(n){case T.Type.BLOCK_FOLDED:case T.Type.BLOCK_LITERAL:case T.Type.QUOTE_DOUBLE:case T.Type.QUOTE_SINGLE:return o.default.defaultTags.STR;case T.Type.FLOW_MAP:case T.Type.MAP:return o.default.defaultTags.MAP;case T.Type.FLOW_SEQ:case T.Type.SEQ:return o.default.defaultTags.SEQ;case T.Type.PLAIN:return r?o.default.defaultTags.STR:null;default:return null}}},{key:"resolveNode",value:function(e){if(!e)return null;var t,n=this.anchors,r=this.errors,a=this.schema,o=!1,s=!1,u={before:[],after:[]},f=function(e){return e&&-1!==[T.Type.MAP_KEY,T.Type.MAP_VALUE,T.Type.SEQ_ITEM].indexOf(e.type)}(e.context.parent)?e.context.parent.props.concat(e.props):e.props,l=!0,c=!1,d=void 0;try{for(var h,p=f[Symbol.iterator]();!(l=(h=p.next()).done);l=!0){var v=h.value,g=v.start,m=v.end;switch(e.context.src[g]){case T.Char.COMMENT:if(!e.commentHasRequiredWhitespace(g)){r.push(new x.YAMLSemanticError(e,"Comments must be separated from other tokens by white space characters"))}var y=e.context.src.slice(g+1,m),_=e.header,b=e.valueRange;b&&(g>b.start||_&&g>_.start)?u.after.push(y):u.before.push(y);break;case T.Char.ANCHOR:if(o){r.push(new x.YAMLSemanticError(e,"A node can have at most one anchor"))}o=!0;break;case T.Char.TAG:if(s){r.push(new x.YAMLSemanticError(e,"A node can have at most one tag"))}s=!0}}}catch(e){c=!0,d=e}finally{try{l||null==p.return||p.return()}finally{if(c)throw d}}if(o){var w=e.anchor,E=n.getNode(w);E&&(n.map[n.newName(w)]=E),n.map[w]=e}if(e.type===T.Type.ALIAS){if(o||s){r.push(new x.YAMLSemanticError(e,"An alias node must not specify any properties"))}var O=e.rawValue,M=n.getNode(O);if(!M){var S="Aliased anchor not found: ".concat(O);return r.push(new x.YAMLReferenceError(e,S)),null}t=new i.default(M),n._cstAliases.push(t)}else{var A=this.resolveTagName(e);if(A)t=a.resolveNodeWithFallback(this,e,A);else{if(e.type!==T.Type.PLAIN){var k="Failed to resolve ".concat(e.type," node here");return r.push(new x.YAMLSyntaxError(e,k)),null}try{t=a.resolveScalar(e.strValue||"")}catch(t){return t.source||(t.source=e),r.push(t),null}}}if(t){t.range=[e.range.start,e.range.end],this.options.keepCstNodes&&(t.cstNode=e),this.options.keepNodeTypes&&(t.type=e.type);var L=u.before.join("\n");L&&(t.commentBefore=t.commentBefore?"".concat(t.commentBefore,"\n").concat(L):L);var P=u.after.join("\n");P&&(t.comment=t.comment?"".concat(t.comment,"\n").concat(P):P)}return e.resolved=t}},{key:"listNonDefaultTags",value:function(){return(0,a.default)(this.contents).filter((function(e){return 0!==e.indexOf(o.default.defaultPrefix)}))}},{key:"setTagPrefix",value:function(e,t){if("!"!==e[0]||"!"!==e[e.length-1])throw new Error("Handle must start and end with !");if(t){var n=this.tagPrefixes.find((function(t){return t.handle===e}));n?n.prefix=t:this.tagPrefixes.push({handle:e,prefix:t})}else this.tagPrefixes=this.tagPrefixes.filter((function(t){return t.handle!==e}))}},{key:"stringifyTag",value:function(e){if("1.0"===(this.version||this.options.version)){var t=e.match(/^tag:private\.yaml\.org,2002:([^:/]+)$/);if(t)return"!"+t[1];var n=e.match(/^tag:([a-zA-Z0-9-]+)\.yaml\.org,2002:(.*)/);return n?"!".concat(n[1],"/").concat(n[2]):"!".concat(e.replace(/^tag:/,""))}var r=this.tagPrefixes.find((function(t){return 0===e.indexOf(t.prefix)}));if(!r){var a=this.getDefaults().tagPrefixes;r=a&&a.find((function(t){return 0===e.indexOf(t.prefix)}))}if(!r)return"!"===e[0]?e:"!<".concat(e,">");var o=e.substr(r.prefix.length).replace(/[!,[\]{}]/g,(function(e){return{"!":"%21",",":"%2C","[":"%5B","]":"%5D","{":"%7B","}":"%7D"}[e]}));return r.handle+o}},{key:"toJSON",value:function(e){var t=this,n=this.options,r=n.keepBlobsInJSON,a=n.mapAsMap,o=n.maxAliasCount,i=r&&("string"!=typeof e||!(this.contents instanceof c.default)),s={doc:this,keep:i,mapAsMap:i&&!!a,maxAliasCount:o},u=Object.keys(this.anchors.map);return u.length>0&&(s.anchors=u.map((function(e){return{alias:[],aliasCount:0,count:1,node:t.anchors.map[e]}}))),(0,d.default)(this.contents,e,s)}},{key:"toString",value:function(){if(this.errors.length>0)throw new Error("Document with errors cannot be stringified");this.setSchema();var e=[],t=!1;if(this.version){var r="%YAML 1.2";"yaml-1.1"===this.schema.name&&("1.0"===this.version?r="%YAML:1.0":"1.1"===this.version&&(r="%YAML 1.1")),e.push(r),t=!0}var a=this.listNonDefaultTags();this.tagPrefixes.forEach((function(n){var r=n.handle,o=n.prefix;a.some((function(e){return 0===e.indexOf(o)}))&&(e.push("%TAG ".concat(r," ").concat(o)),t=!0)})),(t||this.directivesEndMarker)&&e.push("---"),this.commentBefore&&(!t&&this.directivesEndMarker||e.unshift(""),e.unshift(this.commentBefore.replace(/^/gm,"#")));var o={anchors:{},doc:this,indent:""},i=!1,s=null;if(this.contents){this.contents instanceof l.default&&(this.contents.spaceBefore&&(t||this.directivesEndMarker)&&e.push(""),this.contents.commentBefore&&e.push(this.contents.commentBefore.replace(/^/gm,"#")),o.forceBlockIndent=!!this.comment,s=this.contents.comment);var u=s?null:function(){return i=!0},f=this.schema.stringify(this.contents,o,(function(){return s=null}),u);e.push((0,n.default)(f,"",s))}else void 0!==this.contents&&e.push(this.schema.stringify(this.contents,o));return this.comment&&(i&&!s||""===e[e.length-1]||e.push(""),e.push(this.comment.replace(/^/gm,"#"))),e.join("\n")+"\n"}}]),e}();t.default=m,p=m,v="defaults",g={"1.0":{schema:"yaml-1.1",merge:!0,tagPrefixes:[{handle:"!",prefix:o.default.defaultPrefix},{handle:"!!",prefix:"tag:private.yaml.org,2002:"}]},1.1:{schema:"yaml-1.1",merge:!0,tagPrefixes:[{handle:"!",prefix:"!"},{handle:"!!",prefix:o.default.defaultPrefix}]},1.2:{schema:"core",merge:!1,tagPrefixes:[{handle:"!",prefix:"!"},{handle:"!!",prefix:o.default.defaultPrefix}]}},v in p?Object.defineProperty(p,v,{value:g,enumerable:!0,configurable:!0,writable:!0}):p[v]=g}));a(St);var At=o((function(e,t){Object.defineProperty(t,"__esModule",{value:!0}),t.default=void 0;var n=o(q),r=o(St),a=o(Mt);function o(e){return e&&e.__esModule?e:{default:e}}var i={anchorPrefix:"a",customTags:null,keepCstNodes:!1,keepNodeTypes:!0,keepBlobsInJSON:!0,mapAsMap:!1,maxAliasCount:100,prettyErrors:!1,simpleKeys:!1,version:"1.2"};var u=function(e){function t(e){return s(this,t),g(this,c(t).call(this,Object.assign({},i,e)))}return l(t,e),t}(r.default);function f(e,t){var r=(0,n.default)(e),a=new u(t).parse(r[0]);if(r.length>1){a.errors.unshift(new x.YAMLSemanticError(r[1],"Source contains multiple documents; please use YAML.parseAllDocuments()"))}return a}var d={createNode:function(e){var t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0;void 0===n&&"string"==typeof t&&(n=t,t=!0);var o=Object.assign({},r.default.defaults[i.version],i);return new a.default(o).createNode(e,t,n)},defaultOptions:i,Document:u,parse:function(e,t){var n=f(e,t);if(n.warnings.forEach((function(e){return(0,ie.warn)(e)})),n.errors.length>0)throw n.errors[0];return n.toJSON()},parseAllDocuments:function(e,t){var r,a=[],o=!0,i=!1,s=void 0;try{for(var f,l=(0,n.default)(e)[Symbol.iterator]();!(o=(f=l.next()).done);o=!0){var c=f.value,d=new u(t);d.parse(c,r),a.push(d),r=d}}catch(e){i=!0,s=e}finally{try{o||null==l.return||l.return()}finally{if(i)throw s}}return a},parseCST:n.default,parseDocument:f,stringify:function(e,t){var n=new u(t);return n.contents=e,String(n)}};t.default=d}));a(At);var kt=At.default,Lt=o((function(e,t){t.__esModule=!0,t.defineParents=function e(t,n){void 0===n&&(n=null),"children"in t&&t.children.forEach((function(n){return e(n,t)})),"anchor"in t&&t.anchor&&e(t.anchor,t),"tag"in t&&t.tag&&e(t.tag,t),"leadingComments"in t&&t.leadingComments.forEach((function(n){return e(n,t)})),"middleComments"in t&&t.middleComments.forEach((function(n){return e(n,t)})),"indicatorComment"in t&&t.indicatorComment&&e(t.indicatorComment,t),"trailingComment"in t&&t.trailingComment&&e(t.trailingComment,t),"endComments"in t&&t.endComments.forEach((function(n){return e(n,t)})),Object.defineProperty(t,"_parent",{value:n,enumerable:!1})}}));a(Lt);Lt.defineParents;var Tt=o((function(e,t){t.__esModule=!0,t.getPointText=function(e){return e.line+":"+e.column}}));a(Tt);Tt.getPointText;var Pt=o((function(e,t){function n(e,t){if(t.position.end.offset<e.position.end.offset)return!1;switch(e.type){case"sequenceItem":return t.position.start.column>e.position.start.column;case"mappingKey":case"mappingValue":return t.position.start.column>e._parent.position.start.column&&(0===e.children.length||1===e.children.length&&"blockFolded"!==e.children[0].type&&"blockLiteral"!==e.children[0].type&&("mappingValue"===e.type||e.position.start.offset!==e.children[0].position.start.offset));default:return!1}}t.__esModule=!0,t.attachComments=function(e){Lt.defineParents(e);var t=function(e){for(var t=Array.from(new Array(e.position.end.line),(function(){return{}})),n=0,r=e.comments;n<r.length;n++){var a=r[n];t[a.position.start.line-1].comment=a}return function e(t,n){if(n.position.start.offset===n.position.end.offset)return;if("leadingComments"in n){var r=n.position.start,a=t[r.line-1].leadingAttachableNode;(!a||r.column<a.position.start.column)&&(t[r.line-1].leadingAttachableNode=n)}if("trailingComment"in n&&n.position.end.column>1&&"document"!==n.type&&"documentHead"!==n.type){var o=n.position.end,i=t[o.line-1].trailingAttachableNode;(!i||o.column>=i.position.end.column)&&(t[o.line-1].trailingAttachableNode=n)}if("root"!==n.type&&"document"!==n.type&&"documentHead"!==n.type&&"documentBody"!==n.type)for(var s=n.position,u=(r=s.start,[(o=s.end).line].concat(r.line===o.line?[]:r.line)),f=0,l=u;f<l.length;f++){var c=l[f],d=t[c-1].trailingNode;(!d||o.column>=d.position.end.column)&&(t[c-1].trailingNode=n)}"children"in n&&n.children.forEach((function(n){e(t,n)}))}(t,e),t}(e),r=e.children.slice();e.comments.sort((function(e,t){return e.position.start.offset-t.position.end.offset})).filter((function(e){return!e._parent})).forEach((function(e){for(;r.length>1&&e.position.start.line>r[0].position.end.line;)r.shift();!function(e,t,r){var a=e.position.start.line,o=t[a-1].trailingAttachableNode;if(o){if(o.trailingComment)throw new Error("Unexpected multiple trailing comment at "+Tt.getPointText(e.position.start));return Lt.defineParents(e,o),void(o.trailingComment=e)}for(var i=a;i>=r.position.start.line;i--){var s=t[i-1].trailingNode,u=void 0;if(s)u=s;else{if(i===a||!t[i-1].comment)continue;u=t[i-1].comment._parent}for(;;){if(n(u,e))return Lt.defineParents(e,u),void u.endComments.push(e);if(!u._parent)break;u=u._parent}break}for(i=a+1;i<=r.position.end.line;i++){var f=t[i-1].leadingAttachableNode;if(f)return Lt.defineParents(e,f),void f.leadingComments.push(e)}var l=r.children[1];Lt.defineParents(e,l),l.endComments.push(e)}(e,t,r[0])}))}}));a(Pt);Pt.attachComments;var Ct=o((function(e,t){t.__esModule=!0,t.createNode=function(e,t){return{type:e,position:t}}}));a(Ct);Ct.createNode;var Nt,xt=(Nt=k)&&Nt.default||Nt,Rt=o((function(e,t){t.__esModule=!0,t.createRoot=function(e,t,n){return xt.__assign(xt.__assign({},Ct.createNode("root",e)),{children:t,comments:n})}}));a(Rt);Rt.createRoot;var It=o((function(e,t){t.__esModule=!0,t.removeCstBlankLine=function e(t){switch(t.type){case"DOCUMENT":for(var n=t.contents.length-1;n>=0;n--)"BLANK_LINE"===t.contents[n].type?t.contents.splice(n,1):e(t.contents[n]);for(n=t.directives.length-1;n>=0;n--)"BLANK_LINE"===t.directives[n].type&&t.directives.splice(n,1);break;case"FLOW_MAP":case"FLOW_SEQ":case"MAP":case"SEQ":for(n=t.items.length-1;n>=0;n--){var r=t.items[n];"char"in r||("BLANK_LINE"===r.type?t.items.splice(n,1):e(r))}break;case"MAP_KEY":case"MAP_VALUE":case"SEQ_ITEM":t.node&&e(t.node);break;case"ALIAS":case"BLANK_LINE":case"BLOCK_FOLDED":case"BLOCK_LITERAL":case"COMMENT":case"DIRECTIVE":case"PLAIN":case"QUOTE_DOUBLE":case"QUOTE_SINGLE":break;default:throw new Error("Unexpected node type "+JSON.stringify(t.type))}}}));a(It);It.removeCstBlankLine;var Bt=o((function(e,t){t.__esModule=!0,t.createLeadingCommentAttachable=function(){return{leadingComments:[]}}}));a(Bt);Bt.createLeadingCommentAttachable;var Dt=o((function(e,t){t.__esModule=!0,t.createTrailingCommentAttachable=function(e){return void 0===e&&(e=null),{trailingComment:e}}}));a(Dt);Dt.createTrailingCommentAttachable;var jt=o((function(e,t){t.__esModule=!0,t.createCommentAttachable=function(){return xt.__assign(xt.__assign({},Bt.createLeadingCommentAttachable()),Dt.createTrailingCommentAttachable())}}));a(jt);jt.createCommentAttachable;var Yt=o((function(e,t){t.__esModule=!0,t.createAlias=function(e,t,n){return xt.__assign(xt.__assign(xt.__assign(xt.__assign({},Ct.createNode("alias",e)),jt.createCommentAttachable()),t),{value:n})}}));a(Yt);Yt.createAlias;var Ft=o((function(e,t){t.__esModule=!0,t.transformAlias=function(e,t){var n=e.cstNode;return Yt.createAlias(t.transformRange({origStart:n.valueRange.origStart-1,origEnd:n.valueRange.origEnd}),t.transformContent(e),n.rawValue)}}));a(Ft);Ft.transformAlias;var Ut=o((function(e,t){t.__esModule=!0,t.createBlockFolded=function(e){return xt.__assign(xt.__assign({},e),{type:"blockFolded"})}}));a(Ut);Ut.createBlockFolded;var Kt=o((function(e,t){t.__esModule=!0,t.createBlockValue=function(e,t,n,r,a,o){return xt.__assign(xt.__assign(xt.__assign(xt.__assign({},Ct.createNode("blockValue",e)),Bt.createLeadingCommentAttachable()),t),{chomping:n,indent:r,value:a,indicatorComment:o})}}));a(Kt);Kt.createBlockValue;var Wt=o((function(e,t){t.__esModule=!0,function(e){e.Tag="!",e.Anchor="&",e.Comment="#"}(t.PropLeadingCharacter||(t.PropLeadingCharacter={}))}));a(Wt);Wt.PropLeadingCharacter;var Qt=o((function(e,t){t.__esModule=!0,t.createAnchor=function(e,t){return xt.__assign(xt.__assign({},Ct.createNode("anchor",e)),{value:t})}}));a(Qt);Qt.createAnchor;var Vt=o((function(e,t){t.__esModule=!0,t.createComment=function(e,t){return xt.__assign(xt.__assign({},Ct.createNode("comment",e)),{value:t})}}));a(Vt);Vt.createComment;var $t=o((function(e,t){t.__esModule=!0,t.createContent=function(e,t,n){return{anchor:t,tag:e,middleComments:n}}}));a($t);$t.createContent;var qt=o((function(e,t){t.__esModule=!0,t.createTag=function(e,t){return xt.__assign(xt.__assign({},Ct.createNode("tag",e)),{value:t})}}));a(qt);qt.createTag;var Jt=o((function(e,t){t.__esModule=!0,t.transformContent=function(e,t,n){void 0===n&&(n=function(){return!1});for(var r=e.cstNode,a=[],o=null,i=null,s=null,u=0,f=r.props;u<f.length;u++){var l=f[u],c=t.text[l.origStart];switch(c){case Wt.PropLeadingCharacter.Tag:o=o||l,i=qt.createTag(t.transformRange(l),e.tag);break;case Wt.PropLeadingCharacter.Anchor:o=o||l,s=Qt.createAnchor(t.transformRange(l),r.anchor);break;case Wt.PropLeadingCharacter.Comment:var d=Vt.createComment(t.transformRange(l),t.text.slice(l.origStart+1,l.origEnd));t.comments.push(d),!n(d)&&o&&o.origEnd<=l.origStart&&l.origEnd<=r.valueRange.origStart&&a.push(d);break;default:throw new Error("Unexpected leading character "+JSON.stringify(c))}}return $t.createContent(i,s,a)}}));a(Jt);Jt.transformContent;var Gt=o((function(e,t){var n;t.__esModule=!0,function(e){e.CLIP="clip",e.STRIP="strip",e.KEEP="keep"}(n||(n={})),t.transformAstBlockValue=function(e,t){var r=e.cstNode,a="CLIP"===r.chomping?0:1,o=r.header.origEnd-r.header.origStart-1-a!=0,i=t.transformRange({origStart:r.header.origStart,origEnd:r.valueRange.origEnd}),s=null,u=Jt.transformContent(e,t,(function(e){if(!(i.start.offset<e.position.start.offset&&e.position.end.offset<i.end.offset))return!1;if(s)throw new Error("Unexpected multiple indicator comments at "+Tt.getPointText(e.position.start));return s=e,!0}));return Kt.createBlockValue(i,u,n[r.chomping],o?r.blockIndent:null,r.strValue,s)}}));a(Gt);Gt.transformAstBlockValue;var Ht=o((function(e,t){t.__esModule=!0,t.transformBlockFolded=function(e,t){return Ut.createBlockFolded(Gt.transformAstBlockValue(e,t))}}));a(Ht);Ht.transformBlockFolded;var zt=o((function(e,t){t.__esModule=!0,t.createBlockLiteral=function(e){return xt.__assign(xt.__assign({},e),{type:"blockLiteral"})}}));a(zt);zt.createBlockLiteral;var Zt=o((function(e,t){t.__esModule=!0,t.transformBlockLiteral=function(e,t){return zt.createBlockLiteral(Gt.transformAstBlockValue(e,t))}}));a(Zt);Zt.transformBlockLiteral;var Xt=o((function(e,t){t.__esModule=!0,t.transformComment=function(e,t){return Vt.createComment(t.transformRange(e.range),e.comment)}}));a(Xt);Xt.transformComment;var en=o((function(e,t){t.__esModule=!0,t.createDirective=function(e,t,n){return xt.__assign(xt.__assign(xt.__assign({},Ct.createNode("directive",e)),jt.createCommentAttachable()),{name:t,parameters:n})}}));a(en);en.createDirective;var tn=o((function(e,t){t.__esModule=!0,t.extractPropComments=function(e,t){for(var n=0,r=e.props;n<r.length;n++){var a=r[n],o=t.text[a.origStart];switch(o){case Wt.PropLeadingCharacter.Comment:t.comments.push(Vt.createComment(t.transformRange(a),t.text.slice(a.origStart+1,a.origEnd)));break;default:throw new Error("Unexpected leading character "+JSON.stringify(o))}}}}));a(tn);tn.extractPropComments;var nn=o((function(e,t){t.__esModule=!0,t.transformDirective=function(e,t){return tn.extractPropComments(e,t),en.createDirective(t.transformRange(e.range),e.name,e.parameters)}}));a(nn);nn.transformDirective;var rn=o((function(e,t){t.__esModule=!0,t.createDocument=function(e,t,n,r){return xt.__assign(xt.__assign(xt.__assign({},Ct.createNode("document",e)),Dt.createTrailingCommentAttachable(r)),{children:[t,n]})}}));a(rn);rn.createDocument;var an=o((function(e,t){t.__esModule=!0,t.createPosition=function(e,t){return{start:e,end:t}},t.createEmptyPosition=function(e){return{start:e,end:e}}}));a(an);an.createPosition,an.createEmptyPosition;var on=o((function(e,t){t.__esModule=!0,t.createEndCommentAttachable=function(e){return void 0===e&&(e=[]),{endComments:e}}}));a(on);on.createEndCommentAttachable;var sn=o((function(e,t){t.__esModule=!0,t.createDocumentBody=function(e,t,n){return xt.__assign(xt.__assign(xt.__assign({},Ct.createNode("documentBody",e)),on.createEndCommentAttachable(n)),{children:t?[t]:[]})}}));a(sn);sn.createDocumentBody;var un=o((function(e,t){t.__esModule=!0,t.getLast=function(e){return e[e.length-1]}}));a(un);un.getLast;var fn=o((function(e,t){t.__esModule=!0,t.getMatchIndex=function(e,t){var n=e.match(t);return n?n.index:-1}}));a(fn);fn.getMatchIndex;var ln=o((function(e,t){t.__esModule=!0,t.transformDocumentBody=function(e,t,n){var r,a=e.cstNode,o=function(e,t,n){for(var r=[],a=[],o=[],i=!1,s=e.contents.length-1;s>=0;s--){var u=e.contents[s];if("COMMENT"===u.type){var f=t.transformNode(u);n&&n.line===f.position.start.line?o.unshift(f):i?r.unshift(f):f.position.start.offset>=e.valueRange.origEnd?a.unshift(f):r.unshift(f)}else i=!0}if(a.length>1)throw new Error("Unexpected multiple document trailing comments at "+Tt.getPointText(a[1].position.start));if(o.length>1)throw new Error("Unexpected multiple documentHead trailing comments at "+Tt.getPointText(o[1].position.start));return{comments:r,endComments:[],documentTrailingComment:un.getLast(a)||null,documentHeadTrailingComment:un.getLast(o)||null}}(a,t,n),i=o.comments,s=o.endComments,u=o.documentTrailingComment,f=o.documentHeadTrailingComment,l=t.transformNode(e.contents),c=function(e,t,n){var r=fn.getMatchIndex(n.text.slice(e.valueRange.origEnd),/^\.\.\./),a=-1===r?e.valueRange.origEnd:Math.max(0,e.valueRange.origEnd-1);"\r"===n.text[a-1]&&a--;var o=n.transformRange({origStart:null!==t?t.position.start.offset:a,origEnd:a}),i=-1===r?o.end:n.transformOffset(e.valueRange.origEnd+3);return{position:o,documentEndPoint:i}}(a,l,t),d=c.position,h=c.documentEndPoint;return(r=t.comments).push.apply(r,xt.__spreadArrays(i,s)),{documentBody:sn.createDocumentBody(d,l,s),documentEndPoint:h,documentTrailingComment:u,documentHeadTrailingComment:f}}}));a(ln);ln.transformDocumentBody;var cn=o((function(e,t){t.__esModule=!0,t.createDocumentHead=function(e,t,n,r){return xt.__assign(xt.__assign(xt.__assign(xt.__assign({},Ct.createNode("documentHead",e)),on.createEndCommentAttachable(n)),Dt.createTrailingCommentAttachable(r)),{children:t})}}));a(cn);cn.createDocumentHead;var dn=o((function(e,t){t.__esModule=!0,t.transformDocumentHead=function(e,t){var n,r=e.cstNode,a=function(e,t){for(var n=[],r=[],a=[],o=!1,i=e.directives.length-1;i>=0;i--){var s=t.transformNode(e.directives[i]);"comment"===s.type?o?r.unshift(s):a.unshift(s):(o=!0,n.unshift(s))}return{directives:n,comments:r,endComments:a}}(r,t),o=a.directives,i=a.comments,s=a.endComments,u=function(e,t,n){var r=fn.getMatchIndex(n.text.slice(0,e.valueRange.origStart),/---\s*$/),a=-1===r?{origStart:e.valueRange.origStart,origEnd:e.valueRange.origStart}:{origStart:r,origEnd:r+3};0!==t.length&&(a.origStart=t[0].position.start.offset);return{position:n.transformRange(a),endMarkerPoint:-1===r?null:n.transformOffset(r)}}(r,o,t),f=u.position,l=u.endMarkerPoint;return(n=t.comments).push.apply(n,xt.__spreadArrays(i,s)),{createDocumentHeadWithTrailingComment:function(e){return e&&t.comments.push(e),cn.createDocumentHead(f,o,s,e)},documentHeadEndMarkerPoint:l}}}));a(dn);dn.transformDocumentHead;var hn=o((function(e,t){t.__esModule=!0,t.transformDocument=function(e,t){var n=dn.transformDocumentHead(e,t),r=n.createDocumentHeadWithTrailingComment,a=n.documentHeadEndMarkerPoint,o=ln.transformDocumentBody(e,t,a),i=o.documentBody,s=o.documentEndPoint,u=o.documentTrailingComment,f=r(o.documentHeadTrailingComment);return u&&t.comments.push(u),rn.createDocument(an.createPosition(f.position.start,s),f,i,u)}}));a(hn);hn.transformDocument;var pn=o((function(e,t){t.__esModule=!0,t.createFlowCollection=function(e,t,n){return xt.__assign(xt.__assign(xt.__assign(xt.__assign({},Ct.createNode("flowCollection",e)),jt.createCommentAttachable()),t),{children:n})}}));a(pn);pn.createFlowCollection;var vn=o((function(e,t){t.__esModule=!0,t.createFlowMapping=function(e,t,n){return xt.__assign(xt.__assign({},pn.createFlowCollection(e,t,n)),{type:"flowMapping"})}}));a(vn);vn.createFlowMapping;var gn=o((function(e,t){t.__esModule=!0,t.createFlowMappingItem=function(e,t,n){return xt.__assign(xt.__assign(xt.__assign({},Ct.createNode("flowMappingItem",e)),Bt.createLeadingCommentAttachable()),{children:[t,n]})}}));a(gn);gn.createFlowMappingItem;var mn=o((function(e,t){t.__esModule=!0,t.extractComments=function(e,t){for(var n=[],r=0,a=e;r<a.length;r++){var o=a[r];o&&"type"in o&&"COMMENT"===o.type?t.comments.push(t.transformNode(o)):n.push(o)}return n}}));a(mn);mn.extractComments;var yn=o((function(e,t){t.__esModule=!0,t.getFlowMapItemAdditionalRanges=function(e){var t=["?",":"].map((function(t){var n=e.find((function(e){return"char"in e&&e.char===t}));return n?{origStart:n.origOffset,origEnd:n.origOffset+1}:null}));return{additionalKeyRange:t[0],additionalValueRange:t[1]}}}));a(yn);yn.getFlowMapItemAdditionalRanges;var _n=o((function(e,t){t.__esModule=!0,t.createSlicer=function(e,t){var n=t;return function(t){return e.slice(n,n=t)}}}));a(_n);_n.createSlicer;var bn=o((function(e,t){t.__esModule=!0,t.groupCstFlowCollectionItems=function(e){for(var t=[],n=_n.createSlicer(e,1),r=!1,a=1;a<e.length-1;a++){var o=e[a];"char"in o&&","===o.char?(t.push(n(a)),n(a+1),r=!1):r=!0}return r&&t.push(n(e.length-1)),t}}));a(bn);bn.groupCstFlowCollectionItems;var wn=o((function(e,t){t.__esModule=!0,t.createMappingKey=function(e,t){return xt.__assign(xt.__assign(xt.__assign(xt.__assign({},Ct.createNode("mappingKey",e)),Dt.createTrailingCommentAttachable()),on.createEndCommentAttachable()),{children:t?[t]:[]})}}));a(wn);wn.createMappingKey;var En=o((function(e,t){t.__esModule=!0,t.createMappingValue=function(e,t){return xt.__assign(xt.__assign(xt.__assign(xt.__assign({},Ct.createNode("mappingValue",e)),jt.createCommentAttachable()),on.createEndCommentAttachable()),{children:t?[t]:[]})}}));a(En);En.createMappingValue;var On=o((function(e,t){t.__esModule=!0,t.transformAstPair=function(e,t,n,r,a){var o=t.transformNode(e.key),i=t.transformNode("MERGE_PAIR"===e.type?e.value.type?e.value:e.value.items[0]:e.value),s=o||r?wn.createMappingKey(t.transformRange({origStart:r?r.origStart:o.position.start.offset,origEnd:o?o.position.end.offset:r.origStart+1}),o):null,u=i||a?En.createMappingValue(t.transformRange({origStart:a?a.origStart:i.position.start.offset,origEnd:i?i.position.end.offset:a.origStart+1}),i):null;return n(an.createPosition(s?s.position.start:u.position.start,u?u.position.end:s.position.end),s||wn.createMappingKey(an.createEmptyPosition(u.position.start),null),u||En.createMappingValue(an.createEmptyPosition(s.position.end),null))}}));a(On);On.transformAstPair;var Mn=o((function(e,t){t.__esModule=!0,t.transformFlowMap=function(e,t){var n=mn.extractComments(e.cstNode.items,t),r=bn.groupCstFlowCollectionItems(n),a=e.items.map((function(e,n){var a=r[n],o=yn.getFlowMapItemAdditionalRanges(a),i=o.additionalKeyRange,s=o.additionalValueRange;return On.transformAstPair(e,t,gn.createFlowMappingItem,i,s)})),o=n[0],i=un.getLast(n);return vn.createFlowMapping(t.transformRange({origStart:o.origOffset,origEnd:i.origOffset+1}),t.transformContent(e),a)}}));a(Mn);Mn.transformFlowMap;var Sn=o((function(e,t){t.__esModule=!0,t.createFlowSequence=function(e,t,n){return xt.__assign(xt.__assign({},pn.createFlowCollection(e,t,n)),{type:"flowSequence"})}}));a(Sn);Sn.createFlowSequence;var An=o((function(e,t){t.__esModule=!0,t.createFlowSequenceItem=function(e,t){return xt.__assign(xt.__assign({},Ct.createNode("flowSequenceItem",e)),{children:[t]})}}));a(An);An.createFlowSequenceItem;var kn=o((function(e,t){t.__esModule=!0,t.transformFlowSeq=function(e,t){var n=mn.extractComments(e.cstNode.items,t),r=bn.groupCstFlowCollectionItems(n),a=e.items.map((function(e,n){if("PAIR"!==e.type){var a=t.transformNode(e);return An.createFlowSequenceItem(an.createPosition(a.position.start,a.position.end),a)}var o=r[n],i=yn.getFlowMapItemAdditionalRanges(o),s=i.additionalKeyRange,u=i.additionalValueRange;return On.transformAstPair(e,t,gn.createFlowMappingItem,s,u)})),o=n[0],i=un.getLast(n);return Sn.createFlowSequence(t.transformRange({origStart:o.origOffset,origEnd:i.origOffset+1}),t.transformContent(e),a)}}));a(kn);kn.transformFlowSeq;var Ln=o((function(e,t){t.__esModule=!0,t.createMapping=function(e,t,n){return xt.__assign(xt.__assign(xt.__assign(xt.__assign({},Ct.createNode("mapping",e)),Bt.createLeadingCommentAttachable()),t),{children:n})}}));a(Ln);Ln.createMapping;var Tn=o((function(e,t){t.__esModule=!0,t.createMappingItem=function(e,t,n){return xt.__assign(xt.__assign(xt.__assign({},Ct.createNode("mappingItem",e)),Bt.createLeadingCommentAttachable()),{children:[t,n]})}}));a(Tn);Tn.createMappingItem;var Pn=o((function(e,t){t.__esModule=!0,t.transformMap=function(e,t){var n=e.cstNode;n.items.filter((function(e){return"MAP_KEY"===e.type||"MAP_VALUE"===e.type})).forEach((function(e){return tn.extractPropComments(e,t)}));var r=function(e){for(var t=[],n=_n.createSlicer(e,0),r=!1,a=0;a<e.length;a++){"MAP_VALUE"!==e[a].type?(r&&t.push(n(a)),r=!0):(t.push(n(a+1)),r=!1)}r&&t.push(n(1/0));return t}(mn.extractComments(n.items,t)),a=e.items.map((function(e,n){var a=r[n],o="MAP_VALUE"===a[0].type?[null,a[0].range]:[a[0].range,1===a.length?null:a[1].range],i=o[0],s=o[1];return On.transformAstPair(e,t,Tn.createMappingItem,i,s)}));return Ln.createMapping(an.createPosition(a[0].position.start,un.getLast(a).position.end),t.transformContent(e),a)}}));a(Pn);Pn.transformMap;var Cn=o((function(e,t){t.__esModule=!0,t.createPlain=function(e,t,n){return xt.__assign(xt.__assign(xt.__assign(xt.__assign({},Ct.createNode("plain",e)),jt.createCommentAttachable()),t),{value:n})}}));a(Cn);Cn.createPlain;var Nn=o((function(e,t){t.__esModule=!0,t.findLastCharIndex=function(e,t,n){for(var r=t;r>=0;r--)if(n.test(e[r]))return r;return-1}}));a(Nn);Nn.findLastCharIndex;var xn=o((function(e,t){t.__esModule=!0,t.transformPlain=function(e,t){var n=e.cstNode;return Cn.createPlain(t.transformRange({origStart:n.valueRange.origStart,origEnd:Nn.findLastCharIndex(t.text,n.valueRange.origEnd-1,/\S/)+1}),t.transformContent(e),n.strValue)}}));a(xn);xn.transformPlain;var Rn=o((function(e,t){t.__esModule=!0,t.createQuoteDouble=function(e){return xt.__assign(xt.__assign({},e),{type:"quoteDouble"})}}));a(Rn);Rn.createQuoteDouble;var In=o((function(e,t){t.__esModule=!0,t.createQuoteValue=function(e,t,n){return xt.__assign(xt.__assign(xt.__assign(xt.__assign({},Ct.createNode("quoteValue",e)),t),jt.createCommentAttachable()),{value:n})}}));a(In);In.createQuoteValue;var Bn=o((function(e,t){t.__esModule=!0,t.transformAstQuoteValue=function(e,t){var n=e.cstNode;return In.createQuoteValue(t.transformRange(n.valueRange),t.transformContent(e),n.strValue)}}));a(Bn);Bn.transformAstQuoteValue;var Dn=o((function(e,t){t.__esModule=!0,t.transformQuoteDouble=function(e,t){return Rn.createQuoteDouble(Bn.transformAstQuoteValue(e,t))}}));a(Dn);Dn.transformQuoteDouble;var jn=o((function(e,t){t.__esModule=!0,t.createQuoteSingle=function(e){return xt.__assign(xt.__assign({},e),{type:"quoteSingle"})}}));a(jn);jn.createQuoteSingle;var Yn=o((function(e,t){t.__esModule=!0,t.transformQuoteSingle=function(e,t){return jn.createQuoteSingle(Bn.transformAstQuoteValue(e,t))}}));a(Yn);Yn.transformQuoteSingle;var Fn=o((function(e,t){t.__esModule=!0,t.createSequence=function(e,t,n){return xt.__assign(xt.__assign(xt.__assign(xt.__assign(xt.__assign({},Ct.createNode("sequence",e)),Bt.createLeadingCommentAttachable()),on.createEndCommentAttachable()),t),{children:n})}}));a(Fn);Fn.createSequence;var Un=o((function(e,t){t.__esModule=!0,t.createSequenceItem=function(e,t){return xt.__assign(xt.__assign(xt.__assign(xt.__assign({},Ct.createNode("sequenceItem",e)),jt.createCommentAttachable()),on.createEndCommentAttachable()),{children:t?[t]:[]})}}));a(Un);Un.createSequenceItem;var Kn=o((function(e,t){t.__esModule=!0,t.transformSeq=function(e,t){var n=mn.extractComments(e.cstNode.items,t).map((function(n,r){tn.extractPropComments(n,t);var a=t.transformNode(e.items[r]);return Un.createSequenceItem(an.createPosition(t.transformOffset(n.valueRange.origStart),null===a?t.transformOffset(n.valueRange.origStart+1):a.position.end),a)}));return Fn.createSequence(an.createPosition(n[0].position.start,un.getLast(n).position.end),t.transformContent(e),n)}}));a(Kn);Kn.transformSeq;var Wn=o((function(e,t){t.__esModule=!0,t.transformNode=function(e,t){if(null===e)return null;switch(e.type){case"ALIAS":return Ft.transformAlias(e,t);case"BLOCK_FOLDED":return Ht.transformBlockFolded(e,t);case"BLOCK_LITERAL":return Zt.transformBlockLiteral(e,t);case"COMMENT":return Xt.transformComment(e,t);case"DIRECTIVE":return nn.transformDirective(e,t);case"DOCUMENT":return hn.transformDocument(e,t);case"FLOW_MAP":return Mn.transformFlowMap(e,t);case"FLOW_SEQ":return kn.transformFlowSeq(e,t);case"MAP":return Pn.transformMap(e,t);case"PLAIN":return xn.transformPlain(e,t);case"QUOTE_DOUBLE":return Dn.transformQuoteDouble(e,t);case"QUOTE_SINGLE":return Yn.transformQuoteSingle(e,t);case"SEQ":return Kn.transformSeq(e,t);default:throw new Error("Unexpected node type "+e.type)}}}));a(Wn);Wn.transformNode;var Qn=o((function(e,t){t.__esModule=!0,t.createError=function(e,t,n){var r=new SyntaxError(e);return r.name="YAMLSyntaxError",r.source=t,r.position=n,r}}));a(Qn);Qn.createError;var Vn=o((function(e,t){t.__esModule=!0,t.transformError=function(e,t){var n=e.source.range||e.source.valueRange;return Qn.createError(e.message,t.text,t.transformRange(n))}}));a(Vn);Vn.transformError;var $n=o((function(e,t){t.__esModule=!0,t.createPoint=function(e,t,n){return{offset:e,line:t,column:n}}}));a($n);$n.createPoint;var qn=o((function(e,t){t.__esModule=!0,t.transformOffset=function(e,t){e<0?e=0:e>t.text.length&&(e=t.text.length);var n=t.locator.locationForIndex(e);return $n.createPoint(e,n.line+1,n.column+1)}}));a(qn);qn.transformOffset;var Jn=o((function(e,t){t.__esModule=!0,t.transformRange=function(e,t){return an.createPosition(t.transformOffset(e.origStart),t.transformOffset(e.origEnd))}}));a(Jn);Jn.transformRange;var Gn=o((function(e,t){t.__esModule=!0;var n=!0;t.addOrigRange=function(e){if(!e.setOrigRanges()){var t=function(e){return function(e){return"number"==typeof e.start}(e)?(e.origStart=e.start,e.origEnd=e.end,n):function(e){return"number"==typeof e.offset}(e)?(e.origOffset=e.offset,n):void 0};e.forEach((function(e){return function e(t,r){if(!t||"object"!==i(t))return;if(r(t)===n)return;for(var a=0,o=Object.keys(t);a<o.length;a++){var s=o[a];if("context"!==s&&"error"!==s){var u=t[s];Array.isArray(u)?u.forEach((function(t){return e(t,r)})):e(u,r)}}}(e,t)}))}}}));a(Gn);Gn.addOrigRange;var Hn=o((function(e,t){t.__esModule=!0,t.removeFakeNodes=function e(t){if("children"in t){if(1===t.children.length){var n=t.children[0];if("plain"===n.type&&null===n.tag&&null===n.anchor&&""===n.value)return t.children.splice(0,1),t}t.children.forEach(e)}return t}}));a(Hn);Hn.removeFakeNodes;var zn=o((function(e,t){t.__esModule=!0,t.createUpdater=function(e,t,n,r){var a=t(e);return function(t){r(a,t)&&n(e,a=t)}}}));a(zn);zn.createUpdater;var Zn=o((function(e,t){function n(e){return e.start}function r(e,t){e.start=t}function a(e){return e.end}function o(e,t){e.end=t}function i(e,t){return t.offset<e.offset}function s(e,t){return t.offset>e.offset}t.__esModule=!0,t.updatePositions=function e(t){if(null!==t&&"children"in t){var u=t.children;if(u.forEach(e),"document"===t.type){var f=t.children,l=f[0],c=f[1];l.position.start.offset===l.position.end.offset?l.position.start=l.position.end=c.position.start:c.position.start.offset===c.position.end.offset&&(c.position.start=c.position.end=l.position.end)}var d=zn.createUpdater(t.position,n,r,i),h=zn.createUpdater(t.position,a,o,s);"endComments"in t&&0!==t.endComments.length&&(d(t.endComments[0].position.start),h(un.getLast(t.endComments).position.end));var p=u.filter((function(e){return null!==e}));if(0!==p.length){var v=p[0],g=un.getLast(p);d(v.position.start),h(g.position.end),"leadingComments"in v&&0!==v.leadingComments.length&&d(v.leadingComments[0].position.start),"tag"in v&&v.tag&&d(v.tag.position.start),"anchor"in v&&v.anchor&&d(v.anchor.position.start),"trailingComment"in g&&g.trailingComment&&h(g.trailingComment.position.end)}}}}));a(Zn);Zn.updatePositions;var Xn=o((function(e,t){t.__esModule=!0,t.parse=function(e){var t=kt.parseCST(e);Gn.addOrigRange(t);var n=t.map((function(e){return new kt.Document({merge:!0,keepCstNodes:!0}).parse(e)})),r=[],a={text:e,locator:new L.default(e),comments:r,transformOffset:function(e){return qn.transformOffset(e,a)},transformRange:function(e){return Jn.transformRange(e,a)},transformNode:function(e){return Wn.transformNode(e,a)},transformContent:function(e){return Jt.transformContent(e,a)}},o=n.find((function(e){return 0!==e.errors.length}));if(o)throw Vn.transformError(o.errors[0],a);n.forEach((function(e){return It.removeCstBlankLine(e.cstNode)}));var i=Rt.createRoot(a.transformRange({origStart:0,origEnd:a.text.length}),n.map(a.transformNode),r);return Pt.attachComments(i),Zn.updatePositions(i),Hn.removeFakeNodes(i),i}}));a(Xn);Xn.parse;var er=o((function(e,t){t.__esModule=!0,xt.__exportStar(Xn,t)}));a(er);var tr={parsers:{yaml:{astFormat:"yaml",parse:function(e){try{var n=er.parse(e);return delete n.comments,n}catch(e){throw e&&e.position?t(e.message,e.position):e}},hasPragma:n,locStart:function(e){return e.position.start.offset},locEnd:function(e){return e.position.end.offset}}}},nr=tr.parsers;e.default=tr,e.parsers=nr,Object.defineProperty(e,"__esModule",{value:!0})}));


/***/ }),
/* 45 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/base/common/errors.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// Avoid circular dependency on EventEmitter by implementing a subset of the interface.
var ErrorHandler = /** @class */ (function () {
    function ErrorHandler() {
        this.listeners = [];
        this.unexpectedErrorHandler = function (e) {
            setTimeout(function () {
                if (e.stack) {
                    throw new Error(e.message + '\n\n' + e.stack);
                }
                throw e;
            }, 0);
        };
    }
    ErrorHandler.prototype.emit = function (e) {
        this.listeners.forEach(function (listener) {
            listener(e);
        });
    };
    ErrorHandler.prototype.onUnexpectedError = function (e) {
        this.unexpectedErrorHandler(e);
        this.emit(e);
    };
    // For external errors, we don't want the listeners to be called
    ErrorHandler.prototype.onUnexpectedExternalError = function (e) {
        this.unexpectedErrorHandler(e);
    };
    return ErrorHandler;
}());

var errorHandler = new ErrorHandler();
function onUnexpectedError(e) {
    // ignore errors from cancelled promises
    if (!isPromiseCanceledError(e)) {
        errorHandler.onUnexpectedError(e);
    }
    return undefined;
}
function onUnexpectedExternalError(e) {
    // ignore errors from cancelled promises
    if (!isPromiseCanceledError(e)) {
        errorHandler.onUnexpectedExternalError(e);
    }
    return undefined;
}
function transformErrorForSerialization(error) {
    if (error instanceof Error) {
        var name_1 = error.name, message = error.message;
        var stack = error.stacktrace || error.stack;
        return {
            $isError: true,
            name: name_1,
            message: message,
            stack: stack
        };
    }
    // return as is
    return error;
}
var canceledName = 'Canceled';
/**
 * Checks if the given error is a promise in canceled state
 */
function isPromiseCanceledError(error) {
    return error instanceof Error && error.name === canceledName && error.message === canceledName;
}
/**
 * Returns an error that signals cancellation.
 */
function canceled() {
    var error = new Error(canceledName);
    error.name = error.message;
    return error;
}
function illegalArgument(name) {
    if (name) {
        return new Error("Illegal argument: " + name);
    }
    else {
        return new Error('Illegal argument');
    }
}
function illegalState(name) {
    if (name) {
        return new Error("Illegal state: " + name);
    }
    else {
        return new Error('Illegal state');
    }
}

// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/base/common/lifecycle.js
/**
 * Enables logging of potentially leaked disposables.
 *
 * A disposable is considered leaked if it is not disposed or not registered as the child of
 * another disposable. This tracking is very simple an only works for classes that either
 * extend Disposable or use a DisposableStore. This means there are a lot of false positives.
 */
var TRACK_DISPOSABLES = false;
var __is_disposable_tracked__ = '__is_disposable_tracked__';
function markTracked(x) {
    if (!TRACK_DISPOSABLES) {
        return;
    }
    if (x && x !== Disposable.None) {
        try {
            x[__is_disposable_tracked__] = true;
        }
        catch (_a) {
            // noop
        }
    }
}
function trackDisposable(x) {
    if (!TRACK_DISPOSABLES) {
        return x;
    }
    var stack = new Error('Potentially leaked disposable').stack;
    setTimeout(function () {
        if (!x[__is_disposable_tracked__]) {
            console.log(stack);
        }
    }, 3000);
    return x;
}
function isDisposable(thing) {
    return typeof thing.dispose === 'function'
        && thing.dispose.length === 0;
}
function lifecycle_dispose(disposables) {
    if (Array.isArray(disposables)) {
        disposables.forEach(function (d) {
            if (d) {
                markTracked(d);
                d.dispose();
            }
        });
        return [];
    }
    else if (disposables) {
        markTracked(disposables);
        disposables.dispose();
        return disposables;
    }
    else {
        return undefined;
    }
}
function combinedDisposable() {
    var disposables = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        disposables[_i] = arguments[_i];
    }
    disposables.forEach(markTracked);
    return trackDisposable({ dispose: function () { return lifecycle_dispose(disposables); } });
}
function toDisposable(fn) {
    var self = trackDisposable({
        dispose: function () {
            markTracked(self);
            fn();
        }
    });
    return self;
}
var DisposableStore = /** @class */ (function () {
    function DisposableStore() {
        this._toDispose = new Set();
        this._isDisposed = false;
    }
    /**
     * Dispose of all registered disposables and mark this object as disposed.
     *
     * Any future disposables added to this object will be disposed of on `add`.
     */
    DisposableStore.prototype.dispose = function () {
        if (this._isDisposed) {
            return;
        }
        markTracked(this);
        this._isDisposed = true;
        this.clear();
    };
    /**
     * Dispose of all registered disposables but do not mark this object as disposed.
     */
    DisposableStore.prototype.clear = function () {
        this._toDispose.forEach(function (item) { return item.dispose(); });
        this._toDispose.clear();
    };
    DisposableStore.prototype.add = function (t) {
        if (!t) {
            return t;
        }
        if (t === this) {
            throw new Error('Cannot register a disposable on itself!');
        }
        markTracked(t);
        if (this._isDisposed) {
            console.warn(new Error('Trying to add a disposable to a DisposableStore that has already been disposed of. The added object will be leaked!').stack);
        }
        else {
            this._toDispose.add(t);
        }
        return t;
    };
    return DisposableStore;
}());

var Disposable = /** @class */ (function () {
    function Disposable() {
        this._store = new DisposableStore();
        trackDisposable(this);
    }
    Disposable.prototype.dispose = function () {
        markTracked(this);
        this._store.dispose();
    };
    Disposable.prototype._register = function (t) {
        if (t === this) {
            throw new Error('Cannot register a disposable on itself!');
        }
        return this._store.add(t);
    };
    Disposable.None = Object.freeze({ dispose: function () { } });
    return Disposable;
}());

/**
 * Manages the lifecycle of a disposable value that may be changed.
 *
 * This ensures that when the disposable value is changed, the previously held disposable is disposed of. You can
 * also register a `MutableDisposable` on a `Disposable` to ensure it is automatically cleaned up.
 */
var MutableDisposable = /** @class */ (function () {
    function MutableDisposable() {
        this._isDisposed = false;
        trackDisposable(this);
    }
    Object.defineProperty(MutableDisposable.prototype, "value", {
        get: function () {
            return this._isDisposed ? undefined : this._value;
        },
        set: function (value) {
            if (this._isDisposed || value === this._value) {
                return;
            }
            if (this._value) {
                this._value.dispose();
            }
            if (value) {
                markTracked(value);
            }
            this._value = value;
        },
        enumerable: true,
        configurable: true
    });
    MutableDisposable.prototype.clear = function () {
        this.value = undefined;
    };
    MutableDisposable.prototype.dispose = function () {
        this._isDisposed = true;
        markTracked(this);
        if (this._value) {
            this._value.dispose();
        }
        this._value = undefined;
    };
    return MutableDisposable;
}());

var ImmortalReference = /** @class */ (function () {
    function ImmortalReference(object) {
        this.object = object;
    }
    ImmortalReference.prototype.dispose = function () { };
    return ImmortalReference;
}());


// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/base/common/platform.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var LANGUAGE_DEFAULT = 'en';
var _isWindows = false;
var _isMacintosh = false;
var _isLinux = false;
var _isNative = false;
var _isWeb = false;
var _isIOS = false;
var _locale = undefined;
var _language = LANGUAGE_DEFAULT;
var _translationsConfigFile = undefined;
var _userAgent = undefined;
var isElectronRenderer = (typeof process !== 'undefined' && typeof process.versions !== 'undefined' && typeof process.versions.electron !== 'undefined' && process.type === 'renderer');
// OS detection
if (typeof navigator === 'object' && !isElectronRenderer) {
    _userAgent = navigator.userAgent;
    _isWindows = _userAgent.indexOf('Windows') >= 0;
    _isMacintosh = _userAgent.indexOf('Macintosh') >= 0;
    _isIOS = _userAgent.indexOf('Macintosh') >= 0 && !!navigator.maxTouchPoints && navigator.maxTouchPoints > 0;
    _isLinux = _userAgent.indexOf('Linux') >= 0;
    _isWeb = true;
    _locale = navigator.language;
    _language = _locale;
}
else if (typeof process === 'object') {
    _isWindows = (process.platform === 'win32');
    _isMacintosh = (process.platform === 'darwin');
    _isLinux = (process.platform === 'linux');
    _locale = LANGUAGE_DEFAULT;
    _language = LANGUAGE_DEFAULT;
    var rawNlsConfig = process.env['VSCODE_NLS_CONFIG'];
    if (rawNlsConfig) {
        try {
            var nlsConfig = JSON.parse(rawNlsConfig);
            var resolved = nlsConfig.availableLanguages['*'];
            _locale = nlsConfig.locale;
            // VSCode's default language is 'en'
            _language = resolved ? resolved : LANGUAGE_DEFAULT;
            _translationsConfigFile = nlsConfig._translationsConfigFile;
        }
        catch (e) {
        }
    }
    _isNative = true;
}
var _platform = 0 /* Web */;
if (_isMacintosh) {
    _platform = 1 /* Mac */;
}
else if (_isWindows) {
    _platform = 3 /* Windows */;
}
else if (_isLinux) {
    _platform = 2 /* Linux */;
}
var isWindows = _isWindows;
var isMacintosh = _isMacintosh;
var isLinux = _isLinux;
var isNative = _isNative;
var isWeb = _isWeb;
var isIOS = _isIOS;
var _globals = (typeof self === 'object' ? self : typeof global === 'object' ? global : {});
var globals = _globals;
var setImmediate = (function defineSetImmediate() {
    if (globals.setImmediate) {
        return globals.setImmediate.bind(globals);
    }
    if (typeof globals.postMessage === 'function' && !globals.importScripts) {
        var pending_1 = [];
        globals.addEventListener('message', function (e) {
            if (e.data && e.data.vscodeSetImmediateId) {
                for (var i = 0, len = pending_1.length; i < len; i++) {
                    var candidate = pending_1[i];
                    if (candidate.id === e.data.vscodeSetImmediateId) {
                        pending_1.splice(i, 1);
                        candidate.callback();
                        return;
                    }
                }
            }
        });
        var lastId_1 = 0;
        return function (callback) {
            var myId = ++lastId_1;
            pending_1.push({
                id: myId,
                callback: callback
            });
            globals.postMessage({ vscodeSetImmediateId: myId }, '*');
        };
    }
    if (typeof process !== 'undefined' && typeof process.nextTick === 'function') {
        return process.nextTick.bind(process);
    }
    var _promise = Promise.resolve();
    return function (callback) { return _promise.then(callback); };
})();
var OS = (_isMacintosh ? 2 /* Macintosh */ : (_isWindows ? 1 /* Windows */ : 3 /* Linux */));

// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/base/common/types.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var _typeof = {
    number: 'number',
    string: 'string',
    undefined: 'undefined',
    object: 'object',
    function: 'function'
};
/**
 * @returns whether the provided parameter is a JavaScript Array or not.
 */
function isArray(array) {
    if (Array.isArray) {
        return Array.isArray(array);
    }
    if (array && typeof (array.length) === _typeof.number && array.constructor === Array) {
        return true;
    }
    return false;
}
/**
 * @returns whether the provided parameter is a JavaScript String or not.
 */
function isString(str) {
    if (typeof (str) === _typeof.string || str instanceof String) {
        return true;
    }
    return false;
}
/**
 *
 * @returns whether the provided parameter is of type `object` but **not**
 *	`null`, an `array`, a `regexp`, nor a `date`.
 */
function isObject(obj) {
    // The method can't do a type cast since there are type (like strings) which
    // are subclasses of any put not positvely matched by the function. Hence type
    // narrowing results in wrong results.
    return typeof obj === _typeof.object
        && obj !== null
        && !Array.isArray(obj)
        && !(obj instanceof RegExp)
        && !(obj instanceof Date);
}
/**
 * In **contrast** to just checking `typeof` this will return `false` for `NaN`.
 * @returns whether the provided parameter is a JavaScript Number or not.
 */
function isNumber(obj) {
    if ((typeof (obj) === _typeof.number || obj instanceof Number) && !isNaN(obj)) {
        return true;
    }
    return false;
}
/**
 * @returns whether the provided parameter is a JavaScript Boolean or not.
 */
function isBoolean(obj) {
    return obj === true || obj === false;
}
/**
 * @returns whether the provided parameter is undefined.
 */
function isUndefined(obj) {
    return typeof (obj) === _typeof.undefined;
}
/**
 * @returns whether the provided parameter is undefined or null.
 */
function isUndefinedOrNull(obj) {
    return isUndefined(obj) || obj === null;
}
function assertType(condition, type) {
    if (!condition) {
        throw new Error(type ? "Unexpected type, expected '" + type + "'" : 'Unexpected type');
    }
}
var types_hasOwnProperty = Object.prototype.hasOwnProperty;
/**
 * @returns whether the provided parameter is an empty JavaScript Object or not.
 */
function isEmptyObject(obj) {
    if (!isObject(obj)) {
        return false;
    }
    for (var key in obj) {
        if (types_hasOwnProperty.call(obj, key)) {
            return false;
        }
    }
    return true;
}
/**
 * @returns whether the provided parameter is a JavaScript Function or not.
 */
function isFunction(obj) {
    return typeof obj === _typeof.function;
}
function validateConstraints(args, constraints) {
    var len = Math.min(args.length, constraints.length);
    for (var i = 0; i < len; i++) {
        validateConstraint(args[i], constraints[i]);
    }
}
function validateConstraint(arg, constraint) {
    if (isString(constraint)) {
        if (typeof arg !== constraint) {
            throw new Error("argument does not match constraint: typeof " + constraint);
        }
    }
    else if (isFunction(constraint)) {
        try {
            if (arg instanceof constraint) {
                return;
            }
        }
        catch (_a) {
            // ignore
        }
        if (!isUndefinedOrNull(arg) && arg.constructor === constraint) {
            return;
        }
        if (constraint.length === 1 && constraint.call(undefined, arg) === true) {
            return;
        }
        throw new Error("argument does not match one of these constraints: arg instanceof constraint, arg.constructor === constraint, nor constraint(arg) === true");
    }
}
function getAllPropertyNames(obj) {
    var res = [];
    var proto = Object.getPrototypeOf(obj);
    while (Object.prototype !== proto) {
        res = res.concat(Object.getOwnPropertyNames(proto));
        proto = Object.getPrototypeOf(proto);
    }
    return res;
}
function getAllMethodNames(obj) {
    var methods = [];
    for (var _i = 0, _a = getAllPropertyNames(obj); _i < _a.length; _i++) {
        var prop = _a[_i];
        if (typeof obj[prop] === 'function') {
            methods.push(prop);
        }
    }
    return methods;
}
function createProxyObject(methodNames, invoke) {
    var createProxyMethod = function (method) {
        return function () {
            var args = Array.prototype.slice.call(arguments, 0);
            return invoke(method, args);
        };
    };
    var result = {};
    for (var _i = 0, methodNames_1 = methodNames; _i < methodNames_1.length; _i++) {
        var methodName = methodNames_1[_i];
        result[methodName] = createProxyMethod(methodName);
    }
    return result;
}
/**
 * Converts null to undefined, passes all other values through.
 */
function withNullAsUndefined(x) {
    return x === null ? undefined : x;
}
/**
 * Converts undefined to null, passes all other values through.
 */
function withUndefinedAsNull(x) {
    return typeof x === 'undefined' ? null : x;
}

// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/base/common/worker/simpleWorker.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var __extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var INITIALIZE = '$initialize';
var webWorkerWarningLogged = false;
function logOnceWebWorkerWarning(err) {
    if (!isWeb) {
        // running tests
        return;
    }
    if (!webWorkerWarningLogged) {
        webWorkerWarningLogged = true;
        console.warn('Could not create web worker(s). Falling back to loading web worker code in main thread, which might cause UI freezes. Please see https://github.com/Microsoft/monaco-editor#faq');
    }
    console.warn(err.message);
}
var simpleWorker_SimpleWorkerProtocol = /** @class */ (function () {
    function SimpleWorkerProtocol(handler) {
        this._workerId = -1;
        this._handler = handler;
        this._lastSentReq = 0;
        this._pendingReplies = Object.create(null);
    }
    SimpleWorkerProtocol.prototype.setWorkerId = function (workerId) {
        this._workerId = workerId;
    };
    SimpleWorkerProtocol.prototype.sendMessage = function (method, args) {
        var _this = this;
        var req = String(++this._lastSentReq);
        return new Promise(function (resolve, reject) {
            _this._pendingReplies[req] = {
                resolve: resolve,
                reject: reject
            };
            _this._send({
                vsWorker: _this._workerId,
                req: req,
                method: method,
                args: args
            });
        });
    };
    SimpleWorkerProtocol.prototype.handleMessage = function (message) {
        if (!message || !message.vsWorker) {
            return;
        }
        if (this._workerId !== -1 && message.vsWorker !== this._workerId) {
            return;
        }
        this._handleMessage(message);
    };
    SimpleWorkerProtocol.prototype._handleMessage = function (msg) {
        var _this = this;
        if (msg.seq) {
            var replyMessage = msg;
            if (!this._pendingReplies[replyMessage.seq]) {
                console.warn('Got reply to unknown seq');
                return;
            }
            var reply = this._pendingReplies[replyMessage.seq];
            delete this._pendingReplies[replyMessage.seq];
            if (replyMessage.err) {
                var err = replyMessage.err;
                if (replyMessage.err.$isError) {
                    err = new Error();
                    err.name = replyMessage.err.name;
                    err.message = replyMessage.err.message;
                    err.stack = replyMessage.err.stack;
                }
                reply.reject(err);
                return;
            }
            reply.resolve(replyMessage.res);
            return;
        }
        var requestMessage = msg;
        var req = requestMessage.req;
        var result = this._handler.handleMessage(requestMessage.method, requestMessage.args);
        result.then(function (r) {
            _this._send({
                vsWorker: _this._workerId,
                seq: req,
                res: r,
                err: undefined
            });
        }, function (e) {
            if (e.detail instanceof Error) {
                // Loading errors have a detail property that points to the actual error
                e.detail = transformErrorForSerialization(e.detail);
            }
            _this._send({
                vsWorker: _this._workerId,
                seq: req,
                res: undefined,
                err: transformErrorForSerialization(e)
            });
        });
    };
    SimpleWorkerProtocol.prototype._send = function (msg) {
        var transfer = [];
        if (msg.req) {
            var m = msg;
            for (var i = 0; i < m.args.length; i++) {
                if (m.args[i] instanceof ArrayBuffer) {
                    transfer.push(m.args[i]);
                }
            }
        }
        else {
            var m = msg;
            if (m.res instanceof ArrayBuffer) {
                transfer.push(m.res);
            }
        }
        this._handler.sendMessage(msg, transfer);
    };
    return SimpleWorkerProtocol;
}());
/**
 * Main thread side
 */
var simpleWorker_SimpleWorkerClient = /** @class */ (function (_super) {
    __extends(SimpleWorkerClient, _super);
    function SimpleWorkerClient(workerFactory, moduleId, host) {
        var _this = _super.call(this) || this;
        var lazyProxyReject = null;
        _this._worker = _this._register(workerFactory.create('vs/base/common/worker/simpleWorker', function (msg) {
            _this._protocol.handleMessage(msg);
        }, function (err) {
            // in Firefox, web workers fail lazily :(
            // we will reject the proxy
            if (lazyProxyReject) {
                lazyProxyReject(err);
            }
        }));
        _this._protocol = new simpleWorker_SimpleWorkerProtocol({
            sendMessage: function (msg, transfer) {
                _this._worker.postMessage(msg, transfer);
            },
            handleMessage: function (method, args) {
                if (typeof host[method] !== 'function') {
                    return Promise.reject(new Error('Missing method ' + method + ' on main thread host.'));
                }
                try {
                    return Promise.resolve(host[method].apply(host, args));
                }
                catch (e) {
                    return Promise.reject(e);
                }
            }
        });
        _this._protocol.setWorkerId(_this._worker.getId());
        // Gather loader configuration
        var loaderConfiguration = null;
        if (typeof self.require !== 'undefined' && typeof self.require.getConfig === 'function') {
            // Get the configuration from the Monaco AMD Loader
            loaderConfiguration = self.require.getConfig();
        }
        else if (typeof self.requirejs !== 'undefined') {
            // Get the configuration from requirejs
            loaderConfiguration = self.requirejs.s.contexts._.config;
        }
        var hostMethods = getAllMethodNames(host);
        // Send initialize message
        _this._onModuleLoaded = _this._protocol.sendMessage(INITIALIZE, [
            _this._worker.getId(),
            JSON.parse(JSON.stringify(loaderConfiguration)),
            moduleId,
            hostMethods,
        ]);
        // Create proxy to loaded code
        var proxyMethodRequest = function (method, args) {
            return _this._request(method, args);
        };
        _this._lazyProxy = new Promise(function (resolve, reject) {
            lazyProxyReject = reject;
            _this._onModuleLoaded.then(function (availableMethods) {
                resolve(createProxyObject(availableMethods, proxyMethodRequest));
            }, function (e) {
                reject(e);
                _this._onError('Worker failed to load ' + moduleId, e);
            });
        });
        return _this;
    }
    SimpleWorkerClient.prototype.getProxyObject = function () {
        return this._lazyProxy;
    };
    SimpleWorkerClient.prototype._request = function (method, args) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this._onModuleLoaded.then(function () {
                _this._protocol.sendMessage(method, args).then(resolve, reject);
            }, reject);
        });
    };
    SimpleWorkerClient.prototype._onError = function (message, error) {
        console.error(message);
        console.info(error);
    };
    return SimpleWorkerClient;
}(Disposable));

/**
 * Worker side
 */
var simpleWorker_SimpleWorkerServer = /** @class */ (function () {
    function SimpleWorkerServer(postMessage, requestHandlerFactory) {
        var _this = this;
        this._requestHandlerFactory = requestHandlerFactory;
        this._requestHandler = null;
        this._protocol = new simpleWorker_SimpleWorkerProtocol({
            sendMessage: function (msg, transfer) {
                postMessage(msg, transfer);
            },
            handleMessage: function (method, args) { return _this._handleMessage(method, args); }
        });
    }
    SimpleWorkerServer.prototype.onmessage = function (msg) {
        this._protocol.handleMessage(msg);
    };
    SimpleWorkerServer.prototype._handleMessage = function (method, args) {
        if (method === INITIALIZE) {
            return this.initialize(args[0], args[1], args[2], args[3]);
        }
        if (!this._requestHandler || typeof this._requestHandler[method] !== 'function') {
            return Promise.reject(new Error('Missing requestHandler or method: ' + method));
        }
        try {
            return Promise.resolve(this._requestHandler[method].apply(this._requestHandler, args));
        }
        catch (e) {
            return Promise.reject(e);
        }
    };
    SimpleWorkerServer.prototype.initialize = function (workerId, loaderConfig, moduleId, hostMethods) {
        var _this = this;
        this._protocol.setWorkerId(workerId);
        var proxyMethodRequest = function (method, args) {
            return _this._protocol.sendMessage(method, args);
        };
        var hostProxy = createProxyObject(hostMethods, proxyMethodRequest);
        if (this._requestHandlerFactory) {
            // static request handler
            this._requestHandler = this._requestHandlerFactory(hostProxy);
            return Promise.resolve(getAllMethodNames(this._requestHandler));
        }
        if (loaderConfig) {
            // Remove 'baseUrl', handling it is beyond scope for now
            if (typeof loaderConfig.baseUrl !== 'undefined') {
                delete loaderConfig['baseUrl'];
            }
            if (typeof loaderConfig.paths !== 'undefined') {
                if (typeof loaderConfig.paths.vs !== 'undefined') {
                    delete loaderConfig.paths['vs'];
                }
            }
            // Since this is in a web worker, enable catching errors
            loaderConfig.catchError = true;
            self.require.config(loaderConfig);
        }
        return new Promise(function (resolve, reject) {
            // Use the global require to be sure to get the global config
            self.require([moduleId], function (module) {
                _this._requestHandler = module.create(hostProxy);
                if (!_this._requestHandler) {
                    reject(new Error("No RequestHandler!"));
                    return;
                }
                resolve(getAllMethodNames(_this._requestHandler));
            }, reject);
        });
    };
    return SimpleWorkerServer;
}());

/**
 * Called on the worker side
 */
function create(postMessage) {
    return new simpleWorker_SimpleWorkerServer(postMessage, null);
}

// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/base/common/arrays.js
/**
 * Returns the last element of an array.
 * @param array The array.
 * @param n Which element from the end (default is zero).
 */
function arrays_tail(array, n) {
    if (n === void 0) { n = 0; }
    return array[array.length - (1 + n)];
}
function tail2(arr) {
    if (arr.length === 0) {
        throw new Error('Invalid tail call');
    }
    return [arr.slice(0, arr.length - 1), arr[arr.length - 1]];
}
function equals(one, other, itemEquals) {
    if (itemEquals === void 0) { itemEquals = function (a, b) { return a === b; }; }
    if (one === other) {
        return true;
    }
    if (!one || !other) {
        return false;
    }
    if (one.length !== other.length) {
        return false;
    }
    for (var i = 0, len = one.length; i < len; i++) {
        if (!itemEquals(one[i], other[i])) {
            return false;
        }
    }
    return true;
}
function binarySearch(array, key, comparator) {
    var low = 0, high = array.length - 1;
    while (low <= high) {
        var mid = ((low + high) / 2) | 0;
        var comp = comparator(array[mid], key);
        if (comp < 0) {
            low = mid + 1;
        }
        else if (comp > 0) {
            high = mid - 1;
        }
        else {
            return mid;
        }
    }
    return -(low + 1);
}
/**
 * Takes a sorted array and a function p. The array is sorted in such a way that all elements where p(x) is false
 * are located before all elements where p(x) is true.
 * @returns the least x for which p(x) is true or array.length if no element fullfills the given function.
 */
function findFirstInSorted(array, p) {
    var low = 0, high = array.length;
    if (high === 0) {
        return 0; // no children
    }
    while (low < high) {
        var mid = Math.floor((low + high) / 2);
        if (p(array[mid])) {
            high = mid;
        }
        else {
            low = mid + 1;
        }
    }
    return low;
}
/**
 * Like `Array#sort` but always stable. Usually runs a little slower `than Array#sort`
 * so only use this when actually needing stable sort.
 */
function mergeSort(data, compare) {
    _sort(data, compare, 0, data.length - 1, []);
    return data;
}
function _merge(a, compare, lo, mid, hi, aux) {
    var leftIdx = lo, rightIdx = mid + 1;
    for (var i = lo; i <= hi; i++) {
        aux[i] = a[i];
    }
    for (var i = lo; i <= hi; i++) {
        if (leftIdx > mid) {
            // left side consumed
            a[i] = aux[rightIdx++];
        }
        else if (rightIdx > hi) {
            // right side consumed
            a[i] = aux[leftIdx++];
        }
        else if (compare(aux[rightIdx], aux[leftIdx]) < 0) {
            // right element is less -> comes first
            a[i] = aux[rightIdx++];
        }
        else {
            // left element comes first (less or equal)
            a[i] = aux[leftIdx++];
        }
    }
}
function _sort(a, compare, lo, hi, aux) {
    if (hi <= lo) {
        return;
    }
    var mid = lo + ((hi - lo) / 2) | 0;
    _sort(a, compare, lo, mid, aux);
    _sort(a, compare, mid + 1, hi, aux);
    if (compare(a[mid], a[mid + 1]) <= 0) {
        // left and right are sorted and if the last-left element is less
        // or equals than the first-right element there is nothing else
        // to do
        return;
    }
    _merge(a, compare, lo, mid, hi, aux);
}
function groupBy(data, compare) {
    var result = [];
    var currentGroup = undefined;
    for (var _i = 0, _a = mergeSort(data.slice(0), compare); _i < _a.length; _i++) {
        var element = _a[_i];
        if (!currentGroup || compare(currentGroup[0], element) !== 0) {
            currentGroup = [element];
            result.push(currentGroup);
        }
        else {
            currentGroup.push(element);
        }
    }
    return result;
}
/**
 * @returns New array with all falsy values removed. The original array IS NOT modified.
 */
function coalesce(array) {
    return array.filter(function (e) { return !!e; });
}
/**
 * @returns false if the provided object is an array and not empty.
 */
function isFalsyOrEmpty(obj) {
    return !Array.isArray(obj) || obj.length === 0;
}
function isNonEmptyArray(obj) {
    return Array.isArray(obj) && obj.length > 0;
}
/**
 * Removes duplicates from the given array. The optional keyFn allows to specify
 * how elements are checked for equalness by returning a unique string for each.
 */
function distinct(array, keyFn) {
    if (!keyFn) {
        return array.filter(function (element, position) {
            return array.indexOf(element) === position;
        });
    }
    var seen = Object.create(null);
    return array.filter(function (elem) {
        var key = keyFn(elem);
        if (seen[key]) {
            return false;
        }
        seen[key] = true;
        return true;
    });
}
function distinctES6(array) {
    var seen = new Set();
    return array.filter(function (element) {
        if (seen.has(element)) {
            return false;
        }
        seen.add(element);
        return true;
    });
}
function fromSet(set) {
    var result = [];
    set.forEach(function (o) { return result.push(o); });
    return result;
}
function firstIndex(array, fn) {
    for (var i = 0; i < array.length; i++) {
        var element = array[i];
        if (fn(element)) {
            return i;
        }
    }
    return -1;
}
function first(array, fn, notFoundValue) {
    if (notFoundValue === void 0) { notFoundValue = undefined; }
    var index = firstIndex(array, fn);
    return index < 0 ? notFoundValue : array[index];
}
function firstOrDefault(array, notFoundValue) {
    return array.length > 0 ? array[0] : notFoundValue;
}
function flatten(arr) {
    var _a;
    return (_a = []).concat.apply(_a, arr);
}
function arrays_range(arg, to) {
    var from = typeof to === 'number' ? arg : 0;
    if (typeof to === 'number') {
        from = arg;
    }
    else {
        from = 0;
        to = arg;
    }
    var result = [];
    if (from <= to) {
        for (var i = from; i < to; i++) {
            result.push(i);
        }
    }
    else {
        for (var i = from; i > to; i--) {
            result.push(i);
        }
    }
    return result;
}
/**
 * Insert `insertArr` inside `target` at `insertIndex`.
 * Please don't touch unless you understand https://jsperf.com/inserting-an-array-within-an-array
 */
function arrayInsert(target, insertIndex, insertArr) {
    var before = target.slice(0, insertIndex);
    var after = target.slice(insertIndex);
    return before.concat(insertArr, after);
}
/**
 * Pushes an element to the start of the array, if found.
 */
function pushToStart(arr, value) {
    var index = arr.indexOf(value);
    if (index > -1) {
        arr.splice(index, 1);
        arr.unshift(value);
    }
}
/**
 * Pushes an element to the end of the array, if found.
 */
function pushToEnd(arr, value) {
    var index = arr.indexOf(value);
    if (index > -1) {
        arr.splice(index, 1);
        arr.push(value);
    }
}
function find(arr, predicate) {
    for (var i = 0; i < arr.length; i++) {
        var element = arr[i];
        if (predicate(element, i, arr)) {
            return element;
        }
    }
    return undefined;
}
function asArray(x) {
    return Array.isArray(x) ? x : [x];
}

// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/base/common/diff/diffChange.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * Represents information about a specific difference between two sequences.
 */
var DiffChange = /** @class */ (function () {
    /**
     * Constructs a new DiffChange with the given sequence information
     * and content.
     */
    function DiffChange(originalStart, originalLength, modifiedStart, modifiedLength) {
        //Debug.Assert(originalLength > 0 || modifiedLength > 0, "originalLength and modifiedLength cannot both be <= 0");
        this.originalStart = originalStart;
        this.originalLength = originalLength;
        this.modifiedStart = modifiedStart;
        this.modifiedLength = modifiedLength;
    }
    /**
     * The end point (exclusive) of the change in the original sequence.
     */
    DiffChange.prototype.getOriginalEnd = function () {
        return this.originalStart + this.originalLength;
    };
    /**
     * The end point (exclusive) of the change in the modified sequence.
     */
    DiffChange.prototype.getModifiedEnd = function () {
        return this.modifiedStart + this.modifiedLength;
    };
    return DiffChange;
}());


// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/base/common/hash.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * Return a hash value for an object.
 */
function hash_hash(obj, hashVal) {
    if (hashVal === void 0) { hashVal = 0; }
    switch (typeof obj) {
        case 'object':
            if (obj === null) {
                return numberHash(349, hashVal);
            }
            else if (Array.isArray(obj)) {
                return arrayHash(obj, hashVal);
            }
            return objectHash(obj, hashVal);
        case 'string':
            return stringHash(obj, hashVal);
        case 'boolean':
            return booleanHash(obj, hashVal);
        case 'number':
            return numberHash(obj, hashVal);
        case 'undefined':
            return numberHash(0, 937);
        default:
            return numberHash(0, 617);
    }
}
function numberHash(val, initialHashVal) {
    return (((initialHashVal << 5) - initialHashVal) + val) | 0; // hashVal * 31 + ch, keep as int32
}
function booleanHash(b, initialHashVal) {
    return numberHash(b ? 433 : 863, initialHashVal);
}
function stringHash(s, hashVal) {
    hashVal = numberHash(149417, hashVal);
    for (var i = 0, length_1 = s.length; i < length_1; i++) {
        hashVal = numberHash(s.charCodeAt(i), hashVal);
    }
    return hashVal;
}
function arrayHash(arr, initialHashVal) {
    initialHashVal = numberHash(104579, initialHashVal);
    return arr.reduce(function (hashVal, item) { return hash_hash(item, hashVal); }, initialHashVal);
}
function objectHash(obj, initialHashVal) {
    initialHashVal = numberHash(181387, initialHashVal);
    return Object.keys(obj).sort().reduce(function (hashVal, key) {
        hashVal = stringHash(key, hashVal);
        return hash_hash(obj[key], hashVal);
    }, initialHashVal);
}

// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/base/common/diff/diff.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


var StringDiffSequence = /** @class */ (function () {
    function StringDiffSequence(source) {
        this.source = source;
    }
    StringDiffSequence.prototype.getElements = function () {
        var source = this.source;
        var characters = new Int32Array(source.length);
        for (var i = 0, len = source.length; i < len; i++) {
            characters[i] = source.charCodeAt(i);
        }
        return characters;
    };
    return StringDiffSequence;
}());

function stringDiff(original, modified, pretty) {
    return new diff_LcsDiff(new StringDiffSequence(original), new StringDiffSequence(modified)).ComputeDiff(pretty).changes;
}
//
// The code below has been ported from a C# implementation in VS
//
var Debug = /** @class */ (function () {
    function Debug() {
    }
    Debug.Assert = function (condition, message) {
        if (!condition) {
            throw new Error(message);
        }
    };
    return Debug;
}());

var MyArray = /** @class */ (function () {
    function MyArray() {
    }
    /**
     * Copies a range of elements from an Array starting at the specified source index and pastes
     * them to another Array starting at the specified destination index. The length and the indexes
     * are specified as 64-bit integers.
     * sourceArray:
     *		The Array that contains the data to copy.
     * sourceIndex:
     *		A 64-bit integer that represents the index in the sourceArray at which copying begins.
     * destinationArray:
     *		The Array that receives the data.
     * destinationIndex:
     *		A 64-bit integer that represents the index in the destinationArray at which storing begins.
     * length:
     *		A 64-bit integer that represents the number of elements to copy.
     */
    MyArray.Copy = function (sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
        for (var i = 0; i < length; i++) {
            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
        }
    };
    MyArray.Copy2 = function (sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
        for (var i = 0; i < length; i++) {
            destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
        }
    };
    return MyArray;
}());

/**
 * A utility class which helps to create the set of DiffChanges from
 * a difference operation. This class accepts original DiffElements and
 * modified DiffElements that are involved in a particular change. The
 * MarktNextChange() method can be called to mark the separation between
 * distinct changes. At the end, the Changes property can be called to retrieve
 * the constructed changes.
 */
var diff_DiffChangeHelper = /** @class */ (function () {
    /**
     * Constructs a new DiffChangeHelper for the given DiffSequences.
     */
    function DiffChangeHelper() {
        this.m_changes = [];
        this.m_originalStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;
        this.m_modifiedStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;
        this.m_originalCount = 0;
        this.m_modifiedCount = 0;
    }
    /**
     * Marks the beginning of the next change in the set of differences.
     */
    DiffChangeHelper.prototype.MarkNextChange = function () {
        // Only add to the list if there is something to add
        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
            // Add the new change to our list
            this.m_changes.push(new DiffChange(this.m_originalStart, this.m_originalCount, this.m_modifiedStart, this.m_modifiedCount));
        }
        // Reset for the next change
        this.m_originalCount = 0;
        this.m_modifiedCount = 0;
        this.m_originalStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;
        this.m_modifiedStart = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;
    };
    /**
     * Adds the original element at the given position to the elements
     * affected by the current change. The modified index gives context
     * to the change position with respect to the original sequence.
     * @param originalIndex The index of the original element to add.
     * @param modifiedIndex The index of the modified element that provides corresponding position in the modified sequence.
     */
    DiffChangeHelper.prototype.AddOriginalElement = function (originalIndex, modifiedIndex) {
        // The 'true' start index is the smallest of the ones we've seen
        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
        this.m_originalCount++;
    };
    /**
     * Adds the modified element at the given position to the elements
     * affected by the current change. The original index gives context
     * to the change position with respect to the modified sequence.
     * @param originalIndex The index of the original element that provides corresponding position in the original sequence.
     * @param modifiedIndex The index of the modified element to add.
     */
    DiffChangeHelper.prototype.AddModifiedElement = function (originalIndex, modifiedIndex) {
        // The 'true' start index is the smallest of the ones we've seen
        this.m_originalStart = Math.min(this.m_originalStart, originalIndex);
        this.m_modifiedStart = Math.min(this.m_modifiedStart, modifiedIndex);
        this.m_modifiedCount++;
    };
    /**
     * Retrieves all of the changes marked by the class.
     */
    DiffChangeHelper.prototype.getChanges = function () {
        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
            // Finish up on whatever is left
            this.MarkNextChange();
        }
        return this.m_changes;
    };
    /**
     * Retrieves all of the changes marked by the class in the reverse order
     */
    DiffChangeHelper.prototype.getReverseChanges = function () {
        if (this.m_originalCount > 0 || this.m_modifiedCount > 0) {
            // Finish up on whatever is left
            this.MarkNextChange();
        }
        this.m_changes.reverse();
        return this.m_changes;
    };
    return DiffChangeHelper;
}());
/**
 * An implementation of the difference algorithm described in
 * "An O(ND) Difference Algorithm and its variations" by Eugene W. Myers
 */
var diff_LcsDiff = /** @class */ (function () {
    /**
     * Constructs the DiffFinder
     */
    function LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate) {
        if (continueProcessingPredicate === void 0) { continueProcessingPredicate = null; }
        this.ContinueProcessingPredicate = continueProcessingPredicate;
        var _a = LcsDiff._getElements(originalSequence), originalStringElements = _a[0], originalElementsOrHash = _a[1], originalHasStrings = _a[2];
        var _b = LcsDiff._getElements(modifiedSequence), modifiedStringElements = _b[0], modifiedElementsOrHash = _b[1], modifiedHasStrings = _b[2];
        this._hasStrings = (originalHasStrings && modifiedHasStrings);
        this._originalStringElements = originalStringElements;
        this._originalElementsOrHash = originalElementsOrHash;
        this._modifiedStringElements = modifiedStringElements;
        this._modifiedElementsOrHash = modifiedElementsOrHash;
        this.m_forwardHistory = [];
        this.m_reverseHistory = [];
    }
    LcsDiff._isStringArray = function (arr) {
        return (arr.length > 0 && typeof arr[0] === 'string');
    };
    LcsDiff._getElements = function (sequence) {
        var elements = sequence.getElements();
        if (LcsDiff._isStringArray(elements)) {
            var hashes = new Int32Array(elements.length);
            for (var i = 0, len = elements.length; i < len; i++) {
                hashes[i] = stringHash(elements[i], 0);
            }
            return [elements, hashes, true];
        }
        if (elements instanceof Int32Array) {
            return [[], elements, false];
        }
        return [[], new Int32Array(elements), false];
    };
    LcsDiff.prototype.ElementsAreEqual = function (originalIndex, newIndex) {
        if (this._originalElementsOrHash[originalIndex] !== this._modifiedElementsOrHash[newIndex]) {
            return false;
        }
        return (this._hasStrings ? this._originalStringElements[originalIndex] === this._modifiedStringElements[newIndex] : true);
    };
    LcsDiff.prototype.OriginalElementsAreEqual = function (index1, index2) {
        if (this._originalElementsOrHash[index1] !== this._originalElementsOrHash[index2]) {
            return false;
        }
        return (this._hasStrings ? this._originalStringElements[index1] === this._originalStringElements[index2] : true);
    };
    LcsDiff.prototype.ModifiedElementsAreEqual = function (index1, index2) {
        if (this._modifiedElementsOrHash[index1] !== this._modifiedElementsOrHash[index2]) {
            return false;
        }
        return (this._hasStrings ? this._modifiedStringElements[index1] === this._modifiedStringElements[index2] : true);
    };
    LcsDiff.prototype.ComputeDiff = function (pretty) {
        return this._ComputeDiff(0, this._originalElementsOrHash.length - 1, 0, this._modifiedElementsOrHash.length - 1, pretty);
    };
    /**
     * Computes the differences between the original and modified input
     * sequences on the bounded range.
     * @returns An array of the differences between the two input sequences.
     */
    LcsDiff.prototype._ComputeDiff = function (originalStart, originalEnd, modifiedStart, modifiedEnd, pretty) {
        var quitEarlyArr = [false];
        var changes = this.ComputeDiffRecursive(originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr);
        if (pretty) {
            // We have to clean up the computed diff to be more intuitive
            // but it turns out this cannot be done correctly until the entire set
            // of diffs have been computed
            changes = this.PrettifyChanges(changes);
        }
        return {
            quitEarly: quitEarlyArr[0],
            changes: changes
        };
    };
    /**
     * Private helper method which computes the differences on the bounded range
     * recursively.
     * @returns An array of the differences between the two input sequences.
     */
    LcsDiff.prototype.ComputeDiffRecursive = function (originalStart, originalEnd, modifiedStart, modifiedEnd, quitEarlyArr) {
        quitEarlyArr[0] = false;
        // Find the start of the differences
        while (originalStart <= originalEnd && modifiedStart <= modifiedEnd && this.ElementsAreEqual(originalStart, modifiedStart)) {
            originalStart++;
            modifiedStart++;
        }
        // Find the end of the differences
        while (originalEnd >= originalStart && modifiedEnd >= modifiedStart && this.ElementsAreEqual(originalEnd, modifiedEnd)) {
            originalEnd--;
            modifiedEnd--;
        }
        // In the special case where we either have all insertions or all deletions or the sequences are identical
        if (originalStart > originalEnd || modifiedStart > modifiedEnd) {
            var changes = void 0;
            if (modifiedStart <= modifiedEnd) {
                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');
                // All insertions
                changes = [
                    new DiffChange(originalStart, 0, modifiedStart, modifiedEnd - modifiedStart + 1)
                ];
            }
            else if (originalStart <= originalEnd) {
                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');
                // All deletions
                changes = [
                    new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, 0)
                ];
            }
            else {
                Debug.Assert(originalStart === originalEnd + 1, 'originalStart should only be one more than originalEnd');
                Debug.Assert(modifiedStart === modifiedEnd + 1, 'modifiedStart should only be one more than modifiedEnd');
                // Identical sequences - No differences
                changes = [];
            }
            return changes;
        }
        // This problem can be solved using the Divide-And-Conquer technique.
        var midOriginalArr = [0];
        var midModifiedArr = [0];
        var result = this.ComputeRecursionPoint(originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr);
        var midOriginal = midOriginalArr[0];
        var midModified = midModifiedArr[0];
        if (result !== null) {
            // Result is not-null when there was enough memory to compute the changes while
            // searching for the recursion point
            return result;
        }
        else if (!quitEarlyArr[0]) {
            // We can break the problem down recursively by finding the changes in the
            // First Half:   (originalStart, modifiedStart) to (midOriginal, midModified)
            // Second Half:  (midOriginal + 1, minModified + 1) to (originalEnd, modifiedEnd)
            // NOTE: ComputeDiff() is inclusive, therefore the second range starts on the next point
            var leftChanges = this.ComputeDiffRecursive(originalStart, midOriginal, modifiedStart, midModified, quitEarlyArr);
            var rightChanges = [];
            if (!quitEarlyArr[0]) {
                rightChanges = this.ComputeDiffRecursive(midOriginal + 1, originalEnd, midModified + 1, modifiedEnd, quitEarlyArr);
            }
            else {
                // We did't have time to finish the first half, so we don't have time to compute this half.
                // Consider the entire rest of the sequence different.
                rightChanges = [
                    new DiffChange(midOriginal + 1, originalEnd - (midOriginal + 1) + 1, midModified + 1, modifiedEnd - (midModified + 1) + 1)
                ];
            }
            return this.ConcatenateChanges(leftChanges, rightChanges);
        }
        // If we hit here, we quit early, and so can't return anything meaningful
        return [
            new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
        ];
    };
    LcsDiff.prototype.WALKTRACE = function (diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr) {
        var forwardChanges = null;
        var reverseChanges = null;
        // First, walk backward through the forward diagonals history
        var changeHelper = new diff_DiffChangeHelper();
        var diagonalMin = diagonalForwardStart;
        var diagonalMax = diagonalForwardEnd;
        var diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalForwardOffset;
        var lastOriginalIndex = -1073741824 /* MIN_SAFE_SMALL_INTEGER */;
        var historyIndex = this.m_forwardHistory.length - 1;
        do {
            // Get the diagonal index from the relative diagonal number
            var diagonal = diagonalRelative + diagonalForwardBase;
            // Figure out where we came from
            if (diagonal === diagonalMin || (diagonal < diagonalMax && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {
                // Vertical line (the element is an insert)
                originalIndex = forwardPoints[diagonal + 1];
                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
                if (originalIndex < lastOriginalIndex) {
                    changeHelper.MarkNextChange();
                }
                lastOriginalIndex = originalIndex;
                changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex);
                diagonalRelative = (diagonal + 1) - diagonalForwardBase; //Setup for the next iteration
            }
            else {
                // Horizontal line (the element is a deletion)
                originalIndex = forwardPoints[diagonal - 1] + 1;
                modifiedIndex = originalIndex - diagonalRelative - diagonalForwardOffset;
                if (originalIndex < lastOriginalIndex) {
                    changeHelper.MarkNextChange();
                }
                lastOriginalIndex = originalIndex - 1;
                changeHelper.AddOriginalElement(originalIndex, modifiedIndex + 1);
                diagonalRelative = (diagonal - 1) - diagonalForwardBase; //Setup for the next iteration
            }
            if (historyIndex >= 0) {
                forwardPoints = this.m_forwardHistory[historyIndex];
                diagonalForwardBase = forwardPoints[0]; //We stored this in the first spot
                diagonalMin = 1;
                diagonalMax = forwardPoints.length - 1;
            }
        } while (--historyIndex >= -1);
        // Ironically, we get the forward changes as the reverse of the
        // order we added them since we technically added them backwards
        forwardChanges = changeHelper.getReverseChanges();
        if (quitEarlyArr[0]) {
            // TODO: Calculate a partial from the reverse diagonals.
            //       For now, just assume everything after the midOriginal/midModified point is a diff
            var originalStartPoint = midOriginalArr[0] + 1;
            var modifiedStartPoint = midModifiedArr[0] + 1;
            if (forwardChanges !== null && forwardChanges.length > 0) {
                var lastForwardChange = forwardChanges[forwardChanges.length - 1];
                originalStartPoint = Math.max(originalStartPoint, lastForwardChange.getOriginalEnd());
                modifiedStartPoint = Math.max(modifiedStartPoint, lastForwardChange.getModifiedEnd());
            }
            reverseChanges = [
                new DiffChange(originalStartPoint, originalEnd - originalStartPoint + 1, modifiedStartPoint, modifiedEnd - modifiedStartPoint + 1)
            ];
        }
        else {
            // Now walk backward through the reverse diagonals history
            changeHelper = new diff_DiffChangeHelper();
            diagonalMin = diagonalReverseStart;
            diagonalMax = diagonalReverseEnd;
            diagonalRelative = (midOriginalArr[0] - midModifiedArr[0]) - diagonalReverseOffset;
            lastOriginalIndex = 1073741824 /* MAX_SAFE_SMALL_INTEGER */;
            historyIndex = (deltaIsEven) ? this.m_reverseHistory.length - 1 : this.m_reverseHistory.length - 2;
            do {
                // Get the diagonal index from the relative diagonal number
                var diagonal = diagonalRelative + diagonalReverseBase;
                // Figure out where we came from
                if (diagonal === diagonalMin || (diagonal < diagonalMax && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {
                    // Horizontal line (the element is a deletion))
                    originalIndex = reversePoints[diagonal + 1] - 1;
                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
                    if (originalIndex > lastOriginalIndex) {
                        changeHelper.MarkNextChange();
                    }
                    lastOriginalIndex = originalIndex + 1;
                    changeHelper.AddOriginalElement(originalIndex + 1, modifiedIndex + 1);
                    diagonalRelative = (diagonal + 1) - diagonalReverseBase; //Setup for the next iteration
                }
                else {
                    // Vertical line (the element is an insertion)
                    originalIndex = reversePoints[diagonal - 1];
                    modifiedIndex = originalIndex - diagonalRelative - diagonalReverseOffset;
                    if (originalIndex > lastOriginalIndex) {
                        changeHelper.MarkNextChange();
                    }
                    lastOriginalIndex = originalIndex;
                    changeHelper.AddModifiedElement(originalIndex + 1, modifiedIndex + 1);
                    diagonalRelative = (diagonal - 1) - diagonalReverseBase; //Setup for the next iteration
                }
                if (historyIndex >= 0) {
                    reversePoints = this.m_reverseHistory[historyIndex];
                    diagonalReverseBase = reversePoints[0]; //We stored this in the first spot
                    diagonalMin = 1;
                    diagonalMax = reversePoints.length - 1;
                }
            } while (--historyIndex >= -1);
            // There are cases where the reverse history will find diffs that
            // are correct, but not intuitive, so we need shift them.
            reverseChanges = changeHelper.getChanges();
        }
        return this.ConcatenateChanges(forwardChanges, reverseChanges);
    };
    /**
     * Given the range to compute the diff on, this method finds the point:
     * (midOriginal, midModified)
     * that exists in the middle of the LCS of the two sequences and
     * is the point at which the LCS problem may be broken down recursively.
     * This method will try to keep the LCS trace in memory. If the LCS recursion
     * point is calculated and the full trace is available in memory, then this method
     * will return the change list.
     * @param originalStart The start bound of the original sequence range
     * @param originalEnd The end bound of the original sequence range
     * @param modifiedStart The start bound of the modified sequence range
     * @param modifiedEnd The end bound of the modified sequence range
     * @param midOriginal The middle point of the original sequence range
     * @param midModified The middle point of the modified sequence range
     * @returns The diff changes, if available, otherwise null
     */
    LcsDiff.prototype.ComputeRecursionPoint = function (originalStart, originalEnd, modifiedStart, modifiedEnd, midOriginalArr, midModifiedArr, quitEarlyArr) {
        var originalIndex = 0, modifiedIndex = 0;
        var diagonalForwardStart = 0, diagonalForwardEnd = 0;
        var diagonalReverseStart = 0, diagonalReverseEnd = 0;
        // To traverse the edit graph and produce the proper LCS, our actual
        // start position is just outside the given boundary
        originalStart--;
        modifiedStart--;
        // We set these up to make the compiler happy, but they will
        // be replaced before we return with the actual recursion point
        midOriginalArr[0] = 0;
        midModifiedArr[0] = 0;
        // Clear out the history
        this.m_forwardHistory = [];
        this.m_reverseHistory = [];
        // Each cell in the two arrays corresponds to a diagonal in the edit graph.
        // The integer value in the cell represents the originalIndex of the furthest
        // reaching point found so far that ends in that diagonal.
        // The modifiedIndex can be computed mathematically from the originalIndex and the diagonal number.
        var maxDifferences = (originalEnd - originalStart) + (modifiedEnd - modifiedStart);
        var numDiagonals = maxDifferences + 1;
        var forwardPoints = new Int32Array(numDiagonals);
        var reversePoints = new Int32Array(numDiagonals);
        // diagonalForwardBase: Index into forwardPoints of the diagonal which passes through (originalStart, modifiedStart)
        // diagonalReverseBase: Index into reversePoints of the diagonal which passes through (originalEnd, modifiedEnd)
        var diagonalForwardBase = (modifiedEnd - modifiedStart);
        var diagonalReverseBase = (originalEnd - originalStart);
        // diagonalForwardOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the
        //    diagonal number (relative to diagonalForwardBase)
        // diagonalReverseOffset: Geometric offset which allows modifiedIndex to be computed from originalIndex and the
        //    diagonal number (relative to diagonalReverseBase)
        var diagonalForwardOffset = (originalStart - modifiedStart);
        var diagonalReverseOffset = (originalEnd - modifiedEnd);
        // delta: The difference between the end diagonal and the start diagonal. This is used to relate diagonal numbers
        //   relative to the start diagonal with diagonal numbers relative to the end diagonal.
        // The Even/Oddn-ness of this delta is important for determining when we should check for overlap
        var delta = diagonalReverseBase - diagonalForwardBase;
        var deltaIsEven = (delta % 2 === 0);
        // Here we set up the start and end points as the furthest points found so far
        // in both the forward and reverse directions, respectively
        forwardPoints[diagonalForwardBase] = originalStart;
        reversePoints[diagonalReverseBase] = originalEnd;
        // Remember if we quit early, and thus need to do a best-effort result instead of a real result.
        quitEarlyArr[0] = false;
        // A couple of points:
        // --With this method, we iterate on the number of differences between the two sequences.
        //   The more differences there actually are, the longer this will take.
        // --Also, as the number of differences increases, we have to search on diagonals further
        //   away from the reference diagonal (which is diagonalForwardBase for forward, diagonalReverseBase for reverse).
        // --We extend on even diagonals (relative to the reference diagonal) only when numDifferences
        //   is even and odd diagonals only when numDifferences is odd.
        for (var numDifferences = 1; numDifferences <= (maxDifferences / 2) + 1; numDifferences++) {
            var furthestOriginalIndex = 0;
            var furthestModifiedIndex = 0;
            // Run the algorithm in the forward direction
            diagonalForwardStart = this.ClipDiagonalBound(diagonalForwardBase - numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
            diagonalForwardEnd = this.ClipDiagonalBound(diagonalForwardBase + numDifferences, numDifferences, diagonalForwardBase, numDiagonals);
            for (var diagonal = diagonalForwardStart; diagonal <= diagonalForwardEnd; diagonal += 2) {
                // STEP 1: We extend the furthest reaching point in the present diagonal
                // by looking at the diagonals above and below and picking the one whose point
                // is further away from the start point (originalStart, modifiedStart)
                if (diagonal === diagonalForwardStart || (diagonal < diagonalForwardEnd && forwardPoints[diagonal - 1] < forwardPoints[diagonal + 1])) {
                    originalIndex = forwardPoints[diagonal + 1];
                }
                else {
                    originalIndex = forwardPoints[diagonal - 1] + 1;
                }
                modifiedIndex = originalIndex - (diagonal - diagonalForwardBase) - diagonalForwardOffset;
                // Save the current originalIndex so we can test for false overlap in step 3
                var tempOriginalIndex = originalIndex;
                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal
                // so long as the elements are equal.
                while (originalIndex < originalEnd && modifiedIndex < modifiedEnd && this.ElementsAreEqual(originalIndex + 1, modifiedIndex + 1)) {
                    originalIndex++;
                    modifiedIndex++;
                }
                forwardPoints[diagonal] = originalIndex;
                if (originalIndex + modifiedIndex > furthestOriginalIndex + furthestModifiedIndex) {
                    furthestOriginalIndex = originalIndex;
                    furthestModifiedIndex = modifiedIndex;
                }
                // STEP 3: If delta is odd (overlap first happens on forward when delta is odd)
                // and diagonal is in the range of reverse diagonals computed for numDifferences-1
                // (the previous iteration; we haven't computed reverse diagonals for numDifferences yet)
                // then check for overlap.
                if (!deltaIsEven && Math.abs(diagonal - diagonalReverseBase) <= (numDifferences - 1)) {
                    if (originalIndex >= reversePoints[diagonal]) {
                        midOriginalArr[0] = originalIndex;
                        midModifiedArr[0] = modifiedIndex;
                        if (tempOriginalIndex <= reversePoints[diagonal] && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {
                            // BINGO! We overlapped, and we have the full trace in memory!
                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                        }
                        else {
                            // Either false overlap, or we didn't have enough memory for the full trace
                            // Just return the recursion point
                            return null;
                        }
                    }
                }
            }
            // Check to see if we should be quitting early, before moving on to the next iteration.
            var matchLengthOfLongest = ((furthestOriginalIndex - originalStart) + (furthestModifiedIndex - modifiedStart) - numDifferences) / 2;
            if (this.ContinueProcessingPredicate !== null && !this.ContinueProcessingPredicate(furthestOriginalIndex, matchLengthOfLongest)) {
                // We can't finish, so skip ahead to generating a result from what we have.
                quitEarlyArr[0] = true;
                // Use the furthest distance we got in the forward direction.
                midOriginalArr[0] = furthestOriginalIndex;
                midModifiedArr[0] = furthestModifiedIndex;
                if (matchLengthOfLongest > 0 && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {
                    // Enough of the history is in memory to walk it backwards
                    return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                }
                else {
                    // We didn't actually remember enough of the history.
                    //Since we are quiting the diff early, we need to shift back the originalStart and modified start
                    //back into the boundary limits since we decremented their value above beyond the boundary limit.
                    originalStart++;
                    modifiedStart++;
                    return [
                        new DiffChange(originalStart, originalEnd - originalStart + 1, modifiedStart, modifiedEnd - modifiedStart + 1)
                    ];
                }
            }
            // Run the algorithm in the reverse direction
            diagonalReverseStart = this.ClipDiagonalBound(diagonalReverseBase - numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
            diagonalReverseEnd = this.ClipDiagonalBound(diagonalReverseBase + numDifferences, numDifferences, diagonalReverseBase, numDiagonals);
            for (var diagonal = diagonalReverseStart; diagonal <= diagonalReverseEnd; diagonal += 2) {
                // STEP 1: We extend the furthest reaching point in the present diagonal
                // by looking at the diagonals above and below and picking the one whose point
                // is further away from the start point (originalEnd, modifiedEnd)
                if (diagonal === diagonalReverseStart || (diagonal < diagonalReverseEnd && reversePoints[diagonal - 1] >= reversePoints[diagonal + 1])) {
                    originalIndex = reversePoints[diagonal + 1] - 1;
                }
                else {
                    originalIndex = reversePoints[diagonal - 1];
                }
                modifiedIndex = originalIndex - (diagonal - diagonalReverseBase) - diagonalReverseOffset;
                // Save the current originalIndex so we can test for false overlap
                var tempOriginalIndex = originalIndex;
                // STEP 2: We can continue to extend the furthest reaching point in the present diagonal
                // as long as the elements are equal.
                while (originalIndex > originalStart && modifiedIndex > modifiedStart && this.ElementsAreEqual(originalIndex, modifiedIndex)) {
                    originalIndex--;
                    modifiedIndex--;
                }
                reversePoints[diagonal] = originalIndex;
                // STEP 4: If delta is even (overlap first happens on reverse when delta is even)
                // and diagonal is in the range of forward diagonals computed for numDifferences
                // then check for overlap.
                if (deltaIsEven && Math.abs(diagonal - diagonalForwardBase) <= numDifferences) {
                    if (originalIndex <= forwardPoints[diagonal]) {
                        midOriginalArr[0] = originalIndex;
                        midModifiedArr[0] = modifiedIndex;
                        if (tempOriginalIndex >= forwardPoints[diagonal] && 1447 /* MaxDifferencesHistory */ > 0 && numDifferences <= (1447 /* MaxDifferencesHistory */ + 1)) {
                            // BINGO! We overlapped, and we have the full trace in memory!
                            return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
                        }
                        else {
                            // Either false overlap, or we didn't have enough memory for the full trace
                            // Just return the recursion point
                            return null;
                        }
                    }
                }
            }
            // Save current vectors to history before the next iteration
            if (numDifferences <= 1447 /* MaxDifferencesHistory */) {
                // We are allocating space for one extra int, which we fill with
                // the index of the diagonal base index
                var temp = new Int32Array(diagonalForwardEnd - diagonalForwardStart + 2);
                temp[0] = diagonalForwardBase - diagonalForwardStart + 1;
                MyArray.Copy2(forwardPoints, diagonalForwardStart, temp, 1, diagonalForwardEnd - diagonalForwardStart + 1);
                this.m_forwardHistory.push(temp);
                temp = new Int32Array(diagonalReverseEnd - diagonalReverseStart + 2);
                temp[0] = diagonalReverseBase - diagonalReverseStart + 1;
                MyArray.Copy2(reversePoints, diagonalReverseStart, temp, 1, diagonalReverseEnd - diagonalReverseStart + 1);
                this.m_reverseHistory.push(temp);
            }
        }
        // If we got here, then we have the full trace in history. We just have to convert it to a change list
        // NOTE: This part is a bit messy
        return this.WALKTRACE(diagonalForwardBase, diagonalForwardStart, diagonalForwardEnd, diagonalForwardOffset, diagonalReverseBase, diagonalReverseStart, diagonalReverseEnd, diagonalReverseOffset, forwardPoints, reversePoints, originalIndex, originalEnd, midOriginalArr, modifiedIndex, modifiedEnd, midModifiedArr, deltaIsEven, quitEarlyArr);
    };
    /**
     * Shifts the given changes to provide a more intuitive diff.
     * While the first element in a diff matches the first element after the diff,
     * we shift the diff down.
     *
     * @param changes The list of changes to shift
     * @returns The shifted changes
     */
    LcsDiff.prototype.PrettifyChanges = function (changes) {
        // Shift all the changes down first
        for (var i = 0; i < changes.length; i++) {
            var change = changes[i];
            var originalStop = (i < changes.length - 1) ? changes[i + 1].originalStart : this._originalElementsOrHash.length;
            var modifiedStop = (i < changes.length - 1) ? changes[i + 1].modifiedStart : this._modifiedElementsOrHash.length;
            var checkOriginal = change.originalLength > 0;
            var checkModified = change.modifiedLength > 0;
            while (change.originalStart + change.originalLength < originalStop &&
                change.modifiedStart + change.modifiedLength < modifiedStop &&
                (!checkOriginal || this.OriginalElementsAreEqual(change.originalStart, change.originalStart + change.originalLength)) &&
                (!checkModified || this.ModifiedElementsAreEqual(change.modifiedStart, change.modifiedStart + change.modifiedLength))) {
                change.originalStart++;
                change.modifiedStart++;
            }
            var mergedChangeArr = [null];
            if (i < changes.length - 1 && this.ChangesOverlap(changes[i], changes[i + 1], mergedChangeArr)) {
                changes[i] = mergedChangeArr[0];
                changes.splice(i + 1, 1);
                i--;
                continue;
            }
        }
        // Shift changes back up until we hit empty or whitespace-only lines
        for (var i = changes.length - 1; i >= 0; i--) {
            var change = changes[i];
            var originalStop = 0;
            var modifiedStop = 0;
            if (i > 0) {
                var prevChange = changes[i - 1];
                if (prevChange.originalLength > 0) {
                    originalStop = prevChange.originalStart + prevChange.originalLength;
                }
                if (prevChange.modifiedLength > 0) {
                    modifiedStop = prevChange.modifiedStart + prevChange.modifiedLength;
                }
            }
            var checkOriginal = change.originalLength > 0;
            var checkModified = change.modifiedLength > 0;
            var bestDelta = 0;
            var bestScore = this._boundaryScore(change.originalStart, change.originalLength, change.modifiedStart, change.modifiedLength);
            for (var delta = 1;; delta++) {
                var originalStart = change.originalStart - delta;
                var modifiedStart = change.modifiedStart - delta;
                if (originalStart < originalStop || modifiedStart < modifiedStop) {
                    break;
                }
                if (checkOriginal && !this.OriginalElementsAreEqual(originalStart, originalStart + change.originalLength)) {
                    break;
                }
                if (checkModified && !this.ModifiedElementsAreEqual(modifiedStart, modifiedStart + change.modifiedLength)) {
                    break;
                }
                var score = this._boundaryScore(originalStart, change.originalLength, modifiedStart, change.modifiedLength);
                if (score > bestScore) {
                    bestScore = score;
                    bestDelta = delta;
                }
            }
            change.originalStart -= bestDelta;
            change.modifiedStart -= bestDelta;
        }
        return changes;
    };
    LcsDiff.prototype._OriginalIsBoundary = function (index) {
        if (index <= 0 || index >= this._originalElementsOrHash.length - 1) {
            return true;
        }
        return (this._hasStrings && /^\s*$/.test(this._originalStringElements[index]));
    };
    LcsDiff.prototype._OriginalRegionIsBoundary = function (originalStart, originalLength) {
        if (this._OriginalIsBoundary(originalStart) || this._OriginalIsBoundary(originalStart - 1)) {
            return true;
        }
        if (originalLength > 0) {
            var originalEnd = originalStart + originalLength;
            if (this._OriginalIsBoundary(originalEnd - 1) || this._OriginalIsBoundary(originalEnd)) {
                return true;
            }
        }
        return false;
    };
    LcsDiff.prototype._ModifiedIsBoundary = function (index) {
        if (index <= 0 || index >= this._modifiedElementsOrHash.length - 1) {
            return true;
        }
        return (this._hasStrings && /^\s*$/.test(this._modifiedStringElements[index]));
    };
    LcsDiff.prototype._ModifiedRegionIsBoundary = function (modifiedStart, modifiedLength) {
        if (this._ModifiedIsBoundary(modifiedStart) || this._ModifiedIsBoundary(modifiedStart - 1)) {
            return true;
        }
        if (modifiedLength > 0) {
            var modifiedEnd = modifiedStart + modifiedLength;
            if (this._ModifiedIsBoundary(modifiedEnd - 1) || this._ModifiedIsBoundary(modifiedEnd)) {
                return true;
            }
        }
        return false;
    };
    LcsDiff.prototype._boundaryScore = function (originalStart, originalLength, modifiedStart, modifiedLength) {
        var originalScore = (this._OriginalRegionIsBoundary(originalStart, originalLength) ? 1 : 0);
        var modifiedScore = (this._ModifiedRegionIsBoundary(modifiedStart, modifiedLength) ? 1 : 0);
        return (originalScore + modifiedScore);
    };
    /**
     * Concatenates the two input DiffChange lists and returns the resulting
     * list.
     * @param The left changes
     * @param The right changes
     * @returns The concatenated list
     */
    LcsDiff.prototype.ConcatenateChanges = function (left, right) {
        var mergedChangeArr = [];
        if (left.length === 0 || right.length === 0) {
            return (right.length > 0) ? right : left;
        }
        else if (this.ChangesOverlap(left[left.length - 1], right[0], mergedChangeArr)) {
            // Since we break the problem down recursively, it is possible that we
            // might recurse in the middle of a change thereby splitting it into
            // two changes. Here in the combining stage, we detect and fuse those
            // changes back together
            var result = new Array(left.length + right.length - 1);
            MyArray.Copy(left, 0, result, 0, left.length - 1);
            result[left.length - 1] = mergedChangeArr[0];
            MyArray.Copy(right, 1, result, left.length, right.length - 1);
            return result;
        }
        else {
            var result = new Array(left.length + right.length);
            MyArray.Copy(left, 0, result, 0, left.length);
            MyArray.Copy(right, 0, result, left.length, right.length);
            return result;
        }
    };
    /**
     * Returns true if the two changes overlap and can be merged into a single
     * change
     * @param left The left change
     * @param right The right change
     * @param mergedChange The merged change if the two overlap, null otherwise
     * @returns True if the two changes overlap
     */
    LcsDiff.prototype.ChangesOverlap = function (left, right, mergedChangeArr) {
        Debug.Assert(left.originalStart <= right.originalStart, 'Left change is not less than or equal to right change');
        Debug.Assert(left.modifiedStart <= right.modifiedStart, 'Left change is not less than or equal to right change');
        if (left.originalStart + left.originalLength >= right.originalStart || left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
            var originalStart = left.originalStart;
            var originalLength = left.originalLength;
            var modifiedStart = left.modifiedStart;
            var modifiedLength = left.modifiedLength;
            if (left.originalStart + left.originalLength >= right.originalStart) {
                originalLength = right.originalStart + right.originalLength - left.originalStart;
            }
            if (left.modifiedStart + left.modifiedLength >= right.modifiedStart) {
                modifiedLength = right.modifiedStart + right.modifiedLength - left.modifiedStart;
            }
            mergedChangeArr[0] = new DiffChange(originalStart, originalLength, modifiedStart, modifiedLength);
            return true;
        }
        else {
            mergedChangeArr[0] = null;
            return false;
        }
    };
    /**
     * Helper method used to clip a diagonal index to the range of valid
     * diagonals. This also decides whether or not the diagonal index,
     * if it exceeds the boundary, should be clipped to the boundary or clipped
     * one inside the boundary depending on the Even/Odd status of the boundary
     * and numDifferences.
     * @param diagonal The index of the diagonal to clip.
     * @param numDifferences The current number of differences being iterated upon.
     * @param diagonalBaseIndex The base reference diagonal.
     * @param numDiagonals The total number of diagonals.
     * @returns The clipped diagonal index.
     */
    LcsDiff.prototype.ClipDiagonalBound = function (diagonal, numDifferences, diagonalBaseIndex, numDiagonals) {
        if (diagonal >= 0 && diagonal < numDiagonals) {
            // Nothing to clip, its in range
            return diagonal;
        }
        // diagonalsBelow: The number of diagonals below the reference diagonal
        // diagonalsAbove: The number of diagonals above the reference diagonal
        var diagonalsBelow = diagonalBaseIndex;
        var diagonalsAbove = numDiagonals - diagonalBaseIndex - 1;
        var diffEven = (numDifferences % 2 === 0);
        if (diagonal < 0) {
            var lowerBoundEven = (diagonalsBelow % 2 === 0);
            return (diffEven === lowerBoundEven) ? 0 : 1;
        }
        else {
            var upperBoundEven = (diagonalsAbove % 2 === 0);
            return (diffEven === upperBoundEven) ? numDiagonals - 1 : numDiagonals - 2;
        }
    };
    return LcsDiff;
}());


// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/base/common/iterator.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var iterator_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var FIN = { done: true, value: undefined };
var Iterator;
(function (Iterator) {
    var _empty = {
        next: function () {
            return FIN;
        }
    };
    function empty() {
        return _empty;
    }
    Iterator.empty = empty;
    function single(value) {
        var done = false;
        return {
            next: function () {
                if (done) {
                    return FIN;
                }
                done = true;
                return { done: false, value: value };
            }
        };
    }
    Iterator.single = single;
    function fromArray(array, index, length) {
        if (index === void 0) { index = 0; }
        if (length === void 0) { length = array.length; }
        return {
            next: function () {
                if (index >= length) {
                    return FIN;
                }
                return { done: false, value: array[index++] };
            }
        };
    }
    Iterator.fromArray = fromArray;
    function fromNativeIterator(it) {
        return {
            next: function () {
                var result = it.next();
                if (result.done) {
                    return FIN;
                }
                return { done: false, value: result.value };
            }
        };
    }
    Iterator.fromNativeIterator = fromNativeIterator;
    function from(elements) {
        if (!elements) {
            return Iterator.empty();
        }
        else if (Array.isArray(elements)) {
            return Iterator.fromArray(elements);
        }
        else {
            return elements;
        }
    }
    Iterator.from = from;
    function map(iterator, fn) {
        return {
            next: function () {
                var element = iterator.next();
                if (element.done) {
                    return FIN;
                }
                else {
                    return { done: false, value: fn(element.value) };
                }
            }
        };
    }
    Iterator.map = map;
    function filter(iterator, fn) {
        return {
            next: function () {
                while (true) {
                    var element = iterator.next();
                    if (element.done) {
                        return FIN;
                    }
                    if (fn(element.value)) {
                        return { done: false, value: element.value };
                    }
                }
            }
        };
    }
    Iterator.filter = filter;
    function forEach(iterator, fn) {
        for (var next = iterator.next(); !next.done; next = iterator.next()) {
            fn(next.value);
        }
    }
    Iterator.forEach = forEach;
    function collect(iterator, atMost) {
        if (atMost === void 0) { atMost = Number.POSITIVE_INFINITY; }
        var result = [];
        if (atMost === 0) {
            return result;
        }
        var i = 0;
        for (var next = iterator.next(); !next.done; next = iterator.next()) {
            result.push(next.value);
            if (++i >= atMost) {
                break;
            }
        }
        return result;
    }
    Iterator.collect = collect;
    function concat() {
        var iterators = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            iterators[_i] = arguments[_i];
        }
        var i = 0;
        return {
            next: function () {
                if (i >= iterators.length) {
                    return FIN;
                }
                var iterator = iterators[i];
                var result = iterator.next();
                if (result.done) {
                    i++;
                    return this.next();
                }
                return result;
            }
        };
    }
    Iterator.concat = concat;
    function chain(iterator) {
        return new ChainableIterator(iterator);
    }
    Iterator.chain = chain;
})(Iterator || (Iterator = {}));
var ChainableIterator = /** @class */ (function () {
    function ChainableIterator(it) {
        this.it = it;
    }
    ChainableIterator.prototype.next = function () { return this.it.next(); };
    return ChainableIterator;
}());

function getSequenceIterator(arg) {
    if (Array.isArray(arg)) {
        return Iterator.fromArray(arg);
    }
    else if (!arg) {
        return Iterator.empty();
    }
    else {
        return arg;
    }
}
var ArrayIterator = /** @class */ (function () {
    function ArrayIterator(items, start, end, index) {
        if (start === void 0) { start = 0; }
        if (end === void 0) { end = items.length; }
        if (index === void 0) { index = start - 1; }
        this.items = items;
        this.start = start;
        this.end = end;
        this.index = index;
    }
    ArrayIterator.prototype.first = function () {
        this.index = this.start;
        return this.current();
    };
    ArrayIterator.prototype.next = function () {
        this.index = Math.min(this.index + 1, this.end);
        return this.current();
    };
    ArrayIterator.prototype.current = function () {
        if (this.index === this.start - 1 || this.index === this.end) {
            return null;
        }
        return this.items[this.index];
    };
    return ArrayIterator;
}());

var ArrayNavigator = /** @class */ (function (_super) {
    iterator_extends(ArrayNavigator, _super);
    function ArrayNavigator(items, start, end, index) {
        if (start === void 0) { start = 0; }
        if (end === void 0) { end = items.length; }
        if (index === void 0) { index = start - 1; }
        return _super.call(this, items, start, end, index) || this;
    }
    ArrayNavigator.prototype.current = function () {
        return _super.prototype.current.call(this);
    };
    ArrayNavigator.prototype.previous = function () {
        this.index = Math.max(this.index - 1, this.start - 1);
        return this.current();
    };
    ArrayNavigator.prototype.first = function () {
        this.index = this.start;
        return this.current();
    };
    ArrayNavigator.prototype.last = function () {
        this.index = this.end - 1;
        return this.current();
    };
    ArrayNavigator.prototype.parent = function () {
        return null;
    };
    return ArrayNavigator;
}(ArrayIterator));

var MappedIterator = /** @class */ (function () {
    function MappedIterator(iterator, fn) {
        this.iterator = iterator;
        this.fn = fn;
        // noop
    }
    MappedIterator.prototype.next = function () { return this.fn(this.iterator.next()); };
    return MappedIterator;
}());


// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/base/common/uri.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var uri_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var uri_a;

var _schemePattern = /^\w[\w\d+.-]*$/;
var _singleSlashStart = /^\//;
var _doubleSlashStart = /^\/\//;
function _validateUri(ret, _strict) {
    // scheme, must be set
    if (!ret.scheme && _strict) {
        throw new Error("[UriError]: Scheme is missing: {scheme: \"\", authority: \"" + ret.authority + "\", path: \"" + ret.path + "\", query: \"" + ret.query + "\", fragment: \"" + ret.fragment + "\"}");
    }
    // scheme, https://tools.ietf.org/html/rfc3986#section-3.1
    // ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
    if (ret.scheme && !_schemePattern.test(ret.scheme)) {
        throw new Error('[UriError]: Scheme contains illegal characters.');
    }
    // path, http://tools.ietf.org/html/rfc3986#section-3.3
    // If a URI contains an authority component, then the path component
    // must either be empty or begin with a slash ("/") character.  If a URI
    // does not contain an authority component, then the path cannot begin
    // with two slash characters ("//").
    if (ret.path) {
        if (ret.authority) {
            if (!_singleSlashStart.test(ret.path)) {
                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
            }
        }
        else {
            if (_doubleSlashStart.test(ret.path)) {
                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
            }
        }
    }
}
// for a while we allowed uris *without* schemes and this is the migration
// for them, e.g. an uri without scheme and without strict-mode warns and falls
// back to the file-scheme. that should cause the least carnage and still be a
// clear warning
function _schemeFix(scheme, _strict) {
    if (!scheme && !_strict) {
        return 'file';
    }
    return scheme;
}
// implements a bit of https://tools.ietf.org/html/rfc3986#section-5
function _referenceResolution(scheme, path) {
    // the slash-character is our 'default base' as we don't
    // support constructing URIs relative to other URIs. This
    // also means that we alter and potentially break paths.
    // see https://tools.ietf.org/html/rfc3986#section-5.1.4
    switch (scheme) {
        case 'https':
        case 'http':
        case 'file':
            if (!path) {
                path = _slash;
            }
            else if (path[0] !== _slash) {
                path = _slash + path;
            }
            break;
    }
    return path;
}
var _empty = '';
var _slash = '/';
var _regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
/**
 * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.
 * This class is a simple parser which creates the basic component parts
 * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
 * and encoding.
 *
 *       foo://example.com:8042/over/there?name=ferret#nose
 *       \_/   \______________/\_________/ \_________/ \__/
 *        |           |            |            |        |
 *     scheme     authority       path        query   fragment
 *        |   _____________________|__
 *       / \ /                        \
 *       urn:example:animal:ferret:nose
 */
var uri_URI = /** @class */ (function () {
    /**
     * @internal
     */
    function URI(schemeOrData, authority, path, query, fragment, _strict) {
        if (_strict === void 0) { _strict = false; }
        if (typeof schemeOrData === 'object') {
            this.scheme = schemeOrData.scheme || _empty;
            this.authority = schemeOrData.authority || _empty;
            this.path = schemeOrData.path || _empty;
            this.query = schemeOrData.query || _empty;
            this.fragment = schemeOrData.fragment || _empty;
            // no validation because it's this URI
            // that creates uri components.
            // _validateUri(this);
        }
        else {
            this.scheme = _schemeFix(schemeOrData, _strict);
            this.authority = authority || _empty;
            this.path = _referenceResolution(this.scheme, path || _empty);
            this.query = query || _empty;
            this.fragment = fragment || _empty;
            _validateUri(this, _strict);
        }
    }
    URI.isUri = function (thing) {
        if (thing instanceof URI) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return typeof thing.authority === 'string'
            && typeof thing.fragment === 'string'
            && typeof thing.path === 'string'
            && typeof thing.query === 'string'
            && typeof thing.scheme === 'string'
            && typeof thing.fsPath === 'function'
            && typeof thing.with === 'function'
            && typeof thing.toString === 'function';
    };
    Object.defineProperty(URI.prototype, "fsPath", {
        // ---- filesystem path -----------------------
        /**
         * Returns a string representing the corresponding file system path of this URI.
         * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
         * platform specific path separator.
         *
         * * Will *not* validate the path for invalid characters and semantics.
         * * Will *not* look at the scheme of this URI.
         * * The result shall *not* be used for display purposes but for accessing a file on disk.
         *
         *
         * The *difference* to `URI#path` is the use of the platform specific separator and the handling
         * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
         *
         * ```ts
            const u = URI.parse('file://server/c$/folder/file.txt')
            u.authority === 'server'
            u.path === '/shares/c$/file.txt'
            u.fsPath === '\\server\c$\folder\file.txt'
        ```
         *
         * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
         * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
         * with URIs that represent files on disk (`file` scheme).
         */
        get: function () {
            // if (this.scheme !== 'file') {
            // 	console.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);
            // }
            return _makeFsPath(this);
        },
        enumerable: true,
        configurable: true
    });
    // ---- modify to new -------------------------
    URI.prototype.with = function (change) {
        if (!change) {
            return this;
        }
        var scheme = change.scheme, authority = change.authority, path = change.path, query = change.query, fragment = change.fragment;
        if (scheme === undefined) {
            scheme = this.scheme;
        }
        else if (scheme === null) {
            scheme = _empty;
        }
        if (authority === undefined) {
            authority = this.authority;
        }
        else if (authority === null) {
            authority = _empty;
        }
        if (path === undefined) {
            path = this.path;
        }
        else if (path === null) {
            path = _empty;
        }
        if (query === undefined) {
            query = this.query;
        }
        else if (query === null) {
            query = _empty;
        }
        if (fragment === undefined) {
            fragment = this.fragment;
        }
        else if (fragment === null) {
            fragment = _empty;
        }
        if (scheme === this.scheme
            && authority === this.authority
            && path === this.path
            && query === this.query
            && fragment === this.fragment) {
            return this;
        }
        return new _URI(scheme, authority, path, query, fragment);
    };
    // ---- parse & validate ------------------------
    /**
     * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,
     * `file:///usr/home`, or `scheme:with/path`.
     *
     * @param value A string which represents an URI (see `URI#toString`).
     */
    URI.parse = function (value, _strict) {
        if (_strict === void 0) { _strict = false; }
        var match = _regexp.exec(value);
        if (!match) {
            return new _URI(_empty, _empty, _empty, _empty, _empty);
        }
        return new _URI(match[2] || _empty, percentDecode(match[4] || _empty), percentDecode(match[5] || _empty), percentDecode(match[7] || _empty), percentDecode(match[9] || _empty), _strict);
    };
    /**
     * Creates a new URI from a file system path, e.g. `c:\my\files`,
     * `/usr/home`, or `\\server\share\some\path`.
     *
     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
     * `URI.parse('file://' + path)` because the path might contain characters that are
     * interpreted (# and ?). See the following sample:
     * ```ts
    const good = URI.file('/coding/c#/project1');
    good.scheme === 'file';
    good.path === '/coding/c#/project1';
    good.fragment === '';
    const bad = URI.parse('file://' + '/coding/c#/project1');
    bad.scheme === 'file';
    bad.path === '/coding/c'; // path is now broken
    bad.fragment === '/project1';
    ```
     *
     * @param path A file system path (see `URI#fsPath`)
     */
    URI.file = function (path) {
        var authority = _empty;
        // normalize to fwd-slashes on windows,
        // on other systems bwd-slashes are valid
        // filename character, eg /f\oo/ba\r.txt
        if (isWindows) {
            path = path.replace(/\\/g, _slash);
        }
        // check for authority as used in UNC shares
        // or use the path as given
        if (path[0] === _slash && path[1] === _slash) {
            var idx = path.indexOf(_slash, 2);
            if (idx === -1) {
                authority = path.substring(2);
                path = _slash;
            }
            else {
                authority = path.substring(2, idx);
                path = path.substring(idx) || _slash;
            }
        }
        return new _URI('file', authority, path, _empty, _empty);
    };
    URI.from = function (components) {
        return new _URI(components.scheme, components.authority, components.path, components.query, components.fragment);
    };
    // ---- printing/externalize ---------------------------
    /**
     * Creates a string representation for this URI. It's guaranteed that calling
     * `URI.parse` with the result of this function creates an URI which is equal
     * to this URI.
     *
     * * The result shall *not* be used for display purposes but for externalization or transport.
     * * The result will be encoded using the percentage encoding and encoding happens mostly
     * ignore the scheme-specific encoding rules.
     *
     * @param skipEncoding Do not encode the result, default is `false`
     */
    URI.prototype.toString = function (skipEncoding) {
        if (skipEncoding === void 0) { skipEncoding = false; }
        return _asFormatted(this, skipEncoding);
    };
    URI.prototype.toJSON = function () {
        return this;
    };
    URI.revive = function (data) {
        if (!data) {
            return data;
        }
        else if (data instanceof URI) {
            return data;
        }
        else {
            var result = new _URI(data);
            result._formatted = data.external;
            result._fsPath = data._sep === _pathSepMarker ? data.fsPath : null;
            return result;
        }
    };
    return URI;
}());

var _pathSepMarker = isWindows ? 1 : undefined;
// eslint-disable-next-line @typescript-eslint/class-name-casing
var _URI = /** @class */ (function (_super) {
    uri_extends(_URI, _super);
    function _URI() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._formatted = null;
        _this._fsPath = null;
        return _this;
    }
    Object.defineProperty(_URI.prototype, "fsPath", {
        get: function () {
            if (!this._fsPath) {
                this._fsPath = _makeFsPath(this);
            }
            return this._fsPath;
        },
        enumerable: true,
        configurable: true
    });
    _URI.prototype.toString = function (skipEncoding) {
        if (skipEncoding === void 0) { skipEncoding = false; }
        if (!skipEncoding) {
            if (!this._formatted) {
                this._formatted = _asFormatted(this, false);
            }
            return this._formatted;
        }
        else {
            // we don't cache that
            return _asFormatted(this, true);
        }
    };
    _URI.prototype.toJSON = function () {
        var res = {
            $mid: 1
        };
        // cached state
        if (this._fsPath) {
            res.fsPath = this._fsPath;
            res._sep = _pathSepMarker;
        }
        if (this._formatted) {
            res.external = this._formatted;
        }
        // uri components
        if (this.path) {
            res.path = this.path;
        }
        if (this.scheme) {
            res.scheme = this.scheme;
        }
        if (this.authority) {
            res.authority = this.authority;
        }
        if (this.query) {
            res.query = this.query;
        }
        if (this.fragment) {
            res.fragment = this.fragment;
        }
        return res;
    };
    return _URI;
}(uri_URI));
// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2
var encodeTable = (uri_a = {},
    uri_a[58 /* Colon */] = '%3A',
    uri_a[47 /* Slash */] = '%2F',
    uri_a[63 /* QuestionMark */] = '%3F',
    uri_a[35 /* Hash */] = '%23',
    uri_a[91 /* OpenSquareBracket */] = '%5B',
    uri_a[93 /* CloseSquareBracket */] = '%5D',
    uri_a[64 /* AtSign */] = '%40',
    uri_a[33 /* ExclamationMark */] = '%21',
    uri_a[36 /* DollarSign */] = '%24',
    uri_a[38 /* Ampersand */] = '%26',
    uri_a[39 /* SingleQuote */] = '%27',
    uri_a[40 /* OpenParen */] = '%28',
    uri_a[41 /* CloseParen */] = '%29',
    uri_a[42 /* Asterisk */] = '%2A',
    uri_a[43 /* Plus */] = '%2B',
    uri_a[44 /* Comma */] = '%2C',
    uri_a[59 /* Semicolon */] = '%3B',
    uri_a[61 /* Equals */] = '%3D',
    uri_a[32 /* Space */] = '%20',
    uri_a);
function encodeURIComponentFast(uriComponent, allowSlash) {
    var res = undefined;
    var nativeEncodePos = -1;
    for (var pos = 0; pos < uriComponent.length; pos++) {
        var code = uriComponent.charCodeAt(pos);
        // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3
        if ((code >= 97 /* a */ && code <= 122 /* z */)
            || (code >= 65 /* A */ && code <= 90 /* Z */)
            || (code >= 48 /* Digit0 */ && code <= 57 /* Digit9 */)
            || code === 45 /* Dash */
            || code === 46 /* Period */
            || code === 95 /* Underline */
            || code === 126 /* Tilde */
            || (allowSlash && code === 47 /* Slash */)) {
            // check if we are delaying native encode
            if (nativeEncodePos !== -1) {
                res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
                nativeEncodePos = -1;
            }
            // check if we write into a new string (by default we try to return the param)
            if (res !== undefined) {
                res += uriComponent.charAt(pos);
            }
        }
        else {
            // encoding needed, we need to allocate a new string
            if (res === undefined) {
                res = uriComponent.substr(0, pos);
            }
            // check with default table first
            var escaped = encodeTable[code];
            if (escaped !== undefined) {
                // check if we are delaying native encode
                if (nativeEncodePos !== -1) {
                    res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
                    nativeEncodePos = -1;
                }
                // append escaped variant to result
                res += escaped;
            }
            else if (nativeEncodePos === -1) {
                // use native encode only when needed
                nativeEncodePos = pos;
            }
        }
    }
    if (nativeEncodePos !== -1) {
        res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
    }
    return res !== undefined ? res : uriComponent;
}
function encodeURIComponentMinimal(path) {
    var res = undefined;
    for (var pos = 0; pos < path.length; pos++) {
        var code = path.charCodeAt(pos);
        if (code === 35 /* Hash */ || code === 63 /* QuestionMark */) {
            if (res === undefined) {
                res = path.substr(0, pos);
            }
            res += encodeTable[code];
        }
        else {
            if (res !== undefined) {
                res += path[pos];
            }
        }
    }
    return res !== undefined ? res : path;
}
/**
 * Compute `fsPath` for the given uri
 */
function _makeFsPath(uri) {
    var value;
    if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {
        // unc path: file://shares/c$/far/boo
        value = "//" + uri.authority + uri.path;
    }
    else if (uri.path.charCodeAt(0) === 47 /* Slash */
        && (uri.path.charCodeAt(1) >= 65 /* A */ && uri.path.charCodeAt(1) <= 90 /* Z */ || uri.path.charCodeAt(1) >= 97 /* a */ && uri.path.charCodeAt(1) <= 122 /* z */)
        && uri.path.charCodeAt(2) === 58 /* Colon */) {
        // windows drive letter: file:///c:/far/boo
        value = uri.path[1].toLowerCase() + uri.path.substr(2);
    }
    else {
        // other path
        value = uri.path;
    }
    if (isWindows) {
        value = value.replace(/\//g, '\\');
    }
    return value;
}
/**
 * Create the external version of a uri
 */
function _asFormatted(uri, skipEncoding) {
    var encoder = !skipEncoding
        ? encodeURIComponentFast
        : encodeURIComponentMinimal;
    var res = '';
    var scheme = uri.scheme, authority = uri.authority, path = uri.path, query = uri.query, fragment = uri.fragment;
    if (scheme) {
        res += scheme;
        res += ':';
    }
    if (authority || scheme === 'file') {
        res += _slash;
        res += _slash;
    }
    if (authority) {
        var idx = authority.indexOf('@');
        if (idx !== -1) {
            // <user>@<auth>
            var userinfo = authority.substr(0, idx);
            authority = authority.substr(idx + 1);
            idx = userinfo.indexOf(':');
            if (idx === -1) {
                res += encoder(userinfo, false);
            }
            else {
                // <user>:<pass>@<auth>
                res += encoder(userinfo.substr(0, idx), false);
                res += ':';
                res += encoder(userinfo.substr(idx + 1), false);
            }
            res += '@';
        }
        authority = authority.toLowerCase();
        idx = authority.indexOf(':');
        if (idx === -1) {
            res += encoder(authority, false);
        }
        else {
            // <auth>:<port>
            res += encoder(authority.substr(0, idx), false);
            res += authority.substr(idx);
        }
    }
    if (path) {
        // lower-case windows drive letters in /C:/fff or C:/fff
        if (path.length >= 3 && path.charCodeAt(0) === 47 /* Slash */ && path.charCodeAt(2) === 58 /* Colon */) {
            var code = path.charCodeAt(1);
            if (code >= 65 /* A */ && code <= 90 /* Z */) {
                path = "/" + String.fromCharCode(code + 32) + ":" + path.substr(3); // "/c:".length === 3
            }
        }
        else if (path.length >= 2 && path.charCodeAt(1) === 58 /* Colon */) {
            var code = path.charCodeAt(0);
            if (code >= 65 /* A */ && code <= 90 /* Z */) {
                path = String.fromCharCode(code + 32) + ":" + path.substr(2); // "/c:".length === 3
            }
        }
        // encode the rest of the path
        res += encoder(path, true);
    }
    if (query) {
        res += '?';
        res += encoder(query, false);
    }
    if (fragment) {
        res += '#';
        res += !skipEncoding ? encodeURIComponentFast(fragment, false) : fragment;
    }
    return res;
}
// --- decode
function decodeURIComponentGraceful(str) {
    try {
        return decodeURIComponent(str);
    }
    catch (_a) {
        if (str.length > 3) {
            return str.substr(0, 3) + decodeURIComponentGraceful(str.substr(3));
        }
        else {
            return str;
        }
    }
}
var _rEncodedAsHex = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
function percentDecode(str) {
    if (!str.match(_rEncodedAsHex)) {
        return str;
    }
    return str.replace(_rEncodedAsHex, function (match) { return decodeURIComponentGraceful(match); });
}

// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/editor/common/core/position.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
/**
 * A position in the editor.
 */
var Position = /** @class */ (function () {
    function Position(lineNumber, column) {
        this.lineNumber = lineNumber;
        this.column = column;
    }
    /**
     * Create a new position from this position.
     *
     * @param newLineNumber new line number
     * @param newColumn new column
     */
    Position.prototype.with = function (newLineNumber, newColumn) {
        if (newLineNumber === void 0) { newLineNumber = this.lineNumber; }
        if (newColumn === void 0) { newColumn = this.column; }
        if (newLineNumber === this.lineNumber && newColumn === this.column) {
            return this;
        }
        else {
            return new Position(newLineNumber, newColumn);
        }
    };
    /**
     * Derive a new position from this position.
     *
     * @param deltaLineNumber line number delta
     * @param deltaColumn column delta
     */
    Position.prototype.delta = function (deltaLineNumber, deltaColumn) {
        if (deltaLineNumber === void 0) { deltaLineNumber = 0; }
        if (deltaColumn === void 0) { deltaColumn = 0; }
        return this.with(this.lineNumber + deltaLineNumber, this.column + deltaColumn);
    };
    /**
     * Test if this position equals other position
     */
    Position.prototype.equals = function (other) {
        return Position.equals(this, other);
    };
    /**
     * Test if position `a` equals position `b`
     */
    Position.equals = function (a, b) {
        if (!a && !b) {
            return true;
        }
        return (!!a &&
            !!b &&
            a.lineNumber === b.lineNumber &&
            a.column === b.column);
    };
    /**
     * Test if this position is before other position.
     * If the two positions are equal, the result will be false.
     */
    Position.prototype.isBefore = function (other) {
        return Position.isBefore(this, other);
    };
    /**
     * Test if position `a` is before position `b`.
     * If the two positions are equal, the result will be false.
     */
    Position.isBefore = function (a, b) {
        if (a.lineNumber < b.lineNumber) {
            return true;
        }
        if (b.lineNumber < a.lineNumber) {
            return false;
        }
        return a.column < b.column;
    };
    /**
     * Test if this position is before other position.
     * If the two positions are equal, the result will be true.
     */
    Position.prototype.isBeforeOrEqual = function (other) {
        return Position.isBeforeOrEqual(this, other);
    };
    /**
     * Test if position `a` is before position `b`.
     * If the two positions are equal, the result will be true.
     */
    Position.isBeforeOrEqual = function (a, b) {
        if (a.lineNumber < b.lineNumber) {
            return true;
        }
        if (b.lineNumber < a.lineNumber) {
            return false;
        }
        return a.column <= b.column;
    };
    /**
     * A function that compares positions, useful for sorting
     */
    Position.compare = function (a, b) {
        var aLineNumber = a.lineNumber | 0;
        var bLineNumber = b.lineNumber | 0;
        if (aLineNumber === bLineNumber) {
            var aColumn = a.column | 0;
            var bColumn = b.column | 0;
            return aColumn - bColumn;
        }
        return aLineNumber - bLineNumber;
    };
    /**
     * Clone this position.
     */
    Position.prototype.clone = function () {
        return new Position(this.lineNumber, this.column);
    };
    /**
     * Convert to a human-readable representation.
     */
    Position.prototype.toString = function () {
        return '(' + this.lineNumber + ',' + this.column + ')';
    };
    // ---
    /**
     * Create a `Position` from an `IPosition`.
     */
    Position.lift = function (pos) {
        return new Position(pos.lineNumber, pos.column);
    };
    /**
     * Test if `obj` is an `IPosition`.
     */
    Position.isIPosition = function (obj) {
        return (obj
            && (typeof obj.lineNumber === 'number')
            && (typeof obj.column === 'number'));
    };
    return Position;
}());


// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/editor/common/core/range.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * A range in the editor. (startLineNumber,startColumn) is <= (endLineNumber,endColumn)
 */
var range_Range = /** @class */ (function () {
    function Range(startLineNumber, startColumn, endLineNumber, endColumn) {
        if ((startLineNumber > endLineNumber) || (startLineNumber === endLineNumber && startColumn > endColumn)) {
            this.startLineNumber = endLineNumber;
            this.startColumn = endColumn;
            this.endLineNumber = startLineNumber;
            this.endColumn = startColumn;
        }
        else {
            this.startLineNumber = startLineNumber;
            this.startColumn = startColumn;
            this.endLineNumber = endLineNumber;
            this.endColumn = endColumn;
        }
    }
    /**
     * Test if this range is empty.
     */
    Range.prototype.isEmpty = function () {
        return Range.isEmpty(this);
    };
    /**
     * Test if `range` is empty.
     */
    Range.isEmpty = function (range) {
        return (range.startLineNumber === range.endLineNumber && range.startColumn === range.endColumn);
    };
    /**
     * Test if position is in this range. If the position is at the edges, will return true.
     */
    Range.prototype.containsPosition = function (position) {
        return Range.containsPosition(this, position);
    };
    /**
     * Test if `position` is in `range`. If the position is at the edges, will return true.
     */
    Range.containsPosition = function (range, position) {
        if (position.lineNumber < range.startLineNumber || position.lineNumber > range.endLineNumber) {
            return false;
        }
        if (position.lineNumber === range.startLineNumber && position.column < range.startColumn) {
            return false;
        }
        if (position.lineNumber === range.endLineNumber && position.column > range.endColumn) {
            return false;
        }
        return true;
    };
    /**
     * Test if range is in this range. If the range is equal to this range, will return true.
     */
    Range.prototype.containsRange = function (range) {
        return Range.containsRange(this, range);
    };
    /**
     * Test if `otherRange` is in `range`. If the ranges are equal, will return true.
     */
    Range.containsRange = function (range, otherRange) {
        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
            return false;
        }
        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
            return false;
        }
        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn < range.startColumn) {
            return false;
        }
        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn > range.endColumn) {
            return false;
        }
        return true;
    };
    /**
     * Test if `range` is strictly in this range. `range` must start after and end before this range for the result to be true.
     */
    Range.prototype.strictContainsRange = function (range) {
        return Range.strictContainsRange(this, range);
    };
    /**
     * Test if `otherRange` is strinctly in `range` (must start after, and end before). If the ranges are equal, will return false.
     */
    Range.strictContainsRange = function (range, otherRange) {
        if (otherRange.startLineNumber < range.startLineNumber || otherRange.endLineNumber < range.startLineNumber) {
            return false;
        }
        if (otherRange.startLineNumber > range.endLineNumber || otherRange.endLineNumber > range.endLineNumber) {
            return false;
        }
        if (otherRange.startLineNumber === range.startLineNumber && otherRange.startColumn <= range.startColumn) {
            return false;
        }
        if (otherRange.endLineNumber === range.endLineNumber && otherRange.endColumn >= range.endColumn) {
            return false;
        }
        return true;
    };
    /**
     * A reunion of the two ranges.
     * The smallest position will be used as the start point, and the largest one as the end point.
     */
    Range.prototype.plusRange = function (range) {
        return Range.plusRange(this, range);
    };
    /**
     * A reunion of the two ranges.
     * The smallest position will be used as the start point, and the largest one as the end point.
     */
    Range.plusRange = function (a, b) {
        var startLineNumber;
        var startColumn;
        var endLineNumber;
        var endColumn;
        if (b.startLineNumber < a.startLineNumber) {
            startLineNumber = b.startLineNumber;
            startColumn = b.startColumn;
        }
        else if (b.startLineNumber === a.startLineNumber) {
            startLineNumber = b.startLineNumber;
            startColumn = Math.min(b.startColumn, a.startColumn);
        }
        else {
            startLineNumber = a.startLineNumber;
            startColumn = a.startColumn;
        }
        if (b.endLineNumber > a.endLineNumber) {
            endLineNumber = b.endLineNumber;
            endColumn = b.endColumn;
        }
        else if (b.endLineNumber === a.endLineNumber) {
            endLineNumber = b.endLineNumber;
            endColumn = Math.max(b.endColumn, a.endColumn);
        }
        else {
            endLineNumber = a.endLineNumber;
            endColumn = a.endColumn;
        }
        return new Range(startLineNumber, startColumn, endLineNumber, endColumn);
    };
    /**
     * A intersection of the two ranges.
     */
    Range.prototype.intersectRanges = function (range) {
        return Range.intersectRanges(this, range);
    };
    /**
     * A intersection of the two ranges.
     */
    Range.intersectRanges = function (a, b) {
        var resultStartLineNumber = a.startLineNumber;
        var resultStartColumn = a.startColumn;
        var resultEndLineNumber = a.endLineNumber;
        var resultEndColumn = a.endColumn;
        var otherStartLineNumber = b.startLineNumber;
        var otherStartColumn = b.startColumn;
        var otherEndLineNumber = b.endLineNumber;
        var otherEndColumn = b.endColumn;
        if (resultStartLineNumber < otherStartLineNumber) {
            resultStartLineNumber = otherStartLineNumber;
            resultStartColumn = otherStartColumn;
        }
        else if (resultStartLineNumber === otherStartLineNumber) {
            resultStartColumn = Math.max(resultStartColumn, otherStartColumn);
        }
        if (resultEndLineNumber > otherEndLineNumber) {
            resultEndLineNumber = otherEndLineNumber;
            resultEndColumn = otherEndColumn;
        }
        else if (resultEndLineNumber === otherEndLineNumber) {
            resultEndColumn = Math.min(resultEndColumn, otherEndColumn);
        }
        // Check if selection is now empty
        if (resultStartLineNumber > resultEndLineNumber) {
            return null;
        }
        if (resultStartLineNumber === resultEndLineNumber && resultStartColumn > resultEndColumn) {
            return null;
        }
        return new Range(resultStartLineNumber, resultStartColumn, resultEndLineNumber, resultEndColumn);
    };
    /**
     * Test if this range equals other.
     */
    Range.prototype.equalsRange = function (other) {
        return Range.equalsRange(this, other);
    };
    /**
     * Test if range `a` equals `b`.
     */
    Range.equalsRange = function (a, b) {
        return (!!a &&
            !!b &&
            a.startLineNumber === b.startLineNumber &&
            a.startColumn === b.startColumn &&
            a.endLineNumber === b.endLineNumber &&
            a.endColumn === b.endColumn);
    };
    /**
     * Return the end position (which will be after or equal to the start position)
     */
    Range.prototype.getEndPosition = function () {
        return new Position(this.endLineNumber, this.endColumn);
    };
    /**
     * Return the start position (which will be before or equal to the end position)
     */
    Range.prototype.getStartPosition = function () {
        return new Position(this.startLineNumber, this.startColumn);
    };
    /**
     * Transform to a user presentable string representation.
     */
    Range.prototype.toString = function () {
        return '[' + this.startLineNumber + ',' + this.startColumn + ' -> ' + this.endLineNumber + ',' + this.endColumn + ']';
    };
    /**
     * Create a new range using this range's start position, and using endLineNumber and endColumn as the end position.
     */
    Range.prototype.setEndPosition = function (endLineNumber, endColumn) {
        return new Range(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
    };
    /**
     * Create a new range using this range's end position, and using startLineNumber and startColumn as the start position.
     */
    Range.prototype.setStartPosition = function (startLineNumber, startColumn) {
        return new Range(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
    };
    /**
     * Create a new empty range using this range's start position.
     */
    Range.prototype.collapseToStart = function () {
        return Range.collapseToStart(this);
    };
    /**
     * Create a new empty range using this range's start position.
     */
    Range.collapseToStart = function (range) {
        return new Range(range.startLineNumber, range.startColumn, range.startLineNumber, range.startColumn);
    };
    // ---
    Range.fromPositions = function (start, end) {
        if (end === void 0) { end = start; }
        return new Range(start.lineNumber, start.column, end.lineNumber, end.column);
    };
    Range.lift = function (range) {
        if (!range) {
            return null;
        }
        return new Range(range.startLineNumber, range.startColumn, range.endLineNumber, range.endColumn);
    };
    /**
     * Test if `obj` is an `IRange`.
     */
    Range.isIRange = function (obj) {
        return (obj
            && (typeof obj.startLineNumber === 'number')
            && (typeof obj.startColumn === 'number')
            && (typeof obj.endLineNumber === 'number')
            && (typeof obj.endColumn === 'number'));
    };
    /**
     * Test if the two ranges are touching in any way.
     */
    Range.areIntersectingOrTouching = function (a, b) {
        // Check if `a` is before `b`
        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn < b.startColumn)) {
            return false;
        }
        // Check if `b` is before `a`
        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn < a.startColumn)) {
            return false;
        }
        // These ranges must intersect
        return true;
    };
    /**
     * Test if the two ranges are intersecting. If the ranges are touching it returns true.
     */
    Range.areIntersecting = function (a, b) {
        // Check if `a` is before `b`
        if (a.endLineNumber < b.startLineNumber || (a.endLineNumber === b.startLineNumber && a.endColumn <= b.startColumn)) {
            return false;
        }
        // Check if `b` is before `a`
        if (b.endLineNumber < a.startLineNumber || (b.endLineNumber === a.startLineNumber && b.endColumn <= a.startColumn)) {
            return false;
        }
        // These ranges must intersect
        return true;
    };
    /**
     * A function that compares ranges, useful for sorting ranges
     * It will first compare ranges on the startPosition and then on the endPosition
     */
    Range.compareRangesUsingStarts = function (a, b) {
        if (a && b) {
            var aStartLineNumber = a.startLineNumber | 0;
            var bStartLineNumber = b.startLineNumber | 0;
            if (aStartLineNumber === bStartLineNumber) {
                var aStartColumn = a.startColumn | 0;
                var bStartColumn = b.startColumn | 0;
                if (aStartColumn === bStartColumn) {
                    var aEndLineNumber = a.endLineNumber | 0;
                    var bEndLineNumber = b.endLineNumber | 0;
                    if (aEndLineNumber === bEndLineNumber) {
                        var aEndColumn = a.endColumn | 0;
                        var bEndColumn = b.endColumn | 0;
                        return aEndColumn - bEndColumn;
                    }
                    return aEndLineNumber - bEndLineNumber;
                }
                return aStartColumn - bStartColumn;
            }
            return aStartLineNumber - bStartLineNumber;
        }
        var aExists = (a ? 1 : 0);
        var bExists = (b ? 1 : 0);
        return aExists - bExists;
    };
    /**
     * A function that compares ranges, useful for sorting ranges
     * It will first compare ranges on the endPosition and then on the startPosition
     */
    Range.compareRangesUsingEnds = function (a, b) {
        if (a.endLineNumber === b.endLineNumber) {
            if (a.endColumn === b.endColumn) {
                if (a.startLineNumber === b.startLineNumber) {
                    return a.startColumn - b.startColumn;
                }
                return a.startLineNumber - b.startLineNumber;
            }
            return a.endColumn - b.endColumn;
        }
        return a.endLineNumber - b.endLineNumber;
    };
    /**
     * Test if the range spans multiple lines.
     */
    Range.spansMultipleLines = function (range) {
        return range.endLineNumber > range.startLineNumber;
    };
    return Range;
}());


// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/base/common/strings.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function isFalsyOrWhitespace(str) {
    if (!str || typeof str !== 'string') {
        return true;
    }
    return str.trim().length === 0;
}
/**
 * @returns the provided number with the given number of preceding zeros.
 */
function pad(n, l, char) {
    if (char === void 0) { char = '0'; }
    var str = '' + n;
    var r = [str];
    for (var i = str.length; i < l; i++) {
        r.push(char);
    }
    return r.reverse().join('');
}
var _formatRegexp = /{(\d+)}/g;
/**
 * Helper to produce a string with a variable number of arguments. Insert variable segments
 * into the string using the {n} notation where N is the index of the argument following the string.
 * @param value string to which formatting is applied
 * @param args replacements for {n}-entries
 */
function strings_format(value) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    if (args.length === 0) {
        return value;
    }
    return value.replace(_formatRegexp, function (match, group) {
        var idx = parseInt(group, 10);
        return isNaN(idx) || idx < 0 || idx >= args.length ?
            match :
            args[idx];
    });
}
/**
 * Converts HTML characters inside the string to use entities instead. Makes the string safe from
 * being used e.g. in HTMLElement.innerHTML.
 */
function strings_escape(html) {
    return html.replace(/[<>&]/g, function (match) {
        switch (match) {
            case '<': return '&lt;';
            case '>': return '&gt;';
            case '&': return '&amp;';
            default: return match;
        }
    });
}
/**
 * Escapes regular expression characters in a given string
 */
function escapeRegExpCharacters(value) {
    return value.replace(/[\\\{\}\*\+\?\|\^\$\.\[\]\(\)]/g, '\\$&');
}
/**
 * Removes all occurrences of needle from the beginning and end of haystack.
 * @param haystack string to trim
 * @param needle the thing to trim (default is a blank)
 */
function trim(haystack, needle) {
    if (needle === void 0) { needle = ' '; }
    var trimmed = ltrim(haystack, needle);
    return rtrim(trimmed, needle);
}
/**
 * Removes all occurrences of needle from the beginning of haystack.
 * @param haystack string to trim
 * @param needle the thing to trim
 */
function ltrim(haystack, needle) {
    if (!haystack || !needle) {
        return haystack;
    }
    var needleLen = needle.length;
    if (needleLen === 0 || haystack.length === 0) {
        return haystack;
    }
    var offset = 0;
    while (haystack.indexOf(needle, offset) === offset) {
        offset = offset + needleLen;
    }
    return haystack.substring(offset);
}
/**
 * Removes all occurrences of needle from the end of haystack.
 * @param haystack string to trim
 * @param needle the thing to trim
 */
function rtrim(haystack, needle) {
    if (!haystack || !needle) {
        return haystack;
    }
    var needleLen = needle.length, haystackLen = haystack.length;
    if (needleLen === 0 || haystackLen === 0) {
        return haystack;
    }
    var offset = haystackLen, idx = -1;
    while (true) {
        idx = haystack.lastIndexOf(needle, offset - 1);
        if (idx === -1 || idx + needleLen !== offset) {
            break;
        }
        if (idx === 0) {
            return '';
        }
        offset = idx;
    }
    return haystack.substring(0, offset);
}
function convertSimple2RegExpPattern(pattern) {
    return pattern.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&').replace(/[\*]/g, '.*');
}
/**
 * Determines if haystack starts with needle.
 */
function startsWith(haystack, needle) {
    if (haystack.length < needle.length) {
        return false;
    }
    if (haystack === needle) {
        return true;
    }
    for (var i = 0; i < needle.length; i++) {
        if (haystack[i] !== needle[i]) {
            return false;
        }
    }
    return true;
}
/**
 * Determines if haystack ends with needle.
 */
function endsWith(haystack, needle) {
    var diff = haystack.length - needle.length;
    if (diff > 0) {
        return haystack.indexOf(needle, diff) === diff;
    }
    else if (diff === 0) {
        return haystack === needle;
    }
    else {
        return false;
    }
}
function createRegExp(searchString, isRegex, options) {
    if (options === void 0) { options = {}; }
    if (!searchString) {
        throw new Error('Cannot create regex from empty string');
    }
    if (!isRegex) {
        searchString = escapeRegExpCharacters(searchString);
    }
    if (options.wholeWord) {
        if (!/\B/.test(searchString.charAt(0))) {
            searchString = '\\b' + searchString;
        }
        if (!/\B/.test(searchString.charAt(searchString.length - 1))) {
            searchString = searchString + '\\b';
        }
    }
    var modifiers = '';
    if (options.global) {
        modifiers += 'g';
    }
    if (!options.matchCase) {
        modifiers += 'i';
    }
    if (options.multiline) {
        modifiers += 'm';
    }
    if (options.unicode) {
        modifiers += 'u';
    }
    return new RegExp(searchString, modifiers);
}
function regExpLeadsToEndlessLoop(regexp) {
    // Exit early if it's one of these special cases which are meant to match
    // against an empty string
    if (regexp.source === '^' || regexp.source === '^$' || regexp.source === '$' || regexp.source === '^\\s*$') {
        return false;
    }
    // We check against an empty string. If the regular expression doesn't advance
    // (e.g. ends in an endless loop) it will match an empty string.
    var match = regexp.exec('');
    return !!(match && regexp.lastIndex === 0);
}
function regExpFlags(regexp) {
    return (regexp.global ? 'g' : '')
        + (regexp.ignoreCase ? 'i' : '')
        + (regexp.multiline ? 'm' : '')
        + (regexp.unicode ? 'u' : '');
}
/**
 * Returns first index of the string that is not whitespace.
 * If string is empty or contains only whitespaces, returns -1
 */
function firstNonWhitespaceIndex(str) {
    for (var i = 0, len = str.length; i < len; i++) {
        var chCode = str.charCodeAt(i);
        if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
            return i;
        }
    }
    return -1;
}
/**
 * Returns the leading whitespace of the string.
 * If the string contains only whitespaces, returns entire string
 */
function getLeadingWhitespace(str, start, end) {
    if (start === void 0) { start = 0; }
    if (end === void 0) { end = str.length; }
    for (var i = start; i < end; i++) {
        var chCode = str.charCodeAt(i);
        if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
            return str.substring(start, i);
        }
    }
    return str.substring(start, end);
}
/**
 * Returns last index of the string that is not whitespace.
 * If string is empty or contains only whitespaces, returns -1
 */
function lastNonWhitespaceIndex(str, startIndex) {
    if (startIndex === void 0) { startIndex = str.length - 1; }
    for (var i = startIndex; i >= 0; i--) {
        var chCode = str.charCodeAt(i);
        if (chCode !== 32 /* Space */ && chCode !== 9 /* Tab */) {
            return i;
        }
    }
    return -1;
}
function compare(a, b) {
    if (a < b) {
        return -1;
    }
    else if (a > b) {
        return 1;
    }
    else {
        return 0;
    }
}
function compareIgnoreCase(a, b) {
    var len = Math.min(a.length, b.length);
    for (var i = 0; i < len; i++) {
        var codeA = a.charCodeAt(i);
        var codeB = b.charCodeAt(i);
        if (codeA === codeB) {
            // equal
            continue;
        }
        if (isUpperAsciiLetter(codeA)) {
            codeA += 32;
        }
        if (isUpperAsciiLetter(codeB)) {
            codeB += 32;
        }
        var diff = codeA - codeB;
        if (diff === 0) {
            // equal -> ignoreCase
            continue;
        }
        else if (isLowerAsciiLetter(codeA) && isLowerAsciiLetter(codeB)) {
            //
            return diff;
        }
        else {
            return compare(a.toLowerCase(), b.toLowerCase());
        }
    }
    if (a.length < b.length) {
        return -1;
    }
    else if (a.length > b.length) {
        return 1;
    }
    else {
        return 0;
    }
}
function isLowerAsciiLetter(code) {
    return code >= 97 /* a */ && code <= 122 /* z */;
}
function isUpperAsciiLetter(code) {
    return code >= 65 /* A */ && code <= 90 /* Z */;
}
function isAsciiLetter(code) {
    return isLowerAsciiLetter(code) || isUpperAsciiLetter(code);
}
function equalsIgnoreCase(a, b) {
    return a.length === b.length && doEqualsIgnoreCase(a, b);
}
function doEqualsIgnoreCase(a, b, stopAt) {
    if (stopAt === void 0) { stopAt = a.length; }
    for (var i = 0; i < stopAt; i++) {
        var codeA = a.charCodeAt(i);
        var codeB = b.charCodeAt(i);
        if (codeA === codeB) {
            continue;
        }
        // a-z A-Z
        if (isAsciiLetter(codeA) && isAsciiLetter(codeB)) {
            var diff = Math.abs(codeA - codeB);
            if (diff !== 0 && diff !== 32) {
                return false;
            }
        }
        // Any other charcode
        else {
            if (String.fromCharCode(codeA).toLowerCase() !== String.fromCharCode(codeB).toLowerCase()) {
                return false;
            }
        }
    }
    return true;
}
function startsWithIgnoreCase(str, candidate) {
    var candidateLength = candidate.length;
    if (candidate.length > str.length) {
        return false;
    }
    return doEqualsIgnoreCase(str, candidate, candidateLength);
}
/**
 * @returns the length of the common prefix of the two strings.
 */
function commonPrefixLength(a, b) {
    var i, len = Math.min(a.length, b.length);
    for (i = 0; i < len; i++) {
        if (a.charCodeAt(i) !== b.charCodeAt(i)) {
            return i;
        }
    }
    return len;
}
/**
 * @returns the length of the common suffix of the two strings.
 */
function commonSuffixLength(a, b) {
    var i, len = Math.min(a.length, b.length);
    var aLastIndex = a.length - 1;
    var bLastIndex = b.length - 1;
    for (i = 0; i < len; i++) {
        if (a.charCodeAt(aLastIndex - i) !== b.charCodeAt(bLastIndex - i)) {
            return i;
        }
    }
    return len;
}
// --- unicode
// http://en.wikipedia.org/wiki/Surrogate_pair
// Returns the code point starting at a specified index in a string
// Code points U+0000 to U+D7FF and U+E000 to U+FFFF are represented on a single character
// Code points U+10000 to U+10FFFF are represented on two consecutive characters
//export function getUnicodePoint(str:string, index:number, len:number):number {
//	const chrCode = str.charCodeAt(index);
//	if (0xD800 <= chrCode && chrCode <= 0xDBFF && index + 1 < len) {
//		const nextChrCode = str.charCodeAt(index + 1);
//		if (0xDC00 <= nextChrCode && nextChrCode <= 0xDFFF) {
//			return (chrCode - 0xD800) << 10 + (nextChrCode - 0xDC00) + 0x10000;
//		}
//	}
//	return chrCode;
//}
function isHighSurrogate(charCode) {
    return (0xD800 <= charCode && charCode <= 0xDBFF);
}
function isLowSurrogate(charCode) {
    return (0xDC00 <= charCode && charCode <= 0xDFFF);
}
/**
 * get the code point that begins at offset `offset`
 */
function getNextCodePoint(str, len, offset) {
    var charCode = str.charCodeAt(offset);
    if (isHighSurrogate(charCode) && offset + 1 < len) {
        var nextCharCode = str.charCodeAt(offset + 1);
        if (isLowSurrogate(nextCharCode)) {
            return ((charCode - 0xD800) << 10) + (nextCharCode - 0xDC00) + 0x10000;
        }
    }
    return charCode;
}
/**
 * get the code point that ends right before offset `offset`
 */
function getPrevCodePoint(str, offset) {
    var charCode = str.charCodeAt(offset - 1);
    if (isLowSurrogate(charCode) && offset > 1) {
        var prevCharCode = str.charCodeAt(offset - 2);
        if (isHighSurrogate(prevCharCode)) {
            return ((prevCharCode - 0xD800) << 10) + (charCode - 0xDC00) + 0x10000;
        }
    }
    return charCode;
}
function nextCharLength(str, offset) {
    var graphemeBreakTree = GraphemeBreakTree.getInstance();
    var initialOffset = offset;
    var len = str.length;
    var initialCodePoint = getNextCodePoint(str, len, offset);
    offset += (initialCodePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);
    var graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(initialCodePoint);
    while (offset < len) {
        var nextCodePoint = getNextCodePoint(str, len, offset);
        var nextGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(nextCodePoint);
        if (breakBetweenGraphemeBreakType(graphemeBreakType, nextGraphemeBreakType)) {
            break;
        }
        offset += (nextCodePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);
        graphemeBreakType = nextGraphemeBreakType;
    }
    return (offset - initialOffset);
}
function prevCharLength(str, offset) {
    var graphemeBreakTree = GraphemeBreakTree.getInstance();
    var initialOffset = offset;
    var initialCodePoint = getPrevCodePoint(str, offset);
    offset -= (initialCodePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);
    var graphemeBreakType = graphemeBreakTree.getGraphemeBreakType(initialCodePoint);
    while (offset > 0) {
        var prevCodePoint = getPrevCodePoint(str, offset);
        var prevGraphemeBreakType = graphemeBreakTree.getGraphemeBreakType(prevCodePoint);
        if (breakBetweenGraphemeBreakType(prevGraphemeBreakType, graphemeBreakType)) {
            break;
        }
        offset -= (prevCodePoint >= 65536 /* UNICODE_SUPPLEMENTARY_PLANE_BEGIN */ ? 2 : 1);
        graphemeBreakType = prevGraphemeBreakType;
    }
    return (initialOffset - offset);
}
/**
 * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-rtl-test.js
 */
var CONTAINS_RTL = /(?:[\u05BE\u05C0\u05C3\u05C6\u05D0-\u05F4\u0608\u060B\u060D\u061B-\u064A\u066D-\u066F\u0671-\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u0710\u0712-\u072F\u074D-\u07A5\u07B1-\u07EA\u07F4\u07F5\u07FA-\u0815\u081A\u0824\u0828\u0830-\u0858\u085E-\u08BD\u200F\uFB1D\uFB1F-\uFB28\uFB2A-\uFD3D\uFD50-\uFDFC\uFE70-\uFEFC]|\uD802[\uDC00-\uDD1B\uDD20-\uDE00\uDE10-\uDE33\uDE40-\uDEE4\uDEEB-\uDF35\uDF40-\uDFFF]|\uD803[\uDC00-\uDCFF]|\uD83A[\uDC00-\uDCCF\uDD00-\uDD43\uDD50-\uDFFF]|\uD83B[\uDC00-\uDEBB])/;
/**
 * Returns true if `str` contains any Unicode character that is classified as "R" or "AL".
 */
function containsRTL(str) {
    return CONTAINS_RTL.test(str);
}
/**
 * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-emoji-test.js
 */
var CONTAINS_EMOJI = /(?:[\u231A\u231B\u23F0\u23F3\u2600-\u27BF\u2B50\u2B55]|\uD83C[\uDDE6-\uDDFF\uDF00-\uDFFF]|\uD83D[\uDC00-\uDE4F\uDE80-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD00-\uDDFF\uDE70-\uDE73\uDE78-\uDE82\uDE90-\uDE95])/;
function containsEmoji(str) {
    return CONTAINS_EMOJI.test(str);
}
var IS_BASIC_ASCII = /^[\t\n\r\x20-\x7E]*$/;
/**
 * Returns true if `str` contains only basic ASCII characters in the range 32 - 126 (including 32 and 126) or \n, \r, \t
 */
function isBasicASCII(str) {
    return IS_BASIC_ASCII.test(str);
}
function containsFullWidthCharacter(str) {
    for (var i = 0, len = str.length; i < len; i++) {
        if (isFullWidthCharacter(str.charCodeAt(i))) {
            return true;
        }
    }
    return false;
}
function isFullWidthCharacter(charCode) {
    // Do a cheap trick to better support wrapping of wide characters, treat them as 2 columns
    // http://jrgraphix.net/research/unicode_blocks.php
    //          2E80  2EFF   CJK Radicals Supplement
    //          2F00  2FDF   Kangxi Radicals
    //          2FF0  2FFF   Ideographic Description Characters
    //          3000  303F   CJK Symbols and Punctuation
    //          3040  309F   Hiragana
    //          30A0  30FF   Katakana
    //          3100  312F   Bopomofo
    //          3130  318F   Hangul Compatibility Jamo
    //          3190  319F   Kanbun
    //          31A0  31BF   Bopomofo Extended
    //          31F0  31FF   Katakana Phonetic Extensions
    //          3200  32FF   Enclosed CJK Letters and Months
    //          3300  33FF   CJK Compatibility
    //          3400  4DBF   CJK Unified Ideographs Extension A
    //          4DC0  4DFF   Yijing Hexagram Symbols
    //          4E00  9FFF   CJK Unified Ideographs
    //          A000  A48F   Yi Syllables
    //          A490  A4CF   Yi Radicals
    //          AC00  D7AF   Hangul Syllables
    // [IGNORE] D800  DB7F   High Surrogates
    // [IGNORE] DB80  DBFF   High Private Use Surrogates
    // [IGNORE] DC00  DFFF   Low Surrogates
    // [IGNORE] E000  F8FF   Private Use Area
    //          F900  FAFF   CJK Compatibility Ideographs
    // [IGNORE] FB00  FB4F   Alphabetic Presentation Forms
    // [IGNORE] FB50  FDFF   Arabic Presentation Forms-A
    // [IGNORE] FE00  FE0F   Variation Selectors
    // [IGNORE] FE20  FE2F   Combining Half Marks
    // [IGNORE] FE30  FE4F   CJK Compatibility Forms
    // [IGNORE] FE50  FE6F   Small Form Variants
    // [IGNORE] FE70  FEFF   Arabic Presentation Forms-B
    //          FF00  FFEF   Halfwidth and Fullwidth Forms
    //               [https://en.wikipedia.org/wiki/Halfwidth_and_fullwidth_forms]
    //               of which FF01 - FF5E fullwidth ASCII of 21 to 7E
    // [IGNORE]    and FF65 - FFDC halfwidth of Katakana and Hangul
    // [IGNORE] FFF0  FFFF   Specials
    charCode = +charCode; // @perf
    return ((charCode >= 0x2E80 && charCode <= 0xD7AF)
        || (charCode >= 0xF900 && charCode <= 0xFAFF)
        || (charCode >= 0xFF01 && charCode <= 0xFF5E));
}
/**
 * A fast function (therefore imprecise) to check if code points are emojis.
 * Generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-emoji-test.js
 */
function isEmojiImprecise(x) {
    return ((x >= 0x1F1E6 && x <= 0x1F1FF) || (x >= 9728 && x <= 10175) || (x >= 127744 && x <= 128591)
        || (x >= 128640 && x <= 128764) || (x >= 128992 && x <= 129003) || (x >= 129280 && x <= 129535)
        || (x >= 129648 && x <= 129651) || (x >= 129656 && x <= 129666) || (x >= 129680 && x <= 129685));
}
// -- UTF-8 BOM
var UTF8_BOM_CHARACTER = String.fromCharCode(65279 /* UTF8_BOM */);
function startsWithUTF8BOM(str) {
    return !!(str && str.length > 0 && str.charCodeAt(0) === 65279 /* UTF8_BOM */);
}
function safeBtoa(str) {
    return btoa(encodeURIComponent(str)); // we use encodeURIComponent because btoa fails for non Latin 1 values
}
function repeat(s, count) {
    var result = '';
    for (var i = 0; i < count; i++) {
        result += s;
    }
    return result;
}
function containsUppercaseCharacter(target, ignoreEscapedChars) {
    if (ignoreEscapedChars === void 0) { ignoreEscapedChars = false; }
    if (!target) {
        return false;
    }
    if (ignoreEscapedChars) {
        target = target.replace(/\\./g, '');
    }
    return target.toLowerCase() !== target;
}
/**
 * Produces 'a'-'z', followed by 'A'-'Z'... followed by 'a'-'z', etc.
 */
function singleLetterHash(n) {
    var LETTERS_CNT = (90 /* Z */ - 65 /* A */ + 1);
    n = n % (2 * LETTERS_CNT);
    if (n < LETTERS_CNT) {
        return String.fromCharCode(97 /* a */ + n);
    }
    return String.fromCharCode(65 /* A */ + n - LETTERS_CNT);
}
//#region Unicode Grapheme Break
function getGraphemeBreakType(codePoint) {
    var graphemeBreakTree = GraphemeBreakTree.getInstance();
    return graphemeBreakTree.getGraphemeBreakType(codePoint);
}
function breakBetweenGraphemeBreakType(breakTypeA, breakTypeB) {
    // http://www.unicode.org/reports/tr29/#Grapheme_Cluster_Boundary_Rules
    // !!! Let's make the common case a bit faster
    if (breakTypeA === 0 /* Other */) {
        // see https://www.unicode.org/Public/13.0.0/ucd/auxiliary/GraphemeBreakTest-13.0.0d10.html#table
        return (breakTypeB !== 5 /* Extend */ && breakTypeB !== 7 /* SpacingMark */);
    }
    // Do not break between a CR and LF. Otherwise, break before and after controls.
    // GB3                                        CR  LF
    // GB4                       (Control | CR | LF) 
    // GB5                                            (Control | CR | LF)
    if (breakTypeA === 2 /* CR */) {
        if (breakTypeB === 3 /* LF */) {
            return false; // GB3
        }
    }
    if (breakTypeA === 4 /* Control */ || breakTypeA === 2 /* CR */ || breakTypeA === 3 /* LF */) {
        return true; // GB4
    }
    if (breakTypeB === 4 /* Control */ || breakTypeB === 2 /* CR */ || breakTypeB === 3 /* LF */) {
        return true; // GB5
    }
    // Do not break Hangul syllable sequences.
    // GB6                                         L  (L | V | LV | LVT)
    // GB7                                  (LV | V)  (V | T)
    // GB8                                 (LVT | T)  T
    if (breakTypeA === 8 /* L */) {
        if (breakTypeB === 8 /* L */ || breakTypeB === 9 /* V */ || breakTypeB === 11 /* LV */ || breakTypeB === 12 /* LVT */) {
            return false; // GB6
        }
    }
    if (breakTypeA === 11 /* LV */ || breakTypeA === 9 /* V */) {
        if (breakTypeB === 9 /* V */ || breakTypeB === 10 /* T */) {
            return false; // GB7
        }
    }
    if (breakTypeA === 12 /* LVT */ || breakTypeA === 10 /* T */) {
        if (breakTypeB === 10 /* T */) {
            return false; // GB8
        }
    }
    // Do not break before extending characters or ZWJ.
    // GB9                                            (Extend | ZWJ)
    if (breakTypeB === 5 /* Extend */ || breakTypeB === 13 /* ZWJ */) {
        return false; // GB9
    }
    // The GB9a and GB9b rules only apply to extended grapheme clusters:
    // Do not break before SpacingMarks, or after Prepend characters.
    // GB9a                                           SpacingMark
    // GB9b                                  Prepend 
    if (breakTypeB === 7 /* SpacingMark */) {
        return false; // GB9a
    }
    if (breakTypeA === 1 /* Prepend */) {
        return false; // GB9b
    }
    // Do not break within emoji modifier sequences or emoji zwj sequences.
    // GB11    \p{Extended_Pictographic} Extend* ZWJ  \p{Extended_Pictographic}
    if (breakTypeA === 13 /* ZWJ */ && breakTypeB === 14 /* Extended_Pictographic */) {
        // Note: we are not implementing the rule entirely here to avoid introducing states
        return false; // GB11
    }
    // GB12                          sot (RI RI)* RI  RI
    // GB13                        [^RI] (RI RI)* RI  RI
    if (breakTypeA === 6 /* Regional_Indicator */ && breakTypeB === 6 /* Regional_Indicator */) {
        // Note: we are not implementing the rule entirely here to avoid introducing states
        return false; // GB12 & GB13
    }
    // GB999                                     Any  Any
    return true;
}
var GraphemeBreakTree = /** @class */ (function () {
    function GraphemeBreakTree() {
        this._data = getGraphemeBreakRawData();
    }
    GraphemeBreakTree.getInstance = function () {
        if (!GraphemeBreakTree._INSTANCE) {
            GraphemeBreakTree._INSTANCE = new GraphemeBreakTree();
        }
        return GraphemeBreakTree._INSTANCE;
    };
    GraphemeBreakTree.prototype.getGraphemeBreakType = function (codePoint) {
        // !!! Let's make 7bit ASCII a bit faster: 0..31
        if (codePoint < 32) {
            if (codePoint === 10 /* LineFeed */) {
                return 3 /* LF */;
            }
            if (codePoint === 13 /* CarriageReturn */) {
                return 2 /* CR */;
            }
            return 4 /* Control */;
        }
        // !!! Let's make 7bit ASCII a bit faster: 32..126
        if (codePoint < 127) {
            return 0 /* Other */;
        }
        var data = this._data;
        var nodeCount = data.length / 3;
        var nodeIndex = 1;
        while (nodeIndex <= nodeCount) {
            if (codePoint < data[3 * nodeIndex]) {
                // go left
                nodeIndex = 2 * nodeIndex;
            }
            else if (codePoint > data[3 * nodeIndex + 1]) {
                // go right
                nodeIndex = 2 * nodeIndex + 1;
            }
            else {
                // hit
                return data[3 * nodeIndex + 2];
            }
        }
        return 0 /* Other */;
    };
    GraphemeBreakTree._INSTANCE = null;
    return GraphemeBreakTree;
}());
function getGraphemeBreakRawData() {
    // generated using https://github.com/alexandrudima/unicode-utils/blob/master/generate-grapheme-break.js
    return JSON.parse('[0,0,0,51592,51592,11,44424,44424,11,72251,72254,5,7150,7150,7,48008,48008,11,55176,55176,11,128420,128420,14,3276,3277,5,9979,9980,14,46216,46216,11,49800,49800,11,53384,53384,11,70726,70726,5,122915,122916,5,129320,129327,14,2558,2558,5,5906,5908,5,9762,9763,14,43360,43388,8,45320,45320,11,47112,47112,11,48904,48904,11,50696,50696,11,52488,52488,11,54280,54280,11,70082,70083,1,71350,71350,7,73111,73111,5,127892,127893,14,128726,128727,14,129473,129474,14,2027,2035,5,2901,2902,5,3784,3789,5,6754,6754,5,8418,8420,5,9877,9877,14,11088,11088,14,44008,44008,5,44872,44872,11,45768,45768,11,46664,46664,11,47560,47560,11,48456,48456,11,49352,49352,11,50248,50248,11,51144,51144,11,52040,52040,11,52936,52936,11,53832,53832,11,54728,54728,11,69811,69814,5,70459,70460,5,71096,71099,7,71998,71998,5,72874,72880,5,119149,119149,7,127374,127374,14,128335,128335,14,128482,128482,14,128765,128767,14,129399,129400,14,129680,129685,14,1476,1477,5,2377,2380,7,2759,2760,5,3137,3140,7,3458,3459,7,4153,4154,5,6432,6434,5,6978,6978,5,7675,7679,5,9723,9726,14,9823,9823,14,9919,9923,14,10035,10036,14,42736,42737,5,43596,43596,5,44200,44200,11,44648,44648,11,45096,45096,11,45544,45544,11,45992,45992,11,46440,46440,11,46888,46888,11,47336,47336,11,47784,47784,11,48232,48232,11,48680,48680,11,49128,49128,11,49576,49576,11,50024,50024,11,50472,50472,11,50920,50920,11,51368,51368,11,51816,51816,11,52264,52264,11,52712,52712,11,53160,53160,11,53608,53608,11,54056,54056,11,54504,54504,11,54952,54952,11,68108,68111,5,69933,69940,5,70197,70197,7,70498,70499,7,70845,70845,5,71229,71229,5,71727,71735,5,72154,72155,5,72344,72345,5,73023,73029,5,94095,94098,5,121403,121452,5,126981,127182,14,127538,127546,14,127990,127990,14,128391,128391,14,128445,128449,14,128500,128505,14,128752,128752,14,129160,129167,14,129356,129356,14,129432,129442,14,129648,129651,14,129751,131069,14,173,173,4,1757,1757,1,2274,2274,1,2494,2494,5,2641,2641,5,2876,2876,5,3014,3016,7,3262,3262,7,3393,3396,5,3570,3571,7,3968,3972,5,4228,4228,7,6086,6086,5,6679,6680,5,6912,6915,5,7080,7081,5,7380,7392,5,8252,8252,14,9096,9096,14,9748,9749,14,9784,9786,14,9833,9850,14,9890,9894,14,9938,9938,14,9999,9999,14,10085,10087,14,12349,12349,14,43136,43137,7,43454,43456,7,43755,43755,7,44088,44088,11,44312,44312,11,44536,44536,11,44760,44760,11,44984,44984,11,45208,45208,11,45432,45432,11,45656,45656,11,45880,45880,11,46104,46104,11,46328,46328,11,46552,46552,11,46776,46776,11,47000,47000,11,47224,47224,11,47448,47448,11,47672,47672,11,47896,47896,11,48120,48120,11,48344,48344,11,48568,48568,11,48792,48792,11,49016,49016,11,49240,49240,11,49464,49464,11,49688,49688,11,49912,49912,11,50136,50136,11,50360,50360,11,50584,50584,11,50808,50808,11,51032,51032,11,51256,51256,11,51480,51480,11,51704,51704,11,51928,51928,11,52152,52152,11,52376,52376,11,52600,52600,11,52824,52824,11,53048,53048,11,53272,53272,11,53496,53496,11,53720,53720,11,53944,53944,11,54168,54168,11,54392,54392,11,54616,54616,11,54840,54840,11,55064,55064,11,65438,65439,5,69633,69633,5,69837,69837,1,70018,70018,7,70188,70190,7,70368,70370,7,70465,70468,7,70712,70719,5,70835,70840,5,70850,70851,5,71132,71133,5,71340,71340,7,71458,71461,5,71985,71989,7,72002,72002,7,72193,72202,5,72281,72283,5,72766,72766,7,72885,72886,5,73104,73105,5,92912,92916,5,113824,113827,4,119173,119179,5,121505,121519,5,125136,125142,5,127279,127279,14,127489,127490,14,127570,127743,14,127900,127901,14,128254,128254,14,128369,128370,14,128400,128400,14,128425,128432,14,128468,128475,14,128489,128494,14,128715,128720,14,128745,128745,14,128759,128760,14,129004,129023,14,129296,129304,14,129340,129342,14,129388,129392,14,129404,129407,14,129454,129455,14,129485,129487,14,129659,129663,14,129719,129727,14,917536,917631,5,13,13,2,1160,1161,5,1564,1564,4,1807,1807,1,2085,2087,5,2363,2363,7,2402,2403,5,2507,2508,7,2622,2624,7,2691,2691,7,2786,2787,5,2881,2884,5,3006,3006,5,3072,3072,5,3170,3171,5,3267,3268,7,3330,3331,7,3406,3406,1,3538,3540,5,3655,3662,5,3897,3897,5,4038,4038,5,4184,4185,5,4352,4447,8,6068,6069,5,6155,6157,5,6448,6449,7,6742,6742,5,6783,6783,5,6966,6970,5,7042,7042,7,7143,7143,7,7212,7219,5,7412,7412,5,8206,8207,4,8294,8303,4,8596,8601,14,9410,9410,14,9742,9742,14,9757,9757,14,9770,9770,14,9794,9794,14,9828,9828,14,9855,9855,14,9882,9882,14,9900,9903,14,9929,9933,14,9963,9967,14,9987,9988,14,10006,10006,14,10062,10062,14,10175,10175,14,11744,11775,5,42607,42607,5,43043,43044,7,43263,43263,5,43444,43445,7,43569,43570,5,43698,43700,5,43766,43766,5,44032,44032,11,44144,44144,11,44256,44256,11,44368,44368,11,44480,44480,11,44592,44592,11,44704,44704,11,44816,44816,11,44928,44928,11,45040,45040,11,45152,45152,11,45264,45264,11,45376,45376,11,45488,45488,11,45600,45600,11,45712,45712,11,45824,45824,11,45936,45936,11,46048,46048,11,46160,46160,11,46272,46272,11,46384,46384,11,46496,46496,11,46608,46608,11,46720,46720,11,46832,46832,11,46944,46944,11,47056,47056,11,47168,47168,11,47280,47280,11,47392,47392,11,47504,47504,11,47616,47616,11,47728,47728,11,47840,47840,11,47952,47952,11,48064,48064,11,48176,48176,11,48288,48288,11,48400,48400,11,48512,48512,11,48624,48624,11,48736,48736,11,48848,48848,11,48960,48960,11,49072,49072,11,49184,49184,11,49296,49296,11,49408,49408,11,49520,49520,11,49632,49632,11,49744,49744,11,49856,49856,11,49968,49968,11,50080,50080,11,50192,50192,11,50304,50304,11,50416,50416,11,50528,50528,11,50640,50640,11,50752,50752,11,50864,50864,11,50976,50976,11,51088,51088,11,51200,51200,11,51312,51312,11,51424,51424,11,51536,51536,11,51648,51648,11,51760,51760,11,51872,51872,11,51984,51984,11,52096,52096,11,52208,52208,11,52320,52320,11,52432,52432,11,52544,52544,11,52656,52656,11,52768,52768,11,52880,52880,11,52992,52992,11,53104,53104,11,53216,53216,11,53328,53328,11,53440,53440,11,53552,53552,11,53664,53664,11,53776,53776,11,53888,53888,11,54000,54000,11,54112,54112,11,54224,54224,11,54336,54336,11,54448,54448,11,54560,54560,11,54672,54672,11,54784,54784,11,54896,54896,11,55008,55008,11,55120,55120,11,64286,64286,5,66272,66272,5,68900,68903,5,69762,69762,7,69817,69818,5,69927,69931,5,70003,70003,5,70070,70078,5,70094,70094,7,70194,70195,7,70206,70206,5,70400,70401,5,70463,70463,7,70475,70477,7,70512,70516,5,70722,70724,5,70832,70832,5,70842,70842,5,70847,70848,5,71088,71089,7,71102,71102,7,71219,71226,5,71231,71232,5,71342,71343,7,71453,71455,5,71463,71467,5,71737,71738,5,71995,71996,5,72000,72000,7,72145,72147,7,72160,72160,5,72249,72249,7,72273,72278,5,72330,72342,5,72752,72758,5,72850,72871,5,72882,72883,5,73018,73018,5,73031,73031,5,73109,73109,5,73461,73462,7,94031,94031,5,94192,94193,7,119142,119142,7,119155,119162,4,119362,119364,5,121476,121476,5,122888,122904,5,123184,123190,5,126976,126979,14,127184,127231,14,127344,127345,14,127405,127461,14,127514,127514,14,127561,127567,14,127778,127779,14,127896,127896,14,127985,127986,14,127995,127999,5,128326,128328,14,128360,128366,14,128378,128378,14,128394,128397,14,128405,128406,14,128422,128423,14,128435,128443,14,128453,128464,14,128479,128480,14,128484,128487,14,128496,128498,14,128640,128709,14,128723,128724,14,128736,128741,14,128747,128748,14,128755,128755,14,128762,128762,14,128981,128991,14,129096,129103,14,129292,129292,14,129311,129311,14,129329,129330,14,129344,129349,14,129360,129374,14,129394,129394,14,129402,129402,14,129413,129425,14,129445,129450,14,129466,129471,14,129483,129483,14,129511,129535,14,129653,129655,14,129667,129670,14,129705,129711,14,129731,129743,14,917505,917505,4,917760,917999,5,10,10,3,127,159,4,768,879,5,1471,1471,5,1536,1541,1,1648,1648,5,1767,1768,5,1840,1866,5,2070,2073,5,2137,2139,5,2307,2307,7,2366,2368,7,2382,2383,7,2434,2435,7,2497,2500,5,2519,2519,5,2563,2563,7,2631,2632,5,2677,2677,5,2750,2752,7,2763,2764,7,2817,2817,5,2879,2879,5,2891,2892,7,2914,2915,5,3008,3008,5,3021,3021,5,3076,3076,5,3146,3149,5,3202,3203,7,3264,3265,7,3271,3272,7,3298,3299,5,3390,3390,5,3402,3404,7,3426,3427,5,3535,3535,5,3544,3550,7,3635,3635,7,3763,3763,7,3893,3893,5,3953,3966,5,3981,3991,5,4145,4145,7,4157,4158,5,4209,4212,5,4237,4237,5,4520,4607,10,5970,5971,5,6071,6077,5,6089,6099,5,6277,6278,5,6439,6440,5,6451,6456,7,6683,6683,5,6744,6750,5,6765,6770,7,6846,6846,5,6964,6964,5,6972,6972,5,7019,7027,5,7074,7077,5,7083,7085,5,7146,7148,7,7154,7155,7,7222,7223,5,7394,7400,5,7416,7417,5,8204,8204,5,8233,8233,4,8288,8292,4,8413,8416,5,8482,8482,14,8986,8987,14,9193,9203,14,9654,9654,14,9733,9733,14,9745,9745,14,9752,9752,14,9760,9760,14,9766,9766,14,9774,9775,14,9792,9792,14,9800,9811,14,9825,9826,14,9831,9831,14,9852,9853,14,9872,9873,14,9880,9880,14,9885,9887,14,9896,9897,14,9906,9916,14,9926,9927,14,9936,9936,14,9941,9960,14,9974,9974,14,9982,9985,14,9992,9997,14,10002,10002,14,10017,10017,14,10055,10055,14,10071,10071,14,10145,10145,14,11013,11015,14,11503,11505,5,12334,12335,5,12951,12951,14,42612,42621,5,43014,43014,5,43047,43047,7,43204,43205,5,43335,43345,5,43395,43395,7,43450,43451,7,43561,43566,5,43573,43574,5,43644,43644,5,43710,43711,5,43758,43759,7,44005,44005,5,44012,44012,7,44060,44060,11,44116,44116,11,44172,44172,11,44228,44228,11,44284,44284,11,44340,44340,11,44396,44396,11,44452,44452,11,44508,44508,11,44564,44564,11,44620,44620,11,44676,44676,11,44732,44732,11,44788,44788,11,44844,44844,11,44900,44900,11,44956,44956,11,45012,45012,11,45068,45068,11,45124,45124,11,45180,45180,11,45236,45236,11,45292,45292,11,45348,45348,11,45404,45404,11,45460,45460,11,45516,45516,11,45572,45572,11,45628,45628,11,45684,45684,11,45740,45740,11,45796,45796,11,45852,45852,11,45908,45908,11,45964,45964,11,46020,46020,11,46076,46076,11,46132,46132,11,46188,46188,11,46244,46244,11,46300,46300,11,46356,46356,11,46412,46412,11,46468,46468,11,46524,46524,11,46580,46580,11,46636,46636,11,46692,46692,11,46748,46748,11,46804,46804,11,46860,46860,11,46916,46916,11,46972,46972,11,47028,47028,11,47084,47084,11,47140,47140,11,47196,47196,11,47252,47252,11,47308,47308,11,47364,47364,11,47420,47420,11,47476,47476,11,47532,47532,11,47588,47588,11,47644,47644,11,47700,47700,11,47756,47756,11,47812,47812,11,47868,47868,11,47924,47924,11,47980,47980,11,48036,48036,11,48092,48092,11,48148,48148,11,48204,48204,11,48260,48260,11,48316,48316,11,48372,48372,11,48428,48428,11,48484,48484,11,48540,48540,11,48596,48596,11,48652,48652,11,48708,48708,11,48764,48764,11,48820,48820,11,48876,48876,11,48932,48932,11,48988,48988,11,49044,49044,11,49100,49100,11,49156,49156,11,49212,49212,11,49268,49268,11,49324,49324,11,49380,49380,11,49436,49436,11,49492,49492,11,49548,49548,11,49604,49604,11,49660,49660,11,49716,49716,11,49772,49772,11,49828,49828,11,49884,49884,11,49940,49940,11,49996,49996,11,50052,50052,11,50108,50108,11,50164,50164,11,50220,50220,11,50276,50276,11,50332,50332,11,50388,50388,11,50444,50444,11,50500,50500,11,50556,50556,11,50612,50612,11,50668,50668,11,50724,50724,11,50780,50780,11,50836,50836,11,50892,50892,11,50948,50948,11,51004,51004,11,51060,51060,11,51116,51116,11,51172,51172,11,51228,51228,11,51284,51284,11,51340,51340,11,51396,51396,11,51452,51452,11,51508,51508,11,51564,51564,11,51620,51620,11,51676,51676,11,51732,51732,11,51788,51788,11,51844,51844,11,51900,51900,11,51956,51956,11,52012,52012,11,52068,52068,11,52124,52124,11,52180,52180,11,52236,52236,11,52292,52292,11,52348,52348,11,52404,52404,11,52460,52460,11,52516,52516,11,52572,52572,11,52628,52628,11,52684,52684,11,52740,52740,11,52796,52796,11,52852,52852,11,52908,52908,11,52964,52964,11,53020,53020,11,53076,53076,11,53132,53132,11,53188,53188,11,53244,53244,11,53300,53300,11,53356,53356,11,53412,53412,11,53468,53468,11,53524,53524,11,53580,53580,11,53636,53636,11,53692,53692,11,53748,53748,11,53804,53804,11,53860,53860,11,53916,53916,11,53972,53972,11,54028,54028,11,54084,54084,11,54140,54140,11,54196,54196,11,54252,54252,11,54308,54308,11,54364,54364,11,54420,54420,11,54476,54476,11,54532,54532,11,54588,54588,11,54644,54644,11,54700,54700,11,54756,54756,11,54812,54812,11,54868,54868,11,54924,54924,11,54980,54980,11,55036,55036,11,55092,55092,11,55148,55148,11,55216,55238,9,65056,65071,5,65529,65531,4,68097,68099,5,68159,68159,5,69446,69456,5,69688,69702,5,69808,69810,7,69815,69816,7,69821,69821,1,69888,69890,5,69932,69932,7,69957,69958,7,70016,70017,5,70067,70069,7,70079,70080,7,70089,70092,5,70095,70095,5,70191,70193,5,70196,70196,5,70198,70199,5,70367,70367,5,70371,70378,5,70402,70403,7,70462,70462,5,70464,70464,5,70471,70472,7,70487,70487,5,70502,70508,5,70709,70711,7,70720,70721,7,70725,70725,7,70750,70750,5,70833,70834,7,70841,70841,7,70843,70844,7,70846,70846,7,70849,70849,7,71087,71087,5,71090,71093,5,71100,71101,5,71103,71104,5,71216,71218,7,71227,71228,7,71230,71230,7,71339,71339,5,71341,71341,5,71344,71349,5,71351,71351,5,71456,71457,7,71462,71462,7,71724,71726,7,71736,71736,7,71984,71984,5,71991,71992,7,71997,71997,7,71999,71999,1,72001,72001,1,72003,72003,5,72148,72151,5,72156,72159,7,72164,72164,7,72243,72248,5,72250,72250,1,72263,72263,5,72279,72280,7,72324,72329,1,72343,72343,7,72751,72751,7,72760,72765,5,72767,72767,5,72873,72873,7,72881,72881,7,72884,72884,7,73009,73014,5,73020,73021,5,73030,73030,1,73098,73102,7,73107,73108,7,73110,73110,7,73459,73460,5,78896,78904,4,92976,92982,5,94033,94087,7,94180,94180,5,113821,113822,5,119141,119141,5,119143,119145,5,119150,119154,5,119163,119170,5,119210,119213,5,121344,121398,5,121461,121461,5,121499,121503,5,122880,122886,5,122907,122913,5,122918,122922,5,123628,123631,5,125252,125258,5,126980,126980,14,127183,127183,14,127245,127247,14,127340,127343,14,127358,127359,14,127377,127386,14,127462,127487,6,127491,127503,14,127535,127535,14,127548,127551,14,127568,127569,14,127744,127777,14,127780,127891,14,127894,127895,14,127897,127899,14,127902,127984,14,127987,127989,14,127991,127994,14,128000,128253,14,128255,128317,14,128329,128334,14,128336,128359,14,128367,128368,14,128371,128377,14,128379,128390,14,128392,128393,14,128398,128399,14,128401,128404,14,128407,128419,14,128421,128421,14,128424,128424,14,128433,128434,14,128444,128444,14,128450,128452,14,128465,128467,14,128476,128478,14,128481,128481,14,128483,128483,14,128488,128488,14,128495,128495,14,128499,128499,14,128506,128591,14,128710,128714,14,128721,128722,14,128725,128725,14,128728,128735,14,128742,128744,14,128746,128746,14,128749,128751,14,128753,128754,14,128756,128758,14,128761,128761,14,128763,128764,14,128884,128895,14,128992,129003,14,129036,129039,14,129114,129119,14,129198,129279,14,129293,129295,14,129305,129310,14,129312,129319,14,129328,129328,14,129331,129338,14,129343,129343,14,129351,129355,14,129357,129359,14,129375,129387,14,129393,129393,14,129395,129398,14,129401,129401,14,129403,129403,14,129408,129412,14,129426,129431,14,129443,129444,14,129451,129453,14,129456,129465,14,129472,129472,14,129475,129482,14,129484,129484,14,129488,129510,14,129536,129647,14,129652,129652,14,129656,129658,14,129664,129666,14,129671,129679,14,129686,129704,14,129712,129718,14,129728,129730,14,129744,129750,14,917504,917504,4,917506,917535,4,917632,917759,4,918000,921599,4,0,9,4,11,12,4,14,31,4,169,169,14,174,174,14,1155,1159,5,1425,1469,5,1473,1474,5,1479,1479,5,1552,1562,5,1611,1631,5,1750,1756,5,1759,1764,5,1770,1773,5,1809,1809,5,1958,1968,5,2045,2045,5,2075,2083,5,2089,2093,5,2259,2273,5,2275,2306,5,2362,2362,5,2364,2364,5,2369,2376,5,2381,2381,5,2385,2391,5,2433,2433,5,2492,2492,5,2495,2496,7,2503,2504,7,2509,2509,5,2530,2531,5,2561,2562,5,2620,2620,5,2625,2626,5,2635,2637,5,2672,2673,5,2689,2690,5,2748,2748,5,2753,2757,5,2761,2761,7,2765,2765,5,2810,2815,5,2818,2819,7,2878,2878,5,2880,2880,7,2887,2888,7,2893,2893,5,2903,2903,5,2946,2946,5,3007,3007,7,3009,3010,7,3018,3020,7,3031,3031,5,3073,3075,7,3134,3136,5,3142,3144,5,3157,3158,5,3201,3201,5,3260,3260,5,3263,3263,5,3266,3266,5,3270,3270,5,3274,3275,7,3285,3286,5,3328,3329,5,3387,3388,5,3391,3392,7,3398,3400,7,3405,3405,5,3415,3415,5,3457,3457,5,3530,3530,5,3536,3537,7,3542,3542,5,3551,3551,5,3633,3633,5,3636,3642,5,3761,3761,5,3764,3772,5,3864,3865,5,3895,3895,5,3902,3903,7,3967,3967,7,3974,3975,5,3993,4028,5,4141,4144,5,4146,4151,5,4155,4156,7,4182,4183,7,4190,4192,5,4226,4226,5,4229,4230,5,4253,4253,5,4448,4519,9,4957,4959,5,5938,5940,5,6002,6003,5,6070,6070,7,6078,6085,7,6087,6088,7,6109,6109,5,6158,6158,4,6313,6313,5,6435,6438,7,6441,6443,7,6450,6450,5,6457,6459,5,6681,6682,7,6741,6741,7,6743,6743,7,6752,6752,5,6757,6764,5,6771,6780,5,6832,6845,5,6847,6848,5,6916,6916,7,6965,6965,5,6971,6971,7,6973,6977,7,6979,6980,7,7040,7041,5,7073,7073,7,7078,7079,7,7082,7082,7,7142,7142,5,7144,7145,5,7149,7149,5,7151,7153,5,7204,7211,7,7220,7221,7,7376,7378,5,7393,7393,7,7405,7405,5,7415,7415,7,7616,7673,5,8203,8203,4,8205,8205,13,8232,8232,4,8234,8238,4,8265,8265,14,8293,8293,4,8400,8412,5,8417,8417,5,8421,8432,5,8505,8505,14,8617,8618,14,9000,9000,14,9167,9167,14,9208,9210,14,9642,9643,14,9664,9664,14,9728,9732,14,9735,9741,14,9743,9744,14,9746,9746,14,9750,9751,14,9753,9756,14,9758,9759,14,9761,9761,14,9764,9765,14,9767,9769,14,9771,9773,14,9776,9783,14,9787,9791,14,9793,9793,14,9795,9799,14,9812,9822,14,9824,9824,14,9827,9827,14,9829,9830,14,9832,9832,14,9851,9851,14,9854,9854,14,9856,9861,14,9874,9876,14,9878,9879,14,9881,9881,14,9883,9884,14,9888,9889,14,9895,9895,14,9898,9899,14,9904,9905,14,9917,9918,14,9924,9925,14,9928,9928,14,9934,9935,14,9937,9937,14,9939,9940,14,9961,9962,14,9968,9973,14,9975,9978,14,9981,9981,14,9986,9986,14,9989,9989,14,9998,9998,14,10000,10001,14,10004,10004,14,10013,10013,14,10024,10024,14,10052,10052,14,10060,10060,14,10067,10069,14,10083,10084,14,10133,10135,14,10160,10160,14,10548,10549,14,11035,11036,14,11093,11093,14,11647,11647,5,12330,12333,5,12336,12336,14,12441,12442,5,12953,12953,14,42608,42610,5,42654,42655,5,43010,43010,5,43019,43019,5,43045,43046,5,43052,43052,5,43188,43203,7,43232,43249,5,43302,43309,5,43346,43347,7,43392,43394,5,43443,43443,5,43446,43449,5,43452,43453,5,43493,43493,5,43567,43568,7,43571,43572,7,43587,43587,5,43597,43597,7,43696,43696,5,43703,43704,5,43713,43713,5,43756,43757,5,43765,43765,7,44003,44004,7,44006,44007,7,44009,44010,7,44013,44013,5,44033,44059,12,44061,44087,12,44089,44115,12,44117,44143,12,44145,44171,12,44173,44199,12,44201,44227,12,44229,44255,12,44257,44283,12,44285,44311,12,44313,44339,12,44341,44367,12,44369,44395,12,44397,44423,12,44425,44451,12,44453,44479,12,44481,44507,12,44509,44535,12,44537,44563,12,44565,44591,12,44593,44619,12,44621,44647,12,44649,44675,12,44677,44703,12,44705,44731,12,44733,44759,12,44761,44787,12,44789,44815,12,44817,44843,12,44845,44871,12,44873,44899,12,44901,44927,12,44929,44955,12,44957,44983,12,44985,45011,12,45013,45039,12,45041,45067,12,45069,45095,12,45097,45123,12,45125,45151,12,45153,45179,12,45181,45207,12,45209,45235,12,45237,45263,12,45265,45291,12,45293,45319,12,45321,45347,12,45349,45375,12,45377,45403,12,45405,45431,12,45433,45459,12,45461,45487,12,45489,45515,12,45517,45543,12,45545,45571,12,45573,45599,12,45601,45627,12,45629,45655,12,45657,45683,12,45685,45711,12,45713,45739,12,45741,45767,12,45769,45795,12,45797,45823,12,45825,45851,12,45853,45879,12,45881,45907,12,45909,45935,12,45937,45963,12,45965,45991,12,45993,46019,12,46021,46047,12,46049,46075,12,46077,46103,12,46105,46131,12,46133,46159,12,46161,46187,12,46189,46215,12,46217,46243,12,46245,46271,12,46273,46299,12,46301,46327,12,46329,46355,12,46357,46383,12,46385,46411,12,46413,46439,12,46441,46467,12,46469,46495,12,46497,46523,12,46525,46551,12,46553,46579,12,46581,46607,12,46609,46635,12,46637,46663,12,46665,46691,12,46693,46719,12,46721,46747,12,46749,46775,12,46777,46803,12,46805,46831,12,46833,46859,12,46861,46887,12,46889,46915,12,46917,46943,12,46945,46971,12,46973,46999,12,47001,47027,12,47029,47055,12,47057,47083,12,47085,47111,12,47113,47139,12,47141,47167,12,47169,47195,12,47197,47223,12,47225,47251,12,47253,47279,12,47281,47307,12,47309,47335,12,47337,47363,12,47365,47391,12,47393,47419,12,47421,47447,12,47449,47475,12,47477,47503,12,47505,47531,12,47533,47559,12,47561,47587,12,47589,47615,12,47617,47643,12,47645,47671,12,47673,47699,12,47701,47727,12,47729,47755,12,47757,47783,12,47785,47811,12,47813,47839,12,47841,47867,12,47869,47895,12,47897,47923,12,47925,47951,12,47953,47979,12,47981,48007,12,48009,48035,12,48037,48063,12,48065,48091,12,48093,48119,12,48121,48147,12,48149,48175,12,48177,48203,12,48205,48231,12,48233,48259,12,48261,48287,12,48289,48315,12,48317,48343,12,48345,48371,12,48373,48399,12,48401,48427,12,48429,48455,12,48457,48483,12,48485,48511,12,48513,48539,12,48541,48567,12,48569,48595,12,48597,48623,12,48625,48651,12,48653,48679,12,48681,48707,12,48709,48735,12,48737,48763,12,48765,48791,12,48793,48819,12,48821,48847,12,48849,48875,12,48877,48903,12,48905,48931,12,48933,48959,12,48961,48987,12,48989,49015,12,49017,49043,12,49045,49071,12,49073,49099,12,49101,49127,12,49129,49155,12,49157,49183,12,49185,49211,12,49213,49239,12,49241,49267,12,49269,49295,12,49297,49323,12,49325,49351,12,49353,49379,12,49381,49407,12,49409,49435,12,49437,49463,12,49465,49491,12,49493,49519,12,49521,49547,12,49549,49575,12,49577,49603,12,49605,49631,12,49633,49659,12,49661,49687,12,49689,49715,12,49717,49743,12,49745,49771,12,49773,49799,12,49801,49827,12,49829,49855,12,49857,49883,12,49885,49911,12,49913,49939,12,49941,49967,12,49969,49995,12,49997,50023,12,50025,50051,12,50053,50079,12,50081,50107,12,50109,50135,12,50137,50163,12,50165,50191,12,50193,50219,12,50221,50247,12,50249,50275,12,50277,50303,12,50305,50331,12,50333,50359,12,50361,50387,12,50389,50415,12,50417,50443,12,50445,50471,12,50473,50499,12,50501,50527,12,50529,50555,12,50557,50583,12,50585,50611,12,50613,50639,12,50641,50667,12,50669,50695,12,50697,50723,12,50725,50751,12,50753,50779,12,50781,50807,12,50809,50835,12,50837,50863,12,50865,50891,12,50893,50919,12,50921,50947,12,50949,50975,12,50977,51003,12,51005,51031,12,51033,51059,12,51061,51087,12,51089,51115,12,51117,51143,12,51145,51171,12,51173,51199,12,51201,51227,12,51229,51255,12,51257,51283,12,51285,51311,12,51313,51339,12,51341,51367,12,51369,51395,12,51397,51423,12,51425,51451,12,51453,51479,12,51481,51507,12,51509,51535,12,51537,51563,12,51565,51591,12,51593,51619,12,51621,51647,12,51649,51675,12,51677,51703,12,51705,51731,12,51733,51759,12,51761,51787,12,51789,51815,12,51817,51843,12,51845,51871,12,51873,51899,12,51901,51927,12,51929,51955,12,51957,51983,12,51985,52011,12,52013,52039,12,52041,52067,12,52069,52095,12,52097,52123,12,52125,52151,12,52153,52179,12,52181,52207,12,52209,52235,12,52237,52263,12,52265,52291,12,52293,52319,12,52321,52347,12,52349,52375,12,52377,52403,12,52405,52431,12,52433,52459,12,52461,52487,12,52489,52515,12,52517,52543,12,52545,52571,12,52573,52599,12,52601,52627,12,52629,52655,12,52657,52683,12,52685,52711,12,52713,52739,12,52741,52767,12,52769,52795,12,52797,52823,12,52825,52851,12,52853,52879,12,52881,52907,12,52909,52935,12,52937,52963,12,52965,52991,12,52993,53019,12,53021,53047,12,53049,53075,12,53077,53103,12,53105,53131,12,53133,53159,12,53161,53187,12,53189,53215,12,53217,53243,12,53245,53271,12,53273,53299,12,53301,53327,12,53329,53355,12,53357,53383,12,53385,53411,12,53413,53439,12,53441,53467,12,53469,53495,12,53497,53523,12,53525,53551,12,53553,53579,12,53581,53607,12,53609,53635,12,53637,53663,12,53665,53691,12,53693,53719,12,53721,53747,12,53749,53775,12,53777,53803,12,53805,53831,12,53833,53859,12,53861,53887,12,53889,53915,12,53917,53943,12,53945,53971,12,53973,53999,12,54001,54027,12,54029,54055,12,54057,54083,12,54085,54111,12,54113,54139,12,54141,54167,12,54169,54195,12,54197,54223,12,54225,54251,12,54253,54279,12,54281,54307,12,54309,54335,12,54337,54363,12,54365,54391,12,54393,54419,12,54421,54447,12,54449,54475,12,54477,54503,12,54505,54531,12,54533,54559,12,54561,54587,12,54589,54615,12,54617,54643,12,54645,54671,12,54673,54699,12,54701,54727,12,54729,54755,12,54757,54783,12,54785,54811,12,54813,54839,12,54841,54867,12,54869,54895,12,54897,54923,12,54925,54951,12,54953,54979,12,54981,55007,12,55009,55035,12,55037,55063,12,55065,55091,12,55093,55119,12,55121,55147,12,55149,55175,12,55177,55203,12,55243,55291,10,65024,65039,5,65279,65279,4,65520,65528,4,66045,66045,5,66422,66426,5,68101,68102,5,68152,68154,5,68325,68326,5,69291,69292,5,69632,69632,7,69634,69634,7,69759,69761,5]');
}
//#endregion

// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/editor/common/diff/diffComputer.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


var MINIMUM_MATCHING_CHARACTER_LENGTH = 3;
function computeDiff(originalSequence, modifiedSequence, continueProcessingPredicate, pretty) {
    var diffAlgo = new diff_LcsDiff(originalSequence, modifiedSequence, continueProcessingPredicate);
    return diffAlgo.ComputeDiff(pretty);
}
var LineSequence = /** @class */ (function () {
    function LineSequence(lines) {
        var startColumns = [];
        var endColumns = [];
        for (var i = 0, length_1 = lines.length; i < length_1; i++) {
            startColumns[i] = getFirstNonBlankColumn(lines[i], 1);
            endColumns[i] = getLastNonBlankColumn(lines[i], 1);
        }
        this.lines = lines;
        this._startColumns = startColumns;
        this._endColumns = endColumns;
    }
    LineSequence.prototype.getElements = function () {
        var elements = [];
        for (var i = 0, len = this.lines.length; i < len; i++) {
            elements[i] = this.lines[i].substring(this._startColumns[i] - 1, this._endColumns[i] - 1);
        }
        return elements;
    };
    LineSequence.prototype.getStartLineNumber = function (i) {
        return i + 1;
    };
    LineSequence.prototype.getEndLineNumber = function (i) {
        return i + 1;
    };
    LineSequence.prototype.createCharSequence = function (shouldIgnoreTrimWhitespace, startIndex, endIndex) {
        var charCodes = [];
        var lineNumbers = [];
        var columns = [];
        var len = 0;
        for (var index = startIndex; index <= endIndex; index++) {
            var lineContent = this.lines[index];
            var startColumn = (shouldIgnoreTrimWhitespace ? this._startColumns[index] : 1);
            var endColumn = (shouldIgnoreTrimWhitespace ? this._endColumns[index] : lineContent.length + 1);
            for (var col = startColumn; col < endColumn; col++) {
                charCodes[len] = lineContent.charCodeAt(col - 1);
                lineNumbers[len] = index + 1;
                columns[len] = col;
                len++;
            }
        }
        return new CharSequence(charCodes, lineNumbers, columns);
    };
    return LineSequence;
}());
var CharSequence = /** @class */ (function () {
    function CharSequence(charCodes, lineNumbers, columns) {
        this._charCodes = charCodes;
        this._lineNumbers = lineNumbers;
        this._columns = columns;
    }
    CharSequence.prototype.getElements = function () {
        return this._charCodes;
    };
    CharSequence.prototype.getStartLineNumber = function (i) {
        return this._lineNumbers[i];
    };
    CharSequence.prototype.getStartColumn = function (i) {
        return this._columns[i];
    };
    CharSequence.prototype.getEndLineNumber = function (i) {
        return this._lineNumbers[i];
    };
    CharSequence.prototype.getEndColumn = function (i) {
        return this._columns[i] + 1;
    };
    return CharSequence;
}());
var CharChange = /** @class */ (function () {
    function CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn) {
        this.originalStartLineNumber = originalStartLineNumber;
        this.originalStartColumn = originalStartColumn;
        this.originalEndLineNumber = originalEndLineNumber;
        this.originalEndColumn = originalEndColumn;
        this.modifiedStartLineNumber = modifiedStartLineNumber;
        this.modifiedStartColumn = modifiedStartColumn;
        this.modifiedEndLineNumber = modifiedEndLineNumber;
        this.modifiedEndColumn = modifiedEndColumn;
    }
    CharChange.createFromDiffChange = function (diffChange, originalCharSequence, modifiedCharSequence) {
        var originalStartLineNumber;
        var originalStartColumn;
        var originalEndLineNumber;
        var originalEndColumn;
        var modifiedStartLineNumber;
        var modifiedStartColumn;
        var modifiedEndLineNumber;
        var modifiedEndColumn;
        if (diffChange.originalLength === 0) {
            originalStartLineNumber = 0;
            originalStartColumn = 0;
            originalEndLineNumber = 0;
            originalEndColumn = 0;
        }
        else {
            originalStartLineNumber = originalCharSequence.getStartLineNumber(diffChange.originalStart);
            originalStartColumn = originalCharSequence.getStartColumn(diffChange.originalStart);
            originalEndLineNumber = originalCharSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
            originalEndColumn = originalCharSequence.getEndColumn(diffChange.originalStart + diffChange.originalLength - 1);
        }
        if (diffChange.modifiedLength === 0) {
            modifiedStartLineNumber = 0;
            modifiedStartColumn = 0;
            modifiedEndLineNumber = 0;
            modifiedEndColumn = 0;
        }
        else {
            modifiedStartLineNumber = modifiedCharSequence.getStartLineNumber(diffChange.modifiedStart);
            modifiedStartColumn = modifiedCharSequence.getStartColumn(diffChange.modifiedStart);
            modifiedEndLineNumber = modifiedCharSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
            modifiedEndColumn = modifiedCharSequence.getEndColumn(diffChange.modifiedStart + diffChange.modifiedLength - 1);
        }
        return new CharChange(originalStartLineNumber, originalStartColumn, originalEndLineNumber, originalEndColumn, modifiedStartLineNumber, modifiedStartColumn, modifiedEndLineNumber, modifiedEndColumn);
    };
    return CharChange;
}());
function postProcessCharChanges(rawChanges) {
    if (rawChanges.length <= 1) {
        return rawChanges;
    }
    var result = [rawChanges[0]];
    var prevChange = result[0];
    for (var i = 1, len = rawChanges.length; i < len; i++) {
        var currChange = rawChanges[i];
        var originalMatchingLength = currChange.originalStart - (prevChange.originalStart + prevChange.originalLength);
        var modifiedMatchingLength = currChange.modifiedStart - (prevChange.modifiedStart + prevChange.modifiedLength);
        // Both of the above should be equal, but the continueProcessingPredicate may prevent this from being true
        var matchingLength = Math.min(originalMatchingLength, modifiedMatchingLength);
        if (matchingLength < MINIMUM_MATCHING_CHARACTER_LENGTH) {
            // Merge the current change into the previous one
            prevChange.originalLength = (currChange.originalStart + currChange.originalLength) - prevChange.originalStart;
            prevChange.modifiedLength = (currChange.modifiedStart + currChange.modifiedLength) - prevChange.modifiedStart;
        }
        else {
            // Add the current change
            result.push(currChange);
            prevChange = currChange;
        }
    }
    return result;
}
var LineChange = /** @class */ (function () {
    function LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges) {
        this.originalStartLineNumber = originalStartLineNumber;
        this.originalEndLineNumber = originalEndLineNumber;
        this.modifiedStartLineNumber = modifiedStartLineNumber;
        this.modifiedEndLineNumber = modifiedEndLineNumber;
        this.charChanges = charChanges;
    }
    LineChange.createFromDiffResult = function (shouldIgnoreTrimWhitespace, diffChange, originalLineSequence, modifiedLineSequence, continueCharDiff, shouldComputeCharChanges, shouldPostProcessCharChanges) {
        var originalStartLineNumber;
        var originalEndLineNumber;
        var modifiedStartLineNumber;
        var modifiedEndLineNumber;
        var charChanges = undefined;
        if (diffChange.originalLength === 0) {
            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart) - 1;
            originalEndLineNumber = 0;
        }
        else {
            originalStartLineNumber = originalLineSequence.getStartLineNumber(diffChange.originalStart);
            originalEndLineNumber = originalLineSequence.getEndLineNumber(diffChange.originalStart + diffChange.originalLength - 1);
        }
        if (diffChange.modifiedLength === 0) {
            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart) - 1;
            modifiedEndLineNumber = 0;
        }
        else {
            modifiedStartLineNumber = modifiedLineSequence.getStartLineNumber(diffChange.modifiedStart);
            modifiedEndLineNumber = modifiedLineSequence.getEndLineNumber(diffChange.modifiedStart + diffChange.modifiedLength - 1);
        }
        if (shouldComputeCharChanges && diffChange.originalLength > 0 && diffChange.originalLength < 20 && diffChange.modifiedLength > 0 && diffChange.modifiedLength < 20 && continueCharDiff()) {
            // Compute character changes for diff chunks of at most 20 lines...
            var originalCharSequence = originalLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.originalStart, diffChange.originalStart + diffChange.originalLength - 1);
            var modifiedCharSequence = modifiedLineSequence.createCharSequence(shouldIgnoreTrimWhitespace, diffChange.modifiedStart, diffChange.modifiedStart + diffChange.modifiedLength - 1);
            var rawChanges = computeDiff(originalCharSequence, modifiedCharSequence, continueCharDiff, true).changes;
            if (shouldPostProcessCharChanges) {
                rawChanges = postProcessCharChanges(rawChanges);
            }
            charChanges = [];
            for (var i = 0, length_2 = rawChanges.length; i < length_2; i++) {
                charChanges.push(CharChange.createFromDiffChange(rawChanges[i], originalCharSequence, modifiedCharSequence));
            }
        }
        return new LineChange(originalStartLineNumber, originalEndLineNumber, modifiedStartLineNumber, modifiedEndLineNumber, charChanges);
    };
    return LineChange;
}());
var DiffComputer = /** @class */ (function () {
    function DiffComputer(originalLines, modifiedLines, opts) {
        this.shouldComputeCharChanges = opts.shouldComputeCharChanges;
        this.shouldPostProcessCharChanges = opts.shouldPostProcessCharChanges;
        this.shouldIgnoreTrimWhitespace = opts.shouldIgnoreTrimWhitespace;
        this.shouldMakePrettyDiff = opts.shouldMakePrettyDiff;
        this.originalLines = originalLines;
        this.modifiedLines = modifiedLines;
        this.original = new LineSequence(originalLines);
        this.modified = new LineSequence(modifiedLines);
        this.continueLineDiff = createContinueProcessingPredicate(opts.maxComputationTime);
        this.continueCharDiff = createContinueProcessingPredicate(opts.maxComputationTime === 0 ? 0 : Math.min(opts.maxComputationTime, 5000)); // never run after 5s for character changes...
    }
    DiffComputer.prototype.computeDiff = function () {
        if (this.original.lines.length === 1 && this.original.lines[0].length === 0) {
            // empty original => fast path
            return {
                quitEarly: false,
                changes: [{
                        originalStartLineNumber: 1,
                        originalEndLineNumber: 1,
                        modifiedStartLineNumber: 1,
                        modifiedEndLineNumber: this.modified.lines.length,
                        charChanges: [{
                                modifiedEndColumn: 0,
                                modifiedEndLineNumber: 0,
                                modifiedStartColumn: 0,
                                modifiedStartLineNumber: 0,
                                originalEndColumn: 0,
                                originalEndLineNumber: 0,
                                originalStartColumn: 0,
                                originalStartLineNumber: 0
                            }]
                    }]
            };
        }
        if (this.modified.lines.length === 1 && this.modified.lines[0].length === 0) {
            // empty modified => fast path
            return {
                quitEarly: false,
                changes: [{
                        originalStartLineNumber: 1,
                        originalEndLineNumber: this.original.lines.length,
                        modifiedStartLineNumber: 1,
                        modifiedEndLineNumber: 1,
                        charChanges: [{
                                modifiedEndColumn: 0,
                                modifiedEndLineNumber: 0,
                                modifiedStartColumn: 0,
                                modifiedStartLineNumber: 0,
                                originalEndColumn: 0,
                                originalEndLineNumber: 0,
                                originalStartColumn: 0,
                                originalStartLineNumber: 0
                            }]
                    }]
            };
        }
        var diffResult = computeDiff(this.original, this.modified, this.continueLineDiff, this.shouldMakePrettyDiff);
        var rawChanges = diffResult.changes;
        var quitEarly = diffResult.quitEarly;
        // The diff is always computed with ignoring trim whitespace
        // This ensures we get the prettiest diff
        if (this.shouldIgnoreTrimWhitespace) {
            var lineChanges = [];
            for (var i = 0, length_3 = rawChanges.length; i < length_3; i++) {
                lineChanges.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, rawChanges[i], this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
            }
            return {
                quitEarly: quitEarly,
                changes: lineChanges
            };
        }
        // Need to post-process and introduce changes where the trim whitespace is different
        // Note that we are looping starting at -1 to also cover the lines before the first change
        var result = [];
        var originalLineIndex = 0;
        var modifiedLineIndex = 0;
        for (var i = -1 /* !!!! */, len = rawChanges.length; i < len; i++) {
            var nextChange = (i + 1 < len ? rawChanges[i + 1] : null);
            var originalStop = (nextChange ? nextChange.originalStart : this.originalLines.length);
            var modifiedStop = (nextChange ? nextChange.modifiedStart : this.modifiedLines.length);
            while (originalLineIndex < originalStop && modifiedLineIndex < modifiedStop) {
                var originalLine = this.originalLines[originalLineIndex];
                var modifiedLine = this.modifiedLines[modifiedLineIndex];
                if (originalLine !== modifiedLine) {
                    // These lines differ only in trim whitespace
                    // Check the leading whitespace
                    {
                        var originalStartColumn = getFirstNonBlankColumn(originalLine, 1);
                        var modifiedStartColumn = getFirstNonBlankColumn(modifiedLine, 1);
                        while (originalStartColumn > 1 && modifiedStartColumn > 1) {
                            var originalChar = originalLine.charCodeAt(originalStartColumn - 2);
                            var modifiedChar = modifiedLine.charCodeAt(modifiedStartColumn - 2);
                            if (originalChar !== modifiedChar) {
                                break;
                            }
                            originalStartColumn--;
                            modifiedStartColumn--;
                        }
                        if (originalStartColumn > 1 || modifiedStartColumn > 1) {
                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, 1, originalStartColumn, modifiedLineIndex + 1, 1, modifiedStartColumn);
                        }
                    }
                    // Check the trailing whitespace
                    {
                        var originalEndColumn = getLastNonBlankColumn(originalLine, 1);
                        var modifiedEndColumn = getLastNonBlankColumn(modifiedLine, 1);
                        var originalMaxColumn = originalLine.length + 1;
                        var modifiedMaxColumn = modifiedLine.length + 1;
                        while (originalEndColumn < originalMaxColumn && modifiedEndColumn < modifiedMaxColumn) {
                            var originalChar = originalLine.charCodeAt(originalEndColumn - 1);
                            var modifiedChar = originalLine.charCodeAt(modifiedEndColumn - 1);
                            if (originalChar !== modifiedChar) {
                                break;
                            }
                            originalEndColumn++;
                            modifiedEndColumn++;
                        }
                        if (originalEndColumn < originalMaxColumn || modifiedEndColumn < modifiedMaxColumn) {
                            this._pushTrimWhitespaceCharChange(result, originalLineIndex + 1, originalEndColumn, originalMaxColumn, modifiedLineIndex + 1, modifiedEndColumn, modifiedMaxColumn);
                        }
                    }
                }
                originalLineIndex++;
                modifiedLineIndex++;
            }
            if (nextChange) {
                // Emit the actual change
                result.push(LineChange.createFromDiffResult(this.shouldIgnoreTrimWhitespace, nextChange, this.original, this.modified, this.continueCharDiff, this.shouldComputeCharChanges, this.shouldPostProcessCharChanges));
                originalLineIndex += nextChange.originalLength;
                modifiedLineIndex += nextChange.modifiedLength;
            }
        }
        return {
            quitEarly: quitEarly,
            changes: result
        };
    };
    DiffComputer.prototype._pushTrimWhitespaceCharChange = function (result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
        if (this._mergeTrimWhitespaceCharChange(result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn)) {
            // Merged into previous
            return;
        }
        var charChanges = undefined;
        if (this.shouldComputeCharChanges) {
            charChanges = [new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn)];
        }
        result.push(new LineChange(originalLineNumber, originalLineNumber, modifiedLineNumber, modifiedLineNumber, charChanges));
    };
    DiffComputer.prototype._mergeTrimWhitespaceCharChange = function (result, originalLineNumber, originalStartColumn, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedEndColumn) {
        var len = result.length;
        if (len === 0) {
            return false;
        }
        var prevChange = result[len - 1];
        if (prevChange.originalEndLineNumber === 0 || prevChange.modifiedEndLineNumber === 0) {
            // Don't merge with inserts/deletes
            return false;
        }
        if (prevChange.originalEndLineNumber + 1 === originalLineNumber && prevChange.modifiedEndLineNumber + 1 === modifiedLineNumber) {
            prevChange.originalEndLineNumber = originalLineNumber;
            prevChange.modifiedEndLineNumber = modifiedLineNumber;
            if (this.shouldComputeCharChanges && prevChange.charChanges) {
                prevChange.charChanges.push(new CharChange(originalLineNumber, originalStartColumn, originalLineNumber, originalEndColumn, modifiedLineNumber, modifiedStartColumn, modifiedLineNumber, modifiedEndColumn));
            }
            return true;
        }
        return false;
    };
    return DiffComputer;
}());

function getFirstNonBlankColumn(txt, defaultValue) {
    var r = firstNonWhitespaceIndex(txt);
    if (r === -1) {
        return defaultValue;
    }
    return r + 1;
}
function getLastNonBlankColumn(txt, defaultValue) {
    var r = lastNonWhitespaceIndex(txt);
    if (r === -1) {
        return defaultValue;
    }
    return r + 2;
}
function createContinueProcessingPredicate(maximumRuntime) {
    if (maximumRuntime === 0) {
        return function () { return true; };
    }
    var startTime = Date.now();
    return function () {
        return Date.now() - startTime < maximumRuntime;
    };
}

// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/base/common/uint.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function toUint8(v) {
    if (v < 0) {
        return 0;
    }
    if (v > 255 /* MAX_UINT_8 */) {
        return 255 /* MAX_UINT_8 */;
    }
    return v | 0;
}
function toUint32(v) {
    if (v < 0) {
        return 0;
    }
    if (v > 4294967295 /* MAX_UINT_32 */) {
        return 4294967295 /* MAX_UINT_32 */;
    }
    return v | 0;
}

// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/editor/common/viewModel/prefixSumComputer.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

var PrefixSumIndexOfResult = /** @class */ (function () {
    function PrefixSumIndexOfResult(index, remainder) {
        this.index = index;
        this.remainder = remainder;
    }
    return PrefixSumIndexOfResult;
}());

var prefixSumComputer_PrefixSumComputer = /** @class */ (function () {
    function PrefixSumComputer(values) {
        this.values = values;
        this.prefixSum = new Uint32Array(values.length);
        this.prefixSumValidIndex = new Int32Array(1);
        this.prefixSumValidIndex[0] = -1;
    }
    PrefixSumComputer.prototype.insertValues = function (insertIndex, insertValues) {
        insertIndex = toUint32(insertIndex);
        var oldValues = this.values;
        var oldPrefixSum = this.prefixSum;
        var insertValuesLen = insertValues.length;
        if (insertValuesLen === 0) {
            return false;
        }
        this.values = new Uint32Array(oldValues.length + insertValuesLen);
        this.values.set(oldValues.subarray(0, insertIndex), 0);
        this.values.set(oldValues.subarray(insertIndex), insertIndex + insertValuesLen);
        this.values.set(insertValues, insertIndex);
        if (insertIndex - 1 < this.prefixSumValidIndex[0]) {
            this.prefixSumValidIndex[0] = insertIndex - 1;
        }
        this.prefixSum = new Uint32Array(this.values.length);
        if (this.prefixSumValidIndex[0] >= 0) {
            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
        }
        return true;
    };
    PrefixSumComputer.prototype.changeValue = function (index, value) {
        index = toUint32(index);
        value = toUint32(value);
        if (this.values[index] === value) {
            return false;
        }
        this.values[index] = value;
        if (index - 1 < this.prefixSumValidIndex[0]) {
            this.prefixSumValidIndex[0] = index - 1;
        }
        return true;
    };
    PrefixSumComputer.prototype.removeValues = function (startIndex, cnt) {
        startIndex = toUint32(startIndex);
        cnt = toUint32(cnt);
        var oldValues = this.values;
        var oldPrefixSum = this.prefixSum;
        if (startIndex >= oldValues.length) {
            return false;
        }
        var maxCnt = oldValues.length - startIndex;
        if (cnt >= maxCnt) {
            cnt = maxCnt;
        }
        if (cnt === 0) {
            return false;
        }
        this.values = new Uint32Array(oldValues.length - cnt);
        this.values.set(oldValues.subarray(0, startIndex), 0);
        this.values.set(oldValues.subarray(startIndex + cnt), startIndex);
        this.prefixSum = new Uint32Array(this.values.length);
        if (startIndex - 1 < this.prefixSumValidIndex[0]) {
            this.prefixSumValidIndex[0] = startIndex - 1;
        }
        if (this.prefixSumValidIndex[0] >= 0) {
            this.prefixSum.set(oldPrefixSum.subarray(0, this.prefixSumValidIndex[0] + 1));
        }
        return true;
    };
    PrefixSumComputer.prototype.getTotalValue = function () {
        if (this.values.length === 0) {
            return 0;
        }
        return this._getAccumulatedValue(this.values.length - 1);
    };
    PrefixSumComputer.prototype.getAccumulatedValue = function (index) {
        if (index < 0) {
            return 0;
        }
        index = toUint32(index);
        return this._getAccumulatedValue(index);
    };
    PrefixSumComputer.prototype._getAccumulatedValue = function (index) {
        if (index <= this.prefixSumValidIndex[0]) {
            return this.prefixSum[index];
        }
        var startIndex = this.prefixSumValidIndex[0] + 1;
        if (startIndex === 0) {
            this.prefixSum[0] = this.values[0];
            startIndex++;
        }
        if (index >= this.values.length) {
            index = this.values.length - 1;
        }
        for (var i = startIndex; i <= index; i++) {
            this.prefixSum[i] = this.prefixSum[i - 1] + this.values[i];
        }
        this.prefixSumValidIndex[0] = Math.max(this.prefixSumValidIndex[0], index);
        return this.prefixSum[index];
    };
    PrefixSumComputer.prototype.getIndexOf = function (accumulatedValue) {
        accumulatedValue = Math.floor(accumulatedValue); //@perf
        // Compute all sums (to get a fully valid prefixSum)
        this.getTotalValue();
        var low = 0;
        var high = this.values.length - 1;
        var mid = 0;
        var midStop = 0;
        var midStart = 0;
        while (low <= high) {
            mid = low + ((high - low) / 2) | 0;
            midStop = this.prefixSum[mid];
            midStart = midStop - this.values[mid];
            if (accumulatedValue < midStart) {
                high = mid - 1;
            }
            else if (accumulatedValue >= midStop) {
                low = mid + 1;
            }
            else {
                break;
            }
        }
        return new PrefixSumIndexOfResult(mid, accumulatedValue - midStart);
    };
    return PrefixSumComputer;
}());


// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/editor/common/model/mirrorTextModel.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


var mirrorTextModel_MirrorTextModel = /** @class */ (function () {
    function MirrorTextModel(uri, lines, eol, versionId) {
        this._uri = uri;
        this._lines = lines;
        this._eol = eol;
        this._versionId = versionId;
        this._lineStarts = null;
    }
    MirrorTextModel.prototype.dispose = function () {
        this._lines.length = 0;
    };
    MirrorTextModel.prototype.getText = function () {
        return this._lines.join(this._eol);
    };
    MirrorTextModel.prototype.onEvents = function (e) {
        if (e.eol && e.eol !== this._eol) {
            this._eol = e.eol;
            this._lineStarts = null;
        }
        // Update my lines
        var changes = e.changes;
        for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {
            var change = changes_1[_i];
            this._acceptDeleteRange(change.range);
            this._acceptInsertText(new Position(change.range.startLineNumber, change.range.startColumn), change.text);
        }
        this._versionId = e.versionId;
    };
    MirrorTextModel.prototype._ensureLineStarts = function () {
        if (!this._lineStarts) {
            var eolLength = this._eol.length;
            var linesLength = this._lines.length;
            var lineStartValues = new Uint32Array(linesLength);
            for (var i = 0; i < linesLength; i++) {
                lineStartValues[i] = this._lines[i].length + eolLength;
            }
            this._lineStarts = new prefixSumComputer_PrefixSumComputer(lineStartValues);
        }
    };
    /**
     * All changes to a line's text go through this method
     */
    MirrorTextModel.prototype._setLineText = function (lineIndex, newValue) {
        this._lines[lineIndex] = newValue;
        if (this._lineStarts) {
            // update prefix sum
            this._lineStarts.changeValue(lineIndex, this._lines[lineIndex].length + this._eol.length);
        }
    };
    MirrorTextModel.prototype._acceptDeleteRange = function (range) {
        if (range.startLineNumber === range.endLineNumber) {
            if (range.startColumn === range.endColumn) {
                // Nothing to delete
                return;
            }
            // Delete text on the affected line
            this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)
                + this._lines[range.startLineNumber - 1].substring(range.endColumn - 1));
            return;
        }
        // Take remaining text on last line and append it to remaining text on first line
        this._setLineText(range.startLineNumber - 1, this._lines[range.startLineNumber - 1].substring(0, range.startColumn - 1)
            + this._lines[range.endLineNumber - 1].substring(range.endColumn - 1));
        // Delete middle lines
        this._lines.splice(range.startLineNumber, range.endLineNumber - range.startLineNumber);
        if (this._lineStarts) {
            // update prefix sum
            this._lineStarts.removeValues(range.startLineNumber, range.endLineNumber - range.startLineNumber);
        }
    };
    MirrorTextModel.prototype._acceptInsertText = function (position, insertText) {
        if (insertText.length === 0) {
            // Nothing to insert
            return;
        }
        var insertLines = insertText.split(/\r\n|\r|\n/);
        if (insertLines.length === 1) {
            // Inserting text on one line
            this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)
                + insertLines[0]
                + this._lines[position.lineNumber - 1].substring(position.column - 1));
            return;
        }
        // Append overflowing text from first line to the end of text to insert
        insertLines[insertLines.length - 1] += this._lines[position.lineNumber - 1].substring(position.column - 1);
        // Delete overflowing text from first line and insert text on first line
        this._setLineText(position.lineNumber - 1, this._lines[position.lineNumber - 1].substring(0, position.column - 1)
            + insertLines[0]);
        // Insert new lines & store lengths
        var newLengths = new Uint32Array(insertLines.length - 1);
        for (var i = 1; i < insertLines.length; i++) {
            this._lines.splice(position.lineNumber + i - 1, 0, insertLines[i]);
            newLengths[i - 1] = insertLines[i].length + this._eol.length;
        }
        if (this._lineStarts) {
            // update prefix sum
            this._lineStarts.insertValues(position.lineNumber, newLengths);
        }
    };
    return MirrorTextModel;
}());


// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/editor/common/model/wordHelper.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var USUAL_WORD_SEPARATORS = '`~!@#$%^&*()-=+[{]}\\|;:\'",.<>/?';
/**
 * Create a word definition regular expression based on default word separators.
 * Optionally provide allowed separators that should be included in words.
 *
 * The default would look like this:
 * /(-?\d*\.\d\w*)|([^\`\~\!\@\#\$\%\^\&\*\(\)\-\=\+\[\{\]\}\\\|\;\:\'\"\,\.\<\>\/\?\s]+)/g
 */
function createWordRegExp(allowInWords) {
    if (allowInWords === void 0) { allowInWords = ''; }
    var source = '(-?\\d*\\.\\d\\w*)|([^';
    for (var _i = 0, USUAL_WORD_SEPARATORS_1 = USUAL_WORD_SEPARATORS; _i < USUAL_WORD_SEPARATORS_1.length; _i++) {
        var sep = USUAL_WORD_SEPARATORS_1[_i];
        if (allowInWords.indexOf(sep) >= 0) {
            continue;
        }
        source += '\\' + sep;
    }
    source += '\\s]+)';
    return new RegExp(source, 'g');
}
// catches numbers (including floating numbers) in the first group, and alphanum in the second
var DEFAULT_WORD_REGEXP = createWordRegExp();
function ensureValidWordDefinition(wordDefinition) {
    var result = DEFAULT_WORD_REGEXP;
    if (wordDefinition && (wordDefinition instanceof RegExp)) {
        if (!wordDefinition.global) {
            var flags = 'g';
            if (wordDefinition.ignoreCase) {
                flags += 'i';
            }
            if (wordDefinition.multiline) {
                flags += 'm';
            }
            if (wordDefinition.unicode) {
                flags += 'u';
            }
            result = new RegExp(wordDefinition.source, flags);
        }
        else {
            result = wordDefinition;
        }
    }
    result.lastIndex = 0;
    return result;
}
function getWordAtPosFast(column, wordDefinition, text, textOffset) {
    // find whitespace enclosed text around column and match from there
    var pos = column - 1 - textOffset;
    var start = text.lastIndexOf(' ', pos - 1) + 1;
    wordDefinition.lastIndex = start;
    var match;
    while (match = wordDefinition.exec(text)) {
        var matchIndex = match.index || 0;
        if (matchIndex <= pos && wordDefinition.lastIndex >= pos) {
            return {
                word: match[0],
                startColumn: textOffset + 1 + matchIndex,
                endColumn: textOffset + 1 + wordDefinition.lastIndex
            };
        }
    }
    return null;
}
function getWordAtPosSlow(column, wordDefinition, text, textOffset) {
    // matches all words starting at the beginning
    // of the input until it finds a match that encloses
    // the desired column. slow but correct
    var pos = column - 1 - textOffset;
    wordDefinition.lastIndex = 0;
    var match;
    while (match = wordDefinition.exec(text)) {
        var matchIndex = match.index || 0;
        if (matchIndex > pos) {
            // |nW -> matched only after the pos
            return null;
        }
        else if (wordDefinition.lastIndex >= pos) {
            // W|W -> match encloses pos
            return {
                word: match[0],
                startColumn: textOffset + 1 + matchIndex,
                endColumn: textOffset + 1 + wordDefinition.lastIndex
            };
        }
    }
    return null;
}
function getWordAtText(column, wordDefinition, text, textOffset) {
    // if `words` can contain whitespace character we have to use the slow variant
    // otherwise we use the fast variant of finding a word
    wordDefinition.lastIndex = 0;
    var match = wordDefinition.exec(text);
    if (!match) {
        return null;
    }
    // todo@joh the `match` could already be the (first) word
    var ret = match[0].indexOf(' ') >= 0
        // did match a word which contains a space character -> use slow word find
        ? getWordAtPosSlow(column, wordDefinition, text, textOffset)
        // sane word definition -> use fast word find
        : getWordAtPosFast(column, wordDefinition, text, textOffset);
    // both (getWordAtPosFast and getWordAtPosSlow) leave the wordDefinition-RegExp
    // in an undefined state and to not confuse other users of the wordDefinition
    // we reset the lastIndex
    wordDefinition.lastIndex = 0;
    return ret;
}

// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/editor/common/core/characterClassifier.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * A fast character classifier that uses a compact array for ASCII values.
 */
var characterClassifier_CharacterClassifier = /** @class */ (function () {
    function CharacterClassifier(_defaultValue) {
        var defaultValue = toUint8(_defaultValue);
        this._defaultValue = defaultValue;
        this._asciiMap = CharacterClassifier._createAsciiMap(defaultValue);
        this._map = new Map();
    }
    CharacterClassifier._createAsciiMap = function (defaultValue) {
        var asciiMap = new Uint8Array(256);
        for (var i = 0; i < 256; i++) {
            asciiMap[i] = defaultValue;
        }
        return asciiMap;
    };
    CharacterClassifier.prototype.set = function (charCode, _value) {
        var value = toUint8(_value);
        if (charCode >= 0 && charCode < 256) {
            this._asciiMap[charCode] = value;
        }
        else {
            this._map.set(charCode, value);
        }
    };
    CharacterClassifier.prototype.get = function (charCode) {
        if (charCode >= 0 && charCode < 256) {
            return this._asciiMap[charCode];
        }
        else {
            return (this._map.get(charCode) || this._defaultValue);
        }
    };
    return CharacterClassifier;
}());

var CharacterSet = /** @class */ (function () {
    function CharacterSet() {
        this._actual = new characterClassifier_CharacterClassifier(0 /* False */);
    }
    CharacterSet.prototype.add = function (charCode) {
        this._actual.set(charCode, 1 /* True */);
    };
    CharacterSet.prototype.has = function (charCode) {
        return (this._actual.get(charCode) === 1 /* True */);
    };
    return CharacterSet;
}());


// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/editor/common/modes/linkComputer.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

var Uint8Matrix = /** @class */ (function () {
    function Uint8Matrix(rows, cols, defaultValue) {
        var data = new Uint8Array(rows * cols);
        for (var i = 0, len = rows * cols; i < len; i++) {
            data[i] = defaultValue;
        }
        this._data = data;
        this.rows = rows;
        this.cols = cols;
    }
    Uint8Matrix.prototype.get = function (row, col) {
        return this._data[row * this.cols + col];
    };
    Uint8Matrix.prototype.set = function (row, col, value) {
        this._data[row * this.cols + col] = value;
    };
    return Uint8Matrix;
}());

var StateMachine = /** @class */ (function () {
    function StateMachine(edges) {
        var maxCharCode = 0;
        var maxState = 0 /* Invalid */;
        for (var i = 0, len = edges.length; i < len; i++) {
            var _a = edges[i], from = _a[0], chCode = _a[1], to = _a[2];
            if (chCode > maxCharCode) {
                maxCharCode = chCode;
            }
            if (from > maxState) {
                maxState = from;
            }
            if (to > maxState) {
                maxState = to;
            }
        }
        maxCharCode++;
        maxState++;
        var states = new Uint8Matrix(maxState, maxCharCode, 0 /* Invalid */);
        for (var i = 0, len = edges.length; i < len; i++) {
            var _b = edges[i], from = _b[0], chCode = _b[1], to = _b[2];
            states.set(from, chCode, to);
        }
        this._states = states;
        this._maxCharCode = maxCharCode;
    }
    StateMachine.prototype.nextState = function (currentState, chCode) {
        if (chCode < 0 || chCode >= this._maxCharCode) {
            return 0 /* Invalid */;
        }
        return this._states.get(currentState, chCode);
    };
    return StateMachine;
}());

// State machine for http:// or https:// or file://
var _stateMachine = null;
function getStateMachine() {
    if (_stateMachine === null) {
        _stateMachine = new StateMachine([
            [1 /* Start */, 104 /* h */, 2 /* H */],
            [1 /* Start */, 72 /* H */, 2 /* H */],
            [1 /* Start */, 102 /* f */, 6 /* F */],
            [1 /* Start */, 70 /* F */, 6 /* F */],
            [2 /* H */, 116 /* t */, 3 /* HT */],
            [2 /* H */, 84 /* T */, 3 /* HT */],
            [3 /* HT */, 116 /* t */, 4 /* HTT */],
            [3 /* HT */, 84 /* T */, 4 /* HTT */],
            [4 /* HTT */, 112 /* p */, 5 /* HTTP */],
            [4 /* HTT */, 80 /* P */, 5 /* HTTP */],
            [5 /* HTTP */, 115 /* s */, 9 /* BeforeColon */],
            [5 /* HTTP */, 83 /* S */, 9 /* BeforeColon */],
            [5 /* HTTP */, 58 /* Colon */, 10 /* AfterColon */],
            [6 /* F */, 105 /* i */, 7 /* FI */],
            [6 /* F */, 73 /* I */, 7 /* FI */],
            [7 /* FI */, 108 /* l */, 8 /* FIL */],
            [7 /* FI */, 76 /* L */, 8 /* FIL */],
            [8 /* FIL */, 101 /* e */, 9 /* BeforeColon */],
            [8 /* FIL */, 69 /* E */, 9 /* BeforeColon */],
            [9 /* BeforeColon */, 58 /* Colon */, 10 /* AfterColon */],
            [10 /* AfterColon */, 47 /* Slash */, 11 /* AlmostThere */],
            [11 /* AlmostThere */, 47 /* Slash */, 12 /* End */],
        ]);
    }
    return _stateMachine;
}
var _classifier = null;
function getClassifier() {
    if (_classifier === null) {
        _classifier = new characterClassifier_CharacterClassifier(0 /* None */);
        var FORCE_TERMINATION_CHARACTERS = ' \t<>\'\"';
        for (var i = 0; i < FORCE_TERMINATION_CHARACTERS.length; i++) {
            _classifier.set(FORCE_TERMINATION_CHARACTERS.charCodeAt(i), 1 /* ForceTermination */);
        }
        var CANNOT_END_WITH_CHARACTERS = '.,;';
        for (var i = 0; i < CANNOT_END_WITH_CHARACTERS.length; i++) {
            _classifier.set(CANNOT_END_WITH_CHARACTERS.charCodeAt(i), 2 /* CannotEndIn */);
        }
    }
    return _classifier;
}
var LinkComputer = /** @class */ (function () {
    function LinkComputer() {
    }
    LinkComputer._createLink = function (classifier, line, lineNumber, linkBeginIndex, linkEndIndex) {
        // Do not allow to end link in certain characters...
        var lastIncludedCharIndex = linkEndIndex - 1;
        do {
            var chCode = line.charCodeAt(lastIncludedCharIndex);
            var chClass = classifier.get(chCode);
            if (chClass !== 2 /* CannotEndIn */) {
                break;
            }
            lastIncludedCharIndex--;
        } while (lastIncludedCharIndex > linkBeginIndex);
        // Handle links enclosed in parens, square brackets and curlys.
        if (linkBeginIndex > 0) {
            var charCodeBeforeLink = line.charCodeAt(linkBeginIndex - 1);
            var lastCharCodeInLink = line.charCodeAt(lastIncludedCharIndex);
            if ((charCodeBeforeLink === 40 /* OpenParen */ && lastCharCodeInLink === 41 /* CloseParen */)
                || (charCodeBeforeLink === 91 /* OpenSquareBracket */ && lastCharCodeInLink === 93 /* CloseSquareBracket */)
                || (charCodeBeforeLink === 123 /* OpenCurlyBrace */ && lastCharCodeInLink === 125 /* CloseCurlyBrace */)) {
                // Do not end in ) if ( is before the link start
                // Do not end in ] if [ is before the link start
                // Do not end in } if { is before the link start
                lastIncludedCharIndex--;
            }
        }
        return {
            range: {
                startLineNumber: lineNumber,
                startColumn: linkBeginIndex + 1,
                endLineNumber: lineNumber,
                endColumn: lastIncludedCharIndex + 2
            },
            url: line.substring(linkBeginIndex, lastIncludedCharIndex + 1)
        };
    };
    LinkComputer.computeLinks = function (model, stateMachine) {
        if (stateMachine === void 0) { stateMachine = getStateMachine(); }
        var classifier = getClassifier();
        var result = [];
        for (var i = 1, lineCount = model.getLineCount(); i <= lineCount; i++) {
            var line = model.getLineContent(i);
            var len = line.length;
            var j = 0;
            var linkBeginIndex = 0;
            var linkBeginChCode = 0;
            var state = 1 /* Start */;
            var hasOpenParens = false;
            var hasOpenSquareBracket = false;
            var hasOpenCurlyBracket = false;
            while (j < len) {
                var resetStateMachine = false;
                var chCode = line.charCodeAt(j);
                if (state === 13 /* Accept */) {
                    var chClass = void 0;
                    switch (chCode) {
                        case 40 /* OpenParen */:
                            hasOpenParens = true;
                            chClass = 0 /* None */;
                            break;
                        case 41 /* CloseParen */:
                            chClass = (hasOpenParens ? 0 /* None */ : 1 /* ForceTermination */);
                            break;
                        case 91 /* OpenSquareBracket */:
                            hasOpenSquareBracket = true;
                            chClass = 0 /* None */;
                            break;
                        case 93 /* CloseSquareBracket */:
                            chClass = (hasOpenSquareBracket ? 0 /* None */ : 1 /* ForceTermination */);
                            break;
                        case 123 /* OpenCurlyBrace */:
                            hasOpenCurlyBracket = true;
                            chClass = 0 /* None */;
                            break;
                        case 125 /* CloseCurlyBrace */:
                            chClass = (hasOpenCurlyBracket ? 0 /* None */ : 1 /* ForceTermination */);
                            break;
                        /* The following three rules make it that ' or " or ` are allowed inside links if the link began with a different one */
                        case 39 /* SingleQuote */:
                            chClass = (linkBeginChCode === 34 /* DoubleQuote */ || linkBeginChCode === 96 /* BackTick */) ? 0 /* None */ : 1 /* ForceTermination */;
                            break;
                        case 34 /* DoubleQuote */:
                            chClass = (linkBeginChCode === 39 /* SingleQuote */ || linkBeginChCode === 96 /* BackTick */) ? 0 /* None */ : 1 /* ForceTermination */;
                            break;
                        case 96 /* BackTick */:
                            chClass = (linkBeginChCode === 39 /* SingleQuote */ || linkBeginChCode === 34 /* DoubleQuote */) ? 0 /* None */ : 1 /* ForceTermination */;
                            break;
                        case 42 /* Asterisk */:
                            // `*` terminates a link if the link began with `*`
                            chClass = (linkBeginChCode === 42 /* Asterisk */) ? 1 /* ForceTermination */ : 0 /* None */;
                            break;
                        case 124 /* Pipe */:
                            // `|` terminates a link if the link began with `|`
                            chClass = (linkBeginChCode === 124 /* Pipe */) ? 1 /* ForceTermination */ : 0 /* None */;
                            break;
                        default:
                            chClass = classifier.get(chCode);
                    }
                    // Check if character terminates link
                    if (chClass === 1 /* ForceTermination */) {
                        result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, j));
                        resetStateMachine = true;
                    }
                }
                else if (state === 12 /* End */) {
                    var chClass = void 0;
                    if (chCode === 91 /* OpenSquareBracket */) {
                        // Allow for the authority part to contain ipv6 addresses which contain [ and ]
                        hasOpenSquareBracket = true;
                        chClass = 0 /* None */;
                    }
                    else {
                        chClass = classifier.get(chCode);
                    }
                    // Check if character terminates link
                    if (chClass === 1 /* ForceTermination */) {
                        resetStateMachine = true;
                    }
                    else {
                        state = 13 /* Accept */;
                    }
                }
                else {
                    state = stateMachine.nextState(state, chCode);
                    if (state === 0 /* Invalid */) {
                        resetStateMachine = true;
                    }
                }
                if (resetStateMachine) {
                    state = 1 /* Start */;
                    hasOpenParens = false;
                    hasOpenSquareBracket = false;
                    hasOpenCurlyBracket = false;
                    // Record where the link started
                    linkBeginIndex = j + 1;
                    linkBeginChCode = chCode;
                }
                j++;
            }
            if (state === 13 /* Accept */) {
                result.push(LinkComputer._createLink(classifier, line, i, linkBeginIndex, len));
            }
        }
        return result;
    };
    return LinkComputer;
}());

/**
 * Returns an array of all links contains in the provided
 * document. *Note* that this operation is computational
 * expensive and should not run in the UI thread.
 */
function computeLinks(model) {
    if (!model || typeof model.getLineCount !== 'function' || typeof model.getLineContent !== 'function') {
        // Unknown caller!
        return [];
    }
    return LinkComputer.computeLinks(model);
}

// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/editor/common/modes/supports/inplaceReplaceSupport.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var BasicInplaceReplace = /** @class */ (function () {
    function BasicInplaceReplace() {
        this._defaultValueSet = [
            ['true', 'false'],
            ['True', 'False'],
            ['Private', 'Public', 'Friend', 'ReadOnly', 'Partial', 'Protected', 'WriteOnly'],
            ['public', 'protected', 'private'],
        ];
    }
    BasicInplaceReplace.prototype.navigateValueSet = function (range1, text1, range2, text2, up) {
        if (range1 && text1) {
            var result = this.doNavigateValueSet(text1, up);
            if (result) {
                return {
                    range: range1,
                    value: result
                };
            }
        }
        if (range2 && text2) {
            var result = this.doNavigateValueSet(text2, up);
            if (result) {
                return {
                    range: range2,
                    value: result
                };
            }
        }
        return null;
    };
    BasicInplaceReplace.prototype.doNavigateValueSet = function (text, up) {
        var numberResult = this.numberReplace(text, up);
        if (numberResult !== null) {
            return numberResult;
        }
        return this.textReplace(text, up);
    };
    BasicInplaceReplace.prototype.numberReplace = function (value, up) {
        var precision = Math.pow(10, value.length - (value.lastIndexOf('.') + 1));
        var n1 = Number(value);
        var n2 = parseFloat(value);
        if (!isNaN(n1) && !isNaN(n2) && n1 === n2) {
            if (n1 === 0 && !up) {
                return null; // don't do negative
                //			} else if(n1 === 9 && up) {
                //				return null; // don't insert 10 into a number
            }
            else {
                n1 = Math.floor(n1 * precision);
                n1 += up ? precision : -precision;
                return String(n1 / precision);
            }
        }
        return null;
    };
    BasicInplaceReplace.prototype.textReplace = function (value, up) {
        return this.valueSetsReplace(this._defaultValueSet, value, up);
    };
    BasicInplaceReplace.prototype.valueSetsReplace = function (valueSets, value, up) {
        var result = null;
        for (var i = 0, len = valueSets.length; result === null && i < len; i++) {
            result = this.valueSetReplace(valueSets[i], value, up);
        }
        return result;
    };
    BasicInplaceReplace.prototype.valueSetReplace = function (valueSet, value, up) {
        var idx = valueSet.indexOf(value);
        if (idx >= 0) {
            idx += up ? +1 : -1;
            if (idx < 0) {
                idx = valueSet.length - 1;
            }
            else {
                idx %= valueSet.length;
            }
            return valueSet[idx];
        }
        return null;
    };
    BasicInplaceReplace.INSTANCE = new BasicInplaceReplace();
    return BasicInplaceReplace;
}());


// EXTERNAL MODULE: ../node_modules/monaco-editor/esm/vs/editor/common/standalone/promise-polyfill/polyfill.js
var polyfill = __webpack_require__(17);

// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/base/common/functional.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function functional_once(fn) {
    var _this = this;
    var didCall = false;
    var result;
    return function () {
        if (didCall) {
            return result;
        }
        didCall = true;
        result = fn.apply(_this, arguments);
        return result;
    };
}

// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/base/common/linkedList.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

var Node = /** @class */ (function () {
    function Node(element) {
        this.element = element;
        this.next = Node.Undefined;
        this.prev = Node.Undefined;
    }
    Node.Undefined = new Node(undefined);
    return Node;
}());
var linkedList_LinkedList = /** @class */ (function () {
    function LinkedList() {
        this._first = Node.Undefined;
        this._last = Node.Undefined;
        this._size = 0;
    }
    Object.defineProperty(LinkedList.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: true,
        configurable: true
    });
    LinkedList.prototype.isEmpty = function () {
        return this._first === Node.Undefined;
    };
    LinkedList.prototype.clear = function () {
        this._first = Node.Undefined;
        this._last = Node.Undefined;
        this._size = 0;
    };
    LinkedList.prototype.unshift = function (element) {
        return this._insert(element, false);
    };
    LinkedList.prototype.push = function (element) {
        return this._insert(element, true);
    };
    LinkedList.prototype._insert = function (element, atTheEnd) {
        var _this = this;
        var newNode = new Node(element);
        if (this._first === Node.Undefined) {
            this._first = newNode;
            this._last = newNode;
        }
        else if (atTheEnd) {
            // push
            var oldLast = this._last;
            this._last = newNode;
            newNode.prev = oldLast;
            oldLast.next = newNode;
        }
        else {
            // unshift
            var oldFirst = this._first;
            this._first = newNode;
            newNode.next = oldFirst;
            oldFirst.prev = newNode;
        }
        this._size += 1;
        var didRemove = false;
        return function () {
            if (!didRemove) {
                didRemove = true;
                _this._remove(newNode);
            }
        };
    };
    LinkedList.prototype.shift = function () {
        if (this._first === Node.Undefined) {
            return undefined;
        }
        else {
            var res = this._first.element;
            this._remove(this._first);
            return res;
        }
    };
    LinkedList.prototype.pop = function () {
        if (this._last === Node.Undefined) {
            return undefined;
        }
        else {
            var res = this._last.element;
            this._remove(this._last);
            return res;
        }
    };
    LinkedList.prototype._remove = function (node) {
        if (node.prev !== Node.Undefined && node.next !== Node.Undefined) {
            // middle
            var anchor = node.prev;
            anchor.next = node.next;
            node.next.prev = anchor;
        }
        else if (node.prev === Node.Undefined && node.next === Node.Undefined) {
            // only node
            this._first = Node.Undefined;
            this._last = Node.Undefined;
        }
        else if (node.next === Node.Undefined) {
            // last
            this._last = this._last.prev;
            this._last.next = Node.Undefined;
        }
        else if (node.prev === Node.Undefined) {
            // first
            this._first = this._first.next;
            this._first.prev = Node.Undefined;
        }
        // done
        this._size -= 1;
    };
    LinkedList.prototype.iterator = function () {
        var element;
        var node = this._first;
        return {
            next: function () {
                if (node === Node.Undefined) {
                    return FIN;
                }
                if (!element) {
                    element = { done: false, value: node.element };
                }
                else {
                    element.value = node.element;
                }
                node = node.next;
                return element;
            }
        };
    };
    LinkedList.prototype.toArray = function () {
        var result = [];
        for (var node = this._first; node !== Node.Undefined; node = node.next) {
            result.push(node.element);
        }
        return result;
    };
    return LinkedList;
}());


// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/base/common/event.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var event_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var event_Event;
(function (Event) {
    Event.None = function () { return Disposable.None; };
    /**
     * Given an event, returns another event which only fires once.
     */
    function once(event) {
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            // we need this, in case the event fires during the listener call
            var didFire = false;
            var result;
            result = event(function (e) {
                if (didFire) {
                    return;
                }
                else if (result) {
                    result.dispose();
                }
                else {
                    didFire = true;
                }
                return listener.call(thisArgs, e);
            }, null, disposables);
            if (didFire) {
                result.dispose();
            }
            return result;
        };
    }
    Event.once = once;
    /**
     * Given an event and a `map` function, returns another event which maps each element
     * through the mapping function.
     */
    function map(event, map) {
        return snapshot(function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            return event(function (i) { return listener.call(thisArgs, map(i)); }, null, disposables);
        });
    }
    Event.map = map;
    /**
     * Given an event and an `each` function, returns another identical event and calls
     * the `each` function per each element.
     */
    function forEach(event, each) {
        return snapshot(function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            return event(function (i) { each(i); listener.call(thisArgs, i); }, null, disposables);
        });
    }
    Event.forEach = forEach;
    function filter(event, filter) {
        return snapshot(function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            return event(function (e) { return filter(e) && listener.call(thisArgs, e); }, null, disposables);
        });
    }
    Event.filter = filter;
    /**
     * Given an event, returns the same event but typed as `Event<void>`.
     */
    function signal(event) {
        return event;
    }
    Event.signal = signal;
    /**
     * Given a collection of events, returns a single event which emits
     * whenever any of the provided events emit.
     */
    function any() {
        var events = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            events[_i] = arguments[_i];
        }
        return function (listener, thisArgs, disposables) {
            if (thisArgs === void 0) { thisArgs = null; }
            return combinedDisposable.apply(void 0, events.map(function (event) { return event(function (e) { return listener.call(thisArgs, e); }, null, disposables); }));
        };
    }
    Event.any = any;
    /**
     * Given an event and a `merge` function, returns another event which maps each element
     * and the cumulative result through the `merge` function. Similar to `map`, but with memory.
     */
    function reduce(event, merge, initial) {
        var output = initial;
        return map(event, function (e) {
            output = merge(output, e);
            return output;
        });
    }
    Event.reduce = reduce;
    /**
     * Given a chain of event processing functions (filter, map, etc), each
     * function will be invoked per event & per listener. Snapshotting an event
     * chain allows each function to be invoked just once per event.
     */
    function snapshot(event) {
        var listener;
        var emitter = new event_Emitter({
            onFirstListenerAdd: function () {
                listener = event(emitter.fire, emitter);
            },
            onLastListenerRemove: function () {
                listener.dispose();
            }
        });
        return emitter.event;
    }
    Event.snapshot = snapshot;
    function debounce(event, merge, delay, leading, leakWarningThreshold) {
        if (delay === void 0) { delay = 100; }
        if (leading === void 0) { leading = false; }
        var subscription;
        var output = undefined;
        var handle = undefined;
        var numDebouncedCalls = 0;
        var emitter = new event_Emitter({
            leakWarningThreshold: leakWarningThreshold,
            onFirstListenerAdd: function () {
                subscription = event(function (cur) {
                    numDebouncedCalls++;
                    output = merge(output, cur);
                    if (leading && !handle) {
                        emitter.fire(output);
                        output = undefined;
                    }
                    clearTimeout(handle);
                    handle = setTimeout(function () {
                        var _output = output;
                        output = undefined;
                        handle = undefined;
                        if (!leading || numDebouncedCalls > 1) {
                            emitter.fire(_output);
                        }
                        numDebouncedCalls = 0;
                    }, delay);
                });
            },
            onLastListenerRemove: function () {
                subscription.dispose();
            }
        });
        return emitter.event;
    }
    Event.debounce = debounce;
    /**
     * Given an event, it returns another event which fires only once and as soon as
     * the input event emits. The event data is the number of millis it took for the
     * event to fire.
     */
    function stopwatch(event) {
        var start = new Date().getTime();
        return map(once(event), function (_) { return new Date().getTime() - start; });
    }
    Event.stopwatch = stopwatch;
    /**
     * Given an event, it returns another event which fires only when the event
     * element changes.
     */
    function latch(event) {
        var firstCall = true;
        var cache;
        return filter(event, function (value) {
            var shouldEmit = firstCall || value !== cache;
            firstCall = false;
            cache = value;
            return shouldEmit;
        });
    }
    Event.latch = latch;
    /**
     * Buffers the provided event until a first listener comes
     * along, at which point fire all the events at once and
     * pipe the event from then on.
     *
     * ```typescript
     * const emitter = new Emitter<number>();
     * const event = emitter.event;
     * const bufferedEvent = buffer(event);
     *
     * emitter.fire(1);
     * emitter.fire(2);
     * emitter.fire(3);
     * // nothing...
     *
     * const listener = bufferedEvent(num => console.log(num));
     * // 1, 2, 3
     *
     * emitter.fire(4);
     * // 4
     * ```
     */
    function buffer(event, nextTick, _buffer) {
        if (nextTick === void 0) { nextTick = false; }
        if (_buffer === void 0) { _buffer = []; }
        var buffer = _buffer.slice();
        var listener = event(function (e) {
            if (buffer) {
                buffer.push(e);
            }
            else {
                emitter.fire(e);
            }
        });
        var flush = function () {
            if (buffer) {
                buffer.forEach(function (e) { return emitter.fire(e); });
            }
            buffer = null;
        };
        var emitter = new event_Emitter({
            onFirstListenerAdd: function () {
                if (!listener) {
                    listener = event(function (e) { return emitter.fire(e); });
                }
            },
            onFirstListenerDidAdd: function () {
                if (buffer) {
                    if (nextTick) {
                        setTimeout(flush);
                    }
                    else {
                        flush();
                    }
                }
            },
            onLastListenerRemove: function () {
                if (listener) {
                    listener.dispose();
                }
                listener = null;
            }
        });
        return emitter.event;
    }
    Event.buffer = buffer;
    var ChainableEvent = /** @class */ (function () {
        function ChainableEvent(event) {
            this.event = event;
        }
        ChainableEvent.prototype.map = function (fn) {
            return new ChainableEvent(map(this.event, fn));
        };
        ChainableEvent.prototype.forEach = function (fn) {
            return new ChainableEvent(forEach(this.event, fn));
        };
        ChainableEvent.prototype.filter = function (fn) {
            return new ChainableEvent(filter(this.event, fn));
        };
        ChainableEvent.prototype.reduce = function (merge, initial) {
            return new ChainableEvent(reduce(this.event, merge, initial));
        };
        ChainableEvent.prototype.latch = function () {
            return new ChainableEvent(latch(this.event));
        };
        ChainableEvent.prototype.debounce = function (merge, delay, leading, leakWarningThreshold) {
            if (delay === void 0) { delay = 100; }
            if (leading === void 0) { leading = false; }
            return new ChainableEvent(debounce(this.event, merge, delay, leading, leakWarningThreshold));
        };
        ChainableEvent.prototype.on = function (listener, thisArgs, disposables) {
            return this.event(listener, thisArgs, disposables);
        };
        ChainableEvent.prototype.once = function (listener, thisArgs, disposables) {
            return once(this.event)(listener, thisArgs, disposables);
        };
        return ChainableEvent;
    }());
    function chain(event) {
        return new ChainableEvent(event);
    }
    Event.chain = chain;
    function fromNodeEventEmitter(emitter, eventName, map) {
        if (map === void 0) { map = function (id) { return id; }; }
        var fn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return result.fire(map.apply(void 0, args));
        };
        var onFirstListenerAdd = function () { return emitter.on(eventName, fn); };
        var onLastListenerRemove = function () { return emitter.removeListener(eventName, fn); };
        var result = new event_Emitter({ onFirstListenerAdd: onFirstListenerAdd, onLastListenerRemove: onLastListenerRemove });
        return result.event;
    }
    Event.fromNodeEventEmitter = fromNodeEventEmitter;
    function fromDOMEventEmitter(emitter, eventName, map) {
        if (map === void 0) { map = function (id) { return id; }; }
        var fn = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            return result.fire(map.apply(void 0, args));
        };
        var onFirstListenerAdd = function () { return emitter.addEventListener(eventName, fn); };
        var onLastListenerRemove = function () { return emitter.removeEventListener(eventName, fn); };
        var result = new event_Emitter({ onFirstListenerAdd: onFirstListenerAdd, onLastListenerRemove: onLastListenerRemove });
        return result.event;
    }
    Event.fromDOMEventEmitter = fromDOMEventEmitter;
    function fromPromise(promise) {
        var emitter = new event_Emitter();
        var shouldEmit = false;
        promise
            .then(undefined, function () { return null; })
            .then(function () {
            if (!shouldEmit) {
                setTimeout(function () { return emitter.fire(undefined); }, 0);
            }
            else {
                emitter.fire(undefined);
            }
        });
        shouldEmit = true;
        return emitter.event;
    }
    Event.fromPromise = fromPromise;
    function toPromise(event) {
        return new Promise(function (c) { return once(event)(c); });
    }
    Event.toPromise = toPromise;
})(event_Event || (event_Event = {}));
var _globalLeakWarningThreshold = -1;
var LeakageMonitor = /** @class */ (function () {
    function LeakageMonitor(customThreshold, name) {
        if (name === void 0) { name = Math.random().toString(18).slice(2, 5); }
        this.customThreshold = customThreshold;
        this.name = name;
        this._warnCountdown = 0;
    }
    LeakageMonitor.prototype.dispose = function () {
        if (this._stacks) {
            this._stacks.clear();
        }
    };
    LeakageMonitor.prototype.check = function (listenerCount) {
        var _this = this;
        var threshold = _globalLeakWarningThreshold;
        if (typeof this.customThreshold === 'number') {
            threshold = this.customThreshold;
        }
        if (threshold <= 0 || listenerCount < threshold) {
            return undefined;
        }
        if (!this._stacks) {
            this._stacks = new Map();
        }
        var stack = new Error().stack.split('\n').slice(3).join('\n');
        var count = (this._stacks.get(stack) || 0);
        this._stacks.set(stack, count + 1);
        this._warnCountdown -= 1;
        if (this._warnCountdown <= 0) {
            // only warn on first exceed and then every time the limit
            // is exceeded by 50% again
            this._warnCountdown = threshold * 0.5;
            // find most frequent listener and print warning
            var topStack_1;
            var topCount_1 = 0;
            this._stacks.forEach(function (count, stack) {
                if (!topStack_1 || topCount_1 < count) {
                    topStack_1 = stack;
                    topCount_1 = count;
                }
            });
            console.warn("[" + this.name + "] potential listener LEAK detected, having " + listenerCount + " listeners already. MOST frequent listener (" + topCount_1 + "):");
            console.warn(topStack_1);
        }
        return function () {
            var count = (_this._stacks.get(stack) || 0);
            _this._stacks.set(stack, count - 1);
        };
    };
    return LeakageMonitor;
}());
/**
 * The Emitter can be used to expose an Event to the public
 * to fire it from the insides.
 * Sample:
    class Document {

        private readonly _onDidChange = new Emitter<(value:string)=>any>();

        public onDidChange = this._onDidChange.event;

        // getter-style
        // get onDidChange(): Event<(value:string)=>any> {
        // 	return this._onDidChange.event;
        // }

        private _doIt() {
            //...
            this._onDidChange.fire(value);
        }
    }
 */
var event_Emitter = /** @class */ (function () {
    function Emitter(options) {
        this._disposed = false;
        this._options = options;
        this._leakageMon = _globalLeakWarningThreshold > 0
            ? new LeakageMonitor(this._options && this._options.leakWarningThreshold)
            : undefined;
    }
    Object.defineProperty(Emitter.prototype, "event", {
        /**
         * For the public to allow to subscribe
         * to events from this Emitter
         */
        get: function () {
            var _this = this;
            if (!this._event) {
                this._event = function (listener, thisArgs, disposables) {
                    if (!_this._listeners) {
                        _this._listeners = new linkedList_LinkedList();
                    }
                    var firstListener = _this._listeners.isEmpty();
                    if (firstListener && _this._options && _this._options.onFirstListenerAdd) {
                        _this._options.onFirstListenerAdd(_this);
                    }
                    var remove = _this._listeners.push(!thisArgs ? listener : [listener, thisArgs]);
                    if (firstListener && _this._options && _this._options.onFirstListenerDidAdd) {
                        _this._options.onFirstListenerDidAdd(_this);
                    }
                    if (_this._options && _this._options.onListenerDidAdd) {
                        _this._options.onListenerDidAdd(_this, listener, thisArgs);
                    }
                    // check and record this emitter for potential leakage
                    var removeMonitor;
                    if (_this._leakageMon) {
                        removeMonitor = _this._leakageMon.check(_this._listeners.size);
                    }
                    var result;
                    result = {
                        dispose: function () {
                            if (removeMonitor) {
                                removeMonitor();
                            }
                            result.dispose = Emitter._noop;
                            if (!_this._disposed) {
                                remove();
                                if (_this._options && _this._options.onLastListenerRemove) {
                                    var hasListeners = (_this._listeners && !_this._listeners.isEmpty());
                                    if (!hasListeners) {
                                        _this._options.onLastListenerRemove(_this);
                                    }
                                }
                            }
                        }
                    };
                    if (disposables instanceof DisposableStore) {
                        disposables.add(result);
                    }
                    else if (Array.isArray(disposables)) {
                        disposables.push(result);
                    }
                    return result;
                };
            }
            return this._event;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * To be kept private to fire an event to
     * subscribers
     */
    Emitter.prototype.fire = function (event) {
        if (this._listeners) {
            // put all [listener,event]-pairs into delivery queue
            // then emit all event. an inner/nested event might be
            // the driver of this
            if (!this._deliveryQueue) {
                this._deliveryQueue = new linkedList_LinkedList();
            }
            for (var iter = this._listeners.iterator(), e = iter.next(); !e.done; e = iter.next()) {
                this._deliveryQueue.push([e.value, event]);
            }
            while (this._deliveryQueue.size > 0) {
                var _a = this._deliveryQueue.shift(), listener = _a[0], event_1 = _a[1];
                try {
                    if (typeof listener === 'function') {
                        listener.call(undefined, event_1);
                    }
                    else {
                        listener[0].call(listener[1], event_1);
                    }
                }
                catch (e) {
                    onUnexpectedError(e);
                }
            }
        }
    };
    Emitter.prototype.dispose = function () {
        if (this._listeners) {
            this._listeners.clear();
        }
        if (this._deliveryQueue) {
            this._deliveryQueue.clear();
        }
        if (this._leakageMon) {
            this._leakageMon.dispose();
        }
        this._disposed = true;
    };
    Emitter._noop = function () { };
    return Emitter;
}());

var event_PauseableEmitter = /** @class */ (function (_super) {
    event_extends(PauseableEmitter, _super);
    function PauseableEmitter(options) {
        var _this = _super.call(this, options) || this;
        _this._isPaused = 0;
        _this._eventQueue = new linkedList_LinkedList();
        _this._mergeFn = options && options.merge;
        return _this;
    }
    PauseableEmitter.prototype.pause = function () {
        this._isPaused++;
    };
    PauseableEmitter.prototype.resume = function () {
        if (this._isPaused !== 0 && --this._isPaused === 0) {
            if (this._mergeFn) {
                // use the merge function to create a single composite
                // event. make a copy in case firing pauses this emitter
                var events = this._eventQueue.toArray();
                this._eventQueue.clear();
                _super.prototype.fire.call(this, this._mergeFn(events));
            }
            else {
                // no merging, fire each event individually and test
                // that this emitter isn't paused halfway through
                while (!this._isPaused && this._eventQueue.size !== 0) {
                    _super.prototype.fire.call(this, this._eventQueue.shift());
                }
            }
        }
    };
    PauseableEmitter.prototype.fire = function (event) {
        if (this._listeners) {
            if (this._isPaused !== 0) {
                this._eventQueue.push(event);
            }
            else {
                _super.prototype.fire.call(this, event);
            }
        }
    };
    return PauseableEmitter;
}(event_Emitter));

var event_EventMultiplexer = /** @class */ (function () {
    function EventMultiplexer() {
        var _this = this;
        this.hasListeners = false;
        this.events = [];
        this.emitter = new event_Emitter({
            onFirstListenerAdd: function () { return _this.onFirstListenerAdd(); },
            onLastListenerRemove: function () { return _this.onLastListenerRemove(); }
        });
    }
    Object.defineProperty(EventMultiplexer.prototype, "event", {
        get: function () {
            return this.emitter.event;
        },
        enumerable: true,
        configurable: true
    });
    EventMultiplexer.prototype.add = function (event) {
        var _this = this;
        var e = { event: event, listener: null };
        this.events.push(e);
        if (this.hasListeners) {
            this.hook(e);
        }
        var dispose = function () {
            if (_this.hasListeners) {
                _this.unhook(e);
            }
            var idx = _this.events.indexOf(e);
            _this.events.splice(idx, 1);
        };
        return toDisposable(functional_once(dispose));
    };
    EventMultiplexer.prototype.onFirstListenerAdd = function () {
        var _this = this;
        this.hasListeners = true;
        this.events.forEach(function (e) { return _this.hook(e); });
    };
    EventMultiplexer.prototype.onLastListenerRemove = function () {
        var _this = this;
        this.hasListeners = false;
        this.events.forEach(function (e) { return _this.unhook(e); });
    };
    EventMultiplexer.prototype.hook = function (e) {
        var _this = this;
        e.listener = e.event(function (r) { return _this.emitter.fire(r); });
    };
    EventMultiplexer.prototype.unhook = function (e) {
        if (e.listener) {
            e.listener.dispose();
        }
        e.listener = null;
    };
    EventMultiplexer.prototype.dispose = function () {
        this.emitter.dispose();
    };
    return EventMultiplexer;
}());

/**
 * The EventBufferer is useful in situations in which you want
 * to delay firing your events during some code.
 * You can wrap that code and be sure that the event will not
 * be fired during that wrap.
 *
 * ```
 * const emitter: Emitter;
 * const delayer = new EventDelayer();
 * const delayedEvent = delayer.wrapEvent(emitter.event);
 *
 * delayedEvent(console.log);
 *
 * delayer.bufferEvents(() => {
 *   emitter.fire(); // event will not be fired yet
 * });
 *
 * // event will only be fired at this point
 * ```
 */
var EventBufferer = /** @class */ (function () {
    function EventBufferer() {
        this.buffers = [];
    }
    EventBufferer.prototype.wrapEvent = function (event) {
        var _this = this;
        return function (listener, thisArgs, disposables) {
            return event(function (i) {
                var buffer = _this.buffers[_this.buffers.length - 1];
                if (buffer) {
                    buffer.push(function () { return listener.call(thisArgs, i); });
                }
                else {
                    listener.call(thisArgs, i);
                }
            }, undefined, disposables);
        };
    };
    EventBufferer.prototype.bufferEvents = function (fn) {
        var buffer = [];
        this.buffers.push(buffer);
        var r = fn();
        this.buffers.pop();
        buffer.forEach(function (flush) { return flush(); });
        return r;
    };
    return EventBufferer;
}());

/**
 * A Relay is an event forwarder which functions as a replugabble event pipe.
 * Once created, you can connect an input event to it and it will simply forward
 * events from that input event through its own `event` property. The `input`
 * can be changed at any point in time.
 */
var event_Relay = /** @class */ (function () {
    function Relay() {
        var _this = this;
        this.listening = false;
        this.inputEvent = event_Event.None;
        this.inputEventListener = Disposable.None;
        this.emitter = new event_Emitter({
            onFirstListenerDidAdd: function () {
                _this.listening = true;
                _this.inputEventListener = _this.inputEvent(_this.emitter.fire, _this.emitter);
            },
            onLastListenerRemove: function () {
                _this.listening = false;
                _this.inputEventListener.dispose();
            }
        });
        this.event = this.emitter.event;
    }
    Object.defineProperty(Relay.prototype, "input", {
        set: function (event) {
            this.inputEvent = event;
            if (this.listening) {
                this.inputEventListener.dispose();
                this.inputEventListener = event(this.emitter.fire, this.emitter);
            }
        },
        enumerable: true,
        configurable: true
    });
    Relay.prototype.dispose = function () {
        this.inputEventListener.dispose();
        this.emitter.dispose();
    };
    return Relay;
}());


// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/base/common/cancellation.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

var shortcutEvent = Object.freeze(function (callback, context) {
    var handle = setTimeout(callback.bind(context), 0);
    return { dispose: function () { clearTimeout(handle); } };
});
var cancellation_CancellationToken;
(function (CancellationToken) {
    function isCancellationToken(thing) {
        if (thing === CancellationToken.None || thing === CancellationToken.Cancelled) {
            return true;
        }
        if (thing instanceof cancellation_MutableToken) {
            return true;
        }
        if (!thing || typeof thing !== 'object') {
            return false;
        }
        return typeof thing.isCancellationRequested === 'boolean'
            && typeof thing.onCancellationRequested === 'function';
    }
    CancellationToken.isCancellationToken = isCancellationToken;
    CancellationToken.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: event_Event.None
    });
    CancellationToken.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: shortcutEvent
    });
})(cancellation_CancellationToken || (cancellation_CancellationToken = {}));
var cancellation_MutableToken = /** @class */ (function () {
    function MutableToken() {
        this._isCancelled = false;
        this._emitter = null;
    }
    MutableToken.prototype.cancel = function () {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this.dispose();
            }
        }
    };
    Object.defineProperty(MutableToken.prototype, "isCancellationRequested", {
        get: function () {
            return this._isCancelled;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MutableToken.prototype, "onCancellationRequested", {
        get: function () {
            if (this._isCancelled) {
                return shortcutEvent;
            }
            if (!this._emitter) {
                this._emitter = new event_Emitter();
            }
            return this._emitter.event;
        },
        enumerable: true,
        configurable: true
    });
    MutableToken.prototype.dispose = function () {
        if (this._emitter) {
            this._emitter.dispose();
            this._emitter = null;
        }
    };
    return MutableToken;
}());
var CancellationTokenSource = /** @class */ (function () {
    function CancellationTokenSource(parent) {
        this._token = undefined;
        this._parentListener = undefined;
        this._parentListener = parent && parent.onCancellationRequested(this.cancel, this);
    }
    Object.defineProperty(CancellationTokenSource.prototype, "token", {
        get: function () {
            if (!this._token) {
                // be lazy and create the token only when
                // actually needed
                this._token = new cancellation_MutableToken();
            }
            return this._token;
        },
        enumerable: true,
        configurable: true
    });
    CancellationTokenSource.prototype.cancel = function () {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = cancellation_CancellationToken.Cancelled;
        }
        else if (this._token instanceof cancellation_MutableToken) {
            // actually cancel
            this._token.cancel();
        }
    };
    CancellationTokenSource.prototype.dispose = function (cancel) {
        if (cancel === void 0) { cancel = false; }
        if (cancel) {
            this.cancel();
        }
        if (this._parentListener) {
            this._parentListener.dispose();
        }
        if (!this._token) {
            // ensure to initialize with an empty token if we had none
            this._token = cancellation_CancellationToken.None;
        }
        else if (this._token instanceof cancellation_MutableToken) {
            // actually dispose
            this._token.dispose();
        }
    };
    return CancellationTokenSource;
}());


// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/base/common/keyCodes.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

var KeyCodeStrMap = /** @class */ (function () {
    function KeyCodeStrMap() {
        this._keyCodeToStr = [];
        this._strToKeyCode = Object.create(null);
    }
    KeyCodeStrMap.prototype.define = function (keyCode, str) {
        this._keyCodeToStr[keyCode] = str;
        this._strToKeyCode[str.toLowerCase()] = keyCode;
    };
    KeyCodeStrMap.prototype.keyCodeToStr = function (keyCode) {
        return this._keyCodeToStr[keyCode];
    };
    KeyCodeStrMap.prototype.strToKeyCode = function (str) {
        return this._strToKeyCode[str.toLowerCase()] || 0 /* Unknown */;
    };
    return KeyCodeStrMap;
}());
var uiMap = new KeyCodeStrMap();
var userSettingsUSMap = new KeyCodeStrMap();
var userSettingsGeneralMap = new KeyCodeStrMap();
(function () {
    function define(keyCode, uiLabel, usUserSettingsLabel, generalUserSettingsLabel) {
        if (usUserSettingsLabel === void 0) { usUserSettingsLabel = uiLabel; }
        if (generalUserSettingsLabel === void 0) { generalUserSettingsLabel = usUserSettingsLabel; }
        uiMap.define(keyCode, uiLabel);
        userSettingsUSMap.define(keyCode, usUserSettingsLabel);
        userSettingsGeneralMap.define(keyCode, generalUserSettingsLabel);
    }
    define(0 /* Unknown */, 'unknown');
    define(1 /* Backspace */, 'Backspace');
    define(2 /* Tab */, 'Tab');
    define(3 /* Enter */, 'Enter');
    define(4 /* Shift */, 'Shift');
    define(5 /* Ctrl */, 'Ctrl');
    define(6 /* Alt */, 'Alt');
    define(7 /* PauseBreak */, 'PauseBreak');
    define(8 /* CapsLock */, 'CapsLock');
    define(9 /* Escape */, 'Escape');
    define(10 /* Space */, 'Space');
    define(11 /* PageUp */, 'PageUp');
    define(12 /* PageDown */, 'PageDown');
    define(13 /* End */, 'End');
    define(14 /* Home */, 'Home');
    define(15 /* LeftArrow */, 'LeftArrow', 'Left');
    define(16 /* UpArrow */, 'UpArrow', 'Up');
    define(17 /* RightArrow */, 'RightArrow', 'Right');
    define(18 /* DownArrow */, 'DownArrow', 'Down');
    define(19 /* Insert */, 'Insert');
    define(20 /* Delete */, 'Delete');
    define(21 /* KEY_0 */, '0');
    define(22 /* KEY_1 */, '1');
    define(23 /* KEY_2 */, '2');
    define(24 /* KEY_3 */, '3');
    define(25 /* KEY_4 */, '4');
    define(26 /* KEY_5 */, '5');
    define(27 /* KEY_6 */, '6');
    define(28 /* KEY_7 */, '7');
    define(29 /* KEY_8 */, '8');
    define(30 /* KEY_9 */, '9');
    define(31 /* KEY_A */, 'A');
    define(32 /* KEY_B */, 'B');
    define(33 /* KEY_C */, 'C');
    define(34 /* KEY_D */, 'D');
    define(35 /* KEY_E */, 'E');
    define(36 /* KEY_F */, 'F');
    define(37 /* KEY_G */, 'G');
    define(38 /* KEY_H */, 'H');
    define(39 /* KEY_I */, 'I');
    define(40 /* KEY_J */, 'J');
    define(41 /* KEY_K */, 'K');
    define(42 /* KEY_L */, 'L');
    define(43 /* KEY_M */, 'M');
    define(44 /* KEY_N */, 'N');
    define(45 /* KEY_O */, 'O');
    define(46 /* KEY_P */, 'P');
    define(47 /* KEY_Q */, 'Q');
    define(48 /* KEY_R */, 'R');
    define(49 /* KEY_S */, 'S');
    define(50 /* KEY_T */, 'T');
    define(51 /* KEY_U */, 'U');
    define(52 /* KEY_V */, 'V');
    define(53 /* KEY_W */, 'W');
    define(54 /* KEY_X */, 'X');
    define(55 /* KEY_Y */, 'Y');
    define(56 /* KEY_Z */, 'Z');
    define(57 /* Meta */, 'Meta');
    define(58 /* ContextMenu */, 'ContextMenu');
    define(59 /* F1 */, 'F1');
    define(60 /* F2 */, 'F2');
    define(61 /* F3 */, 'F3');
    define(62 /* F4 */, 'F4');
    define(63 /* F5 */, 'F5');
    define(64 /* F6 */, 'F6');
    define(65 /* F7 */, 'F7');
    define(66 /* F8 */, 'F8');
    define(67 /* F9 */, 'F9');
    define(68 /* F10 */, 'F10');
    define(69 /* F11 */, 'F11');
    define(70 /* F12 */, 'F12');
    define(71 /* F13 */, 'F13');
    define(72 /* F14 */, 'F14');
    define(73 /* F15 */, 'F15');
    define(74 /* F16 */, 'F16');
    define(75 /* F17 */, 'F17');
    define(76 /* F18 */, 'F18');
    define(77 /* F19 */, 'F19');
    define(78 /* NumLock */, 'NumLock');
    define(79 /* ScrollLock */, 'ScrollLock');
    define(80 /* US_SEMICOLON */, ';', ';', 'OEM_1');
    define(81 /* US_EQUAL */, '=', '=', 'OEM_PLUS');
    define(82 /* US_COMMA */, ',', ',', 'OEM_COMMA');
    define(83 /* US_MINUS */, '-', '-', 'OEM_MINUS');
    define(84 /* US_DOT */, '.', '.', 'OEM_PERIOD');
    define(85 /* US_SLASH */, '/', '/', 'OEM_2');
    define(86 /* US_BACKTICK */, '`', '`', 'OEM_3');
    define(110 /* ABNT_C1 */, 'ABNT_C1');
    define(111 /* ABNT_C2 */, 'ABNT_C2');
    define(87 /* US_OPEN_SQUARE_BRACKET */, '[', '[', 'OEM_4');
    define(88 /* US_BACKSLASH */, '\\', '\\', 'OEM_5');
    define(89 /* US_CLOSE_SQUARE_BRACKET */, ']', ']', 'OEM_6');
    define(90 /* US_QUOTE */, '\'', '\'', 'OEM_7');
    define(91 /* OEM_8 */, 'OEM_8');
    define(92 /* OEM_102 */, 'OEM_102');
    define(93 /* NUMPAD_0 */, 'NumPad0');
    define(94 /* NUMPAD_1 */, 'NumPad1');
    define(95 /* NUMPAD_2 */, 'NumPad2');
    define(96 /* NUMPAD_3 */, 'NumPad3');
    define(97 /* NUMPAD_4 */, 'NumPad4');
    define(98 /* NUMPAD_5 */, 'NumPad5');
    define(99 /* NUMPAD_6 */, 'NumPad6');
    define(100 /* NUMPAD_7 */, 'NumPad7');
    define(101 /* NUMPAD_8 */, 'NumPad8');
    define(102 /* NUMPAD_9 */, 'NumPad9');
    define(103 /* NUMPAD_MULTIPLY */, 'NumPad_Multiply');
    define(104 /* NUMPAD_ADD */, 'NumPad_Add');
    define(105 /* NUMPAD_SEPARATOR */, 'NumPad_Separator');
    define(106 /* NUMPAD_SUBTRACT */, 'NumPad_Subtract');
    define(107 /* NUMPAD_DECIMAL */, 'NumPad_Decimal');
    define(108 /* NUMPAD_DIVIDE */, 'NumPad_Divide');
})();
var KeyCodeUtils;
(function (KeyCodeUtils) {
    function toString(keyCode) {
        return uiMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils.toString = toString;
    function fromString(key) {
        return uiMap.strToKeyCode(key);
    }
    KeyCodeUtils.fromString = fromString;
    function toUserSettingsUS(keyCode) {
        return userSettingsUSMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils.toUserSettingsUS = toUserSettingsUS;
    function toUserSettingsGeneral(keyCode) {
        return userSettingsGeneralMap.keyCodeToStr(keyCode);
    }
    KeyCodeUtils.toUserSettingsGeneral = toUserSettingsGeneral;
    function fromUserSettings(key) {
        return userSettingsUSMap.strToKeyCode(key) || userSettingsGeneralMap.strToKeyCode(key);
    }
    KeyCodeUtils.fromUserSettings = fromUserSettings;
})(KeyCodeUtils || (KeyCodeUtils = {}));
function KeyChord(firstPart, secondPart) {
    var chordPart = ((secondPart & 0x0000FFFF) << 16) >>> 0;
    return (firstPart | chordPart) >>> 0;
}
function createKeybinding(keybinding, OS) {
    if (keybinding === 0) {
        return null;
    }
    var firstPart = (keybinding & 0x0000FFFF) >>> 0;
    var chordPart = (keybinding & 0xFFFF0000) >>> 16;
    if (chordPart !== 0) {
        return new keyCodes_ChordKeybinding([
            createSimpleKeybinding(firstPart, OS),
            createSimpleKeybinding(chordPart, OS)
        ]);
    }
    return new keyCodes_ChordKeybinding([createSimpleKeybinding(firstPart, OS)]);
}
function createSimpleKeybinding(keybinding, OS) {
    var ctrlCmd = (keybinding & 2048 /* CtrlCmd */ ? true : false);
    var winCtrl = (keybinding & 256 /* WinCtrl */ ? true : false);
    var ctrlKey = (OS === 2 /* Macintosh */ ? winCtrl : ctrlCmd);
    var shiftKey = (keybinding & 1024 /* Shift */ ? true : false);
    var altKey = (keybinding & 512 /* Alt */ ? true : false);
    var metaKey = (OS === 2 /* Macintosh */ ? ctrlCmd : winCtrl);
    var keyCode = (keybinding & 255 /* KeyCode */);
    return new SimpleKeybinding(ctrlKey, shiftKey, altKey, metaKey, keyCode);
}
var SimpleKeybinding = /** @class */ (function () {
    function SimpleKeybinding(ctrlKey, shiftKey, altKey, metaKey, keyCode) {
        this.ctrlKey = ctrlKey;
        this.shiftKey = shiftKey;
        this.altKey = altKey;
        this.metaKey = metaKey;
        this.keyCode = keyCode;
    }
    SimpleKeybinding.prototype.equals = function (other) {
        return (this.ctrlKey === other.ctrlKey
            && this.shiftKey === other.shiftKey
            && this.altKey === other.altKey
            && this.metaKey === other.metaKey
            && this.keyCode === other.keyCode);
    };
    SimpleKeybinding.prototype.isModifierKey = function () {
        return (this.keyCode === 0 /* Unknown */
            || this.keyCode === 5 /* Ctrl */
            || this.keyCode === 57 /* Meta */
            || this.keyCode === 6 /* Alt */
            || this.keyCode === 4 /* Shift */);
    };
    SimpleKeybinding.prototype.toChord = function () {
        return new keyCodes_ChordKeybinding([this]);
    };
    /**
     * Does this keybinding refer to the key code of a modifier and it also has the modifier flag?
     */
    SimpleKeybinding.prototype.isDuplicateModifierCase = function () {
        return ((this.ctrlKey && this.keyCode === 5 /* Ctrl */)
            || (this.shiftKey && this.keyCode === 4 /* Shift */)
            || (this.altKey && this.keyCode === 6 /* Alt */)
            || (this.metaKey && this.keyCode === 57 /* Meta */));
    };
    return SimpleKeybinding;
}());

var keyCodes_ChordKeybinding = /** @class */ (function () {
    function ChordKeybinding(parts) {
        if (parts.length === 0) {
            throw illegalArgument("parts");
        }
        this.parts = parts;
    }
    ChordKeybinding.prototype.equals = function (other) {
        if (other === null) {
            return false;
        }
        if (this.parts.length !== other.parts.length) {
            return false;
        }
        for (var i = 0; i < this.parts.length; i++) {
            if (!this.parts[i].equals(other.parts[i])) {
                return false;
            }
        }
        return true;
    };
    return ChordKeybinding;
}());

var ResolvedKeybindingPart = /** @class */ (function () {
    function ResolvedKeybindingPart(ctrlKey, shiftKey, altKey, metaKey, kbLabel, kbAriaLabel) {
        this.ctrlKey = ctrlKey;
        this.shiftKey = shiftKey;
        this.altKey = altKey;
        this.metaKey = metaKey;
        this.keyLabel = kbLabel;
        this.keyAriaLabel = kbAriaLabel;
    }
    return ResolvedKeybindingPart;
}());

/**
 * A resolved keybinding. Can be a simple keybinding or a chord keybinding.
 */
var ResolvedKeybinding = /** @class */ (function () {
    function ResolvedKeybinding() {
    }
    return ResolvedKeybinding;
}());


// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/editor/common/core/selection.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var selection_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();


/**
 * A selection in the editor.
 * The selection is a range that has an orientation.
 */
var selection_Selection = /** @class */ (function (_super) {
    selection_extends(Selection, _super);
    function Selection(selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) {
        var _this = _super.call(this, selectionStartLineNumber, selectionStartColumn, positionLineNumber, positionColumn) || this;
        _this.selectionStartLineNumber = selectionStartLineNumber;
        _this.selectionStartColumn = selectionStartColumn;
        _this.positionLineNumber = positionLineNumber;
        _this.positionColumn = positionColumn;
        return _this;
    }
    /**
     * Transform to a human-readable representation.
     */
    Selection.prototype.toString = function () {
        return '[' + this.selectionStartLineNumber + ',' + this.selectionStartColumn + ' -> ' + this.positionLineNumber + ',' + this.positionColumn + ']';
    };
    /**
     * Test if equals other selection.
     */
    Selection.prototype.equalsSelection = function (other) {
        return (Selection.selectionsEqual(this, other));
    };
    /**
     * Test if the two selections are equal.
     */
    Selection.selectionsEqual = function (a, b) {
        return (a.selectionStartLineNumber === b.selectionStartLineNumber &&
            a.selectionStartColumn === b.selectionStartColumn &&
            a.positionLineNumber === b.positionLineNumber &&
            a.positionColumn === b.positionColumn);
    };
    /**
     * Get directions (LTR or RTL).
     */
    Selection.prototype.getDirection = function () {
        if (this.selectionStartLineNumber === this.startLineNumber && this.selectionStartColumn === this.startColumn) {
            return 0 /* LTR */;
        }
        return 1 /* RTL */;
    };
    /**
     * Create a new selection with a different `positionLineNumber` and `positionColumn`.
     */
    Selection.prototype.setEndPosition = function (endLineNumber, endColumn) {
        if (this.getDirection() === 0 /* LTR */) {
            return new Selection(this.startLineNumber, this.startColumn, endLineNumber, endColumn);
        }
        return new Selection(endLineNumber, endColumn, this.startLineNumber, this.startColumn);
    };
    /**
     * Get the position at `positionLineNumber` and `positionColumn`.
     */
    Selection.prototype.getPosition = function () {
        return new Position(this.positionLineNumber, this.positionColumn);
    };
    /**
     * Create a new selection with a different `selectionStartLineNumber` and `selectionStartColumn`.
     */
    Selection.prototype.setStartPosition = function (startLineNumber, startColumn) {
        if (this.getDirection() === 0 /* LTR */) {
            return new Selection(startLineNumber, startColumn, this.endLineNumber, this.endColumn);
        }
        return new Selection(this.endLineNumber, this.endColumn, startLineNumber, startColumn);
    };
    // ----
    /**
     * Create a `Selection` from one or two positions
     */
    Selection.fromPositions = function (start, end) {
        if (end === void 0) { end = start; }
        return new Selection(start.lineNumber, start.column, end.lineNumber, end.column);
    };
    /**
     * Create a `Selection` from an `ISelection`.
     */
    Selection.liftSelection = function (sel) {
        return new Selection(sel.selectionStartLineNumber, sel.selectionStartColumn, sel.positionLineNumber, sel.positionColumn);
    };
    /**
     * `a` equals `b`.
     */
    Selection.selectionsArrEqual = function (a, b) {
        if (a && !b || !a && b) {
            return false;
        }
        if (!a && !b) {
            return true;
        }
        if (a.length !== b.length) {
            return false;
        }
        for (var i = 0, len = a.length; i < len; i++) {
            if (!this.selectionsEqual(a[i], b[i])) {
                return false;
            }
        }
        return true;
    };
    /**
     * Test if `obj` is an `ISelection`.
     */
    Selection.isISelection = function (obj) {
        return (obj
            && (typeof obj.selectionStartLineNumber === 'number')
            && (typeof obj.selectionStartColumn === 'number')
            && (typeof obj.positionLineNumber === 'number')
            && (typeof obj.positionColumn === 'number'));
    };
    /**
     * Create with a direction.
     */
    Selection.createWithDirection = function (startLineNumber, startColumn, endLineNumber, endColumn, direction) {
        if (direction === 0 /* LTR */) {
            return new Selection(startLineNumber, startColumn, endLineNumber, endColumn);
        }
        return new Selection(endLineNumber, endColumn, startLineNumber, startColumn);
    };
    return Selection;
}(range_Range));


// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/editor/common/core/token.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var Token = /** @class */ (function () {
    function Token(offset, type, language) {
        this.offset = offset | 0; // @perf
        this.type = type;
        this.language = language;
    }
    Token.prototype.toString = function () {
        return '(' + this.offset + ', ' + this.type + ')';
    };
    return Token;
}());

var TokenizationResult = /** @class */ (function () {
    function TokenizationResult(tokens, endState) {
        this.tokens = tokens;
        this.endState = endState;
    }
    return TokenizationResult;
}());

var TokenizationResult2 = /** @class */ (function () {
    function TokenizationResult2(tokens, endState) {
        this.tokens = tokens;
        this.endState = endState;
    }
    return TokenizationResult2;
}());


// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneEnums.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
// THIS IS A GENERATED FILE. DO NOT EDIT DIRECTLY.
var AccessibilitySupport;
(function (AccessibilitySupport) {
    /**
     * This should be the browser case where it is not known if a screen reader is attached or no.
     */
    AccessibilitySupport[AccessibilitySupport["Unknown"] = 0] = "Unknown";
    AccessibilitySupport[AccessibilitySupport["Disabled"] = 1] = "Disabled";
    AccessibilitySupport[AccessibilitySupport["Enabled"] = 2] = "Enabled";
})(AccessibilitySupport || (AccessibilitySupport = {}));
var CompletionItemInsertTextRule;
(function (CompletionItemInsertTextRule) {
    /**
     * Adjust whitespace/indentation of multiline insert texts to
     * match the current line indentation.
     */
    CompletionItemInsertTextRule[CompletionItemInsertTextRule["KeepWhitespace"] = 1] = "KeepWhitespace";
    /**
     * `insertText` is a snippet.
     */
    CompletionItemInsertTextRule[CompletionItemInsertTextRule["InsertAsSnippet"] = 4] = "InsertAsSnippet";
})(CompletionItemInsertTextRule || (CompletionItemInsertTextRule = {}));
var CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind[CompletionItemKind["Method"] = 0] = "Method";
    CompletionItemKind[CompletionItemKind["Function"] = 1] = "Function";
    CompletionItemKind[CompletionItemKind["Constructor"] = 2] = "Constructor";
    CompletionItemKind[CompletionItemKind["Field"] = 3] = "Field";
    CompletionItemKind[CompletionItemKind["Variable"] = 4] = "Variable";
    CompletionItemKind[CompletionItemKind["Class"] = 5] = "Class";
    CompletionItemKind[CompletionItemKind["Struct"] = 6] = "Struct";
    CompletionItemKind[CompletionItemKind["Interface"] = 7] = "Interface";
    CompletionItemKind[CompletionItemKind["Module"] = 8] = "Module";
    CompletionItemKind[CompletionItemKind["Property"] = 9] = "Property";
    CompletionItemKind[CompletionItemKind["Event"] = 10] = "Event";
    CompletionItemKind[CompletionItemKind["Operator"] = 11] = "Operator";
    CompletionItemKind[CompletionItemKind["Unit"] = 12] = "Unit";
    CompletionItemKind[CompletionItemKind["Value"] = 13] = "Value";
    CompletionItemKind[CompletionItemKind["Constant"] = 14] = "Constant";
    CompletionItemKind[CompletionItemKind["Enum"] = 15] = "Enum";
    CompletionItemKind[CompletionItemKind["EnumMember"] = 16] = "EnumMember";
    CompletionItemKind[CompletionItemKind["Keyword"] = 17] = "Keyword";
    CompletionItemKind[CompletionItemKind["Text"] = 18] = "Text";
    CompletionItemKind[CompletionItemKind["Color"] = 19] = "Color";
    CompletionItemKind[CompletionItemKind["File"] = 20] = "File";
    CompletionItemKind[CompletionItemKind["Reference"] = 21] = "Reference";
    CompletionItemKind[CompletionItemKind["Customcolor"] = 22] = "Customcolor";
    CompletionItemKind[CompletionItemKind["Folder"] = 23] = "Folder";
    CompletionItemKind[CompletionItemKind["TypeParameter"] = 24] = "TypeParameter";
    CompletionItemKind[CompletionItemKind["Snippet"] = 25] = "Snippet";
})(CompletionItemKind || (CompletionItemKind = {}));
var CompletionItemTag;
(function (CompletionItemTag) {
    CompletionItemTag[CompletionItemTag["Deprecated"] = 1] = "Deprecated";
})(CompletionItemTag || (CompletionItemTag = {}));
/**
 * How a suggest provider was triggered.
 */
var CompletionTriggerKind;
(function (CompletionTriggerKind) {
    CompletionTriggerKind[CompletionTriggerKind["Invoke"] = 0] = "Invoke";
    CompletionTriggerKind[CompletionTriggerKind["TriggerCharacter"] = 1] = "TriggerCharacter";
    CompletionTriggerKind[CompletionTriggerKind["TriggerForIncompleteCompletions"] = 2] = "TriggerForIncompleteCompletions";
})(CompletionTriggerKind || (CompletionTriggerKind = {}));
/**
 * A positioning preference for rendering content widgets.
 */
var ContentWidgetPositionPreference;
(function (ContentWidgetPositionPreference) {
    /**
     * Place the content widget exactly at a position
     */
    ContentWidgetPositionPreference[ContentWidgetPositionPreference["EXACT"] = 0] = "EXACT";
    /**
     * Place the content widget above a position
     */
    ContentWidgetPositionPreference[ContentWidgetPositionPreference["ABOVE"] = 1] = "ABOVE";
    /**
     * Place the content widget below a position
     */
    ContentWidgetPositionPreference[ContentWidgetPositionPreference["BELOW"] = 2] = "BELOW";
})(ContentWidgetPositionPreference || (ContentWidgetPositionPreference = {}));
/**
 * Describes the reason the cursor has changed its position.
 */
var CursorChangeReason;
(function (CursorChangeReason) {
    /**
     * Unknown or not set.
     */
    CursorChangeReason[CursorChangeReason["NotSet"] = 0] = "NotSet";
    /**
     * A `model.setValue()` was called.
     */
    CursorChangeReason[CursorChangeReason["ContentFlush"] = 1] = "ContentFlush";
    /**
     * The `model` has been changed outside of this cursor and the cursor recovers its position from associated markers.
     */
    CursorChangeReason[CursorChangeReason["RecoverFromMarkers"] = 2] = "RecoverFromMarkers";
    /**
     * There was an explicit user gesture.
     */
    CursorChangeReason[CursorChangeReason["Explicit"] = 3] = "Explicit";
    /**
     * There was a Paste.
     */
    CursorChangeReason[CursorChangeReason["Paste"] = 4] = "Paste";
    /**
     * There was an Undo.
     */
    CursorChangeReason[CursorChangeReason["Undo"] = 5] = "Undo";
    /**
     * There was a Redo.
     */
    CursorChangeReason[CursorChangeReason["Redo"] = 6] = "Redo";
})(CursorChangeReason || (CursorChangeReason = {}));
/**
 * The default end of line to use when instantiating models.
 */
var DefaultEndOfLine;
(function (DefaultEndOfLine) {
    /**
     * Use line feed (\n) as the end of line character.
     */
    DefaultEndOfLine[DefaultEndOfLine["LF"] = 1] = "LF";
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    DefaultEndOfLine[DefaultEndOfLine["CRLF"] = 2] = "CRLF";
})(DefaultEndOfLine || (DefaultEndOfLine = {}));
/**
 * A document highlight kind.
 */
var DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind[DocumentHighlightKind["Text"] = 0] = "Text";
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind[DocumentHighlightKind["Read"] = 1] = "Read";
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind[DocumentHighlightKind["Write"] = 2] = "Write";
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
/**
 * Configuration options for auto indentation in the editor
 */
var EditorAutoIndentStrategy;
(function (EditorAutoIndentStrategy) {
    EditorAutoIndentStrategy[EditorAutoIndentStrategy["None"] = 0] = "None";
    EditorAutoIndentStrategy[EditorAutoIndentStrategy["Keep"] = 1] = "Keep";
    EditorAutoIndentStrategy[EditorAutoIndentStrategy["Brackets"] = 2] = "Brackets";
    EditorAutoIndentStrategy[EditorAutoIndentStrategy["Advanced"] = 3] = "Advanced";
    EditorAutoIndentStrategy[EditorAutoIndentStrategy["Full"] = 4] = "Full";
})(EditorAutoIndentStrategy || (EditorAutoIndentStrategy = {}));
var EditorOption;
(function (EditorOption) {
    EditorOption[EditorOption["acceptSuggestionOnCommitCharacter"] = 0] = "acceptSuggestionOnCommitCharacter";
    EditorOption[EditorOption["acceptSuggestionOnEnter"] = 1] = "acceptSuggestionOnEnter";
    EditorOption[EditorOption["accessibilitySupport"] = 2] = "accessibilitySupport";
    EditorOption[EditorOption["accessibilityPageSize"] = 3] = "accessibilityPageSize";
    EditorOption[EditorOption["ariaLabel"] = 4] = "ariaLabel";
    EditorOption[EditorOption["autoClosingBrackets"] = 5] = "autoClosingBrackets";
    EditorOption[EditorOption["autoClosingOvertype"] = 6] = "autoClosingOvertype";
    EditorOption[EditorOption["autoClosingQuotes"] = 7] = "autoClosingQuotes";
    EditorOption[EditorOption["autoIndent"] = 8] = "autoIndent";
    EditorOption[EditorOption["automaticLayout"] = 9] = "automaticLayout";
    EditorOption[EditorOption["autoSurround"] = 10] = "autoSurround";
    EditorOption[EditorOption["codeLens"] = 11] = "codeLens";
    EditorOption[EditorOption["colorDecorators"] = 12] = "colorDecorators";
    EditorOption[EditorOption["comments"] = 13] = "comments";
    EditorOption[EditorOption["contextmenu"] = 14] = "contextmenu";
    EditorOption[EditorOption["copyWithSyntaxHighlighting"] = 15] = "copyWithSyntaxHighlighting";
    EditorOption[EditorOption["cursorBlinking"] = 16] = "cursorBlinking";
    EditorOption[EditorOption["cursorSmoothCaretAnimation"] = 17] = "cursorSmoothCaretAnimation";
    EditorOption[EditorOption["cursorStyle"] = 18] = "cursorStyle";
    EditorOption[EditorOption["cursorSurroundingLines"] = 19] = "cursorSurroundingLines";
    EditorOption[EditorOption["cursorSurroundingLinesStyle"] = 20] = "cursorSurroundingLinesStyle";
    EditorOption[EditorOption["cursorWidth"] = 21] = "cursorWidth";
    EditorOption[EditorOption["disableLayerHinting"] = 22] = "disableLayerHinting";
    EditorOption[EditorOption["disableMonospaceOptimizations"] = 23] = "disableMonospaceOptimizations";
    EditorOption[EditorOption["dragAndDrop"] = 24] = "dragAndDrop";
    EditorOption[EditorOption["emptySelectionClipboard"] = 25] = "emptySelectionClipboard";
    EditorOption[EditorOption["extraEditorClassName"] = 26] = "extraEditorClassName";
    EditorOption[EditorOption["fastScrollSensitivity"] = 27] = "fastScrollSensitivity";
    EditorOption[EditorOption["find"] = 28] = "find";
    EditorOption[EditorOption["fixedOverflowWidgets"] = 29] = "fixedOverflowWidgets";
    EditorOption[EditorOption["folding"] = 30] = "folding";
    EditorOption[EditorOption["foldingStrategy"] = 31] = "foldingStrategy";
    EditorOption[EditorOption["foldingHighlight"] = 32] = "foldingHighlight";
    EditorOption[EditorOption["fontFamily"] = 33] = "fontFamily";
    EditorOption[EditorOption["fontInfo"] = 34] = "fontInfo";
    EditorOption[EditorOption["fontLigatures"] = 35] = "fontLigatures";
    EditorOption[EditorOption["fontSize"] = 36] = "fontSize";
    EditorOption[EditorOption["fontWeight"] = 37] = "fontWeight";
    EditorOption[EditorOption["formatOnPaste"] = 38] = "formatOnPaste";
    EditorOption[EditorOption["formatOnType"] = 39] = "formatOnType";
    EditorOption[EditorOption["glyphMargin"] = 40] = "glyphMargin";
    EditorOption[EditorOption["gotoLocation"] = 41] = "gotoLocation";
    EditorOption[EditorOption["hideCursorInOverviewRuler"] = 42] = "hideCursorInOverviewRuler";
    EditorOption[EditorOption["highlightActiveIndentGuide"] = 43] = "highlightActiveIndentGuide";
    EditorOption[EditorOption["hover"] = 44] = "hover";
    EditorOption[EditorOption["inDiffEditor"] = 45] = "inDiffEditor";
    EditorOption[EditorOption["letterSpacing"] = 46] = "letterSpacing";
    EditorOption[EditorOption["lightbulb"] = 47] = "lightbulb";
    EditorOption[EditorOption["lineDecorationsWidth"] = 48] = "lineDecorationsWidth";
    EditorOption[EditorOption["lineHeight"] = 49] = "lineHeight";
    EditorOption[EditorOption["lineNumbers"] = 50] = "lineNumbers";
    EditorOption[EditorOption["lineNumbersMinChars"] = 51] = "lineNumbersMinChars";
    EditorOption[EditorOption["links"] = 52] = "links";
    EditorOption[EditorOption["matchBrackets"] = 53] = "matchBrackets";
    EditorOption[EditorOption["minimap"] = 54] = "minimap";
    EditorOption[EditorOption["mouseStyle"] = 55] = "mouseStyle";
    EditorOption[EditorOption["mouseWheelScrollSensitivity"] = 56] = "mouseWheelScrollSensitivity";
    EditorOption[EditorOption["mouseWheelZoom"] = 57] = "mouseWheelZoom";
    EditorOption[EditorOption["multiCursorMergeOverlapping"] = 58] = "multiCursorMergeOverlapping";
    EditorOption[EditorOption["multiCursorModifier"] = 59] = "multiCursorModifier";
    EditorOption[EditorOption["multiCursorPaste"] = 60] = "multiCursorPaste";
    EditorOption[EditorOption["occurrencesHighlight"] = 61] = "occurrencesHighlight";
    EditorOption[EditorOption["overviewRulerBorder"] = 62] = "overviewRulerBorder";
    EditorOption[EditorOption["overviewRulerLanes"] = 63] = "overviewRulerLanes";
    EditorOption[EditorOption["parameterHints"] = 64] = "parameterHints";
    EditorOption[EditorOption["peekWidgetDefaultFocus"] = 65] = "peekWidgetDefaultFocus";
    EditorOption[EditorOption["quickSuggestions"] = 66] = "quickSuggestions";
    EditorOption[EditorOption["quickSuggestionsDelay"] = 67] = "quickSuggestionsDelay";
    EditorOption[EditorOption["readOnly"] = 68] = "readOnly";
    EditorOption[EditorOption["renderControlCharacters"] = 69] = "renderControlCharacters";
    EditorOption[EditorOption["renderIndentGuides"] = 70] = "renderIndentGuides";
    EditorOption[EditorOption["renderFinalNewline"] = 71] = "renderFinalNewline";
    EditorOption[EditorOption["renderLineHighlight"] = 72] = "renderLineHighlight";
    EditorOption[EditorOption["renderValidationDecorations"] = 73] = "renderValidationDecorations";
    EditorOption[EditorOption["renderWhitespace"] = 74] = "renderWhitespace";
    EditorOption[EditorOption["revealHorizontalRightPadding"] = 75] = "revealHorizontalRightPadding";
    EditorOption[EditorOption["roundedSelection"] = 76] = "roundedSelection";
    EditorOption[EditorOption["rulers"] = 77] = "rulers";
    EditorOption[EditorOption["scrollbar"] = 78] = "scrollbar";
    EditorOption[EditorOption["scrollBeyondLastColumn"] = 79] = "scrollBeyondLastColumn";
    EditorOption[EditorOption["scrollBeyondLastLine"] = 80] = "scrollBeyondLastLine";
    EditorOption[EditorOption["selectionClipboard"] = 81] = "selectionClipboard";
    EditorOption[EditorOption["selectionHighlight"] = 82] = "selectionHighlight";
    EditorOption[EditorOption["selectOnLineNumbers"] = 83] = "selectOnLineNumbers";
    EditorOption[EditorOption["showFoldingControls"] = 84] = "showFoldingControls";
    EditorOption[EditorOption["showUnused"] = 85] = "showUnused";
    EditorOption[EditorOption["snippetSuggestions"] = 86] = "snippetSuggestions";
    EditorOption[EditorOption["smoothScrolling"] = 87] = "smoothScrolling";
    EditorOption[EditorOption["stopRenderingLineAfter"] = 88] = "stopRenderingLineAfter";
    EditorOption[EditorOption["suggest"] = 89] = "suggest";
    EditorOption[EditorOption["suggestFontSize"] = 90] = "suggestFontSize";
    EditorOption[EditorOption["suggestLineHeight"] = 91] = "suggestLineHeight";
    EditorOption[EditorOption["suggestOnTriggerCharacters"] = 92] = "suggestOnTriggerCharacters";
    EditorOption[EditorOption["suggestSelection"] = 93] = "suggestSelection";
    EditorOption[EditorOption["tabCompletion"] = 94] = "tabCompletion";
    EditorOption[EditorOption["useTabStops"] = 95] = "useTabStops";
    EditorOption[EditorOption["wordSeparators"] = 96] = "wordSeparators";
    EditorOption[EditorOption["wordWrap"] = 97] = "wordWrap";
    EditorOption[EditorOption["wordWrapBreakAfterCharacters"] = 98] = "wordWrapBreakAfterCharacters";
    EditorOption[EditorOption["wordWrapBreakBeforeCharacters"] = 99] = "wordWrapBreakBeforeCharacters";
    EditorOption[EditorOption["wordWrapColumn"] = 100] = "wordWrapColumn";
    EditorOption[EditorOption["wordWrapMinified"] = 101] = "wordWrapMinified";
    EditorOption[EditorOption["wrappingIndent"] = 102] = "wrappingIndent";
    EditorOption[EditorOption["wrappingStrategy"] = 103] = "wrappingStrategy";
    EditorOption[EditorOption["editorClassName"] = 104] = "editorClassName";
    EditorOption[EditorOption["pixelRatio"] = 105] = "pixelRatio";
    EditorOption[EditorOption["tabFocusMode"] = 106] = "tabFocusMode";
    EditorOption[EditorOption["layoutInfo"] = 107] = "layoutInfo";
    EditorOption[EditorOption["wrappingInfo"] = 108] = "wrappingInfo";
})(EditorOption || (EditorOption = {}));
/**
 * End of line character preference.
 */
var EndOfLinePreference;
(function (EndOfLinePreference) {
    /**
     * Use the end of line character identified in the text buffer.
     */
    EndOfLinePreference[EndOfLinePreference["TextDefined"] = 0] = "TextDefined";
    /**
     * Use line feed (\n) as the end of line character.
     */
    EndOfLinePreference[EndOfLinePreference["LF"] = 1] = "LF";
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    EndOfLinePreference[EndOfLinePreference["CRLF"] = 2] = "CRLF";
})(EndOfLinePreference || (EndOfLinePreference = {}));
/**
 * End of line character preference.
 */
var EndOfLineSequence;
(function (EndOfLineSequence) {
    /**
     * Use line feed (\n) as the end of line character.
     */
    EndOfLineSequence[EndOfLineSequence["LF"] = 0] = "LF";
    /**
     * Use carriage return and line feed (\r\n) as the end of line character.
     */
    EndOfLineSequence[EndOfLineSequence["CRLF"] = 1] = "CRLF";
})(EndOfLineSequence || (EndOfLineSequence = {}));
/**
 * Describes what to do with the indentation when pressing Enter.
 */
var IndentAction;
(function (IndentAction) {
    /**
     * Insert new line and copy the previous line's indentation.
     */
    IndentAction[IndentAction["None"] = 0] = "None";
    /**
     * Insert new line and indent once (relative to the previous line's indentation).
     */
    IndentAction[IndentAction["Indent"] = 1] = "Indent";
    /**
     * Insert two new lines:
     *  - the first one indented which will hold the cursor
     *  - the second one at the same indentation level
     */
    IndentAction[IndentAction["IndentOutdent"] = 2] = "IndentOutdent";
    /**
     * Insert new line and outdent once (relative to the previous line's indentation).
     */
    IndentAction[IndentAction["Outdent"] = 3] = "Outdent";
})(IndentAction || (IndentAction = {}));
/**
 * Virtual Key Codes, the value does not hold any inherent meaning.
 * Inspired somewhat from https://msdn.microsoft.com/en-us/library/windows/desktop/dd375731(v=vs.85).aspx
 * But these are "more general", as they should work across browsers & OS`s.
 */
var KeyCode;
(function (KeyCode) {
    /**
     * Placed first to cover the 0 value of the enum.
     */
    KeyCode[KeyCode["Unknown"] = 0] = "Unknown";
    KeyCode[KeyCode["Backspace"] = 1] = "Backspace";
    KeyCode[KeyCode["Tab"] = 2] = "Tab";
    KeyCode[KeyCode["Enter"] = 3] = "Enter";
    KeyCode[KeyCode["Shift"] = 4] = "Shift";
    KeyCode[KeyCode["Ctrl"] = 5] = "Ctrl";
    KeyCode[KeyCode["Alt"] = 6] = "Alt";
    KeyCode[KeyCode["PauseBreak"] = 7] = "PauseBreak";
    KeyCode[KeyCode["CapsLock"] = 8] = "CapsLock";
    KeyCode[KeyCode["Escape"] = 9] = "Escape";
    KeyCode[KeyCode["Space"] = 10] = "Space";
    KeyCode[KeyCode["PageUp"] = 11] = "PageUp";
    KeyCode[KeyCode["PageDown"] = 12] = "PageDown";
    KeyCode[KeyCode["End"] = 13] = "End";
    KeyCode[KeyCode["Home"] = 14] = "Home";
    KeyCode[KeyCode["LeftArrow"] = 15] = "LeftArrow";
    KeyCode[KeyCode["UpArrow"] = 16] = "UpArrow";
    KeyCode[KeyCode["RightArrow"] = 17] = "RightArrow";
    KeyCode[KeyCode["DownArrow"] = 18] = "DownArrow";
    KeyCode[KeyCode["Insert"] = 19] = "Insert";
    KeyCode[KeyCode["Delete"] = 20] = "Delete";
    KeyCode[KeyCode["KEY_0"] = 21] = "KEY_0";
    KeyCode[KeyCode["KEY_1"] = 22] = "KEY_1";
    KeyCode[KeyCode["KEY_2"] = 23] = "KEY_2";
    KeyCode[KeyCode["KEY_3"] = 24] = "KEY_3";
    KeyCode[KeyCode["KEY_4"] = 25] = "KEY_4";
    KeyCode[KeyCode["KEY_5"] = 26] = "KEY_5";
    KeyCode[KeyCode["KEY_6"] = 27] = "KEY_6";
    KeyCode[KeyCode["KEY_7"] = 28] = "KEY_7";
    KeyCode[KeyCode["KEY_8"] = 29] = "KEY_8";
    KeyCode[KeyCode["KEY_9"] = 30] = "KEY_9";
    KeyCode[KeyCode["KEY_A"] = 31] = "KEY_A";
    KeyCode[KeyCode["KEY_B"] = 32] = "KEY_B";
    KeyCode[KeyCode["KEY_C"] = 33] = "KEY_C";
    KeyCode[KeyCode["KEY_D"] = 34] = "KEY_D";
    KeyCode[KeyCode["KEY_E"] = 35] = "KEY_E";
    KeyCode[KeyCode["KEY_F"] = 36] = "KEY_F";
    KeyCode[KeyCode["KEY_G"] = 37] = "KEY_G";
    KeyCode[KeyCode["KEY_H"] = 38] = "KEY_H";
    KeyCode[KeyCode["KEY_I"] = 39] = "KEY_I";
    KeyCode[KeyCode["KEY_J"] = 40] = "KEY_J";
    KeyCode[KeyCode["KEY_K"] = 41] = "KEY_K";
    KeyCode[KeyCode["KEY_L"] = 42] = "KEY_L";
    KeyCode[KeyCode["KEY_M"] = 43] = "KEY_M";
    KeyCode[KeyCode["KEY_N"] = 44] = "KEY_N";
    KeyCode[KeyCode["KEY_O"] = 45] = "KEY_O";
    KeyCode[KeyCode["KEY_P"] = 46] = "KEY_P";
    KeyCode[KeyCode["KEY_Q"] = 47] = "KEY_Q";
    KeyCode[KeyCode["KEY_R"] = 48] = "KEY_R";
    KeyCode[KeyCode["KEY_S"] = 49] = "KEY_S";
    KeyCode[KeyCode["KEY_T"] = 50] = "KEY_T";
    KeyCode[KeyCode["KEY_U"] = 51] = "KEY_U";
    KeyCode[KeyCode["KEY_V"] = 52] = "KEY_V";
    KeyCode[KeyCode["KEY_W"] = 53] = "KEY_W";
    KeyCode[KeyCode["KEY_X"] = 54] = "KEY_X";
    KeyCode[KeyCode["KEY_Y"] = 55] = "KEY_Y";
    KeyCode[KeyCode["KEY_Z"] = 56] = "KEY_Z";
    KeyCode[KeyCode["Meta"] = 57] = "Meta";
    KeyCode[KeyCode["ContextMenu"] = 58] = "ContextMenu";
    KeyCode[KeyCode["F1"] = 59] = "F1";
    KeyCode[KeyCode["F2"] = 60] = "F2";
    KeyCode[KeyCode["F3"] = 61] = "F3";
    KeyCode[KeyCode["F4"] = 62] = "F4";
    KeyCode[KeyCode["F5"] = 63] = "F5";
    KeyCode[KeyCode["F6"] = 64] = "F6";
    KeyCode[KeyCode["F7"] = 65] = "F7";
    KeyCode[KeyCode["F8"] = 66] = "F8";
    KeyCode[KeyCode["F9"] = 67] = "F9";
    KeyCode[KeyCode["F10"] = 68] = "F10";
    KeyCode[KeyCode["F11"] = 69] = "F11";
    KeyCode[KeyCode["F12"] = 70] = "F12";
    KeyCode[KeyCode["F13"] = 71] = "F13";
    KeyCode[KeyCode["F14"] = 72] = "F14";
    KeyCode[KeyCode["F15"] = 73] = "F15";
    KeyCode[KeyCode["F16"] = 74] = "F16";
    KeyCode[KeyCode["F17"] = 75] = "F17";
    KeyCode[KeyCode["F18"] = 76] = "F18";
    KeyCode[KeyCode["F19"] = 77] = "F19";
    KeyCode[KeyCode["NumLock"] = 78] = "NumLock";
    KeyCode[KeyCode["ScrollLock"] = 79] = "ScrollLock";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the ';:' key
     */
    KeyCode[KeyCode["US_SEMICOLON"] = 80] = "US_SEMICOLON";
    /**
     * For any country/region, the '+' key
     * For the US standard keyboard, the '=+' key
     */
    KeyCode[KeyCode["US_EQUAL"] = 81] = "US_EQUAL";
    /**
     * For any country/region, the ',' key
     * For the US standard keyboard, the ',<' key
     */
    KeyCode[KeyCode["US_COMMA"] = 82] = "US_COMMA";
    /**
     * For any country/region, the '-' key
     * For the US standard keyboard, the '-_' key
     */
    KeyCode[KeyCode["US_MINUS"] = 83] = "US_MINUS";
    /**
     * For any country/region, the '.' key
     * For the US standard keyboard, the '.>' key
     */
    KeyCode[KeyCode["US_DOT"] = 84] = "US_DOT";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the '/?' key
     */
    KeyCode[KeyCode["US_SLASH"] = 85] = "US_SLASH";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the '`~' key
     */
    KeyCode[KeyCode["US_BACKTICK"] = 86] = "US_BACKTICK";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the '[{' key
     */
    KeyCode[KeyCode["US_OPEN_SQUARE_BRACKET"] = 87] = "US_OPEN_SQUARE_BRACKET";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the '\|' key
     */
    KeyCode[KeyCode["US_BACKSLASH"] = 88] = "US_BACKSLASH";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the ']}' key
     */
    KeyCode[KeyCode["US_CLOSE_SQUARE_BRACKET"] = 89] = "US_CLOSE_SQUARE_BRACKET";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     * For the US standard keyboard, the ''"' key
     */
    KeyCode[KeyCode["US_QUOTE"] = 90] = "US_QUOTE";
    /**
     * Used for miscellaneous characters; it can vary by keyboard.
     */
    KeyCode[KeyCode["OEM_8"] = 91] = "OEM_8";
    /**
     * Either the angle bracket key or the backslash key on the RT 102-key keyboard.
     */
    KeyCode[KeyCode["OEM_102"] = 92] = "OEM_102";
    KeyCode[KeyCode["NUMPAD_0"] = 93] = "NUMPAD_0";
    KeyCode[KeyCode["NUMPAD_1"] = 94] = "NUMPAD_1";
    KeyCode[KeyCode["NUMPAD_2"] = 95] = "NUMPAD_2";
    KeyCode[KeyCode["NUMPAD_3"] = 96] = "NUMPAD_3";
    KeyCode[KeyCode["NUMPAD_4"] = 97] = "NUMPAD_4";
    KeyCode[KeyCode["NUMPAD_5"] = 98] = "NUMPAD_5";
    KeyCode[KeyCode["NUMPAD_6"] = 99] = "NUMPAD_6";
    KeyCode[KeyCode["NUMPAD_7"] = 100] = "NUMPAD_7";
    KeyCode[KeyCode["NUMPAD_8"] = 101] = "NUMPAD_8";
    KeyCode[KeyCode["NUMPAD_9"] = 102] = "NUMPAD_9";
    KeyCode[KeyCode["NUMPAD_MULTIPLY"] = 103] = "NUMPAD_MULTIPLY";
    KeyCode[KeyCode["NUMPAD_ADD"] = 104] = "NUMPAD_ADD";
    KeyCode[KeyCode["NUMPAD_SEPARATOR"] = 105] = "NUMPAD_SEPARATOR";
    KeyCode[KeyCode["NUMPAD_SUBTRACT"] = 106] = "NUMPAD_SUBTRACT";
    KeyCode[KeyCode["NUMPAD_DECIMAL"] = 107] = "NUMPAD_DECIMAL";
    KeyCode[KeyCode["NUMPAD_DIVIDE"] = 108] = "NUMPAD_DIVIDE";
    /**
     * Cover all key codes when IME is processing input.
     */
    KeyCode[KeyCode["KEY_IN_COMPOSITION"] = 109] = "KEY_IN_COMPOSITION";
    KeyCode[KeyCode["ABNT_C1"] = 110] = "ABNT_C1";
    KeyCode[KeyCode["ABNT_C2"] = 111] = "ABNT_C2";
    /**
     * Placed last to cover the length of the enum.
     * Please do not depend on this value!
     */
    KeyCode[KeyCode["MAX_VALUE"] = 112] = "MAX_VALUE";
})(KeyCode || (KeyCode = {}));
var MarkerSeverity;
(function (MarkerSeverity) {
    MarkerSeverity[MarkerSeverity["Hint"] = 1] = "Hint";
    MarkerSeverity[MarkerSeverity["Info"] = 2] = "Info";
    MarkerSeverity[MarkerSeverity["Warning"] = 4] = "Warning";
    MarkerSeverity[MarkerSeverity["Error"] = 8] = "Error";
})(MarkerSeverity || (MarkerSeverity = {}));
var MarkerTag;
(function (MarkerTag) {
    MarkerTag[MarkerTag["Unnecessary"] = 1] = "Unnecessary";
    MarkerTag[MarkerTag["Deprecated"] = 2] = "Deprecated";
})(MarkerTag || (MarkerTag = {}));
/**
 * Position in the minimap to render the decoration.
 */
var MinimapPosition;
(function (MinimapPosition) {
    MinimapPosition[MinimapPosition["Inline"] = 1] = "Inline";
    MinimapPosition[MinimapPosition["Gutter"] = 2] = "Gutter";
})(MinimapPosition || (MinimapPosition = {}));
/**
 * Type of hit element with the mouse in the editor.
 */
var MouseTargetType;
(function (MouseTargetType) {
    /**
     * Mouse is on top of an unknown element.
     */
    MouseTargetType[MouseTargetType["UNKNOWN"] = 0] = "UNKNOWN";
    /**
     * Mouse is on top of the textarea used for input.
     */
    MouseTargetType[MouseTargetType["TEXTAREA"] = 1] = "TEXTAREA";
    /**
     * Mouse is on top of the glyph margin
     */
    MouseTargetType[MouseTargetType["GUTTER_GLYPH_MARGIN"] = 2] = "GUTTER_GLYPH_MARGIN";
    /**
     * Mouse is on top of the line numbers
     */
    MouseTargetType[MouseTargetType["GUTTER_LINE_NUMBERS"] = 3] = "GUTTER_LINE_NUMBERS";
    /**
     * Mouse is on top of the line decorations
     */
    MouseTargetType[MouseTargetType["GUTTER_LINE_DECORATIONS"] = 4] = "GUTTER_LINE_DECORATIONS";
    /**
     * Mouse is on top of the whitespace left in the gutter by a view zone.
     */
    MouseTargetType[MouseTargetType["GUTTER_VIEW_ZONE"] = 5] = "GUTTER_VIEW_ZONE";
    /**
     * Mouse is on top of text in the content.
     */
    MouseTargetType[MouseTargetType["CONTENT_TEXT"] = 6] = "CONTENT_TEXT";
    /**
     * Mouse is on top of empty space in the content (e.g. after line text or below last line)
     */
    MouseTargetType[MouseTargetType["CONTENT_EMPTY"] = 7] = "CONTENT_EMPTY";
    /**
     * Mouse is on top of a view zone in the content.
     */
    MouseTargetType[MouseTargetType["CONTENT_VIEW_ZONE"] = 8] = "CONTENT_VIEW_ZONE";
    /**
     * Mouse is on top of a content widget.
     */
    MouseTargetType[MouseTargetType["CONTENT_WIDGET"] = 9] = "CONTENT_WIDGET";
    /**
     * Mouse is on top of the decorations overview ruler.
     */
    MouseTargetType[MouseTargetType["OVERVIEW_RULER"] = 10] = "OVERVIEW_RULER";
    /**
     * Mouse is on top of a scrollbar.
     */
    MouseTargetType[MouseTargetType["SCROLLBAR"] = 11] = "SCROLLBAR";
    /**
     * Mouse is on top of an overlay widget.
     */
    MouseTargetType[MouseTargetType["OVERLAY_WIDGET"] = 12] = "OVERLAY_WIDGET";
    /**
     * Mouse is outside of the editor.
     */
    MouseTargetType[MouseTargetType["OUTSIDE_EDITOR"] = 13] = "OUTSIDE_EDITOR";
})(MouseTargetType || (MouseTargetType = {}));
/**
 * A positioning preference for rendering overlay widgets.
 */
var OverlayWidgetPositionPreference;
(function (OverlayWidgetPositionPreference) {
    /**
     * Position the overlay widget in the top right corner
     */
    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference["TOP_RIGHT_CORNER"] = 0] = "TOP_RIGHT_CORNER";
    /**
     * Position the overlay widget in the bottom right corner
     */
    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference["BOTTOM_RIGHT_CORNER"] = 1] = "BOTTOM_RIGHT_CORNER";
    /**
     * Position the overlay widget in the top center
     */
    OverlayWidgetPositionPreference[OverlayWidgetPositionPreference["TOP_CENTER"] = 2] = "TOP_CENTER";
})(OverlayWidgetPositionPreference || (OverlayWidgetPositionPreference = {}));
/**
 * Vertical Lane in the overview ruler of the editor.
 */
var OverviewRulerLane;
(function (OverviewRulerLane) {
    OverviewRulerLane[OverviewRulerLane["Left"] = 1] = "Left";
    OverviewRulerLane[OverviewRulerLane["Center"] = 2] = "Center";
    OverviewRulerLane[OverviewRulerLane["Right"] = 4] = "Right";
    OverviewRulerLane[OverviewRulerLane["Full"] = 7] = "Full";
})(OverviewRulerLane || (OverviewRulerLane = {}));
var RenderLineNumbersType;
(function (RenderLineNumbersType) {
    RenderLineNumbersType[RenderLineNumbersType["Off"] = 0] = "Off";
    RenderLineNumbersType[RenderLineNumbersType["On"] = 1] = "On";
    RenderLineNumbersType[RenderLineNumbersType["Relative"] = 2] = "Relative";
    RenderLineNumbersType[RenderLineNumbersType["Interval"] = 3] = "Interval";
    RenderLineNumbersType[RenderLineNumbersType["Custom"] = 4] = "Custom";
})(RenderLineNumbersType || (RenderLineNumbersType = {}));
var RenderMinimap;
(function (RenderMinimap) {
    RenderMinimap[RenderMinimap["None"] = 0] = "None";
    RenderMinimap[RenderMinimap["Text"] = 1] = "Text";
    RenderMinimap[RenderMinimap["Blocks"] = 2] = "Blocks";
})(RenderMinimap || (RenderMinimap = {}));
var ScrollType;
(function (ScrollType) {
    ScrollType[ScrollType["Smooth"] = 0] = "Smooth";
    ScrollType[ScrollType["Immediate"] = 1] = "Immediate";
})(ScrollType || (ScrollType = {}));
var ScrollbarVisibility;
(function (ScrollbarVisibility) {
    ScrollbarVisibility[ScrollbarVisibility["Auto"] = 1] = "Auto";
    ScrollbarVisibility[ScrollbarVisibility["Hidden"] = 2] = "Hidden";
    ScrollbarVisibility[ScrollbarVisibility["Visible"] = 3] = "Visible";
})(ScrollbarVisibility || (ScrollbarVisibility = {}));
/**
 * The direction of a selection.
 */
var SelectionDirection;
(function (SelectionDirection) {
    /**
     * The selection starts above where it ends.
     */
    SelectionDirection[SelectionDirection["LTR"] = 0] = "LTR";
    /**
     * The selection starts below where it ends.
     */
    SelectionDirection[SelectionDirection["RTL"] = 1] = "RTL";
})(SelectionDirection || (SelectionDirection = {}));
var SignatureHelpTriggerKind;
(function (SignatureHelpTriggerKind) {
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["Invoke"] = 1] = "Invoke";
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["TriggerCharacter"] = 2] = "TriggerCharacter";
    SignatureHelpTriggerKind[SignatureHelpTriggerKind["ContentChange"] = 3] = "ContentChange";
})(SignatureHelpTriggerKind || (SignatureHelpTriggerKind = {}));
/**
 * A symbol kind.
 */
var SymbolKind;
(function (SymbolKind) {
    SymbolKind[SymbolKind["File"] = 0] = "File";
    SymbolKind[SymbolKind["Module"] = 1] = "Module";
    SymbolKind[SymbolKind["Namespace"] = 2] = "Namespace";
    SymbolKind[SymbolKind["Package"] = 3] = "Package";
    SymbolKind[SymbolKind["Class"] = 4] = "Class";
    SymbolKind[SymbolKind["Method"] = 5] = "Method";
    SymbolKind[SymbolKind["Property"] = 6] = "Property";
    SymbolKind[SymbolKind["Field"] = 7] = "Field";
    SymbolKind[SymbolKind["Constructor"] = 8] = "Constructor";
    SymbolKind[SymbolKind["Enum"] = 9] = "Enum";
    SymbolKind[SymbolKind["Interface"] = 10] = "Interface";
    SymbolKind[SymbolKind["Function"] = 11] = "Function";
    SymbolKind[SymbolKind["Variable"] = 12] = "Variable";
    SymbolKind[SymbolKind["Constant"] = 13] = "Constant";
    SymbolKind[SymbolKind["String"] = 14] = "String";
    SymbolKind[SymbolKind["Number"] = 15] = "Number";
    SymbolKind[SymbolKind["Boolean"] = 16] = "Boolean";
    SymbolKind[SymbolKind["Array"] = 17] = "Array";
    SymbolKind[SymbolKind["Object"] = 18] = "Object";
    SymbolKind[SymbolKind["Key"] = 19] = "Key";
    SymbolKind[SymbolKind["Null"] = 20] = "Null";
    SymbolKind[SymbolKind["EnumMember"] = 21] = "EnumMember";
    SymbolKind[SymbolKind["Struct"] = 22] = "Struct";
    SymbolKind[SymbolKind["Event"] = 23] = "Event";
    SymbolKind[SymbolKind["Operator"] = 24] = "Operator";
    SymbolKind[SymbolKind["TypeParameter"] = 25] = "TypeParameter";
})(SymbolKind || (SymbolKind = {}));
var SymbolTag;
(function (SymbolTag) {
    SymbolTag[SymbolTag["Deprecated"] = 1] = "Deprecated";
})(SymbolTag || (SymbolTag = {}));
/**
 * The kind of animation in which the editor's cursor should be rendered.
 */
var TextEditorCursorBlinkingStyle;
(function (TextEditorCursorBlinkingStyle) {
    /**
     * Hidden
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Hidden"] = 0] = "Hidden";
    /**
     * Blinking
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Blink"] = 1] = "Blink";
    /**
     * Blinking with smooth fading
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Smooth"] = 2] = "Smooth";
    /**
     * Blinking with prolonged filled state and smooth fading
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Phase"] = 3] = "Phase";
    /**
     * Expand collapse animation on the y axis
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Expand"] = 4] = "Expand";
    /**
     * No-Blinking
     */
    TextEditorCursorBlinkingStyle[TextEditorCursorBlinkingStyle["Solid"] = 5] = "Solid";
})(TextEditorCursorBlinkingStyle || (TextEditorCursorBlinkingStyle = {}));
/**
 * The style in which the editor's cursor should be rendered.
 */
var TextEditorCursorStyle;
(function (TextEditorCursorStyle) {
    /**
     * As a vertical line (sitting between two characters).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["Line"] = 1] = "Line";
    /**
     * As a block (sitting on top of a character).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["Block"] = 2] = "Block";
    /**
     * As a horizontal line (sitting under a character).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["Underline"] = 3] = "Underline";
    /**
     * As a thin vertical line (sitting between two characters).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["LineThin"] = 4] = "LineThin";
    /**
     * As an outlined block (sitting on top of a character).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["BlockOutline"] = 5] = "BlockOutline";
    /**
     * As a thin horizontal line (sitting under a character).
     */
    TextEditorCursorStyle[TextEditorCursorStyle["UnderlineThin"] = 6] = "UnderlineThin";
})(TextEditorCursorStyle || (TextEditorCursorStyle = {}));
/**
 * Describes the behavior of decorations when typing/editing near their edges.
 * Note: Please do not edit the values, as they very carefully match `DecorationRangeBehavior`
 */
var TrackedRangeStickiness;
(function (TrackedRangeStickiness) {
    TrackedRangeStickiness[TrackedRangeStickiness["AlwaysGrowsWhenTypingAtEdges"] = 0] = "AlwaysGrowsWhenTypingAtEdges";
    TrackedRangeStickiness[TrackedRangeStickiness["NeverGrowsWhenTypingAtEdges"] = 1] = "NeverGrowsWhenTypingAtEdges";
    TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingBefore"] = 2] = "GrowsOnlyWhenTypingBefore";
    TrackedRangeStickiness[TrackedRangeStickiness["GrowsOnlyWhenTypingAfter"] = 3] = "GrowsOnlyWhenTypingAfter";
})(TrackedRangeStickiness || (TrackedRangeStickiness = {}));
/**
 * Describes how to indent wrapped lines.
 */
var WrappingIndent;
(function (WrappingIndent) {
    /**
     * No indentation => wrapped lines begin at column 1.
     */
    WrappingIndent[WrappingIndent["None"] = 0] = "None";
    /**
     * Same => wrapped lines get the same indentation as the parent.
     */
    WrappingIndent[WrappingIndent["Same"] = 1] = "Same";
    /**
     * Indent => wrapped lines get +1 indentation toward the parent.
     */
    WrappingIndent[WrappingIndent["Indent"] = 2] = "Indent";
    /**
     * DeepIndent => wrapped lines get +2 indentation toward the parent.
     */
    WrappingIndent[WrappingIndent["DeepIndent"] = 3] = "DeepIndent";
})(WrappingIndent || (WrappingIndent = {}));

// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/editor/common/standalone/standaloneBase.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/










var standaloneBase_KeyMod = /** @class */ (function () {
    function KeyMod() {
    }
    KeyMod.chord = function (firstPart, secondPart) {
        return KeyChord(firstPart, secondPart);
    };
    KeyMod.CtrlCmd = 2048 /* CtrlCmd */;
    KeyMod.Shift = 1024 /* Shift */;
    KeyMod.Alt = 512 /* Alt */;
    KeyMod.WinCtrl = 256 /* WinCtrl */;
    return KeyMod;
}());

function createMonacoBaseAPI() {
    return {
        editor: undefined,
        languages: undefined,
        CancellationTokenSource: CancellationTokenSource,
        Emitter: event_Emitter,
        KeyCode: KeyCode,
        KeyMod: standaloneBase_KeyMod,
        Position: Position,
        Range: range_Range,
        Selection: selection_Selection,
        SelectionDirection: SelectionDirection,
        MarkerSeverity: MarkerSeverity,
        MarkerTag: MarkerTag,
        Uri: uri_URI,
        Token: Token
    };
}

// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/editor/common/services/editorSimpleWorker.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var editorSimpleWorker_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};














/**
 * @internal
 */
var editorSimpleWorker_MirrorModel = /** @class */ (function (_super) {
    editorSimpleWorker_extends(MirrorModel, _super);
    function MirrorModel() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(MirrorModel.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MirrorModel.prototype, "version", {
        get: function () {
            return this._versionId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MirrorModel.prototype, "eol", {
        get: function () {
            return this._eol;
        },
        enumerable: true,
        configurable: true
    });
    MirrorModel.prototype.getValue = function () {
        return this.getText();
    };
    MirrorModel.prototype.getLinesContent = function () {
        return this._lines.slice(0);
    };
    MirrorModel.prototype.getLineCount = function () {
        return this._lines.length;
    };
    MirrorModel.prototype.getLineContent = function (lineNumber) {
        return this._lines[lineNumber - 1];
    };
    MirrorModel.prototype.getWordAtPosition = function (position, wordDefinition) {
        var wordAtText = getWordAtText(position.column, ensureValidWordDefinition(wordDefinition), this._lines[position.lineNumber - 1], 0);
        if (wordAtText) {
            return new range_Range(position.lineNumber, wordAtText.startColumn, position.lineNumber, wordAtText.endColumn);
        }
        return null;
    };
    MirrorModel.prototype.createWordIterator = function (wordDefinition) {
        var _this = this;
        var obj;
        var lineNumber = 0;
        var lineText;
        var wordRangesIdx = 0;
        var wordRanges = [];
        var next = function () {
            if (wordRangesIdx < wordRanges.length) {
                var value = lineText.substring(wordRanges[wordRangesIdx].start, wordRanges[wordRangesIdx].end);
                wordRangesIdx += 1;
                if (!obj) {
                    obj = { done: false, value: value };
                }
                else {
                    obj.value = value;
                }
                return obj;
            }
            else if (lineNumber >= _this._lines.length) {
                return FIN;
            }
            else {
                lineText = _this._lines[lineNumber];
                wordRanges = _this._wordenize(lineText, wordDefinition);
                wordRangesIdx = 0;
                lineNumber += 1;
                return next();
            }
        };
        return { next: next };
    };
    MirrorModel.prototype.getLineWords = function (lineNumber, wordDefinition) {
        var content = this._lines[lineNumber - 1];
        var ranges = this._wordenize(content, wordDefinition);
        var words = [];
        for (var _i = 0, ranges_1 = ranges; _i < ranges_1.length; _i++) {
            var range = ranges_1[_i];
            words.push({
                word: content.substring(range.start, range.end),
                startColumn: range.start + 1,
                endColumn: range.end + 1
            });
        }
        return words;
    };
    MirrorModel.prototype._wordenize = function (content, wordDefinition) {
        var result = [];
        var match;
        wordDefinition.lastIndex = 0; // reset lastIndex just to be sure
        while (match = wordDefinition.exec(content)) {
            if (match[0].length === 0) {
                // it did match the empty string
                break;
            }
            result.push({ start: match.index, end: match.index + match[0].length });
        }
        return result;
    };
    MirrorModel.prototype.getValueInRange = function (range) {
        range = this._validateRange(range);
        if (range.startLineNumber === range.endLineNumber) {
            return this._lines[range.startLineNumber - 1].substring(range.startColumn - 1, range.endColumn - 1);
        }
        var lineEnding = this._eol;
        var startLineIndex = range.startLineNumber - 1;
        var endLineIndex = range.endLineNumber - 1;
        var resultLines = [];
        resultLines.push(this._lines[startLineIndex].substring(range.startColumn - 1));
        for (var i = startLineIndex + 1; i < endLineIndex; i++) {
            resultLines.push(this._lines[i]);
        }
        resultLines.push(this._lines[endLineIndex].substring(0, range.endColumn - 1));
        return resultLines.join(lineEnding);
    };
    MirrorModel.prototype.offsetAt = function (position) {
        position = this._validatePosition(position);
        this._ensureLineStarts();
        return this._lineStarts.getAccumulatedValue(position.lineNumber - 2) + (position.column - 1);
    };
    MirrorModel.prototype.positionAt = function (offset) {
        offset = Math.floor(offset);
        offset = Math.max(0, offset);
        this._ensureLineStarts();
        var out = this._lineStarts.getIndexOf(offset);
        var lineLength = this._lines[out.index].length;
        // Ensure we return a valid position
        return {
            lineNumber: 1 + out.index,
            column: 1 + Math.min(out.remainder, lineLength)
        };
    };
    MirrorModel.prototype._validateRange = function (range) {
        var start = this._validatePosition({ lineNumber: range.startLineNumber, column: range.startColumn });
        var end = this._validatePosition({ lineNumber: range.endLineNumber, column: range.endColumn });
        if (start.lineNumber !== range.startLineNumber
            || start.column !== range.startColumn
            || end.lineNumber !== range.endLineNumber
            || end.column !== range.endColumn) {
            return {
                startLineNumber: start.lineNumber,
                startColumn: start.column,
                endLineNumber: end.lineNumber,
                endColumn: end.column
            };
        }
        return range;
    };
    MirrorModel.prototype._validatePosition = function (position) {
        if (!Position.isIPosition(position)) {
            throw new Error('bad position');
        }
        var lineNumber = position.lineNumber, column = position.column;
        var hasChanged = false;
        if (lineNumber < 1) {
            lineNumber = 1;
            column = 1;
            hasChanged = true;
        }
        else if (lineNumber > this._lines.length) {
            lineNumber = this._lines.length;
            column = this._lines[lineNumber - 1].length + 1;
            hasChanged = true;
        }
        else {
            var maxCharacter = this._lines[lineNumber - 1].length + 1;
            if (column < 1) {
                column = 1;
                hasChanged = true;
            }
            else if (column > maxCharacter) {
                column = maxCharacter;
                hasChanged = true;
            }
        }
        if (!hasChanged) {
            return position;
        }
        else {
            return { lineNumber: lineNumber, column: column };
        }
    };
    return MirrorModel;
}(mirrorTextModel_MirrorTextModel));
/**
 * @internal
 */
var editorSimpleWorker_EditorSimpleWorker = /** @class */ (function () {
    function EditorSimpleWorker(host, foreignModuleFactory) {
        this._host = host;
        this._models = Object.create(null);
        this._foreignModuleFactory = foreignModuleFactory;
        this._foreignModule = null;
    }
    EditorSimpleWorker.prototype.dispose = function () {
        this._models = Object.create(null);
    };
    EditorSimpleWorker.prototype._getModel = function (uri) {
        return this._models[uri];
    };
    EditorSimpleWorker.prototype._getModels = function () {
        var _this = this;
        var all = [];
        Object.keys(this._models).forEach(function (key) { return all.push(_this._models[key]); });
        return all;
    };
    EditorSimpleWorker.prototype.acceptNewModel = function (data) {
        this._models[data.url] = new editorSimpleWorker_MirrorModel(uri_URI.parse(data.url), data.lines, data.EOL, data.versionId);
    };
    EditorSimpleWorker.prototype.acceptModelChanged = function (strURL, e) {
        if (!this._models[strURL]) {
            return;
        }
        var model = this._models[strURL];
        model.onEvents(e);
    };
    EditorSimpleWorker.prototype.acceptRemovedModel = function (strURL) {
        if (!this._models[strURL]) {
            return;
        }
        delete this._models[strURL];
    };
    // ---- BEGIN diff --------------------------------------------------------------------------
    EditorSimpleWorker.prototype.computeDiff = function (originalUrl, modifiedUrl, ignoreTrimWhitespace, maxComputationTime) {
        return __awaiter(this, void 0, void 0, function () {
            var original, modified, originalLines, modifiedLines, diffComputer, diffResult, identical;
            return __generator(this, function (_a) {
                original = this._getModel(originalUrl);
                modified = this._getModel(modifiedUrl);
                if (!original || !modified) {
                    return [2 /*return*/, null];
                }
                originalLines = original.getLinesContent();
                modifiedLines = modified.getLinesContent();
                diffComputer = new DiffComputer(originalLines, modifiedLines, {
                    shouldComputeCharChanges: true,
                    shouldPostProcessCharChanges: true,
                    shouldIgnoreTrimWhitespace: ignoreTrimWhitespace,
                    shouldMakePrettyDiff: true,
                    maxComputationTime: maxComputationTime
                });
                diffResult = diffComputer.computeDiff();
                identical = (diffResult.changes.length > 0 ? false : this._modelsAreIdentical(original, modified));
                return [2 /*return*/, {
                        quitEarly: diffResult.quitEarly,
                        identical: identical,
                        changes: diffResult.changes
                    }];
            });
        });
    };
    EditorSimpleWorker.prototype._modelsAreIdentical = function (original, modified) {
        var originalLineCount = original.getLineCount();
        var modifiedLineCount = modified.getLineCount();
        if (originalLineCount !== modifiedLineCount) {
            return false;
        }
        for (var line = 1; line <= originalLineCount; line++) {
            var originalLine = original.getLineContent(line);
            var modifiedLine = modified.getLineContent(line);
            if (originalLine !== modifiedLine) {
                return false;
            }
        }
        return true;
    };
    EditorSimpleWorker.prototype.computeMoreMinimalEdits = function (modelUrl, edits) {
        return __awaiter(this, void 0, void 0, function () {
            var model, result, lastEol, _i, edits_1, _a, range, text, eol, original, changes, editOffset, _b, changes_1, change, start, end, newEdit;
            return __generator(this, function (_c) {
                model = this._getModel(modelUrl);
                if (!model) {
                    return [2 /*return*/, edits];
                }
                result = [];
                lastEol = undefined;
                edits = mergeSort(edits, function (a, b) {
                    if (a.range && b.range) {
                        return range_Range.compareRangesUsingStarts(a.range, b.range);
                    }
                    // eol only changes should go to the end
                    var aRng = a.range ? 0 : 1;
                    var bRng = b.range ? 0 : 1;
                    return aRng - bRng;
                });
                for (_i = 0, edits_1 = edits; _i < edits_1.length; _i++) {
                    _a = edits_1[_i], range = _a.range, text = _a.text, eol = _a.eol;
                    if (typeof eol === 'number') {
                        lastEol = eol;
                    }
                    if (range_Range.isEmpty(range) && !text) {
                        // empty change
                        continue;
                    }
                    original = model.getValueInRange(range);
                    text = text.replace(/\r\n|\n|\r/g, model.eol);
                    if (original === text) {
                        // noop
                        continue;
                    }
                    // make sure diff won't take too long
                    if (Math.max(text.length, original.length) > EditorSimpleWorker._diffLimit) {
                        result.push({ range: range, text: text });
                        continue;
                    }
                    changes = stringDiff(original, text, false);
                    editOffset = model.offsetAt(range_Range.lift(range).getStartPosition());
                    for (_b = 0, changes_1 = changes; _b < changes_1.length; _b++) {
                        change = changes_1[_b];
                        start = model.positionAt(editOffset + change.originalStart);
                        end = model.positionAt(editOffset + change.originalStart + change.originalLength);
                        newEdit = {
                            text: text.substr(change.modifiedStart, change.modifiedLength),
                            range: { startLineNumber: start.lineNumber, startColumn: start.column, endLineNumber: end.lineNumber, endColumn: end.column }
                        };
                        if (model.getValueInRange(newEdit.range) !== newEdit.text) {
                            result.push(newEdit);
                        }
                    }
                }
                if (typeof lastEol === 'number') {
                    result.push({ eol: lastEol, text: '', range: { startLineNumber: 0, startColumn: 0, endLineNumber: 0, endColumn: 0 } });
                }
                return [2 /*return*/, result];
            });
        });
    };
    // ---- END minimal edits ---------------------------------------------------------------
    EditorSimpleWorker.prototype.computeLinks = function (modelUrl) {
        return __awaiter(this, void 0, void 0, function () {
            var model;
            return __generator(this, function (_a) {
                model = this._getModel(modelUrl);
                if (!model) {
                    return [2 /*return*/, null];
                }
                return [2 /*return*/, computeLinks(model)];
            });
        });
    };
    EditorSimpleWorker.prototype.textualSuggest = function (modelUrl, position, wordDef, wordDefFlags) {
        return __awaiter(this, void 0, void 0, function () {
            var model, words, seen, wordDefRegExp, wordAt, iter, e, word;
            return __generator(this, function (_a) {
                model = this._getModel(modelUrl);
                if (!model) {
                    return [2 /*return*/, null];
                }
                words = [];
                seen = new Set();
                wordDefRegExp = new RegExp(wordDef, wordDefFlags);
                wordAt = model.getWordAtPosition(position, wordDefRegExp);
                if (wordAt) {
                    seen.add(model.getValueInRange(wordAt));
                }
                for (iter = model.createWordIterator(wordDefRegExp), e = iter.next(); !e.done && seen.size <= EditorSimpleWorker._suggestionsLimit; e = iter.next()) {
                    word = e.value;
                    if (seen.has(word)) {
                        continue;
                    }
                    seen.add(word);
                    if (!isNaN(Number(word))) {
                        continue;
                    }
                    words.push(word);
                }
                return [2 /*return*/, words];
            });
        });
    };
    // ---- END suggest --------------------------------------------------------------------------
    //#region -- word ranges --
    EditorSimpleWorker.prototype.computeWordRanges = function (modelUrl, range, wordDef, wordDefFlags) {
        return __awaiter(this, void 0, void 0, function () {
            var model, wordDefRegExp, result, line, words, _i, words_1, word, array;
            return __generator(this, function (_a) {
                model = this._getModel(modelUrl);
                if (!model) {
                    return [2 /*return*/, Object.create(null)];
                }
                wordDefRegExp = new RegExp(wordDef, wordDefFlags);
                result = Object.create(null);
                for (line = range.startLineNumber; line < range.endLineNumber; line++) {
                    words = model.getLineWords(line, wordDefRegExp);
                    for (_i = 0, words_1 = words; _i < words_1.length; _i++) {
                        word = words_1[_i];
                        if (!isNaN(Number(word.word))) {
                            continue;
                        }
                        array = result[word.word];
                        if (!array) {
                            array = [];
                            result[word.word] = array;
                        }
                        array.push({
                            startLineNumber: line,
                            startColumn: word.startColumn,
                            endLineNumber: line,
                            endColumn: word.endColumn
                        });
                    }
                }
                return [2 /*return*/, result];
            });
        });
    };
    //#endregion
    EditorSimpleWorker.prototype.navigateValueSet = function (modelUrl, range, up, wordDef, wordDefFlags) {
        return __awaiter(this, void 0, void 0, function () {
            var model, wordDefRegExp, selectionText, wordRange, word, result;
            return __generator(this, function (_a) {
                model = this._getModel(modelUrl);
                if (!model) {
                    return [2 /*return*/, null];
                }
                wordDefRegExp = new RegExp(wordDef, wordDefFlags);
                if (range.startColumn === range.endColumn) {
                    range = {
                        startLineNumber: range.startLineNumber,
                        startColumn: range.startColumn,
                        endLineNumber: range.endLineNumber,
                        endColumn: range.endColumn + 1
                    };
                }
                selectionText = model.getValueInRange(range);
                wordRange = model.getWordAtPosition({ lineNumber: range.startLineNumber, column: range.startColumn }, wordDefRegExp);
                if (!wordRange) {
                    return [2 /*return*/, null];
                }
                word = model.getValueInRange(wordRange);
                result = BasicInplaceReplace.INSTANCE.navigateValueSet(range, selectionText, wordRange, word, up);
                return [2 /*return*/, result];
            });
        });
    };
    // ---- BEGIN foreign module support --------------------------------------------------------------------------
    EditorSimpleWorker.prototype.loadForeignModule = function (moduleId, createData, foreignHostMethods) {
        var _this = this;
        var proxyMethodRequest = function (method, args) {
            return _this._host.fhr(method, args);
        };
        var foreignHost = createProxyObject(foreignHostMethods, proxyMethodRequest);
        var ctx = {
            host: foreignHost,
            getMirrorModels: function () {
                return _this._getModels();
            }
        };
        if (this._foreignModuleFactory) {
            this._foreignModule = this._foreignModuleFactory(ctx, createData);
            // static foreing module
            return Promise.resolve(getAllMethodNames(this._foreignModule));
        }
        // ESM-comment-begin
        // 		return new Promise<any>((resolve, reject) => {
        // 			require([moduleId], (foreignModule: { create: IForeignModuleFactory }) => {
        // 				this._foreignModule = foreignModule.create(ctx, createData);
        // 
        // 				resolve(types.getAllMethodNames(this._foreignModule));
        // 
        // 			}, reject);
        // 		});
        // ESM-comment-end
        // ESM-uncomment-begin
        return Promise.reject(new Error("Unexpected usage"));
        // ESM-uncomment-end
    };
    // foreign method request
    EditorSimpleWorker.prototype.fmr = function (method, args) {
        if (!this._foreignModule || typeof this._foreignModule[method] !== 'function') {
            return Promise.reject(new Error('Missing requestHandler or method: ' + method));
        }
        try {
            return Promise.resolve(this._foreignModule[method].apply(this._foreignModule, args));
        }
        catch (e) {
            return Promise.reject(e);
        }
    };
    // ---- END diff --------------------------------------------------------------------------
    // ---- BEGIN minimal edits ---------------------------------------------------------------
    EditorSimpleWorker._diffLimit = 100000;
    // ---- BEGIN suggest --------------------------------------------------------------------------
    EditorSimpleWorker._suggestionsLimit = 10000;
    return EditorSimpleWorker;
}());

/**
 * Called on the worker side
 * @internal
 */
function editorSimpleWorker_create(host) {
    return new editorSimpleWorker_EditorSimpleWorker(host, null);
}
if (typeof importScripts === 'function') {
    // Running in a web worker
    globals.monaco = createMonacoBaseAPI();
}

// CONCATENATED MODULE: ../node_modules/monaco-editor/esm/vs/editor/editor.worker.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


var initialized = false;
function initialize(foreignModule) {
    if (initialized) {
        return;
    }
    initialized = true;
    var simpleWorker = new simpleWorker_SimpleWorkerServer(function (msg) {
        self.postMessage(msg);
    }, function (host) { return new editorSimpleWorker_EditorSimpleWorker(host, foreignModule); });
    self.onmessage = function (e) {
        simpleWorker.onmessage(e.data);
    };
}
self.onmessage = function (e) {
    // Ignore first message in this case and initialize if not yet initialized
    if (!initialized) {
        initialize(null);
    }
};

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/vscode-languageserver-types/main.js
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

/**
 * The Position namespace provides helper functions to work with
 * [Position](#Position) literals.
 */
var main_Position;
(function (Position) {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */
    function create(line, character) {
        return { line: line, character: character };
    }
    Position.create = create;
    /**
     * Checks whether the given liternal conforms to the [Position](#Position) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && Is.number(candidate.line) && Is.number(candidate.character);
    }
    Position.is = is;
})(main_Position || (main_Position = {}));
/**
 * The Range namespace provides helper functions to work with
 * [Range](#Range) literals.
 */
var main_Range;
(function (Range) {
    function create(one, two, three, four) {
        if (Is.number(one) && Is.number(two) && Is.number(three) && Is.number(four)) {
            return { start: main_Position.create(one, two), end: main_Position.create(three, four) };
        }
        else if (main_Position.is(one) && main_Position.is(two)) {
            return { start: one, end: two };
        }
        else {
            throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
        }
    }
    Range.create = create;
    /**
     * Checks whether the given literal conforms to the [Range](#Range) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && main_Position.is(candidate.start) && main_Position.is(candidate.end);
    }
    Range.is = is;
})(main_Range || (main_Range = {}));
/**
 * The Location namespace provides helper functions to work with
 * [Location](#Location) literals.
 */
var Location;
(function (Location) {
    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */
    function create(uri, range) {
        return { uri: uri, range: range };
    }
    Location.create = create;
    /**
     * Checks whether the given literal conforms to the [Location](#Location) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && main_Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location.is = is;
})(Location || (Location = {}));
/**
 * The Color namespace provides helper functions to work with
 * [Color](#Color) literals.
 */
var Color;
(function (Color) {
    /**
     * Creates a new Color literal.
     */
    function create(red, green, blue, alpha) {
        return {
            red: red,
            green: green,
            blue: blue,
            alpha: alpha,
        };
    }
    Color.create = create;
    /**
     * Checks whether the given literal conforms to the [Color](#Color) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.number(candidate.red)
            && Is.number(candidate.green)
            && Is.number(candidate.blue)
            && Is.number(candidate.alpha);
    }
    Color.is = is;
})(Color || (Color = {}));
/**
 * The ColorInformation namespace provides helper functions to work with
 * [ColorInformation](#ColorInformation) literals.
 */
var ColorInformation;
(function (ColorInformation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(range, color) {
        return {
            range: range,
            color: color,
        };
    }
    ColorInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return main_Range.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation.is = is;
})(ColorInformation || (ColorInformation = {}));
/**
 * The Color namespace provides helper functions to work with
 * [ColorPresentation](#ColorPresentation) literals.
 */
var ColorPresentation;
(function (ColorPresentation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(label, textEdit, additionalTextEdits) {
        return {
            label: label,
            textEdit: textEdit,
            additionalTextEdits: additionalTextEdits,
        };
    }
    ColorPresentation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate.label)
            && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate))
            && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
    }
    ColorPresentation.is = is;
})(ColorPresentation || (ColorPresentation = {}));
/**
 * Enum of known range kinds
 */
var FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind["Comment"] = "comment";
    /**
     * Folding range for a imports or includes
     */
    FoldingRangeKind["Imports"] = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind["Region"] = "region";
})(FoldingRangeKind || (FoldingRangeKind = {}));
/**
 * The folding range namespace provides helper functions to work with
 * [FoldingRange](#FoldingRange) literals.
 */
var FoldingRange;
(function (FoldingRange) {
    /**
     * Creates a new FoldingRange literal.
     */
    function create(startLine, endLine, startCharacter, endCharacter, kind) {
        var result = {
            startLine: startLine,
            endLine: endLine
        };
        if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
            result.kind = kind;
        }
        return result;
    }
    FoldingRange.create = create;
    /**
     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.number(candidate.startLine) && Is.number(candidate.startLine)
            && (Is.undefined(candidate.startCharacter) || Is.number(candidate.startCharacter))
            && (Is.undefined(candidate.endCharacter) || Is.number(candidate.endCharacter))
            && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange.is = is;
})(FoldingRange || (FoldingRange = {}));
/**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.
 */
var DiagnosticRelatedInformation;
(function (DiagnosticRelatedInformation) {
    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */
    function create(location, message) {
        return {
            location: location,
            message: message
        };
    }
    DiagnosticRelatedInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
/**
 * The diagnostic's severity.
 */
var DiagnosticSeverity;
(function (DiagnosticSeverity) {
    /**
     * Reports an error.
     */
    DiagnosticSeverity.Error = 1;
    /**
     * Reports a warning.
     */
    DiagnosticSeverity.Warning = 2;
    /**
     * Reports an information.
     */
    DiagnosticSeverity.Information = 3;
    /**
     * Reports a hint.
     */
    DiagnosticSeverity.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
/**
 * The Diagnostic namespace provides helper functions to work with
 * [Diagnostic](#Diagnostic) literals.
 */
var Diagnostic;
(function (Diagnostic) {
    /**
     * Creates a new Diagnostic literal.
     */
    function create(range, message, severity, code, source, relatedInformation) {
        var result = { range: range, message: message };
        if (Is.defined(severity)) {
            result.severity = severity;
        }
        if (Is.defined(code)) {
            result.code = code;
        }
        if (Is.defined(source)) {
            result.source = source;
        }
        if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
        }
        return result;
    }
    Diagnostic.create = create;
    /**
     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate)
            && main_Range.is(candidate.range)
            && Is.string(candidate.message)
            && (Is.number(candidate.severity) || Is.undefined(candidate.severity))
            && (Is.number(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code))
            && (Is.string(candidate.source) || Is.undefined(candidate.source))
            && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic.is = is;
})(Diagnostic || (Diagnostic = {}));
/**
 * The Command namespace provides helper functions to work with
 * [Command](#Command) literals.
 */
var Command;
(function (Command) {
    /**
     * Creates a new Command literal.
     */
    function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var result = { title: title, command: command };
        if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
        }
        return result;
    }
    Command.create = create;
    /**
     * Checks whether the given literal conforms to the [Command](#Command) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command.is = is;
})(Command || (Command = {}));
/**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */
var TextEdit;
(function (TextEdit) {
    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */
    function replace(range, newText) {
        return { range: range, newText: newText };
    }
    TextEdit.replace = replace;
    /**
     * Creates a insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */
    function insert(position, newText) {
        return { range: { start: position, end: position }, newText: newText };
    }
    TextEdit.insert = insert;
    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */
    function del(range) {
        return { range: range, newText: '' };
    }
    TextEdit.del = del;
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate)
            && Is.string(candidate.newText)
            && main_Range.is(candidate.range);
    }
    TextEdit.is = is;
})(TextEdit || (TextEdit = {}));
/**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */
var TextDocumentEdit;
(function (TextDocumentEdit) {
    /**
     * Creates a new `TextDocumentEdit`
     */
    function create(textDocument, edits) {
        return { textDocument: textDocument, edits: edits };
    }
    TextDocumentEdit.create = create;
    function is(value) {
        var candidate = value;
        return Is.defined(candidate)
            && VersionedTextDocumentIdentifier.is(candidate.textDocument)
            && Array.isArray(candidate.edits);
    }
    TextDocumentEdit.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var WorkspaceEdit;
(function (WorkspaceEdit) {
    function is(value) {
        var candidate = value;
        return candidate &&
            (candidate.changes !== void 0 || candidate.documentChanges !== void 0) &&
            (candidate.documentChanges === void 0 || Is.typedArray(candidate.documentChanges, TextDocumentEdit.is));
    }
    WorkspaceEdit.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));
var TextEditChangeImpl = /** @class */ (function () {
    function TextEditChangeImpl(edits) {
        this.edits = edits;
    }
    TextEditChangeImpl.prototype.insert = function (position, newText) {
        this.edits.push(TextEdit.insert(position, newText));
    };
    TextEditChangeImpl.prototype.replace = function (range, newText) {
        this.edits.push(TextEdit.replace(range, newText));
    };
    TextEditChangeImpl.prototype.delete = function (range) {
        this.edits.push(TextEdit.del(range));
    };
    TextEditChangeImpl.prototype.add = function (edit) {
        this.edits.push(edit);
    };
    TextEditChangeImpl.prototype.all = function () {
        return this.edits;
    };
    TextEditChangeImpl.prototype.clear = function () {
        this.edits.splice(0, this.edits.length);
    };
    return TextEditChangeImpl;
}());
/**
 * A workspace change helps constructing changes to a workspace.
 */
var WorkspaceChange = /** @class */ (function () {
    function WorkspaceChange(workspaceEdit) {
        var _this = this;
        this._textEditChanges = Object.create(null);
        if (workspaceEdit) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
                workspaceEdit.documentChanges.forEach(function (textDocumentEdit) {
                    var textEditChange = new TextEditChangeImpl(textDocumentEdit.edits);
                    _this._textEditChanges[textDocumentEdit.textDocument.uri] = textEditChange;
                });
            }
            else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function (key) {
                    var textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                    _this._textEditChanges[key] = textEditChange;
                });
            }
        }
    }
    Object.defineProperty(WorkspaceChange.prototype, "edit", {
        /**
         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
         * use to be returned from a workspace edit operation like rename.
         */
        get: function () {
            return this._workspaceEdit;
        },
        enumerable: true,
        configurable: true
    });
    WorkspaceChange.prototype.getTextEditChange = function (key) {
        if (VersionedTextDocumentIdentifier.is(key)) {
            if (!this._workspaceEdit) {
                this._workspaceEdit = {
                    documentChanges: []
                };
            }
            if (!this._workspaceEdit.documentChanges) {
                throw new Error('Workspace edit is not configured for versioned document changes.');
            }
            var textDocument = key;
            var result = this._textEditChanges[textDocument.uri];
            if (!result) {
                var edits = [];
                var textDocumentEdit = {
                    textDocument: textDocument,
                    edits: edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[textDocument.uri] = result;
            }
            return result;
        }
        else {
            if (!this._workspaceEdit) {
                this._workspaceEdit = {
                    changes: Object.create(null)
                };
            }
            if (!this._workspaceEdit.changes) {
                throw new Error('Workspace edit is not configured for normal text edit changes.');
            }
            var result = this._textEditChanges[key];
            if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
            }
            return result;
        }
    };
    return WorkspaceChange;
}());

/**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.
 */
var TextDocumentIdentifier;
(function (TextDocumentIdentifier) {
    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */
    function create(uri) {
        return { uri: uri };
    }
    TextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
/**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.
 */
var VersionedTextDocumentIdentifier;
(function (VersionedTextDocumentIdentifier) {
    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param uri The document's text.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    VersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.number(candidate.version);
    }
    VersionedTextDocumentIdentifier.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
/**
 * The TextDocumentItem namespace provides helper functions to work with
 * [TextDocumentItem](#TextDocumentItem) literals.
 */
var TextDocumentItem;
(function (TextDocumentItem) {
    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */
    function create(uri, languageId, version, text) {
        return { uri: uri, languageId: languageId, version: version, text: text };
    }
    TextDocumentItem.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.number(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */
var MarkupKind;
(function (MarkupKind) {
    /**
     * Plain text is supported as a content format
     */
    MarkupKind.PlainText = 'plaintext';
    /**
     * Markdown is supported as a content format
     */
    MarkupKind.Markdown = 'markdown';
})(MarkupKind || (MarkupKind = {}));
(function (MarkupKind) {
    /**
     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.
     */
    function is(value) {
        var candidate = value;
        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
    }
    MarkupKind.is = is;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function (MarkupContent) {
    /**
     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent.is = is;
})(MarkupContent || (MarkupContent = {}));
/**
 * The kind of a completion entry.
 */
var main_CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind.Text = 1;
    CompletionItemKind.Method = 2;
    CompletionItemKind.Function = 3;
    CompletionItemKind.Constructor = 4;
    CompletionItemKind.Field = 5;
    CompletionItemKind.Variable = 6;
    CompletionItemKind.Class = 7;
    CompletionItemKind.Interface = 8;
    CompletionItemKind.Module = 9;
    CompletionItemKind.Property = 10;
    CompletionItemKind.Unit = 11;
    CompletionItemKind.Value = 12;
    CompletionItemKind.Enum = 13;
    CompletionItemKind.Keyword = 14;
    CompletionItemKind.Snippet = 15;
    CompletionItemKind.Color = 16;
    CompletionItemKind.File = 17;
    CompletionItemKind.Reference = 18;
    CompletionItemKind.Folder = 19;
    CompletionItemKind.EnumMember = 20;
    CompletionItemKind.Constant = 21;
    CompletionItemKind.Struct = 22;
    CompletionItemKind.Event = 23;
    CompletionItemKind.Operator = 24;
    CompletionItemKind.TypeParameter = 25;
})(main_CompletionItemKind || (main_CompletionItemKind = {}));
/**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */
var InsertTextFormat;
(function (InsertTextFormat) {
    /**
     * The primary text to be inserted is treated as a plain string.
     */
    InsertTextFormat.PlainText = 1;
    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://github.com/Microsoft/vscode/blob/master/src/vs/editor/contrib/snippet/common/snippet.md
     */
    InsertTextFormat.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
/**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */
var CompletionItem;
(function (CompletionItem) {
    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */
    function create(label) {
        return { label: label };
    }
    CompletionItem.create = create;
})(CompletionItem || (CompletionItem = {}));
/**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */
var CompletionList;
(function (CompletionList) {
    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */
    function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
    }
    CompletionList.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function (MarkedString) {
    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */
    function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&"); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
    }
    MarkedString.fromPlainText = fromPlainText;
    /**
     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.
     */
    function is(value) {
        var candidate = value;
        return Is.string(candidate) || (Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value));
    }
    MarkedString.is = is;
})(MarkedString || (MarkedString = {}));
var Hover;
(function (Hover) {
    /**
     * Checks whether the given value conforms to the [Hover](#Hover) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) ||
            MarkedString.is(candidate.contents) ||
            Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === void 0 || main_Range.is(value.range));
    }
    Hover.is = is;
})(Hover || (Hover = {}));
/**
 * The ParameterInformation namespace provides helper functions to work with
 * [ParameterInformation](#ParameterInformation) literals.
 */
var ParameterInformation;
(function (ParameterInformation) {
    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */
    function create(label, documentation) {
        return documentation ? { label: label, documentation: documentation } : { label: label };
    }
    ParameterInformation.create = create;
    ;
})(ParameterInformation || (ParameterInformation = {}));
/**
 * The SignatureInformation namespace provides helper functions to work with
 * [SignatureInformation](#SignatureInformation) literals.
 */
var SignatureInformation;
(function (SignatureInformation) {
    function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
        }
        var result = { label: label };
        if (Is.defined(documentation)) {
            result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
            result.parameters = parameters;
        }
        else {
            result.parameters = [];
        }
        return result;
    }
    SignatureInformation.create = create;
})(SignatureInformation || (SignatureInformation = {}));
/**
 * A document highlight kind.
 */
var main_DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind.Text = 1;
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind.Read = 2;
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind.Write = 3;
})(main_DocumentHighlightKind || (main_DocumentHighlightKind = {}));
/**
 * DocumentHighlight namespace to provide helper functions to work with
 * [DocumentHighlight](#DocumentHighlight) literals.
 */
var DocumentHighlight;
(function (DocumentHighlight) {
    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     */
    function create(range, kind) {
        var result = { range: range };
        if (Is.number(kind)) {
            result.kind = kind;
        }
        return result;
    }
    DocumentHighlight.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
/**
 * A symbol kind.
 */
var main_SymbolKind;
(function (SymbolKind) {
    SymbolKind.File = 1;
    SymbolKind.Module = 2;
    SymbolKind.Namespace = 3;
    SymbolKind.Package = 4;
    SymbolKind.Class = 5;
    SymbolKind.Method = 6;
    SymbolKind.Property = 7;
    SymbolKind.Field = 8;
    SymbolKind.Constructor = 9;
    SymbolKind.Enum = 10;
    SymbolKind.Interface = 11;
    SymbolKind.Function = 12;
    SymbolKind.Variable = 13;
    SymbolKind.Constant = 14;
    SymbolKind.String = 15;
    SymbolKind.Number = 16;
    SymbolKind.Boolean = 17;
    SymbolKind.Array = 18;
    SymbolKind.Object = 19;
    SymbolKind.Key = 20;
    SymbolKind.Null = 21;
    SymbolKind.EnumMember = 22;
    SymbolKind.Struct = 23;
    SymbolKind.Event = 24;
    SymbolKind.Operator = 25;
    SymbolKind.TypeParameter = 26;
})(main_SymbolKind || (main_SymbolKind = {}));
var SymbolInformation;
(function (SymbolInformation) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol, defaults to the current document.
     * @param containerName The name of the symbol containing the symbol.
     */
    function create(name, kind, range, uri, containerName) {
        var result = {
            name: name,
            kind: kind,
            location: { uri: uri, range: range }
        };
        if (containerName) {
            result.containerName = containerName;
        }
        return result;
    }
    SymbolInformation.create = create;
})(SymbolInformation || (SymbolInformation = {}));
/**
 * Represents programming constructs like variables, classes, interfaces etc.
 * that appear in a document. Document symbols can be hierarchical and they
 * have two ranges: one that encloses its definition and one that points to
 * its most interesting range, e.g. the range of an identifier.
 */
var DocumentSymbol = /** @class */ (function () {
    function DocumentSymbol() {
    }
    return DocumentSymbol;
}());

(function (DocumentSymbol) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */
    function create(name, detail, kind, range, selectionRange, children) {
        var result = {
            name: name,
            detail: detail,
            kind: kind,
            range: range,
            selectionRange: selectionRange
        };
        if (children !== void 0) {
            result.children = children;
        }
        return result;
    }
    DocumentSymbol.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate &&
            Is.string(candidate.name) && Is.number(candidate.kind) &&
            main_Range.is(candidate.range) && main_Range.is(candidate.selectionRange) &&
            (candidate.detail === void 0 || Is.string(candidate.detail)) &&
            (candidate.deprecated === void 0 || Is.boolean(candidate.deprecated)) &&
            (candidate.children === void 0 || Array.isArray(candidate.children));
    }
    DocumentSymbol.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
/**
 * A set of predefined code action kinds
 */
var CodeActionKind;
(function (CodeActionKind) {
    /**
     * Base kind for quickfix actions: 'quickfix'
     */
    CodeActionKind.QuickFix = 'quickfix';
    /**
     * Base kind for refactoring actions: 'refactor'
     */
    CodeActionKind.Refactor = 'refactor';
    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */
    CodeActionKind.RefactorExtract = 'refactor.extract';
    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */
    CodeActionKind.RefactorInline = 'refactor.inline';
    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */
    CodeActionKind.RefactorRewrite = 'refactor.rewrite';
    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */
    CodeActionKind.Source = 'source';
    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */
    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
})(CodeActionKind || (CodeActionKind = {}));
/**
 * The CodeActionContext namespace provides helper functions to work with
 * [CodeActionContext](#CodeActionContext) literals.
 */
var CodeActionContext;
(function (CodeActionContext) {
    /**
     * Creates a new CodeActionContext literal.
     */
    function create(diagnostics, only) {
        var result = { diagnostics: diagnostics };
        if (only !== void 0 && only !== null) {
            result.only = only;
        }
        return result;
    }
    CodeActionContext.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === void 0 || Is.typedArray(candidate.only, Is.string));
    }
    CodeActionContext.is = is;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function (CodeAction) {
    function create(title, commandOrEdit, kind) {
        var result = { title: title };
        if (Command.is(commandOrEdit)) {
            result.command = commandOrEdit;
        }
        else {
            result.edit = commandOrEdit;
        }
        if (kind !== void null) {
            result.kind = kind;
        }
        return result;
    }
    CodeAction.create = create;
    function is(value) {
        var candidate = value;
        return candidate && Is.string(candidate.title) &&
            (candidate.diagnostics === void 0 || Is.typedArray(candidate.diagnostics, Diagnostic.is)) &&
            (candidate.kind === void 0 || Is.string(candidate.kind)) &&
            (candidate.edit !== void 0 || candidate.command !== void 0) &&
            (candidate.command === void 0 || Command.is(candidate.command)) &&
            (candidate.edit === void 0 || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction.is = is;
})(CodeAction || (CodeAction = {}));
/**
 * The CodeLens namespace provides helper functions to work with
 * [CodeLens](#CodeLens) literals.
 */
var CodeLens;
(function (CodeLens) {
    /**
     * Creates a new CodeLens literal.
     */
    function create(range, data) {
        var result = { range: range };
        if (Is.defined(data))
            result.data = data;
        return result;
    }
    CodeLens.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && main_Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
    }
    CodeLens.is = is;
})(CodeLens || (CodeLens = {}));
/**
 * The FormattingOptions namespace provides helper functions to work with
 * [FormattingOptions](#FormattingOptions) literals.
 */
var FormattingOptions;
(function (FormattingOptions) {
    /**
     * Creates a new FormattingOptions literal.
     */
    function create(tabSize, insertSpaces) {
        return { tabSize: tabSize, insertSpaces: insertSpaces };
    }
    FormattingOptions.create = create;
    /**
     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.number(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions.is = is;
})(FormattingOptions || (FormattingOptions = {}));
/**
 * A document link is a range in a text document that links to an internal or external resource, like another
 * text document or a web site.
 */
var DocumentLink = /** @class */ (function () {
    function DocumentLink() {
    }
    return DocumentLink;
}());

/**
 * The DocumentLink namespace provides helper functions to work with
 * [DocumentLink](#DocumentLink) literals.
 */
(function (DocumentLink) {
    /**
     * Creates a new DocumentLink literal.
     */
    function create(range, target, data) {
        return { range: range, target: target, data: data };
    }
    DocumentLink.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && main_Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink.is = is;
})(DocumentLink || (DocumentLink = {}));
var EOL = ['\n', '\r\n', '\r'];
var TextDocument;
(function (TextDocument) {
    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.
     */
    function is(value) {
        var candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.number(candidate.lineCount)
            && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument.is = is;
    function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits, function (a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            }
            else {
                throw new Error('Ovelapping edit');
            }
            lastModifiedOffset = startOffset;
        }
        return text;
    }
    TextDocument.applyEdits = applyEdits;
    function mergeSort(data, compare) {
        if (data.length <= 1) {
            // sorted
            return data;
        }
        var p = (data.length / 2) | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
                // smaller_equal -> take left to preserve order
                data[i++] = left[leftIdx++];
            }
            else {
                // greater -> take right
                data[i++] = right[rightIdx++];
            }
        }
        while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
        }
        return data;
    }
})(TextDocument || (TextDocument = {}));
/**
 * Represents reasons why a text document is saved.
 */
var TextDocumentSaveReason;
(function (TextDocumentSaveReason) {
    /**
     * Manually triggered, e.g. by the user pressing save, by starting debugging,
     * or by an API call.
     */
    TextDocumentSaveReason.Manual = 1;
    /**
     * Automatic after a delay.
     */
    TextDocumentSaveReason.AfterDelay = 2;
    /**
     * When the editor lost focus.
     */
    TextDocumentSaveReason.FocusOut = 3;
})(TextDocumentSaveReason || (TextDocumentSaveReason = {}));
var FullTextDocument = /** @class */ (function () {
    function FullTextDocument(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = null;
    }
    Object.defineProperty(FullTextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: true,
        configurable: true
    });
    FullTextDocument.prototype.getText = function (range) {
        if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    };
    FullTextDocument.prototype.update = function (event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = null;
    };
    FullTextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === null) {
            var lineOffsets = [];
            var text = this._content;
            var isLineStart = true;
            for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = (ch === '\r' || ch === '\n');
                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                    i++;
                }
            }
            if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
    };
    FullTextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return main_Position.create(0, offset);
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return main_Position.create(line, offset - lineOffsets[line]);
    };
    FullTextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: true,
        configurable: true
    });
    return FullTextDocument;
}());
var Is;
(function (Is) {
    var toString = Object.prototype.toString;
    function defined(value) {
        return typeof value !== 'undefined';
    }
    Is.defined = defined;
    function undefined(value) {
        return typeof value === 'undefined';
    }
    Is.undefined = undefined;
    function boolean(value) {
        return value === true || value === false;
    }
    Is.boolean = boolean;
    function string(value) {
        return toString.call(value) === '[object String]';
    }
    Is.string = string;
    function number(value) {
        return toString.call(value) === '[object Number]';
    }
    Is.number = number;
    function func(value) {
        return toString.call(value) === '[object Function]';
    }
    Is.func = func;
    function objectLiteral(value) {
        // Strictly speaking class instances pass this check as well. Since the LSP
        // doesn't use classes we ignore this for now. If we do we need to add something
        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
        return value !== null && typeof value === 'object';
    }
    Is.objectLiteral = objectLiteral;
    function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
    }
    Is.typedArray = typedArray;
})(Is || (Is = {}));

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/vscode-json-languageservice/_deps/jsonc-parser/impl/scanner.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * Creates a JSON scanner on the given text.
 * If ignoreTrivia is set, whitespaces or comments are ignored.
 */
function createScanner(text, ignoreTrivia) {
    if (ignoreTrivia === void 0) { ignoreTrivia = false; }
    var len = text.length;
    var pos = 0, value = '', tokenOffset = 0, token = 16 /* Unknown */, lineNumber = 0, lineStartOffset = 0, tokenLineStartOffset = 0, prevTokenLineStartOffset = 0, scanError = 0 /* None */;
    function scanHexDigits(count, exact) {
        var digits = 0;
        var value = 0;
        while (digits < count || !exact) {
            var ch = text.charCodeAt(pos);
            if (ch >= 48 /* _0 */ && ch <= 57 /* _9 */) {
                value = value * 16 + ch - 48 /* _0 */;
            }
            else if (ch >= 65 /* A */ && ch <= 70 /* F */) {
                value = value * 16 + ch - 65 /* A */ + 10;
            }
            else if (ch >= 97 /* a */ && ch <= 102 /* f */) {
                value = value * 16 + ch - 97 /* a */ + 10;
            }
            else {
                break;
            }
            pos++;
            digits++;
        }
        if (digits < count) {
            value = -1;
        }
        return value;
    }
    function setPosition(newPosition) {
        pos = newPosition;
        value = '';
        tokenOffset = 0;
        token = 16 /* Unknown */;
        scanError = 0 /* None */;
    }
    function scanNumber() {
        var start = pos;
        if (text.charCodeAt(pos) === 48 /* _0 */) {
            pos++;
        }
        else {
            pos++;
            while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                pos++;
            }
        }
        if (pos < text.length && text.charCodeAt(pos) === 46 /* dot */) {
            pos++;
            if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                pos++;
                while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                }
            }
            else {
                scanError = 3 /* UnexpectedEndOfNumber */;
                return text.substring(start, pos);
            }
        }
        var end = pos;
        if (pos < text.length && (text.charCodeAt(pos) === 69 /* E */ || text.charCodeAt(pos) === 101 /* e */)) {
            pos++;
            if (pos < text.length && text.charCodeAt(pos) === 43 /* plus */ || text.charCodeAt(pos) === 45 /* minus */) {
                pos++;
            }
            if (pos < text.length && isDigit(text.charCodeAt(pos))) {
                pos++;
                while (pos < text.length && isDigit(text.charCodeAt(pos))) {
                    pos++;
                }
                end = pos;
            }
            else {
                scanError = 3 /* UnexpectedEndOfNumber */;
            }
        }
        return text.substring(start, end);
    }
    function scanString() {
        var result = '', start = pos;
        while (true) {
            if (pos >= len) {
                result += text.substring(start, pos);
                scanError = 2 /* UnexpectedEndOfString */;
                break;
            }
            var ch = text.charCodeAt(pos);
            if (ch === 34 /* doubleQuote */) {
                result += text.substring(start, pos);
                pos++;
                break;
            }
            if (ch === 92 /* backslash */) {
                result += text.substring(start, pos);
                pos++;
                if (pos >= len) {
                    scanError = 2 /* UnexpectedEndOfString */;
                    break;
                }
                var ch2 = text.charCodeAt(pos++);
                switch (ch2) {
                    case 34 /* doubleQuote */:
                        result += '\"';
                        break;
                    case 92 /* backslash */:
                        result += '\\';
                        break;
                    case 47 /* slash */:
                        result += '/';
                        break;
                    case 98 /* b */:
                        result += '\b';
                        break;
                    case 102 /* f */:
                        result += '\f';
                        break;
                    case 110 /* n */:
                        result += '\n';
                        break;
                    case 114 /* r */:
                        result += '\r';
                        break;
                    case 116 /* t */:
                        result += '\t';
                        break;
                    case 117 /* u */:
                        var ch3 = scanHexDigits(4, true);
                        if (ch3 >= 0) {
                            result += String.fromCharCode(ch3);
                        }
                        else {
                            scanError = 4 /* InvalidUnicode */;
                        }
                        break;
                    default:
                        scanError = 5 /* InvalidEscapeCharacter */;
                }
                start = pos;
                continue;
            }
            if (ch >= 0 && ch <= 0x1f) {
                if (isLineBreak(ch)) {
                    result += text.substring(start, pos);
                    scanError = 2 /* UnexpectedEndOfString */;
                    break;
                }
                else {
                    scanError = 6 /* InvalidCharacter */;
                    // mark as error but continue with string
                }
            }
            pos++;
        }
        return result;
    }
    function scanNext() {
        value = '';
        scanError = 0 /* None */;
        tokenOffset = pos;
        lineStartOffset = lineNumber;
        prevTokenLineStartOffset = tokenLineStartOffset;
        if (pos >= len) {
            // at the end
            tokenOffset = len;
            return token = 17 /* EOF */;
        }
        var code = text.charCodeAt(pos);
        // trivia: whitespace
        if (isWhiteSpace(code)) {
            do {
                pos++;
                value += String.fromCharCode(code);
                code = text.charCodeAt(pos);
            } while (isWhiteSpace(code));
            return token = 15 /* Trivia */;
        }
        // trivia: newlines
        if (isLineBreak(code)) {
            pos++;
            value += String.fromCharCode(code);
            if (code === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {
                pos++;
                value += '\n';
            }
            lineNumber++;
            tokenLineStartOffset = pos;
            return token = 14 /* LineBreakTrivia */;
        }
        switch (code) {
            // tokens: []{}:,
            case 123 /* openBrace */:
                pos++;
                return token = 1 /* OpenBraceToken */;
            case 125 /* closeBrace */:
                pos++;
                return token = 2 /* CloseBraceToken */;
            case 91 /* openBracket */:
                pos++;
                return token = 3 /* OpenBracketToken */;
            case 93 /* closeBracket */:
                pos++;
                return token = 4 /* CloseBracketToken */;
            case 58 /* colon */:
                pos++;
                return token = 6 /* ColonToken */;
            case 44 /* comma */:
                pos++;
                return token = 5 /* CommaToken */;
            // strings
            case 34 /* doubleQuote */:
                pos++;
                value = scanString();
                return token = 10 /* StringLiteral */;
            // comments
            case 47 /* slash */:
                var start = pos - 1;
                // Single-line comment
                if (text.charCodeAt(pos + 1) === 47 /* slash */) {
                    pos += 2;
                    while (pos < len) {
                        if (isLineBreak(text.charCodeAt(pos))) {
                            break;
                        }
                        pos++;
                    }
                    value = text.substring(start, pos);
                    return token = 12 /* LineCommentTrivia */;
                }
                // Multi-line comment
                if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {
                    pos += 2;
                    var safeLength = len - 1; // For lookahead.
                    var commentClosed = false;
                    while (pos < safeLength) {
                        var ch = text.charCodeAt(pos);
                        if (ch === 42 /* asterisk */ && text.charCodeAt(pos + 1) === 47 /* slash */) {
                            pos += 2;
                            commentClosed = true;
                            break;
                        }
                        pos++;
                        if (isLineBreak(ch)) {
                            if (ch === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {
                                pos++;
                            }
                            lineNumber++;
                            tokenLineStartOffset = pos;
                        }
                    }
                    if (!commentClosed) {
                        pos++;
                        scanError = 1 /* UnexpectedEndOfComment */;
                    }
                    value = text.substring(start, pos);
                    return token = 13 /* BlockCommentTrivia */;
                }
                // just a single slash
                value += String.fromCharCode(code);
                pos++;
                return token = 16 /* Unknown */;
            // numbers
            case 45 /* minus */:
                value += String.fromCharCode(code);
                pos++;
                if (pos === len || !isDigit(text.charCodeAt(pos))) {
                    return token = 16 /* Unknown */;
                }
            // found a minus, followed by a number so
            // we fall through to proceed with scanning
            // numbers
            case 48 /* _0 */:
            case 49 /* _1 */:
            case 50 /* _2 */:
            case 51 /* _3 */:
            case 52 /* _4 */:
            case 53 /* _5 */:
            case 54 /* _6 */:
            case 55 /* _7 */:
            case 56 /* _8 */:
            case 57 /* _9 */:
                value += scanNumber();
                return token = 11 /* NumericLiteral */;
            // literals and unknown symbols
            default:
                // is a literal? Read the full word.
                while (pos < len && isUnknownContentCharacter(code)) {
                    pos++;
                    code = text.charCodeAt(pos);
                }
                if (tokenOffset !== pos) {
                    value = text.substring(tokenOffset, pos);
                    // keywords: true, false, null
                    switch (value) {
                        case 'true': return token = 8 /* TrueKeyword */;
                        case 'false': return token = 9 /* FalseKeyword */;
                        case 'null': return token = 7 /* NullKeyword */;
                    }
                    return token = 16 /* Unknown */;
                }
                // some
                value += String.fromCharCode(code);
                pos++;
                return token = 16 /* Unknown */;
        }
    }
    function isUnknownContentCharacter(code) {
        if (isWhiteSpace(code) || isLineBreak(code)) {
            return false;
        }
        switch (code) {
            case 125 /* closeBrace */:
            case 93 /* closeBracket */:
            case 123 /* openBrace */:
            case 91 /* openBracket */:
            case 34 /* doubleQuote */:
            case 58 /* colon */:
            case 44 /* comma */:
            case 47 /* slash */:
                return false;
        }
        return true;
    }
    function scanNextNonTrivia() {
        var result;
        do {
            result = scanNext();
        } while (result >= 12 /* LineCommentTrivia */ && result <= 15 /* Trivia */);
        return result;
    }
    return {
        setPosition: setPosition,
        getPosition: function () { return pos; },
        scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
        getToken: function () { return token; },
        getTokenValue: function () { return value; },
        getTokenOffset: function () { return tokenOffset; },
        getTokenLength: function () { return pos - tokenOffset; },
        getTokenStartLine: function () { return lineStartOffset; },
        getTokenStartCharacter: function () { return tokenOffset - prevTokenLineStartOffset; },
        getTokenError: function () { return scanError; },
    };
}
function isWhiteSpace(ch) {
    return ch === 32 /* space */ || ch === 9 /* tab */ || ch === 11 /* verticalTab */ || ch === 12 /* formFeed */ ||
        ch === 160 /* nonBreakingSpace */ || ch === 5760 /* ogham */ || ch >= 8192 /* enQuad */ && ch <= 8203 /* zeroWidthSpace */ ||
        ch === 8239 /* narrowNoBreakSpace */ || ch === 8287 /* mathematicalSpace */ || ch === 12288 /* ideographicSpace */ || ch === 65279 /* byteOrderMark */;
}
function isLineBreak(ch) {
    return ch === 10 /* lineFeed */ || ch === 13 /* carriageReturn */ || ch === 8232 /* lineSeparator */ || ch === 8233 /* paragraphSeparator */;
}
function isDigit(ch) {
    return ch >= 48 /* _0 */ && ch <= 57 /* _9 */;
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/vscode-json-languageservice/_deps/jsonc-parser/impl/format.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


function format_format(documentText, range, options) {
    var initialIndentLevel;
    var formatText;
    var formatTextStart;
    var rangeStart;
    var rangeEnd;
    if (range) {
        rangeStart = range.offset;
        rangeEnd = rangeStart + range.length;
        formatTextStart = rangeStart;
        while (formatTextStart > 0 && !isEOL(documentText, formatTextStart - 1)) {
            formatTextStart--;
        }
        var endOffset = rangeEnd;
        while (endOffset < documentText.length && !isEOL(documentText, endOffset)) {
            endOffset++;
        }
        formatText = documentText.substring(formatTextStart, endOffset);
        initialIndentLevel = computeIndentLevel(formatText, options);
    }
    else {
        formatText = documentText;
        initialIndentLevel = 0;
        formatTextStart = 0;
        rangeStart = 0;
        rangeEnd = documentText.length;
    }
    var eol = getEOL(options, documentText);
    var lineBreak = false;
    var indentLevel = 0;
    var indentValue;
    if (options.insertSpaces) {
        indentValue = format_repeat(' ', options.tabSize || 4);
    }
    else {
        indentValue = '\t';
    }
    var scanner = createScanner(formatText, false);
    var hasError = false;
    function newLineAndIndent() {
        return eol + format_repeat(indentValue, initialIndentLevel + indentLevel);
    }
    function scanNext() {
        var token = scanner.scan();
        lineBreak = false;
        while (token === 15 /* Trivia */ || token === 14 /* LineBreakTrivia */) {
            lineBreak = lineBreak || (token === 14 /* LineBreakTrivia */);
            token = scanner.scan();
        }
        hasError = token === 16 /* Unknown */ || scanner.getTokenError() !== 0 /* None */;
        return token;
    }
    var editOperations = [];
    function addEdit(text, startOffset, endOffset) {
        if (!hasError && startOffset < rangeEnd && endOffset > rangeStart && documentText.substring(startOffset, endOffset) !== text) {
            editOperations.push({ offset: startOffset, length: endOffset - startOffset, content: text });
        }
    }
    var firstToken = scanNext();
    if (firstToken !== 17 /* EOF */) {
        var firstTokenStart = scanner.getTokenOffset() + formatTextStart;
        var initialIndent = format_repeat(indentValue, initialIndentLevel);
        addEdit(initialIndent, formatTextStart, firstTokenStart);
    }
    while (firstToken !== 17 /* EOF */) {
        var firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
        var secondToken = scanNext();
        var replaceContent = '';
        while (!lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {
            // comments on the same line: keep them on the same line, but ignore them otherwise
            var commentTokenStart = scanner.getTokenOffset() + formatTextStart;
            addEdit(' ', firstTokenEnd, commentTokenStart);
            firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
            replaceContent = secondToken === 12 /* LineCommentTrivia */ ? newLineAndIndent() : '';
            secondToken = scanNext();
        }
        if (secondToken === 2 /* CloseBraceToken */) {
            if (firstToken !== 1 /* OpenBraceToken */) {
                indentLevel--;
                replaceContent = newLineAndIndent();
            }
        }
        else if (secondToken === 4 /* CloseBracketToken */) {
            if (firstToken !== 3 /* OpenBracketToken */) {
                indentLevel--;
                replaceContent = newLineAndIndent();
            }
        }
        else {
            switch (firstToken) {
                case 3 /* OpenBracketToken */:
                case 1 /* OpenBraceToken */:
                    indentLevel++;
                    replaceContent = newLineAndIndent();
                    break;
                case 5 /* CommaToken */:
                case 12 /* LineCommentTrivia */:
                    replaceContent = newLineAndIndent();
                    break;
                case 13 /* BlockCommentTrivia */:
                    if (lineBreak) {
                        replaceContent = newLineAndIndent();
                    }
                    else {
                        // symbol following comment on the same line: keep on same line, separate with ' '
                        replaceContent = ' ';
                    }
                    break;
                case 6 /* ColonToken */:
                    replaceContent = ' ';
                    break;
                case 10 /* StringLiteral */:
                    if (secondToken === 6 /* ColonToken */) {
                        replaceContent = '';
                        break;
                    }
                // fall through
                case 7 /* NullKeyword */:
                case 8 /* TrueKeyword */:
                case 9 /* FalseKeyword */:
                case 11 /* NumericLiteral */:
                case 2 /* CloseBraceToken */:
                case 4 /* CloseBracketToken */:
                    if (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */) {
                        replaceContent = ' ';
                    }
                    else if (secondToken !== 5 /* CommaToken */ && secondToken !== 17 /* EOF */) {
                        hasError = true;
                    }
                    break;
                case 16 /* Unknown */:
                    hasError = true;
                    break;
            }
            if (lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {
                replaceContent = newLineAndIndent();
            }
        }
        var secondTokenStart = scanner.getTokenOffset() + formatTextStart;
        addEdit(replaceContent, firstTokenEnd, secondTokenStart);
        firstToken = secondToken;
    }
    return editOperations;
}
function format_repeat(s, count) {
    var result = '';
    for (var i = 0; i < count; i++) {
        result += s;
    }
    return result;
}
function computeIndentLevel(content, options) {
    var i = 0;
    var nChars = 0;
    var tabSize = options.tabSize || 4;
    while (i < content.length) {
        var ch = content.charAt(i);
        if (ch === ' ') {
            nChars++;
        }
        else if (ch === '\t') {
            nChars += tabSize;
        }
        else {
            break;
        }
        i++;
    }
    return Math.floor(nChars / tabSize);
}
function getEOL(options, text) {
    for (var i = 0; i < text.length; i++) {
        var ch = text.charAt(i);
        if (ch === '\r') {
            if (i + 1 < text.length && text.charAt(i + 1) === '\n') {
                return '\r\n';
            }
            return '\r';
        }
        else if (ch === '\n') {
            return '\n';
        }
    }
    return (options && options.eol) || '\n';
}
function isEOL(text, offset) {
    return '\r\n'.indexOf(text.charAt(offset)) !== -1;
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/vscode-json-languageservice/_deps/jsonc-parser/impl/parser.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


var ParseOptions;
(function (ParseOptions) {
    ParseOptions.DEFAULT = {
        allowTrailingComma: false
    };
})(ParseOptions || (ParseOptions = {}));
/**
 * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.
 */
function getLocation(text, position) {
    var segments = []; // strings or numbers
    var earlyReturnException = new Object();
    var previousNode = undefined;
    var previousNodeInst = {
        value: {},
        offset: 0,
        length: 0,
        type: 'object',
        parent: undefined
    };
    var isAtPropertyKey = false;
    function setPreviousNode(value, offset, length, type) {
        previousNodeInst.value = value;
        previousNodeInst.offset = offset;
        previousNodeInst.length = length;
        previousNodeInst.type = type;
        previousNodeInst.colonOffset = undefined;
        previousNode = previousNodeInst;
    }
    try {
        visit(text, {
            onObjectBegin: function (offset, length) {
                if (position <= offset) {
                    throw earlyReturnException;
                }
                previousNode = undefined;
                isAtPropertyKey = position > offset;
                segments.push(''); // push a placeholder (will be replaced)
            },
            onObjectProperty: function (name, offset, length) {
                if (position < offset) {
                    throw earlyReturnException;
                }
                setPreviousNode(name, offset, length, 'property');
                segments[segments.length - 1] = name;
                if (position <= offset + length) {
                    throw earlyReturnException;
                }
            },
            onObjectEnd: function (offset, length) {
                if (position <= offset) {
                    throw earlyReturnException;
                }
                previousNode = undefined;
                segments.pop();
            },
            onArrayBegin: function (offset, length) {
                if (position <= offset) {
                    throw earlyReturnException;
                }
                previousNode = undefined;
                segments.push(0);
            },
            onArrayEnd: function (offset, length) {
                if (position <= offset) {
                    throw earlyReturnException;
                }
                previousNode = undefined;
                segments.pop();
            },
            onLiteralValue: function (value, offset, length) {
                if (position < offset) {
                    throw earlyReturnException;
                }
                setPreviousNode(value, offset, length, getNodeType(value));
                if (position <= offset + length) {
                    throw earlyReturnException;
                }
            },
            onSeparator: function (sep, offset, length) {
                if (position <= offset) {
                    throw earlyReturnException;
                }
                if (sep === ':' && previousNode && previousNode.type === 'property') {
                    previousNode.colonOffset = offset;
                    isAtPropertyKey = false;
                    previousNode = undefined;
                }
                else if (sep === ',') {
                    var last = segments[segments.length - 1];
                    if (typeof last === 'number') {
                        segments[segments.length - 1] = last + 1;
                    }
                    else {
                        isAtPropertyKey = true;
                        segments[segments.length - 1] = '';
                    }
                    previousNode = undefined;
                }
            }
        });
    }
    catch (e) {
        if (e !== earlyReturnException) {
            throw e;
        }
    }
    return {
        path: segments,
        previousNode: previousNode,
        isAtPropertyKey: isAtPropertyKey,
        matches: function (pattern) {
            var k = 0;
            for (var i = 0; k < pattern.length && i < segments.length; i++) {
                if (pattern[k] === segments[i] || pattern[k] === '*') {
                    k++;
                }
                else if (pattern[k] !== '**') {
                    return false;
                }
            }
            return k === pattern.length;
        }
    };
}
/**
 * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 * Therefore always check the errors list to find out if the input was valid.
 */
function parse(text, errors, options) {
    if (errors === void 0) { errors = []; }
    if (options === void 0) { options = ParseOptions.DEFAULT; }
    var currentProperty = null;
    var currentParent = [];
    var previousParents = [];
    function onValue(value) {
        if (Array.isArray(currentParent)) {
            currentParent.push(value);
        }
        else if (currentProperty !== null) {
            currentParent[currentProperty] = value;
        }
    }
    var visitor = {
        onObjectBegin: function () {
            var object = {};
            onValue(object);
            previousParents.push(currentParent);
            currentParent = object;
            currentProperty = null;
        },
        onObjectProperty: function (name) {
            currentProperty = name;
        },
        onObjectEnd: function () {
            currentParent = previousParents.pop();
        },
        onArrayBegin: function () {
            var array = [];
            onValue(array);
            previousParents.push(currentParent);
            currentParent = array;
            currentProperty = null;
        },
        onArrayEnd: function () {
            currentParent = previousParents.pop();
        },
        onLiteralValue: onValue,
        onError: function (error, offset, length) {
            errors.push({ error: error, offset: offset, length: length });
        }
    };
    visit(text, visitor, options);
    return currentParent[0];
}
/**
 * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 */
function parseTree(text, errors, options) {
    if (errors === void 0) { errors = []; }
    if (options === void 0) { options = ParseOptions.DEFAULT; }
    var currentParent = { type: 'array', offset: -1, length: -1, children: [], parent: undefined }; // artificial root
    function ensurePropertyComplete(endOffset) {
        if (currentParent.type === 'property') {
            currentParent.length = endOffset - currentParent.offset;
            currentParent = currentParent.parent;
        }
    }
    function onValue(valueNode) {
        currentParent.children.push(valueNode);
        return valueNode;
    }
    var visitor = {
        onObjectBegin: function (offset) {
            currentParent = onValue({ type: 'object', offset: offset, length: -1, parent: currentParent, children: [] });
        },
        onObjectProperty: function (name, offset, length) {
            currentParent = onValue({ type: 'property', offset: offset, length: -1, parent: currentParent, children: [] });
            currentParent.children.push({ type: 'string', value: name, offset: offset, length: length, parent: currentParent });
        },
        onObjectEnd: function (offset, length) {
            currentParent.length = offset + length - currentParent.offset;
            currentParent = currentParent.parent;
            ensurePropertyComplete(offset + length);
        },
        onArrayBegin: function (offset, length) {
            currentParent = onValue({ type: 'array', offset: offset, length: -1, parent: currentParent, children: [] });
        },
        onArrayEnd: function (offset, length) {
            currentParent.length = offset + length - currentParent.offset;
            currentParent = currentParent.parent;
            ensurePropertyComplete(offset + length);
        },
        onLiteralValue: function (value, offset, length) {
            onValue({ type: getNodeType(value), offset: offset, length: length, parent: currentParent, value: value });
            ensurePropertyComplete(offset + length);
        },
        onSeparator: function (sep, offset, length) {
            if (currentParent.type === 'property') {
                if (sep === ':') {
                    currentParent.colonOffset = offset;
                }
                else if (sep === ',') {
                    ensurePropertyComplete(offset);
                }
            }
        },
        onError: function (error, offset, length) {
            errors.push({ error: error, offset: offset, length: length });
        }
    };
    visit(text, visitor, options);
    var result = currentParent.children[0];
    if (result) {
        delete result.parent;
    }
    return result;
}
/**
 * Finds the node at the given path in a JSON DOM.
 */
function findNodeAtLocation(root, path) {
    if (!root) {
        return undefined;
    }
    var node = root;
    for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {
        var segment = path_1[_i];
        if (typeof segment === 'string') {
            if (node.type !== 'object' || !Array.isArray(node.children)) {
                return undefined;
            }
            var found = false;
            for (var _a = 0, _b = node.children; _a < _b.length; _a++) {
                var propertyNode = _b[_a];
                if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {
                    node = propertyNode.children[1];
                    found = true;
                    break;
                }
            }
            if (!found) {
                return undefined;
            }
        }
        else {
            var index = segment;
            if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {
                return undefined;
            }
            node = node.children[index];
        }
    }
    return node;
}
/**
 * Gets the JSON path of the given JSON DOM node
 */
function getNodePath(node) {
    if (!node.parent || !node.parent.children) {
        return [];
    }
    var path = getNodePath(node.parent);
    if (node.parent.type === 'property') {
        var key = node.parent.children[0].value;
        path.push(key);
    }
    else if (node.parent.type === 'array') {
        var index = node.parent.children.indexOf(node);
        if (index !== -1) {
            path.push(index);
        }
    }
    return path;
}
/**
 * Evaluates the JavaScript object of the given JSON DOM node
 */
function getNodeValue(node) {
    switch (node.type) {
        case 'array':
            return node.children.map(getNodeValue);
        case 'object':
            var obj = Object.create(null);
            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                var prop = _a[_i];
                var valueNode = prop.children[1];
                if (valueNode) {
                    obj[prop.children[0].value] = getNodeValue(valueNode);
                }
            }
            return obj;
        case 'null':
        case 'string':
        case 'number':
        case 'boolean':
            return node.value;
        default:
            return undefined;
    }
}
function contains(node, offset, includeRightBound) {
    if (includeRightBound === void 0) { includeRightBound = false; }
    return (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));
}
/**
 * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.
 */
function findNodeAtOffset(node, offset, includeRightBound) {
    if (includeRightBound === void 0) { includeRightBound = false; }
    if (contains(node, offset, includeRightBound)) {
        var children = node.children;
        if (Array.isArray(children)) {
            for (var i = 0; i < children.length && children[i].offset <= offset; i++) {
                var item = findNodeAtOffset(children[i], offset, includeRightBound);
                if (item) {
                    return item;
                }
            }
        }
        return node;
    }
    return undefined;
}
/**
 * Parses the given text and invokes the visitor functions for each object, array and literal reached.
 */
function visit(text, visitor, options) {
    if (options === void 0) { options = ParseOptions.DEFAULT; }
    var _scanner = createScanner(text, false);
    function toNoArgVisit(visitFunction) {
        return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()); } : function () { return true; };
    }
    function toOneArgVisit(visitFunction) {
        return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength(), _scanner.getTokenStartLine(), _scanner.getTokenStartCharacter()); } : function () { return true; };
    }
    var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
    var disallowComments = options && options.disallowComments;
    var allowTrailingComma = options && options.allowTrailingComma;
    function scanNext() {
        while (true) {
            var token = _scanner.scan();
            switch (_scanner.getTokenError()) {
                case 4 /* InvalidUnicode */:
                    handleError(14 /* InvalidUnicode */);
                    break;
                case 5 /* InvalidEscapeCharacter */:
                    handleError(15 /* InvalidEscapeCharacter */);
                    break;
                case 3 /* UnexpectedEndOfNumber */:
                    handleError(13 /* UnexpectedEndOfNumber */);
                    break;
                case 1 /* UnexpectedEndOfComment */:
                    if (!disallowComments) {
                        handleError(11 /* UnexpectedEndOfComment */);
                    }
                    break;
                case 2 /* UnexpectedEndOfString */:
                    handleError(12 /* UnexpectedEndOfString */);
                    break;
                case 6 /* InvalidCharacter */:
                    handleError(16 /* InvalidCharacter */);
                    break;
            }
            switch (token) {
                case 12 /* LineCommentTrivia */:
                case 13 /* BlockCommentTrivia */:
                    if (disallowComments) {
                        handleError(10 /* InvalidCommentToken */);
                    }
                    else {
                        onComment();
                    }
                    break;
                case 16 /* Unknown */:
                    handleError(1 /* InvalidSymbol */);
                    break;
                case 15 /* Trivia */:
                case 14 /* LineBreakTrivia */:
                    break;
                default:
                    return token;
            }
        }
    }
    function handleError(error, skipUntilAfter, skipUntil) {
        if (skipUntilAfter === void 0) { skipUntilAfter = []; }
        if (skipUntil === void 0) { skipUntil = []; }
        onError(error);
        if (skipUntilAfter.length + skipUntil.length > 0) {
            var token = _scanner.getToken();
            while (token !== 17 /* EOF */) {
                if (skipUntilAfter.indexOf(token) !== -1) {
                    scanNext();
                    break;
                }
                else if (skipUntil.indexOf(token) !== -1) {
                    break;
                }
                token = scanNext();
            }
        }
    }
    function parseString(isValue) {
        var value = _scanner.getTokenValue();
        if (isValue) {
            onLiteralValue(value);
        }
        else {
            onObjectProperty(value);
        }
        scanNext();
        return true;
    }
    function parseLiteral() {
        switch (_scanner.getToken()) {
            case 11 /* NumericLiteral */:
                var value = 0;
                try {
                    value = JSON.parse(_scanner.getTokenValue());
                    if (typeof value !== 'number') {
                        handleError(2 /* InvalidNumberFormat */);
                        value = 0;
                    }
                }
                catch (e) {
                    handleError(2 /* InvalidNumberFormat */);
                }
                onLiteralValue(value);
                break;
            case 7 /* NullKeyword */:
                onLiteralValue(null);
                break;
            case 8 /* TrueKeyword */:
                onLiteralValue(true);
                break;
            case 9 /* FalseKeyword */:
                onLiteralValue(false);
                break;
            default:
                return false;
        }
        scanNext();
        return true;
    }
    function parseProperty() {
        if (_scanner.getToken() !== 10 /* StringLiteral */) {
            handleError(3 /* PropertyNameExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
            return false;
        }
        parseString(false);
        if (_scanner.getToken() === 6 /* ColonToken */) {
            onSeparator(':');
            scanNext(); // consume colon
            if (!parseValue()) {
                handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
            }
        }
        else {
            handleError(5 /* ColonExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
        }
        return true;
    }
    function parseObject() {
        onObjectBegin();
        scanNext(); // consume open brace
        var needsComma = false;
        while (_scanner.getToken() !== 2 /* CloseBraceToken */ && _scanner.getToken() !== 17 /* EOF */) {
            if (_scanner.getToken() === 5 /* CommaToken */) {
                if (!needsComma) {
                    handleError(4 /* ValueExpected */, [], []);
                }
                onSeparator(',');
                scanNext(); // consume comma
                if (_scanner.getToken() === 2 /* CloseBraceToken */ && allowTrailingComma) {
                    break;
                }
            }
            else if (needsComma) {
                handleError(6 /* CommaExpected */, [], []);
            }
            if (!parseProperty()) {
                handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
            }
            needsComma = true;
        }
        onObjectEnd();
        if (_scanner.getToken() !== 2 /* CloseBraceToken */) {
            handleError(7 /* CloseBraceExpected */, [2 /* CloseBraceToken */], []);
        }
        else {
            scanNext(); // consume close brace
        }
        return true;
    }
    function parseArray() {
        onArrayBegin();
        scanNext(); // consume open bracket
        var needsComma = false;
        while (_scanner.getToken() !== 4 /* CloseBracketToken */ && _scanner.getToken() !== 17 /* EOF */) {
            if (_scanner.getToken() === 5 /* CommaToken */) {
                if (!needsComma) {
                    handleError(4 /* ValueExpected */, [], []);
                }
                onSeparator(',');
                scanNext(); // consume comma
                if (_scanner.getToken() === 4 /* CloseBracketToken */ && allowTrailingComma) {
                    break;
                }
            }
            else if (needsComma) {
                handleError(6 /* CommaExpected */, [], []);
            }
            if (!parseValue()) {
                handleError(4 /* ValueExpected */, [], [4 /* CloseBracketToken */, 5 /* CommaToken */]);
            }
            needsComma = true;
        }
        onArrayEnd();
        if (_scanner.getToken() !== 4 /* CloseBracketToken */) {
            handleError(8 /* CloseBracketExpected */, [4 /* CloseBracketToken */], []);
        }
        else {
            scanNext(); // consume close bracket
        }
        return true;
    }
    function parseValue() {
        switch (_scanner.getToken()) {
            case 3 /* OpenBracketToken */:
                return parseArray();
            case 1 /* OpenBraceToken */:
                return parseObject();
            case 10 /* StringLiteral */:
                return parseString(true);
            default:
                return parseLiteral();
        }
    }
    scanNext();
    if (_scanner.getToken() === 17 /* EOF */) {
        if (options.allowEmptyContent) {
            return true;
        }
        handleError(4 /* ValueExpected */, [], []);
        return false;
    }
    if (!parseValue()) {
        handleError(4 /* ValueExpected */, [], []);
        return false;
    }
    if (_scanner.getToken() !== 17 /* EOF */) {
        handleError(9 /* EndOfFileExpected */, [], []);
    }
    return true;
}
/**
 * Takes JSON with JavaScript-style comments and remove
 * them. Optionally replaces every none-newline character
 * of comments with a replaceCharacter
 */
function stripComments(text, replaceCh) {
    var _scanner = createScanner(text), parts = [], kind, offset = 0, pos;
    do {
        pos = _scanner.getPosition();
        kind = _scanner.scan();
        switch (kind) {
            case 12 /* LineCommentTrivia */:
            case 13 /* BlockCommentTrivia */:
            case 17 /* EOF */:
                if (offset !== pos) {
                    parts.push(text.substring(offset, pos));
                }
                if (replaceCh !== undefined) {
                    parts.push(_scanner.getTokenValue().replace(/[^\r\n]/g, replaceCh));
                }
                offset = _scanner.getPosition();
                break;
        }
    } while (kind !== 17 /* EOF */);
    return parts.join('');
}
function getNodeType(value) {
    switch (typeof value) {
        case 'boolean': return 'boolean';
        case 'number': return 'number';
        case 'string': return 'string';
        case 'object': {
            if (!value) {
                return 'null';
            }
            else if (Array.isArray(value)) {
                return 'array';
            }
            return 'object';
        }
        default: return 'null';
    }
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/vscode-json-languageservice/_deps/jsonc-parser/impl/edit.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



function removeProperty(text, path, formattingOptions) {
    return setProperty(text, path, void 0, formattingOptions);
}
function setProperty(text, originalPath, value, formattingOptions, getInsertionIndex) {
    var _a;
    var path = originalPath.slice();
    var errors = [];
    var root = parseTree(text, errors);
    var parent = void 0;
    var lastSegment = void 0;
    while (path.length > 0) {
        lastSegment = path.pop();
        parent = findNodeAtLocation(root, path);
        if (parent === void 0 && value !== void 0) {
            if (typeof lastSegment === 'string') {
                value = (_a = {}, _a[lastSegment] = value, _a);
            }
            else {
                value = [value];
            }
        }
        else {
            break;
        }
    }
    if (!parent) {
        // empty document
        if (value === void 0) { // delete
            throw new Error('Can not delete in empty document');
        }
        return withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, formattingOptions);
    }
    else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {
        var existing = findNodeAtLocation(parent, [lastSegment]);
        if (existing !== void 0) {
            if (value === void 0) { // delete
                if (!existing.parent) {
                    throw new Error('Malformed AST');
                }
                var propertyIndex = parent.children.indexOf(existing.parent);
                var removeBegin = void 0;
                var removeEnd = existing.parent.offset + existing.parent.length;
                if (propertyIndex > 0) {
                    // remove the comma of the previous node
                    var previous = parent.children[propertyIndex - 1];
                    removeBegin = previous.offset + previous.length;
                }
                else {
                    removeBegin = parent.offset + 1;
                    if (parent.children.length > 1) {
                        // remove the comma of the next node
                        var next = parent.children[1];
                        removeEnd = next.offset;
                    }
                }
                return withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: '' }, formattingOptions);
            }
            else {
                // set value of existing property
                return withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, formattingOptions);
            }
        }
        else {
            if (value === void 0) { // delete
                return []; // property does not exist, nothing to do
            }
            var newProperty = JSON.stringify(lastSegment) + ": " + JSON.stringify(value);
            var index = getInsertionIndex ? getInsertionIndex(parent.children.map(function (p) { return p.children[0].value; })) : parent.children.length;
            var edit = void 0;
            if (index > 0) {
                var previous = parent.children[index - 1];
                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };
            }
            else if (parent.children.length === 0) {
                edit = { offset: parent.offset + 1, length: 0, content: newProperty };
            }
            else {
                edit = { offset: parent.offset + 1, length: 0, content: newProperty + ',' };
            }
            return withFormatting(text, edit, formattingOptions);
        }
    }
    else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {
        var insertIndex = lastSegment;
        if (insertIndex === -1) {
            // Insert
            var newProperty = "" + JSON.stringify(value);
            var edit = void 0;
            if (parent.children.length === 0) {
                edit = { offset: parent.offset + 1, length: 0, content: newProperty };
            }
            else {
                var previous = parent.children[parent.children.length - 1];
                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };
            }
            return withFormatting(text, edit, formattingOptions);
        }
        else {
            if (value === void 0 && parent.children.length >= 0) {
                //Removal
                var removalIndex = lastSegment;
                var toRemove = parent.children[removalIndex];
                var edit = void 0;
                if (parent.children.length === 1) {
                    // only item
                    edit = { offset: parent.offset + 1, length: parent.length - 2, content: '' };
                }
                else if (parent.children.length - 1 === removalIndex) {
                    // last item
                    var previous = parent.children[removalIndex - 1];
                    var offset = previous.offset + previous.length;
                    var parentEndOffset = parent.offset + parent.length;
                    edit = { offset: offset, length: parentEndOffset - 2 - offset, content: '' };
                }
                else {
                    edit = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: '' };
                }
                return withFormatting(text, edit, formattingOptions);
            }
            else {
                throw new Error('Array modification not supported yet');
            }
        }
    }
    else {
        throw new Error("Can not add " + (typeof lastSegment !== 'number' ? 'index' : 'property') + " to parent of type " + parent.type);
    }
}
function withFormatting(text, edit, formattingOptions) {
    // apply the edit
    var newText = applyEdit(text, edit);
    // format the new text
    var begin = edit.offset;
    var end = edit.offset + edit.content.length;
    if (edit.length === 0 || edit.content.length === 0) { // insert or remove
        while (begin > 0 && !isEOL(newText, begin - 1)) {
            begin--;
        }
        while (end < newText.length && !isEOL(newText, end)) {
            end++;
        }
    }
    var edits = format_format(newText, { offset: begin, length: end - begin }, formattingOptions);
    // apply the formatting edits and track the begin and end offsets of the changes
    for (var i = edits.length - 1; i >= 0; i--) {
        var edit_1 = edits[i];
        newText = applyEdit(newText, edit_1);
        begin = Math.min(begin, edit_1.offset);
        end = Math.max(end, edit_1.offset + edit_1.length);
        end += edit_1.content.length - edit_1.length;
    }
    // create a single edit with all changes
    var editLength = text.length - (newText.length - end) - begin;
    return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];
}
function applyEdit(text, edit) {
    return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);
}
function isWS(text, offset) {
    return '\r\n \t'.indexOf(text.charAt(offset)) !== -1;
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/vscode-json-languageservice/_deps/jsonc-parser/main.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





/**
 * Creates a JSON scanner on the given text.
 * If ignoreTrivia is set, whitespaces or comments are ignored.
 */
var main_createScanner = createScanner;
/**
 * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.
 */
var main_getLocation = getLocation;
/**
 * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 * Therefore, always check the errors list to find out if the input was valid.
 */
var main_parse = parse;
/**
 * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 */
var main_parseTree = parseTree;
/**
 * Finds the node at the given path in a JSON DOM.
 */
var main_findNodeAtLocation = findNodeAtLocation;
/**
 * Finds the innermost node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.
 */
var main_findNodeAtOffset = findNodeAtOffset;
/**
 * Gets the JSON path of the given JSON DOM node
 */
var main_getNodePath = getNodePath;
/**
 * Evaluates the JavaScript object of the given JSON DOM node
 */
var main_getNodeValue = getNodeValue;
/**
 * Parses the given text and invokes the visitor functions for each object, array and literal reached.
 */
var main_visit = visit;
/**
 * Takes JSON with JavaScript-style comments and remove
 * them. Optionally replaces every none-newline character
 * of comments with a replaceCharacter
 */
var main_stripComments = stripComments;
function printParseErrorCode(code) {
    switch (code) {
        case 1 /* InvalidSymbol */: return 'InvalidSymbol';
        case 2 /* InvalidNumberFormat */: return 'InvalidNumberFormat';
        case 3 /* PropertyNameExpected */: return 'PropertyNameExpected';
        case 4 /* ValueExpected */: return 'ValueExpected';
        case 5 /* ColonExpected */: return 'ColonExpected';
        case 6 /* CommaExpected */: return 'CommaExpected';
        case 7 /* CloseBraceExpected */: return 'CloseBraceExpected';
        case 8 /* CloseBracketExpected */: return 'CloseBracketExpected';
        case 9 /* EndOfFileExpected */: return 'EndOfFileExpected';
        case 10 /* InvalidCommentToken */: return 'InvalidCommentToken';
        case 11 /* UnexpectedEndOfComment */: return 'UnexpectedEndOfComment';
        case 12 /* UnexpectedEndOfString */: return 'UnexpectedEndOfString';
        case 13 /* UnexpectedEndOfNumber */: return 'UnexpectedEndOfNumber';
        case 14 /* InvalidUnicode */: return 'InvalidUnicode';
        case 15 /* InvalidEscapeCharacter */: return 'InvalidEscapeCharacter';
        case 16 /* InvalidCharacter */: return 'InvalidCharacter';
    }
    return '<unknown ParseErrorCode>';
}
/**
 * Computes the edits needed to format a JSON document.
 *
 * @param documentText The input text
 * @param range The range to format or `undefined` to format the full content
 * @param options The formatting options
 * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or
 * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of
 * text in the original document. However, multiple edits can have
 * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.
 * To apply edits to an input, you can use `applyEdits`.
 */
function main_format(documentText, range, options) {
    return format_format(documentText, range, options);
}
/**
 * Computes the edits needed to modify a value in the JSON document.
 *
 * @param documentText The input text
 * @param path The path of the value to change. The path represents either to the document root, a property or an array item.
 * If the path points to an non-existing property or item, it will be created.
 * @param value The new value for the specified property or item. If the value is undefined,
 * the property or item will be removed.
 * @param options Options
 * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or
 * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of
 * text in the original document. However, multiple edits can have
 * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.
 * To apply edits to an input, you can use `applyEdits`.
 */
function modify(text, path, value, options) {
    return setProperty(text, path, value, options.formattingOptions, options.getInsertionIndex);
}
/**
 * Applies edits to a input string.
 */
function applyEdits(text, edits) {
    for (var i = edits.length - 1; i >= 0; i--) {
        text = applyEdit(text, edits[i]);
    }
    return text;
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/vscode-uri/index.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

var vscode_uri_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var vscode_uri_a;
var vscode_uri_isWindows;
if (typeof process === 'object') {
    vscode_uri_isWindows = process.platform === 'win32';
}
else if (typeof navigator === 'object') {
    var userAgent = navigator.userAgent;
    vscode_uri_isWindows = userAgent.indexOf('Windows') >= 0;
}
function vscode_uri_isHighSurrogate(charCode) {
    return (0xD800 <= charCode && charCode <= 0xDBFF);
}
function vscode_uri_isLowSurrogate(charCode) {
    return (0xDC00 <= charCode && charCode <= 0xDFFF);
}
function isLowerAsciiHex(code) {
    return code >= 97 /* a */ && code <= 102 /* f */;
}
function vscode_uri_isLowerAsciiLetter(code) {
    return code >= 97 /* a */ && code <= 122 /* z */;
}
function vscode_uri_isUpperAsciiLetter(code) {
    return code >= 65 /* A */ && code <= 90 /* Z */;
}
function vscode_uri_isAsciiLetter(code) {
    return vscode_uri_isLowerAsciiLetter(code) || vscode_uri_isUpperAsciiLetter(code);
}
//#endregion
var vscode_uri_schemePattern = /^\w[\w\d+.-]*$/;
var vscode_uri_singleSlashStart = /^\//;
var vscode_uri_doubleSlashStart = /^\/\//;
function vscode_uri_validateUri(ret, _strict) {
    // scheme, must be set
    if (!ret.scheme && _strict) {
        throw new Error("[UriError]: Scheme is missing: {scheme: \"\", authority: \"" + ret.authority + "\", path: \"" + ret.path + "\", query: \"" + ret.query + "\", fragment: \"" + ret.fragment + "\"}");
    }
    // scheme, https://tools.ietf.org/html/rfc3986#section-3.1
    // ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )
    if (ret.scheme && !vscode_uri_schemePattern.test(ret.scheme)) {
        throw new Error('[UriError]: Scheme contains illegal characters.');
    }
    // path, http://tools.ietf.org/html/rfc3986#section-3.3
    // If a URI contains an authority component, then the path component
    // must either be empty or begin with a slash ("/") character.  If a URI
    // does not contain an authority component, then the path cannot begin
    // with two slash characters ("//").
    if (ret.path) {
        if (ret.authority) {
            if (!vscode_uri_singleSlashStart.test(ret.path)) {
                throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
            }
        }
        else {
            if (vscode_uri_doubleSlashStart.test(ret.path)) {
                throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
            }
        }
    }
}
// for a while we allowed uris *without* schemes and this is the migration
// for them, e.g. an uri without scheme and without strict-mode warns and falls
// back to the file-scheme. that should cause the least carnage and still be a
// clear warning
function vscode_uri_schemeFix(scheme, _strict) {
    if (!scheme && !_strict) {
        return 'file';
    }
    return scheme;
}
// implements a bit of https://tools.ietf.org/html/rfc3986#section-5
function vscode_uri_referenceResolution(scheme, path) {
    // the slash-character is our 'default base' as we don't
    // support constructing URIs relative to other URIs. This
    // also means that we alter and potentially break paths.
    // see https://tools.ietf.org/html/rfc3986#section-5.1.4
    switch (scheme) {
        case 'https':
        case 'http':
        case 'file':
            if (!path) {
                path = vscode_uri_slash;
            }
            else if (path[0] !== vscode_uri_slash) {
                path = vscode_uri_slash + path;
            }
            break;
    }
    return path;
}
var vscode_uri_empty = '';
var vscode_uri_slash = '/';
var vscode_uri_regexp = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
/**
 * Uniform Resource Identifier (URI) http://tools.ietf.org/html/rfc3986.
 * This class is a simple parser which creates the basic component parts
 * (http://tools.ietf.org/html/rfc3986#section-3) with minimal validation
 * and encoding.
 *
 *       foo://example.com:8042/over/there?name=ferret#nose
 *       \_/   \______________/\_________/ \_________/ \__/
 *        |           |            |            |        |
 *     scheme     authority       path        query   fragment
 *        |   _____________________|__
 *       / \ /                        \
 *       urn:example:animal:ferret:nose
 */
var vscode_uri_URI = /** @class */ (function () {
    /**
     * @internal
     */
    function URI(schemeOrData, authority, path, query, fragment, _strict) {
        if (_strict === void 0) { _strict = false; }
        if (typeof schemeOrData === 'object') {
            this.scheme = schemeOrData.scheme || vscode_uri_empty;
            this.authority = schemeOrData.authority || vscode_uri_empty;
            this.path = schemeOrData.path || vscode_uri_empty;
            this.query = schemeOrData.query || vscode_uri_empty;
            this.fragment = schemeOrData.fragment || vscode_uri_empty;
            // no validation because it's this URI
            // that creates uri components.
            // _validateUri(this);
        }
        else {
            this.scheme = vscode_uri_schemeFix(schemeOrData, _strict);
            this.authority = authority || vscode_uri_empty;
            this.path = vscode_uri_referenceResolution(this.scheme, path || vscode_uri_empty);
            this.query = query || vscode_uri_empty;
            this.fragment = fragment || vscode_uri_empty;
            vscode_uri_validateUri(this, _strict);
        }
    }
    URI.isUri = function (thing) {
        if (thing instanceof URI) {
            return true;
        }
        if (!thing) {
            return false;
        }
        return typeof thing.authority === 'string'
            && typeof thing.fragment === 'string'
            && typeof thing.path === 'string'
            && typeof thing.query === 'string'
            && typeof thing.scheme === 'string'
            && typeof thing.fsPath === 'function'
            && typeof thing.with === 'function'
            && typeof thing.toString === 'function';
    };
    Object.defineProperty(URI.prototype, "fsPath", {
        // ---- filesystem path -----------------------
        /**
         * Returns a string representing the corresponding file system path of this URI.
         * Will handle UNC paths, normalizes windows drive letters to lower-case, and uses the
         * platform specific path separator.
         *
         * * Will *not* validate the path for invalid characters and semantics.
         * * Will *not* look at the scheme of this URI.
         * * The result shall *not* be used for display purposes but for accessing a file on disk.
         *
         *
         * The *difference* to `URI#path` is the use of the platform specific separator and the handling
         * of UNC paths. See the below sample of a file-uri with an authority (UNC path).
         *
         * ```ts
            const u = URI.parse('file://server/c$/folder/file.txt')
            u.authority === 'server'
            u.path === '/shares/c$/file.txt'
            u.fsPath === '\\server\c$\folder\file.txt'
        ```
         *
         * Using `URI#path` to read a file (using fs-apis) would not be enough because parts of the path,
         * namely the server name, would be missing. Therefore `URI#fsPath` exists - it's sugar to ease working
         * with URIs that represent files on disk (`file` scheme).
         */
        get: function () {
            // if (this.scheme !== 'file') {
            // 	console.warn(`[UriError] calling fsPath with scheme ${this.scheme}`);
            // }
            return vscode_uri_makeFsPath(this);
        },
        enumerable: true,
        configurable: true
    });
    // ---- modify to new -------------------------
    URI.prototype.with = function (change) {
        if (!change) {
            return this;
        }
        var scheme = change.scheme, authority = change.authority, path = change.path, query = change.query, fragment = change.fragment;
        if (scheme === undefined) {
            scheme = this.scheme;
        }
        else if (scheme === null) {
            scheme = vscode_uri_empty;
        }
        if (authority === undefined) {
            authority = this.authority;
        }
        else if (authority === null) {
            authority = vscode_uri_empty;
        }
        if (path === undefined) {
            path = this.path;
        }
        else if (path === null) {
            path = vscode_uri_empty;
        }
        if (query === undefined) {
            query = this.query;
        }
        else if (query === null) {
            query = vscode_uri_empty;
        }
        if (fragment === undefined) {
            fragment = this.fragment;
        }
        else if (fragment === null) {
            fragment = vscode_uri_empty;
        }
        if (scheme === this.scheme
            && authority === this.authority
            && path === this.path
            && query === this.query
            && fragment === this.fragment) {
            return this;
        }
        return new _deps_vscode_uri_URI(scheme, authority, path, query, fragment);
    };
    // ---- parse & validate ------------------------
    /**
     * Creates a new URI from a string, e.g. `http://www.msft.com/some/path`,
     * `file:///usr/home`, or `scheme:with/path`.
     *
     * @param value A string which represents an URI (see `URI#toString`).
     */
    URI.parse = function (value, _strict) {
        if (_strict === void 0) { _strict = false; }
        var match = vscode_uri_regexp.exec(value);
        if (!match) {
            return new _deps_vscode_uri_URI(vscode_uri_empty, vscode_uri_empty, vscode_uri_empty, vscode_uri_empty, vscode_uri_empty);
        }
        return new _deps_vscode_uri_URI(match[2] || vscode_uri_empty, decodeURIComponent(match[4] || vscode_uri_empty), decodeURIComponent(match[5] || vscode_uri_empty), decodeURIComponent(match[7] || vscode_uri_empty), decodeURIComponent(match[9] || vscode_uri_empty), _strict);
    };
    /**
     * Creates a new URI from a file system path, e.g. `c:\my\files`,
     * `/usr/home`, or `\\server\share\some\path`.
     *
     * The *difference* between `URI#parse` and `URI#file` is that the latter treats the argument
     * as path, not as stringified-uri. E.g. `URI.file(path)` is **not the same as**
     * `URI.parse('file://' + path)` because the path might contain characters that are
     * interpreted (# and ?). See the following sample:
     * ```ts
    const good = URI.file('/coding/c#/project1');
    good.scheme === 'file';
    good.path === '/coding/c#/project1';
    good.fragment === '';
    const bad = URI.parse('file://' + '/coding/c#/project1');
    bad.scheme === 'file';
    bad.path === '/coding/c'; // path is now broken
    bad.fragment === '/project1';
    ```
     *
     * @param path A file system path (see `URI#fsPath`)
     */
    URI.file = function (path) {
        var authority = vscode_uri_empty;
        // normalize to fwd-slashes on windows,
        // on other systems bwd-slashes are valid
        // filename character, eg /f\oo/ba\r.txt
        if (vscode_uri_isWindows) {
            path = path.replace(/\\/g, vscode_uri_slash);
        }
        // check for authority as used in UNC shares
        // or use the path as given
        if (path[0] === vscode_uri_slash && path[1] === vscode_uri_slash) {
            var idx = path.indexOf(vscode_uri_slash, 2);
            if (idx === -1) {
                authority = path.substring(2);
                path = vscode_uri_slash;
            }
            else {
                authority = path.substring(2, idx);
                path = path.substring(idx) || vscode_uri_slash;
            }
        }
        return new _deps_vscode_uri_URI('file', authority, path, vscode_uri_empty, vscode_uri_empty);
    };
    URI.from = function (components) {
        return new _deps_vscode_uri_URI(components.scheme, components.authority, components.path, components.query, components.fragment);
    };
    // ---- printing/externalize ---------------------------
    /**
     * Creates a string representation for this URI. It's guaranteed that calling
     * `URI.parse` with the result of this function creates an URI which is equal
     * to this URI.
     *
     * * The result shall *not* be used for display purposes but for externalization or transport.
     * * The result will be encoded using the percentage encoding and encoding happens mostly
     * ignore the scheme-specific encoding rules.
     *
     * @param skipEncoding Do not encode the result, default is `false`
     */
    URI.prototype.toString = function (skipEncoding) {
        if (skipEncoding === void 0) { skipEncoding = false; }
        return vscode_uri_asFormatted(this, skipEncoding);
    };
    URI.prototype.toJSON = function () {
        return this;
    };
    URI.revive = function (data) {
        if (!data) {
            return data;
        }
        else if (data instanceof URI) {
            return data;
        }
        else {
            var result = new _deps_vscode_uri_URI(data);
            result._formatted = data.external;
            result._fsPath = data._sep === vscode_uri_pathSepMarker ? data.fsPath : null;
            return result;
        }
    };
    return URI;
}());

var vscode_uri_pathSepMarker = vscode_uri_isWindows ? 1 : undefined;
// tslint:disable-next-line:class-name
var _deps_vscode_uri_URI = /** @class */ (function (_super) {
    vscode_uri_extends(_URI, _super);
    function _URI() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        _this._formatted = null;
        _this._fsPath = null;
        return _this;
    }
    Object.defineProperty(_URI.prototype, "fsPath", {
        get: function () {
            if (!this._fsPath) {
                this._fsPath = vscode_uri_makeFsPath(this);
            }
            return this._fsPath;
        },
        enumerable: true,
        configurable: true
    });
    _URI.prototype.toString = function (skipEncoding) {
        if (skipEncoding === void 0) { skipEncoding = false; }
        if (!skipEncoding) {
            if (!this._formatted) {
                this._formatted = vscode_uri_asFormatted(this, false);
            }
            return this._formatted;
        }
        else {
            // we don't cache that
            return vscode_uri_asFormatted(this, true);
        }
    };
    _URI.prototype.toJSON = function () {
        var res = {
            $mid: 1
        };
        // cached state
        if (this._fsPath) {
            res.fsPath = this._fsPath;
            res._sep = vscode_uri_pathSepMarker;
        }
        if (this._formatted) {
            res.external = this._formatted;
        }
        // uri components
        if (this.path) {
            res.path = this.path;
        }
        if (this.scheme) {
            res.scheme = this.scheme;
        }
        if (this.authority) {
            res.authority = this.authority;
        }
        if (this.query) {
            res.query = this.query;
        }
        if (this.fragment) {
            res.fragment = this.fragment;
        }
        return res;
    };
    return _URI;
}(vscode_uri_URI));
// reserved characters: https://tools.ietf.org/html/rfc3986#section-2.2
var vscode_uri_encodeTable = (vscode_uri_a = {},
    vscode_uri_a[58 /* Colon */] = '%3A',
    vscode_uri_a[47 /* Slash */] = '%2F',
    vscode_uri_a[63 /* QuestionMark */] = '%3F',
    vscode_uri_a[35 /* Hash */] = '%23',
    vscode_uri_a[91 /* OpenSquareBracket */] = '%5B',
    vscode_uri_a[93 /* CloseSquareBracket */] = '%5D',
    vscode_uri_a[64 /* AtSign */] = '%40',
    vscode_uri_a[33 /* ExclamationMark */] = '%21',
    vscode_uri_a[36 /* DollarSign */] = '%24',
    vscode_uri_a[38 /* Ampersand */] = '%26',
    vscode_uri_a[39 /* SingleQuote */] = '%27',
    vscode_uri_a[40 /* OpenParen */] = '%28',
    vscode_uri_a[41 /* CloseParen */] = '%29',
    vscode_uri_a[42 /* Asterisk */] = '%2A',
    vscode_uri_a[43 /* Plus */] = '%2B',
    vscode_uri_a[44 /* Comma */] = '%2C',
    vscode_uri_a[59 /* Semicolon */] = '%3B',
    vscode_uri_a[61 /* Equals */] = '%3D',
    vscode_uri_a[32 /* Space */] = '%20',
    vscode_uri_a);
function vscode_uri_encodeURIComponentFast(uriComponent, allowSlash) {
    var res = undefined;
    var nativeEncodePos = -1;
    for (var pos = 0; pos < uriComponent.length; pos++) {
        var code = uriComponent.charCodeAt(pos);
        // unreserved characters: https://tools.ietf.org/html/rfc3986#section-2.3
        if ((code >= 97 /* a */ && code <= 122 /* z */)
            || (code >= 65 /* A */ && code <= 90 /* Z */)
            || (code >= 48 /* Digit0 */ && code <= 57 /* Digit9 */)
            || code === 45 /* Dash */
            || code === 46 /* Period */
            || code === 95 /* Underline */
            || code === 126 /* Tilde */
            || (allowSlash && code === 47 /* Slash */)) {
            // check if we are delaying native encode
            if (nativeEncodePos !== -1) {
                res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
                nativeEncodePos = -1;
            }
            // check if we write into a new string (by default we try to return the param)
            if (res !== undefined) {
                res += uriComponent.charAt(pos);
            }
        }
        else {
            // encoding needed, we need to allocate a new string
            if (res === undefined) {
                res = uriComponent.substr(0, pos);
            }
            // check with default table first
            var escaped = vscode_uri_encodeTable[code];
            if (escaped !== undefined) {
                // check if we are delaying native encode
                if (nativeEncodePos !== -1) {
                    res += encodeURIComponent(uriComponent.substring(nativeEncodePos, pos));
                    nativeEncodePos = -1;
                }
                // append escaped variant to result
                res += escaped;
            }
            else if (nativeEncodePos === -1) {
                // use native encode only when needed
                nativeEncodePos = pos;
            }
        }
    }
    if (nativeEncodePos !== -1) {
        res += encodeURIComponent(uriComponent.substring(nativeEncodePos));
    }
    return res !== undefined ? res : uriComponent;
}
function vscode_uri_encodeURIComponentMinimal(path) {
    var res = undefined;
    for (var pos = 0; pos < path.length; pos++) {
        var code = path.charCodeAt(pos);
        if (code === 35 /* Hash */ || code === 63 /* QuestionMark */) {
            if (res === undefined) {
                res = path.substr(0, pos);
            }
            res += vscode_uri_encodeTable[code];
        }
        else {
            if (res !== undefined) {
                res += path[pos];
            }
        }
    }
    return res !== undefined ? res : path;
}
/**
 * Compute `fsPath` for the given uri
 */
function vscode_uri_makeFsPath(uri) {
    var value;
    if (uri.authority && uri.path.length > 1 && uri.scheme === 'file') {
        // unc path: file://shares/c$/far/boo
        value = "//" + uri.authority + uri.path;
    }
    else if (uri.path.charCodeAt(0) === 47 /* Slash */
        && (uri.path.charCodeAt(1) >= 65 /* A */ && uri.path.charCodeAt(1) <= 90 /* Z */ || uri.path.charCodeAt(1) >= 97 /* a */ && uri.path.charCodeAt(1) <= 122 /* z */)
        && uri.path.charCodeAt(2) === 58 /* Colon */) {
        // windows drive letter: file:///c:/far/boo
        value = uri.path[1].toLowerCase() + uri.path.substr(2);
    }
    else {
        // other path
        value = uri.path;
    }
    if (vscode_uri_isWindows) {
        value = value.replace(/\//g, '\\');
    }
    return value;
}
/**
 * Create the external version of a uri
 */
function vscode_uri_asFormatted(uri, skipEncoding) {
    var encoder = !skipEncoding
        ? vscode_uri_encodeURIComponentFast
        : vscode_uri_encodeURIComponentMinimal;
    var res = '';
    var scheme = uri.scheme, authority = uri.authority, path = uri.path, query = uri.query, fragment = uri.fragment;
    if (scheme) {
        res += scheme;
        res += ':';
    }
    if (authority || scheme === 'file') {
        res += vscode_uri_slash;
        res += vscode_uri_slash;
    }
    if (authority) {
        var idx = authority.indexOf('@');
        if (idx !== -1) {
            // <user>@<auth>
            var userinfo = authority.substr(0, idx);
            authority = authority.substr(idx + 1);
            idx = userinfo.indexOf(':');
            if (idx === -1) {
                res += encoder(userinfo, false);
            }
            else {
                // <user>:<pass>@<auth>
                res += encoder(userinfo.substr(0, idx), false);
                res += ':';
                res += encoder(userinfo.substr(idx + 1), false);
            }
            res += '@';
        }
        authority = authority.toLowerCase();
        idx = authority.indexOf(':');
        if (idx === -1) {
            res += encoder(authority, false);
        }
        else {
            // <auth>:<port>
            res += encoder(authority.substr(0, idx), false);
            res += authority.substr(idx);
        }
    }
    if (path) {
        // lower-case windows drive letters in /C:/fff or C:/fff
        if (path.length >= 3 && path.charCodeAt(0) === 47 /* Slash */ && path.charCodeAt(2) === 58 /* Colon */) {
            var code = path.charCodeAt(1);
            if (code >= 65 /* A */ && code <= 90 /* Z */) {
                path = "/" + String.fromCharCode(code + 32) + ":" + path.substr(3); // "/c:".length === 3
            }
        }
        else if (path.length >= 2 && path.charCodeAt(1) === 58 /* Colon */) {
            var code = path.charCodeAt(0);
            if (code >= 65 /* A */ && code <= 90 /* Z */) {
                path = String.fromCharCode(code + 32) + ":" + path.substr(2); // "/c:".length === 3
            }
        }
        // encode the rest of the path
        res += encoder(path, true);
    }
    if (query) {
        res += '?';
        res += encoder(query, false);
    }
    if (fragment) {
        res += '#';
        res += !skipEncoding ? vscode_uri_encodeURIComponentFast(fragment, false) : fragment;
    }
    return res;
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/vscode-json-languageservice/lib/esm/utils/strings.js
/*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/
function strings_startsWith(haystack, needle) {
    if (haystack.length < needle.length) {
        return false;
    }
    for (var i = 0; i < needle.length; i++) {
        if (haystack[i] !== needle[i]) {
            return false;
        }
    }
    return true;
}
/**
 * Determines if haystack ends with needle.
 */
function strings_endsWith(haystack, needle) {
    var diff = haystack.length - needle.length;
    if (diff > 0) {
        return haystack.lastIndexOf(needle) === diff;
    }
    else if (diff === 0) {
        return haystack === needle;
    }
    else {
        return false;
    }
}
function strings_convertSimple2RegExpPattern(pattern) {
    return pattern.replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&').replace(/[\*]/g, '.*');
}
function strings_repeat(value, count) {
    var s = '';
    while (count > 0) {
        if ((count & 1) === 1) {
            s += value;
        }
        value += value;
        count = count >>> 1;
    }
    return s;
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/vscode-json-languageservice/lib/esm/utils/objects.js
/*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/
function objects_equals(one, other) {
    if (one === other) {
        return true;
    }
    if (one === null || one === undefined || other === null || other === undefined) {
        return false;
    }
    if (typeof one !== typeof other) {
        return false;
    }
    if (typeof one !== 'object') {
        return false;
    }
    if ((Array.isArray(one)) !== (Array.isArray(other))) {
        return false;
    }
    var i, key;
    if (Array.isArray(one)) {
        if (one.length !== other.length) {
            return false;
        }
        for (i = 0; i < one.length; i++) {
            if (!objects_equals(one[i], other[i])) {
                return false;
            }
        }
    }
    else {
        var oneKeys = [];
        for (key in one) {
            oneKeys.push(key);
        }
        oneKeys.sort();
        var otherKeys = [];
        for (key in other) {
            otherKeys.push(key);
        }
        otherKeys.sort();
        if (!objects_equals(oneKeys, otherKeys)) {
            return false;
        }
        for (i = 0; i < oneKeys.length; i++) {
            if (!objects_equals(one[oneKeys[i]], other[oneKeys[i]])) {
                return false;
            }
        }
    }
    return true;
}
function objects_isNumber(val) {
    return typeof val === 'number';
}
function isDefined(val) {
    return typeof val !== 'undefined';
}
function objects_isBoolean(val) {
    return typeof val === 'boolean';
}
function objects_isString(val) {
    return typeof val === 'string';
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/vscode-json-languageservice/_deps/vscode-languageserver-types/main.js
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

/**
 * The Position namespace provides helper functions to work with
 * [Position](#Position) literals.
 */
var vscode_languageserver_types_main_Position;
(function (Position) {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */
    function create(line, character) {
        return { line: line, character: character };
    }
    Position.create = create;
    /**
     * Checks whether the given liternal conforms to the [Position](#Position) interface.
     */
    function is(value) {
        var candidate = value;
        return main_Is.objectLiteral(candidate) && main_Is.number(candidate.line) && main_Is.number(candidate.character);
    }
    Position.is = is;
})(vscode_languageserver_types_main_Position || (vscode_languageserver_types_main_Position = {}));
/**
 * The Range namespace provides helper functions to work with
 * [Range](#Range) literals.
 */
var vscode_languageserver_types_main_Range;
(function (Range) {
    function create(one, two, three, four) {
        if (main_Is.number(one) && main_Is.number(two) && main_Is.number(three) && main_Is.number(four)) {
            return { start: vscode_languageserver_types_main_Position.create(one, two), end: vscode_languageserver_types_main_Position.create(three, four) };
        }
        else if (vscode_languageserver_types_main_Position.is(one) && vscode_languageserver_types_main_Position.is(two)) {
            return { start: one, end: two };
        }
        else {
            throw new Error("Range#create called with invalid arguments[" + one + ", " + two + ", " + three + ", " + four + "]");
        }
    }
    Range.create = create;
    /**
     * Checks whether the given literal conforms to the [Range](#Range) interface.
     */
    function is(value) {
        var candidate = value;
        return main_Is.objectLiteral(candidate) && vscode_languageserver_types_main_Position.is(candidate.start) && vscode_languageserver_types_main_Position.is(candidate.end);
    }
    Range.is = is;
})(vscode_languageserver_types_main_Range || (vscode_languageserver_types_main_Range = {}));
/**
 * The Location namespace provides helper functions to work with
 * [Location](#Location) literals.
 */
var main_Location;
(function (Location) {
    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */
    function create(uri, range) {
        return { uri: uri, range: range };
    }
    Location.create = create;
    /**
     * Checks whether the given literal conforms to the [Location](#Location) interface.
     */
    function is(value) {
        var candidate = value;
        return main_Is.defined(candidate) && vscode_languageserver_types_main_Range.is(candidate.range) && (main_Is.string(candidate.uri) || main_Is.undefined(candidate.uri));
    }
    Location.is = is;
})(main_Location || (main_Location = {}));
/**
 * The LocationLink namespace provides helper functions to work with
 * [LocationLink](#LocationLink) literals.
 */
var LocationLink;
(function (LocationLink) {
    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */
    function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return { targetUri: targetUri, targetRange: targetRange, targetSelectionRange: targetSelectionRange, originSelectionRange: originSelectionRange };
    }
    LocationLink.create = create;
    /**
     * Checks whether the given literal conforms to the [LocationLink](#LocationLink) interface.
     */
    function is(value) {
        var candidate = value;
        return main_Is.defined(candidate) && vscode_languageserver_types_main_Range.is(candidate.targetRange) && main_Is.string(candidate.targetUri)
            && (vscode_languageserver_types_main_Range.is(candidate.targetSelectionRange) || main_Is.undefined(candidate.targetSelectionRange))
            && (vscode_languageserver_types_main_Range.is(candidate.originSelectionRange) || main_Is.undefined(candidate.originSelectionRange));
    }
    LocationLink.is = is;
})(LocationLink || (LocationLink = {}));
/**
 * The Color namespace provides helper functions to work with
 * [Color](#Color) literals.
 */
var main_Color;
(function (Color) {
    /**
     * Creates a new Color literal.
     */
    function create(red, green, blue, alpha) {
        return {
            red: red,
            green: green,
            blue: blue,
            alpha: alpha,
        };
    }
    Color.create = create;
    /**
     * Checks whether the given literal conforms to the [Color](#Color) interface.
     */
    function is(value) {
        var candidate = value;
        return main_Is.number(candidate.red)
            && main_Is.number(candidate.green)
            && main_Is.number(candidate.blue)
            && main_Is.number(candidate.alpha);
    }
    Color.is = is;
})(main_Color || (main_Color = {}));
/**
 * The ColorInformation namespace provides helper functions to work with
 * [ColorInformation](#ColorInformation) literals.
 */
var main_ColorInformation;
(function (ColorInformation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(range, color) {
        return {
            range: range,
            color: color,
        };
    }
    ColorInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return vscode_languageserver_types_main_Range.is(candidate.range) && main_Color.is(candidate.color);
    }
    ColorInformation.is = is;
})(main_ColorInformation || (main_ColorInformation = {}));
/**
 * The Color namespace provides helper functions to work with
 * [ColorPresentation](#ColorPresentation) literals.
 */
var main_ColorPresentation;
(function (ColorPresentation) {
    /**
     * Creates a new ColorInformation literal.
     */
    function create(label, textEdit, additionalTextEdits) {
        return {
            label: label,
            textEdit: textEdit,
            additionalTextEdits: additionalTextEdits,
        };
    }
    ColorPresentation.create = create;
    /**
     * Checks whether the given literal conforms to the [ColorInformation](#ColorInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return main_Is.string(candidate.label)
            && (main_Is.undefined(candidate.textEdit) || main_TextEdit.is(candidate))
            && (main_Is.undefined(candidate.additionalTextEdits) || main_Is.typedArray(candidate.additionalTextEdits, main_TextEdit.is));
    }
    ColorPresentation.is = is;
})(main_ColorPresentation || (main_ColorPresentation = {}));
/**
 * Enum of known range kinds
 */
var main_FoldingRangeKind;
(function (FoldingRangeKind) {
    /**
     * Folding range for a comment
     */
    FoldingRangeKind["Comment"] = "comment";
    /**
     * Folding range for a imports or includes
     */
    FoldingRangeKind["Imports"] = "imports";
    /**
     * Folding range for a region (e.g. `#region`)
     */
    FoldingRangeKind["Region"] = "region";
})(main_FoldingRangeKind || (main_FoldingRangeKind = {}));
/**
 * The folding range namespace provides helper functions to work with
 * [FoldingRange](#FoldingRange) literals.
 */
var main_FoldingRange;
(function (FoldingRange) {
    /**
     * Creates a new FoldingRange literal.
     */
    function create(startLine, endLine, startCharacter, endCharacter, kind) {
        var result = {
            startLine: startLine,
            endLine: endLine
        };
        if (main_Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
        }
        if (main_Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
        }
        if (main_Is.defined(kind)) {
            result.kind = kind;
        }
        return result;
    }
    FoldingRange.create = create;
    /**
     * Checks whether the given literal conforms to the [FoldingRange](#FoldingRange) interface.
     */
    function is(value) {
        var candidate = value;
        return main_Is.number(candidate.startLine) && main_Is.number(candidate.startLine)
            && (main_Is.undefined(candidate.startCharacter) || main_Is.number(candidate.startCharacter))
            && (main_Is.undefined(candidate.endCharacter) || main_Is.number(candidate.endCharacter))
            && (main_Is.undefined(candidate.kind) || main_Is.string(candidate.kind));
    }
    FoldingRange.is = is;
})(main_FoldingRange || (main_FoldingRange = {}));
/**
 * The DiagnosticRelatedInformation namespace provides helper functions to work with
 * [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) literals.
 */
var main_DiagnosticRelatedInformation;
(function (DiagnosticRelatedInformation) {
    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */
    function create(location, message) {
        return {
            location: location,
            message: message
        };
    }
    DiagnosticRelatedInformation.create = create;
    /**
     * Checks whether the given literal conforms to the [DiagnosticRelatedInformation](#DiagnosticRelatedInformation) interface.
     */
    function is(value) {
        var candidate = value;
        return main_Is.defined(candidate) && main_Location.is(candidate.location) && main_Is.string(candidate.message);
    }
    DiagnosticRelatedInformation.is = is;
})(main_DiagnosticRelatedInformation || (main_DiagnosticRelatedInformation = {}));
/**
 * The diagnostic's severity.
 */
var main_DiagnosticSeverity;
(function (DiagnosticSeverity) {
    /**
     * Reports an error.
     */
    DiagnosticSeverity.Error = 1;
    /**
     * Reports a warning.
     */
    DiagnosticSeverity.Warning = 2;
    /**
     * Reports an information.
     */
    DiagnosticSeverity.Information = 3;
    /**
     * Reports a hint.
     */
    DiagnosticSeverity.Hint = 4;
})(main_DiagnosticSeverity || (main_DiagnosticSeverity = {}));
/**
 * The diagnostic tags.
 *
 * @since 3.15.0
 */
var DiagnosticTag;
(function (DiagnosticTag) {
    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */
    DiagnosticTag.Unnecessary = 1;
    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */
    DiagnosticTag.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
/**
 * The Diagnostic namespace provides helper functions to work with
 * [Diagnostic](#Diagnostic) literals.
 */
var main_Diagnostic;
(function (Diagnostic) {
    /**
     * Creates a new Diagnostic literal.
     */
    function create(range, message, severity, code, source, relatedInformation) {
        var result = { range: range, message: message };
        if (main_Is.defined(severity)) {
            result.severity = severity;
        }
        if (main_Is.defined(code)) {
            result.code = code;
        }
        if (main_Is.defined(source)) {
            result.source = source;
        }
        if (main_Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
        }
        return result;
    }
    Diagnostic.create = create;
    /**
     * Checks whether the given literal conforms to the [Diagnostic](#Diagnostic) interface.
     */
    function is(value) {
        var candidate = value;
        return main_Is.defined(candidate)
            && vscode_languageserver_types_main_Range.is(candidate.range)
            && main_Is.string(candidate.message)
            && (main_Is.number(candidate.severity) || main_Is.undefined(candidate.severity))
            && (main_Is.number(candidate.code) || main_Is.string(candidate.code) || main_Is.undefined(candidate.code))
            && (main_Is.string(candidate.source) || main_Is.undefined(candidate.source))
            && (main_Is.undefined(candidate.relatedInformation) || main_Is.typedArray(candidate.relatedInformation, main_DiagnosticRelatedInformation.is));
    }
    Diagnostic.is = is;
})(main_Diagnostic || (main_Diagnostic = {}));
/**
 * The Command namespace provides helper functions to work with
 * [Command](#Command) literals.
 */
var main_Command;
(function (Command) {
    /**
     * Creates a new Command literal.
     */
    function create(title, command) {
        var args = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            args[_i - 2] = arguments[_i];
        }
        var result = { title: title, command: command };
        if (main_Is.defined(args) && args.length > 0) {
            result.arguments = args;
        }
        return result;
    }
    Command.create = create;
    /**
     * Checks whether the given literal conforms to the [Command](#Command) interface.
     */
    function is(value) {
        var candidate = value;
        return main_Is.defined(candidate) && main_Is.string(candidate.title) && main_Is.string(candidate.command);
    }
    Command.is = is;
})(main_Command || (main_Command = {}));
/**
 * The TextEdit namespace provides helper function to create replace,
 * insert and delete edits more easily.
 */
var main_TextEdit;
(function (TextEdit) {
    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */
    function replace(range, newText) {
        return { range: range, newText: newText };
    }
    TextEdit.replace = replace;
    /**
     * Creates a insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */
    function insert(position, newText) {
        return { range: { start: position, end: position }, newText: newText };
    }
    TextEdit.insert = insert;
    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */
    function del(range) {
        return { range: range, newText: '' };
    }
    TextEdit.del = del;
    function is(value) {
        var candidate = value;
        return main_Is.objectLiteral(candidate)
            && main_Is.string(candidate.newText)
            && vscode_languageserver_types_main_Range.is(candidate.range);
    }
    TextEdit.is = is;
})(main_TextEdit || (main_TextEdit = {}));
/**
 * The TextDocumentEdit namespace provides helper function to create
 * an edit that manipulates a text document.
 */
var main_TextDocumentEdit;
(function (TextDocumentEdit) {
    /**
     * Creates a new `TextDocumentEdit`
     */
    function create(textDocument, edits) {
        return { textDocument: textDocument, edits: edits };
    }
    TextDocumentEdit.create = create;
    function is(value) {
        var candidate = value;
        return main_Is.defined(candidate)
            && main_VersionedTextDocumentIdentifier.is(candidate.textDocument)
            && Array.isArray(candidate.edits);
    }
    TextDocumentEdit.is = is;
})(main_TextDocumentEdit || (main_TextDocumentEdit = {}));
var CreateFile;
(function (CreateFile) {
    function create(uri, options) {
        var result = {
            kind: 'create',
            uri: uri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
        }
        return result;
    }
    CreateFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'create' && main_Is.string(candidate.uri) &&
            (candidate.options === void 0 ||
                ((candidate.options.overwrite === void 0 || main_Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || main_Is.boolean(candidate.options.ignoreIfExists))));
    }
    CreateFile.is = is;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function (RenameFile) {
    function create(oldUri, newUri, options) {
        var result = {
            kind: 'rename',
            oldUri: oldUri,
            newUri: newUri
        };
        if (options !== void 0 && (options.overwrite !== void 0 || options.ignoreIfExists !== void 0)) {
            result.options = options;
        }
        return result;
    }
    RenameFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'rename' && main_Is.string(candidate.oldUri) && main_Is.string(candidate.newUri) &&
            (candidate.options === void 0 ||
                ((candidate.options.overwrite === void 0 || main_Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === void 0 || main_Is.boolean(candidate.options.ignoreIfExists))));
    }
    RenameFile.is = is;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function (DeleteFile) {
    function create(uri, options) {
        var result = {
            kind: 'delete',
            uri: uri
        };
        if (options !== void 0 && (options.recursive !== void 0 || options.ignoreIfNotExists !== void 0)) {
            result.options = options;
        }
        return result;
    }
    DeleteFile.create = create;
    function is(value) {
        var candidate = value;
        return candidate && candidate.kind === 'delete' && main_Is.string(candidate.uri) &&
            (candidate.options === void 0 ||
                ((candidate.options.recursive === void 0 || main_Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === void 0 || main_Is.boolean(candidate.options.ignoreIfNotExists))));
    }
    DeleteFile.is = is;
})(DeleteFile || (DeleteFile = {}));
var main_WorkspaceEdit;
(function (WorkspaceEdit) {
    function is(value) {
        var candidate = value;
        return candidate &&
            (candidate.changes !== void 0 || candidate.documentChanges !== void 0) &&
            (candidate.documentChanges === void 0 || candidate.documentChanges.every(function (change) {
                if (main_Is.string(change.kind)) {
                    return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
                }
                else {
                    return main_TextDocumentEdit.is(change);
                }
            }));
    }
    WorkspaceEdit.is = is;
})(main_WorkspaceEdit || (main_WorkspaceEdit = {}));
var main_TextEditChangeImpl = /** @class */ (function () {
    function TextEditChangeImpl(edits) {
        this.edits = edits;
    }
    TextEditChangeImpl.prototype.insert = function (position, newText) {
        this.edits.push(main_TextEdit.insert(position, newText));
    };
    TextEditChangeImpl.prototype.replace = function (range, newText) {
        this.edits.push(main_TextEdit.replace(range, newText));
    };
    TextEditChangeImpl.prototype.delete = function (range) {
        this.edits.push(main_TextEdit.del(range));
    };
    TextEditChangeImpl.prototype.add = function (edit) {
        this.edits.push(edit);
    };
    TextEditChangeImpl.prototype.all = function () {
        return this.edits;
    };
    TextEditChangeImpl.prototype.clear = function () {
        this.edits.splice(0, this.edits.length);
    };
    return TextEditChangeImpl;
}());
/**
 * A workspace change helps constructing changes to a workspace.
 */
var main_WorkspaceChange = /** @class */ (function () {
    function WorkspaceChange(workspaceEdit) {
        var _this = this;
        this._textEditChanges = Object.create(null);
        if (workspaceEdit) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
                workspaceEdit.documentChanges.forEach(function (change) {
                    if (main_TextDocumentEdit.is(change)) {
                        var textEditChange = new main_TextEditChangeImpl(change.edits);
                        _this._textEditChanges[change.textDocument.uri] = textEditChange;
                    }
                });
            }
            else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach(function (key) {
                    var textEditChange = new main_TextEditChangeImpl(workspaceEdit.changes[key]);
                    _this._textEditChanges[key] = textEditChange;
                });
            }
        }
    }
    Object.defineProperty(WorkspaceChange.prototype, "edit", {
        /**
         * Returns the underlying [WorkspaceEdit](#WorkspaceEdit) literal
         * use to be returned from a workspace edit operation like rename.
         */
        get: function () {
            return this._workspaceEdit;
        },
        enumerable: true,
        configurable: true
    });
    WorkspaceChange.prototype.getTextEditChange = function (key) {
        if (main_VersionedTextDocumentIdentifier.is(key)) {
            if (!this._workspaceEdit) {
                this._workspaceEdit = {
                    documentChanges: []
                };
            }
            if (!this._workspaceEdit.documentChanges) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            var textDocument = key;
            var result = this._textEditChanges[textDocument.uri];
            if (!result) {
                var edits = [];
                var textDocumentEdit = {
                    textDocument: textDocument,
                    edits: edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new main_TextEditChangeImpl(edits);
                this._textEditChanges[textDocument.uri] = result;
            }
            return result;
        }
        else {
            if (!this._workspaceEdit) {
                this._workspaceEdit = {
                    changes: Object.create(null)
                };
            }
            if (!this._workspaceEdit.changes) {
                throw new Error('Workspace edit is not configured for normal text edit changes.');
            }
            var result = this._textEditChanges[key];
            if (!result) {
                var edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new main_TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
            }
            return result;
        }
    };
    WorkspaceChange.prototype.createFile = function (uri, options) {
        this.checkDocumentChanges();
        this._workspaceEdit.documentChanges.push(CreateFile.create(uri, options));
    };
    WorkspaceChange.prototype.renameFile = function (oldUri, newUri, options) {
        this.checkDocumentChanges();
        this._workspaceEdit.documentChanges.push(RenameFile.create(oldUri, newUri, options));
    };
    WorkspaceChange.prototype.deleteFile = function (uri, options) {
        this.checkDocumentChanges();
        this._workspaceEdit.documentChanges.push(DeleteFile.create(uri, options));
    };
    WorkspaceChange.prototype.checkDocumentChanges = function () {
        if (!this._workspaceEdit || !this._workspaceEdit.documentChanges) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
    };
    return WorkspaceChange;
}());

/**
 * The TextDocumentIdentifier namespace provides helper functions to work with
 * [TextDocumentIdentifier](#TextDocumentIdentifier) literals.
 */
var main_TextDocumentIdentifier;
(function (TextDocumentIdentifier) {
    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */
    function create(uri) {
        return { uri: uri };
    }
    TextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentIdentifier](#TextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return main_Is.defined(candidate) && main_Is.string(candidate.uri);
    }
    TextDocumentIdentifier.is = is;
})(main_TextDocumentIdentifier || (main_TextDocumentIdentifier = {}));
/**
 * The VersionedTextDocumentIdentifier namespace provides helper functions to work with
 * [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) literals.
 */
var main_VersionedTextDocumentIdentifier;
(function (VersionedTextDocumentIdentifier) {
    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param uri The document's text.
     */
    function create(uri, version) {
        return { uri: uri, version: version };
    }
    VersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the [VersionedTextDocumentIdentifier](#VersionedTextDocumentIdentifier) interface.
     */
    function is(value) {
        var candidate = value;
        return main_Is.defined(candidate) && main_Is.string(candidate.uri) && (candidate.version === null || main_Is.number(candidate.version));
    }
    VersionedTextDocumentIdentifier.is = is;
})(main_VersionedTextDocumentIdentifier || (main_VersionedTextDocumentIdentifier = {}));
/**
 * The TextDocumentItem namespace provides helper functions to work with
 * [TextDocumentItem](#TextDocumentItem) literals.
 */
var main_TextDocumentItem;
(function (TextDocumentItem) {
    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */
    function create(uri, languageId, version, text) {
        return { uri: uri, languageId: languageId, version: version, text: text };
    }
    TextDocumentItem.create = create;
    /**
     * Checks whether the given literal conforms to the [TextDocumentItem](#TextDocumentItem) interface.
     */
    function is(value) {
        var candidate = value;
        return main_Is.defined(candidate) && main_Is.string(candidate.uri) && main_Is.string(candidate.languageId) && main_Is.number(candidate.version) && main_Is.string(candidate.text);
    }
    TextDocumentItem.is = is;
})(main_TextDocumentItem || (main_TextDocumentItem = {}));
/**
 * Describes the content type that a client supports in various
 * result literals like `Hover`, `ParameterInfo` or `CompletionItem`.
 *
 * Please note that `MarkupKinds` must not start with a `$`. This kinds
 * are reserved for internal usage.
 */
var main_MarkupKind;
(function (MarkupKind) {
    /**
     * Plain text is supported as a content format
     */
    MarkupKind.PlainText = 'plaintext';
    /**
     * Markdown is supported as a content format
     */
    MarkupKind.Markdown = 'markdown';
})(main_MarkupKind || (main_MarkupKind = {}));
(function (MarkupKind) {
    /**
     * Checks whether the given value is a value of the [MarkupKind](#MarkupKind) type.
     */
    function is(value) {
        var candidate = value;
        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
    }
    MarkupKind.is = is;
})(main_MarkupKind || (main_MarkupKind = {}));
var main_MarkupContent;
(function (MarkupContent) {
    /**
     * Checks whether the given value conforms to the [MarkupContent](#MarkupContent) interface.
     */
    function is(value) {
        var candidate = value;
        return main_Is.objectLiteral(value) && main_MarkupKind.is(candidate.kind) && main_Is.string(candidate.value);
    }
    MarkupContent.is = is;
})(main_MarkupContent || (main_MarkupContent = {}));
/**
 * The kind of a completion entry.
 */
var vscode_languageserver_types_main_CompletionItemKind;
(function (CompletionItemKind) {
    CompletionItemKind.Text = 1;
    CompletionItemKind.Method = 2;
    CompletionItemKind.Function = 3;
    CompletionItemKind.Constructor = 4;
    CompletionItemKind.Field = 5;
    CompletionItemKind.Variable = 6;
    CompletionItemKind.Class = 7;
    CompletionItemKind.Interface = 8;
    CompletionItemKind.Module = 9;
    CompletionItemKind.Property = 10;
    CompletionItemKind.Unit = 11;
    CompletionItemKind.Value = 12;
    CompletionItemKind.Enum = 13;
    CompletionItemKind.Keyword = 14;
    CompletionItemKind.Snippet = 15;
    CompletionItemKind.Color = 16;
    CompletionItemKind.File = 17;
    CompletionItemKind.Reference = 18;
    CompletionItemKind.Folder = 19;
    CompletionItemKind.EnumMember = 20;
    CompletionItemKind.Constant = 21;
    CompletionItemKind.Struct = 22;
    CompletionItemKind.Event = 23;
    CompletionItemKind.Operator = 24;
    CompletionItemKind.TypeParameter = 25;
})(vscode_languageserver_types_main_CompletionItemKind || (vscode_languageserver_types_main_CompletionItemKind = {}));
/**
 * Defines whether the insert text in a completion item should be interpreted as
 * plain text or a snippet.
 */
var main_InsertTextFormat;
(function (InsertTextFormat) {
    /**
     * The primary text to be inserted is treated as a plain string.
     */
    InsertTextFormat.PlainText = 1;
    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://github.com/Microsoft/vscode/blob/master/src/vs/editor/contrib/snippet/common/snippet.md
     */
    InsertTextFormat.Snippet = 2;
})(main_InsertTextFormat || (main_InsertTextFormat = {}));
/**
 * Completion item tags are extra annotations that tweak the rendering of a completion
 * item.
 *
 * @since 3.15.0
 */
var main_CompletionItemTag;
(function (CompletionItemTag) {
    /**
     * Render a completion as obsolete, usually using a strike-out.
     */
    CompletionItemTag.Deprecated = 1;
})(main_CompletionItemTag || (main_CompletionItemTag = {}));
/**
 * The CompletionItem namespace provides functions to deal with
 * completion items.
 */
var main_CompletionItem;
(function (CompletionItem) {
    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */
    function create(label) {
        return { label: label };
    }
    CompletionItem.create = create;
})(main_CompletionItem || (main_CompletionItem = {}));
/**
 * The CompletionList namespace provides functions to deal with
 * completion lists.
 */
var main_CompletionList;
(function (CompletionList) {
    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */
    function create(items, isIncomplete) {
        return { items: items ? items : [], isIncomplete: !!isIncomplete };
    }
    CompletionList.create = create;
})(main_CompletionList || (main_CompletionList = {}));
var main_MarkedString;
(function (MarkedString) {
    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */
    function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
    }
    MarkedString.fromPlainText = fromPlainText;
    /**
     * Checks whether the given value conforms to the [MarkedString](#MarkedString) type.
     */
    function is(value) {
        var candidate = value;
        return main_Is.string(candidate) || (main_Is.objectLiteral(candidate) && main_Is.string(candidate.language) && main_Is.string(candidate.value));
    }
    MarkedString.is = is;
})(main_MarkedString || (main_MarkedString = {}));
var main_Hover;
(function (Hover) {
    /**
     * Checks whether the given value conforms to the [Hover](#Hover) interface.
     */
    function is(value) {
        var candidate = value;
        return !!candidate && main_Is.objectLiteral(candidate) && (main_MarkupContent.is(candidate.contents) ||
            main_MarkedString.is(candidate.contents) ||
            main_Is.typedArray(candidate.contents, main_MarkedString.is)) && (value.range === void 0 || vscode_languageserver_types_main_Range.is(value.range));
    }
    Hover.is = is;
})(main_Hover || (main_Hover = {}));
/**
 * The ParameterInformation namespace provides helper functions to work with
 * [ParameterInformation](#ParameterInformation) literals.
 */
var main_ParameterInformation;
(function (ParameterInformation) {
    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */
    function create(label, documentation) {
        return documentation ? { label: label, documentation: documentation } : { label: label };
    }
    ParameterInformation.create = create;
})(main_ParameterInformation || (main_ParameterInformation = {}));
/**
 * The SignatureInformation namespace provides helper functions to work with
 * [SignatureInformation](#SignatureInformation) literals.
 */
var main_SignatureInformation;
(function (SignatureInformation) {
    function create(label, documentation) {
        var parameters = [];
        for (var _i = 2; _i < arguments.length; _i++) {
            parameters[_i - 2] = arguments[_i];
        }
        var result = { label: label };
        if (main_Is.defined(documentation)) {
            result.documentation = documentation;
        }
        if (main_Is.defined(parameters)) {
            result.parameters = parameters;
        }
        else {
            result.parameters = [];
        }
        return result;
    }
    SignatureInformation.create = create;
})(main_SignatureInformation || (main_SignatureInformation = {}));
/**
 * A document highlight kind.
 */
var vscode_languageserver_types_main_DocumentHighlightKind;
(function (DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */
    DocumentHighlightKind.Text = 1;
    /**
     * Read-access of a symbol, like reading a variable.
     */
    DocumentHighlightKind.Read = 2;
    /**
     * Write-access of a symbol, like writing to a variable.
     */
    DocumentHighlightKind.Write = 3;
})(vscode_languageserver_types_main_DocumentHighlightKind || (vscode_languageserver_types_main_DocumentHighlightKind = {}));
/**
 * DocumentHighlight namespace to provide helper functions to work with
 * [DocumentHighlight](#DocumentHighlight) literals.
 */
var main_DocumentHighlight;
(function (DocumentHighlight) {
    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     */
    function create(range, kind) {
        var result = { range: range };
        if (main_Is.number(kind)) {
            result.kind = kind;
        }
        return result;
    }
    DocumentHighlight.create = create;
})(main_DocumentHighlight || (main_DocumentHighlight = {}));
/**
 * A symbol kind.
 */
var vscode_languageserver_types_main_SymbolKind;
(function (SymbolKind) {
    SymbolKind.File = 1;
    SymbolKind.Module = 2;
    SymbolKind.Namespace = 3;
    SymbolKind.Package = 4;
    SymbolKind.Class = 5;
    SymbolKind.Method = 6;
    SymbolKind.Property = 7;
    SymbolKind.Field = 8;
    SymbolKind.Constructor = 9;
    SymbolKind.Enum = 10;
    SymbolKind.Interface = 11;
    SymbolKind.Function = 12;
    SymbolKind.Variable = 13;
    SymbolKind.Constant = 14;
    SymbolKind.String = 15;
    SymbolKind.Number = 16;
    SymbolKind.Boolean = 17;
    SymbolKind.Array = 18;
    SymbolKind.Object = 19;
    SymbolKind.Key = 20;
    SymbolKind.Null = 21;
    SymbolKind.EnumMember = 22;
    SymbolKind.Struct = 23;
    SymbolKind.Event = 24;
    SymbolKind.Operator = 25;
    SymbolKind.TypeParameter = 26;
})(vscode_languageserver_types_main_SymbolKind || (vscode_languageserver_types_main_SymbolKind = {}));
/**
 * Symbol tags are extra annotations that tweak the rendering of a symbol.
 * @since 3.15
 */
var main_SymbolTag;
(function (SymbolTag) {
    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */
    SymbolTag.Deprecated = 1;
})(main_SymbolTag || (main_SymbolTag = {}));
var main_SymbolInformation;
(function (SymbolInformation) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol, defaults to the current document.
     * @param containerName The name of the symbol containing the symbol.
     */
    function create(name, kind, range, uri, containerName) {
        var result = {
            name: name,
            kind: kind,
            location: { uri: uri, range: range }
        };
        if (containerName) {
            result.containerName = containerName;
        }
        return result;
    }
    SymbolInformation.create = create;
})(main_SymbolInformation || (main_SymbolInformation = {}));
var main_DocumentSymbol;
(function (DocumentSymbol) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */
    function create(name, detail, kind, range, selectionRange, children) {
        var result = {
            name: name,
            detail: detail,
            kind: kind,
            range: range,
            selectionRange: selectionRange
        };
        if (children !== void 0) {
            result.children = children;
        }
        return result;
    }
    DocumentSymbol.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentSymbol](#DocumentSymbol) interface.
     */
    function is(value) {
        var candidate = value;
        return candidate &&
            main_Is.string(candidate.name) && main_Is.number(candidate.kind) &&
            vscode_languageserver_types_main_Range.is(candidate.range) && vscode_languageserver_types_main_Range.is(candidate.selectionRange) &&
            (candidate.detail === void 0 || main_Is.string(candidate.detail)) &&
            (candidate.deprecated === void 0 || main_Is.boolean(candidate.deprecated)) &&
            (candidate.children === void 0 || Array.isArray(candidate.children));
    }
    DocumentSymbol.is = is;
})(main_DocumentSymbol || (main_DocumentSymbol = {}));
/**
 * A set of predefined code action kinds
 */
var main_CodeActionKind;
(function (CodeActionKind) {
    /**
     * Empty kind.
     */
    CodeActionKind.Empty = '';
    /**
     * Base kind for quickfix actions: 'quickfix'
     */
    CodeActionKind.QuickFix = 'quickfix';
    /**
     * Base kind for refactoring actions: 'refactor'
     */
    CodeActionKind.Refactor = 'refactor';
    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */
    CodeActionKind.RefactorExtract = 'refactor.extract';
    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */
    CodeActionKind.RefactorInline = 'refactor.inline';
    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */
    CodeActionKind.RefactorRewrite = 'refactor.rewrite';
    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */
    CodeActionKind.Source = 'source';
    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */
    CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */
    CodeActionKind.SourceFixAll = 'source.fixAll';
})(main_CodeActionKind || (main_CodeActionKind = {}));
/**
 * The CodeActionContext namespace provides helper functions to work with
 * [CodeActionContext](#CodeActionContext) literals.
 */
var main_CodeActionContext;
(function (CodeActionContext) {
    /**
     * Creates a new CodeActionContext literal.
     */
    function create(diagnostics, only) {
        var result = { diagnostics: diagnostics };
        if (only !== void 0 && only !== null) {
            result.only = only;
        }
        return result;
    }
    CodeActionContext.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeActionContext](#CodeActionContext) interface.
     */
    function is(value) {
        var candidate = value;
        return main_Is.defined(candidate) && main_Is.typedArray(candidate.diagnostics, main_Diagnostic.is) && (candidate.only === void 0 || main_Is.typedArray(candidate.only, main_Is.string));
    }
    CodeActionContext.is = is;
})(main_CodeActionContext || (main_CodeActionContext = {}));
var main_CodeAction;
(function (CodeAction) {
    function create(title, commandOrEdit, kind) {
        var result = { title: title };
        if (main_Command.is(commandOrEdit)) {
            result.command = commandOrEdit;
        }
        else {
            result.edit = commandOrEdit;
        }
        if (kind !== void 0) {
            result.kind = kind;
        }
        return result;
    }
    CodeAction.create = create;
    function is(value) {
        var candidate = value;
        return candidate && main_Is.string(candidate.title) &&
            (candidate.diagnostics === void 0 || main_Is.typedArray(candidate.diagnostics, main_Diagnostic.is)) &&
            (candidate.kind === void 0 || main_Is.string(candidate.kind)) &&
            (candidate.edit !== void 0 || candidate.command !== void 0) &&
            (candidate.command === void 0 || main_Command.is(candidate.command)) &&
            (candidate.isPreferred === void 0 || main_Is.boolean(candidate.isPreferred)) &&
            (candidate.edit === void 0 || main_WorkspaceEdit.is(candidate.edit));
    }
    CodeAction.is = is;
})(main_CodeAction || (main_CodeAction = {}));
/**
 * The CodeLens namespace provides helper functions to work with
 * [CodeLens](#CodeLens) literals.
 */
var main_CodeLens;
(function (CodeLens) {
    /**
     * Creates a new CodeLens literal.
     */
    function create(range, data) {
        var result = { range: range };
        if (main_Is.defined(data)) {
            result.data = data;
        }
        return result;
    }
    CodeLens.create = create;
    /**
     * Checks whether the given literal conforms to the [CodeLens](#CodeLens) interface.
     */
    function is(value) {
        var candidate = value;
        return main_Is.defined(candidate) && vscode_languageserver_types_main_Range.is(candidate.range) && (main_Is.undefined(candidate.command) || main_Command.is(candidate.command));
    }
    CodeLens.is = is;
})(main_CodeLens || (main_CodeLens = {}));
/**
 * The FormattingOptions namespace provides helper functions to work with
 * [FormattingOptions](#FormattingOptions) literals.
 */
var main_FormattingOptions;
(function (FormattingOptions) {
    /**
     * Creates a new FormattingOptions literal.
     */
    function create(tabSize, insertSpaces) {
        return { tabSize: tabSize, insertSpaces: insertSpaces };
    }
    FormattingOptions.create = create;
    /**
     * Checks whether the given literal conforms to the [FormattingOptions](#FormattingOptions) interface.
     */
    function is(value) {
        var candidate = value;
        return main_Is.defined(candidate) && main_Is.number(candidate.tabSize) && main_Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions.is = is;
})(main_FormattingOptions || (main_FormattingOptions = {}));
/**
 * The DocumentLink namespace provides helper functions to work with
 * [DocumentLink](#DocumentLink) literals.
 */
var main_DocumentLink;
(function (DocumentLink) {
    /**
     * Creates a new DocumentLink literal.
     */
    function create(range, target, data) {
        return { range: range, target: target, data: data };
    }
    DocumentLink.create = create;
    /**
     * Checks whether the given literal conforms to the [DocumentLink](#DocumentLink) interface.
     */
    function is(value) {
        var candidate = value;
        return main_Is.defined(candidate) && vscode_languageserver_types_main_Range.is(candidate.range) && (main_Is.undefined(candidate.target) || main_Is.string(candidate.target));
    }
    DocumentLink.is = is;
})(main_DocumentLink || (main_DocumentLink = {}));
/**
 * The SelectionRange namespace provides helper function to work with
 * SelectionRange literals.
 */
var SelectionRange;
(function (SelectionRange) {
    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */
    function create(range, parent) {
        return { range: range, parent: parent };
    }
    SelectionRange.create = create;
    function is(value) {
        var candidate = value;
        return candidate !== undefined && vscode_languageserver_types_main_Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
    }
    SelectionRange.is = is;
})(SelectionRange || (SelectionRange = {}));
var main_EOL = ['\n', '\r\n', '\r'];
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */
var main_TextDocument;
(function (TextDocument) {
    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new main_FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Checks whether the given literal conforms to the [ITextDocument](#ITextDocument) interface.
     */
    function is(value) {
        var candidate = value;
        return main_Is.defined(candidate) && main_Is.string(candidate.uri) && (main_Is.undefined(candidate.languageId) || main_Is.string(candidate.languageId)) && main_Is.number(candidate.lineCount)
            && main_Is.func(candidate.getText) && main_Is.func(candidate.positionAt) && main_Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument.is = is;
    function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = mergeSort(edits, function (a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            }
            else {
                throw new Error('Overlapping edit');
            }
            lastModifiedOffset = startOffset;
        }
        return text;
    }
    TextDocument.applyEdits = applyEdits;
    function mergeSort(data, compare) {
        if (data.length <= 1) {
            // sorted
            return data;
        }
        var p = (data.length / 2) | 0;
        var left = data.slice(0, p);
        var right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        var leftIdx = 0;
        var rightIdx = 0;
        var i = 0;
        while (leftIdx < left.length && rightIdx < right.length) {
            var ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
                // smaller_equal -> take left to preserve order
                data[i++] = left[leftIdx++];
            }
            else {
                // greater -> take right
                data[i++] = right[rightIdx++];
            }
        }
        while (leftIdx < left.length) {
            data[i++] = left[leftIdx++];
        }
        while (rightIdx < right.length) {
            data[i++] = right[rightIdx++];
        }
        return data;
    }
})(main_TextDocument || (main_TextDocument = {}));
var main_FullTextDocument = /** @class */ (function () {
    function FullTextDocument(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    Object.defineProperty(FullTextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: true,
        configurable: true
    });
    FullTextDocument.prototype.getText = function (range) {
        if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    };
    FullTextDocument.prototype.update = function (event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = undefined;
    };
    FullTextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === undefined) {
            var lineOffsets = [];
            var text = this._content;
            var isLineStart = true;
            for (var i = 0; i < text.length; i++) {
                if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                }
                var ch = text.charAt(i);
                isLineStart = (ch === '\r' || ch === '\n');
                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                    i++;
                }
            }
            if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
    };
    FullTextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return vscode_languageserver_types_main_Position.create(0, offset);
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return vscode_languageserver_types_main_Position.create(line, offset - lineOffsets[line]);
    };
    FullTextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: true,
        configurable: true
    });
    return FullTextDocument;
}());
var main_Is;
(function (Is) {
    var toString = Object.prototype.toString;
    function defined(value) {
        return typeof value !== 'undefined';
    }
    Is.defined = defined;
    function undefined(value) {
        return typeof value === 'undefined';
    }
    Is.undefined = undefined;
    function boolean(value) {
        return value === true || value === false;
    }
    Is.boolean = boolean;
    function string(value) {
        return toString.call(value) === '[object String]';
    }
    Is.string = string;
    function number(value) {
        return toString.call(value) === '[object Number]';
    }
    Is.number = number;
    function func(value) {
        return toString.call(value) === '[object Function]';
    }
    Is.func = func;
    function objectLiteral(value) {
        // Strictly speaking class instances pass this check as well. Since the LSP
        // doesn't use classes we ignore this for now. If we do we need to add something
        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
        return value !== null && typeof value === 'object';
    }
    Is.objectLiteral = objectLiteral;
    function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
    }
    Is.typedArray = typedArray;
})(main_Is || (main_Is = {}));

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/vscode-languageserver-textdocument/lib/esm/main.js
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */

var esm_main_FullTextDocument = /** @class */ (function () {
    function FullTextDocument(uri, languageId, version, content) {
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    Object.defineProperty(FullTextDocument.prototype, "uri", {
        get: function () {
            return this._uri;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "languageId", {
        get: function () {
            return this._languageId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FullTextDocument.prototype, "version", {
        get: function () {
            return this._version;
        },
        enumerable: true,
        configurable: true
    });
    FullTextDocument.prototype.getText = function (range) {
        if (range) {
            var start = this.offsetAt(range.start);
            var end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    };
    FullTextDocument.prototype.update = function (changes, version) {
        for (var _i = 0, changes_1 = changes; _i < changes_1.length; _i++) {
            var change = changes_1[_i];
            if (FullTextDocument.isIncremental(change)) {
                // makes sure start is before end
                var range = getWellformedRange(change.range);
                // update content
                var startOffset = this.offsetAt(range.start);
                var endOffset = this.offsetAt(range.end);
                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                // update the offsets
                var startLine = Math.max(range.start.line, 0);
                var endLine = Math.max(range.end.line, 0);
                var lineOffsets = this._lineOffsets;
                var addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                if (endLine - startLine === addedLineOffsets.length) {
                    for (var i = 0, len = addedLineOffsets.length; i < len; i++) {
                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                    }
                }
                else {
                    if (addedLineOffsets.length < 10000) {
                        lineOffsets.splice.apply(lineOffsets, [startLine + 1, endLine - startLine].concat(addedLineOffsets));
                    }
                    else { // avoid too many arguments for splice
                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                    }
                }
                var diff = change.text.length - (endOffset - startOffset);
                if (diff !== 0) {
                    for (var i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++) {
                        lineOffsets[i] = lineOffsets[i] + diff;
                    }
                }
            }
            else if (FullTextDocument.isFull(change)) {
                this._content = change.text;
                this._lineOffsets = undefined;
            }
            else {
                throw new Error('Unknown change event received');
            }
        }
        this._version = version;
    };
    FullTextDocument.prototype.getLineOffsets = function () {
        if (this._lineOffsets === undefined) {
            this._lineOffsets = computeLineOffsets(this._content, true);
        }
        return this._lineOffsets;
    };
    FullTextDocument.prototype.positionAt = function (offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        var lineOffsets = this.getLineOffsets();
        var low = 0, high = lineOffsets.length;
        if (high === 0) {
            return { line: 0, character: offset };
        }
        while (low < high) {
            var mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            }
            else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        var line = low - 1;
        return { line: line, character: offset - lineOffsets[line] };
    };
    FullTextDocument.prototype.offsetAt = function (position) {
        var lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        }
        else if (position.line < 0) {
            return 0;
        }
        var lineOffset = lineOffsets[position.line];
        var nextLineOffset = (position.line + 1 < lineOffsets.length) ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    };
    Object.defineProperty(FullTextDocument.prototype, "lineCount", {
        get: function () {
            return this.getLineOffsets().length;
        },
        enumerable: true,
        configurable: true
    });
    FullTextDocument.isIncremental = function (event) {
        var candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range !== undefined &&
            (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
    };
    FullTextDocument.isFull = function (event) {
        var candidate = event;
        return candidate !== undefined && candidate !== null &&
            typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
    };
    return FullTextDocument;
}());
var esm_main_TextDocument;
(function (TextDocument) {
    /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */
    function create(uri, languageId, version, content) {
        return new esm_main_FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Updates a TextDocument by modifing its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */
    function update(document, changes, version) {
        if (document instanceof esm_main_FullTextDocument) {
            document.update(changes, version);
            return document;
        }
        else {
            throw new Error('TextDocument.update: document must be created by TextDocument.create');
        }
    }
    TextDocument.update = update;
    function applyEdits(document, edits) {
        var text = document.getText();
        var sortedEdits = main_mergeSort(edits.map(getWellformedEdit), function (a, b) {
            var diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        var lastModifiedOffset = text.length;
        for (var i = sortedEdits.length - 1; i >= 0; i--) {
            var e = sortedEdits[i];
            var startOffset = document.offsetAt(e.range.start);
            var endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            }
            else {
                throw new Error('Overlapping edit');
            }
            lastModifiedOffset = startOffset;
        }
        return text;
    }
    TextDocument.applyEdits = applyEdits;
})(esm_main_TextDocument || (esm_main_TextDocument = {}));
function main_mergeSort(data, compare) {
    if (data.length <= 1) {
        // sorted
        return data;
    }
    var p = (data.length / 2) | 0;
    var left = data.slice(0, p);
    var right = data.slice(p);
    main_mergeSort(left, compare);
    main_mergeSort(right, compare);
    var leftIdx = 0;
    var rightIdx = 0;
    var i = 0;
    while (leftIdx < left.length && rightIdx < right.length) {
        var ret = compare(left[leftIdx], right[rightIdx]);
        if (ret <= 0) {
            // smaller_equal -> take left to preserve order
            data[i++] = left[leftIdx++];
        }
        else {
            // greater -> take right
            data[i++] = right[rightIdx++];
        }
    }
    while (leftIdx < left.length) {
        data[i++] = left[leftIdx++];
    }
    while (rightIdx < right.length) {
        data[i++] = right[rightIdx++];
    }
    return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset) {
    if (textOffset === void 0) { textOffset = 0; }
    var result = isAtLineStart ? [textOffset] : [];
    for (var i = 0; i < text.length; i++) {
        var ch = text.charCodeAt(i);
        if (ch === 13 /* CarriageReturn */ || ch === 10 /* LineFeed */) {
            if (ch === 13 /* CarriageReturn */ && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* LineFeed */) {
                i++;
            }
            result.push(textOffset + i + 1);
        }
    }
    return result;
}
function getWellformedRange(range) {
    var start = range.start;
    var end = range.end;
    if (start.line > end.line || (start.line === end.line && start.character > end.character)) {
        return { start: end, end: start };
    }
    return range;
}
function getWellformedEdit(textEdit) {
    var range = getWellformedRange(textEdit.range);
    if (range !== textEdit.range) {
        return { newText: textEdit.newText, range: range };
    }
    return textEdit;
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/vscode-json-languageservice/lib/esm/jsonLanguageTypes.js



/**
 * Error codes used by diagnostics
 */
var ErrorCode;
(function (ErrorCode) {
    ErrorCode[ErrorCode["Undefined"] = 0] = "Undefined";
    ErrorCode[ErrorCode["EnumValueMismatch"] = 1] = "EnumValueMismatch";
    ErrorCode[ErrorCode["UnexpectedEndOfComment"] = 257] = "UnexpectedEndOfComment";
    ErrorCode[ErrorCode["UnexpectedEndOfString"] = 258] = "UnexpectedEndOfString";
    ErrorCode[ErrorCode["UnexpectedEndOfNumber"] = 259] = "UnexpectedEndOfNumber";
    ErrorCode[ErrorCode["InvalidUnicode"] = 260] = "InvalidUnicode";
    ErrorCode[ErrorCode["InvalidEscapeCharacter"] = 261] = "InvalidEscapeCharacter";
    ErrorCode[ErrorCode["InvalidCharacter"] = 262] = "InvalidCharacter";
    ErrorCode[ErrorCode["PropertyExpected"] = 513] = "PropertyExpected";
    ErrorCode[ErrorCode["CommaExpected"] = 514] = "CommaExpected";
    ErrorCode[ErrorCode["ColonExpected"] = 515] = "ColonExpected";
    ErrorCode[ErrorCode["ValueExpected"] = 516] = "ValueExpected";
    ErrorCode[ErrorCode["CommaOrCloseBacketExpected"] = 517] = "CommaOrCloseBacketExpected";
    ErrorCode[ErrorCode["CommaOrCloseBraceExpected"] = 518] = "CommaOrCloseBraceExpected";
    ErrorCode[ErrorCode["TrailingComma"] = 519] = "TrailingComma";
    ErrorCode[ErrorCode["DuplicateKey"] = 520] = "DuplicateKey";
    ErrorCode[ErrorCode["CommentNotPermitted"] = 521] = "CommentNotPermitted";
    ErrorCode[ErrorCode["SchemaResolveError"] = 768] = "SchemaResolveError";
})(ErrorCode || (ErrorCode = {}));
var jsonLanguageTypes_ClientCapabilities;
(function (ClientCapabilities) {
    ClientCapabilities.LATEST = {
        textDocument: {
            completion: {
                completionItem: {
                    documentationFormat: [main_MarkupKind.Markdown, main_MarkupKind.PlainText],
                    commitCharactersSupport: true
                }
            }
        }
    };
})(jsonLanguageTypes_ClientCapabilities || (jsonLanguageTypes_ClientCapabilities = {}));

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/fillers/vscode-nls.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
function vscode_nls_format(message, args) {
    var result;
    if (args.length === 0) {
        result = message;
    }
    else {
        result = message.replace(/\{(\d+)\}/g, function (match, rest) {
            var index = rest[0];
            return typeof args[index] !== 'undefined' ? args[index] : match;
        });
    }
    return result;
}
function localize(key, message) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    return vscode_nls_format(message, args);
}
function loadMessageBundle(file) {
    return localize;
}
function vscode_nls_config(opt) {
    return loadMessageBundle;
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/vscode-json-languageservice/lib/esm/parser/jsonParser.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var jsonParser_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();




var jsonParser_localize = loadMessageBundle();
var formats = {
    'color-hex': { errorMessage: jsonParser_localize('colorHexFormatWarning', 'Invalid color format. Use #RGB, #RGBA, #RRGGBB or #RRGGBBAA.'), pattern: /^#([0-9A-Fa-f]{3,4}|([0-9A-Fa-f]{2}){3,4})$/ },
    'date-time': { errorMessage: jsonParser_localize('dateTimeFormatWarning', 'String is not a RFC3339 date-time.'), pattern: /^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i },
    'date': { errorMessage: jsonParser_localize('dateFormatWarning', 'String is not a RFC3339 date.'), pattern: /^(\d{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/i },
    'time': { errorMessage: jsonParser_localize('timeFormatWarning', 'String is not a RFC3339 time.'), pattern: /^([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(\.[0-9]+)?(Z|(\+|-)([01][0-9]|2[0-3]):([0-5][0-9]))$/i },
    'email': { errorMessage: jsonParser_localize('emailFormatWarning', 'String is not an e-mail address.'), pattern: /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/ }
};
var ASTNodeImpl = /** @class */ (function () {
    function ASTNodeImpl(parent, offset, length) {
        this.offset = offset;
        this.length = length;
        this.parent = parent;
    }
    Object.defineProperty(ASTNodeImpl.prototype, "children", {
        get: function () {
            return [];
        },
        enumerable: true,
        configurable: true
    });
    ASTNodeImpl.prototype.toString = function () {
        return 'type: ' + this.type + ' (' + this.offset + '/' + this.length + ')' + (this.parent ? ' parent: {' + this.parent.toString() + '}' : '');
    };
    return ASTNodeImpl;
}());

var NullASTNodeImpl = /** @class */ (function (_super) {
    jsonParser_extends(NullASTNodeImpl, _super);
    function NullASTNodeImpl(parent, offset) {
        var _this = _super.call(this, parent, offset) || this;
        _this.type = 'null';
        _this.value = null;
        return _this;
    }
    return NullASTNodeImpl;
}(ASTNodeImpl));

var BooleanASTNodeImpl = /** @class */ (function (_super) {
    jsonParser_extends(BooleanASTNodeImpl, _super);
    function BooleanASTNodeImpl(parent, boolValue, offset) {
        var _this = _super.call(this, parent, offset) || this;
        _this.type = 'boolean';
        _this.value = boolValue;
        return _this;
    }
    return BooleanASTNodeImpl;
}(ASTNodeImpl));

var ArrayASTNodeImpl = /** @class */ (function (_super) {
    jsonParser_extends(ArrayASTNodeImpl, _super);
    function ArrayASTNodeImpl(parent, offset) {
        var _this = _super.call(this, parent, offset) || this;
        _this.type = 'array';
        _this.items = [];
        return _this;
    }
    Object.defineProperty(ArrayASTNodeImpl.prototype, "children", {
        get: function () {
            return this.items;
        },
        enumerable: true,
        configurable: true
    });
    return ArrayASTNodeImpl;
}(ASTNodeImpl));

var NumberASTNodeImpl = /** @class */ (function (_super) {
    jsonParser_extends(NumberASTNodeImpl, _super);
    function NumberASTNodeImpl(parent, offset) {
        var _this = _super.call(this, parent, offset) || this;
        _this.type = 'number';
        _this.isInteger = true;
        _this.value = Number.NaN;
        return _this;
    }
    return NumberASTNodeImpl;
}(ASTNodeImpl));

var StringASTNodeImpl = /** @class */ (function (_super) {
    jsonParser_extends(StringASTNodeImpl, _super);
    function StringASTNodeImpl(parent, offset, length) {
        var _this = _super.call(this, parent, offset, length) || this;
        _this.type = 'string';
        _this.value = '';
        return _this;
    }
    return StringASTNodeImpl;
}(ASTNodeImpl));

var PropertyASTNodeImpl = /** @class */ (function (_super) {
    jsonParser_extends(PropertyASTNodeImpl, _super);
    function PropertyASTNodeImpl(parent, offset) {
        var _this = _super.call(this, parent, offset) || this;
        _this.type = 'property';
        _this.colonOffset = -1;
        return _this;
    }
    Object.defineProperty(PropertyASTNodeImpl.prototype, "children", {
        get: function () {
            return this.valueNode ? [this.keyNode, this.valueNode] : [this.keyNode];
        },
        enumerable: true,
        configurable: true
    });
    return PropertyASTNodeImpl;
}(ASTNodeImpl));

var ObjectASTNodeImpl = /** @class */ (function (_super) {
    jsonParser_extends(ObjectASTNodeImpl, _super);
    function ObjectASTNodeImpl(parent, offset) {
        var _this = _super.call(this, parent, offset) || this;
        _this.type = 'object';
        _this.properties = [];
        return _this;
    }
    Object.defineProperty(ObjectASTNodeImpl.prototype, "children", {
        get: function () {
            return this.properties;
        },
        enumerable: true,
        configurable: true
    });
    return ObjectASTNodeImpl;
}(ASTNodeImpl));

function asSchema(schema) {
    if (objects_isBoolean(schema)) {
        return schema ? {} : { "not": {} };
    }
    return schema;
}
var EnumMatch;
(function (EnumMatch) {
    EnumMatch[EnumMatch["Key"] = 0] = "Key";
    EnumMatch[EnumMatch["Enum"] = 1] = "Enum";
})(EnumMatch || (EnumMatch = {}));
var SchemaCollector = /** @class */ (function () {
    function SchemaCollector(focusOffset, exclude) {
        if (focusOffset === void 0) { focusOffset = -1; }
        if (exclude === void 0) { exclude = null; }
        this.focusOffset = focusOffset;
        this.exclude = exclude;
        this.schemas = [];
    }
    SchemaCollector.prototype.add = function (schema) {
        this.schemas.push(schema);
    };
    SchemaCollector.prototype.merge = function (other) {
        var _a;
        (_a = this.schemas).push.apply(_a, other.schemas);
    };
    SchemaCollector.prototype.include = function (node) {
        return (this.focusOffset === -1 || jsonParser_contains(node, this.focusOffset)) && (node !== this.exclude);
    };
    SchemaCollector.prototype.newSub = function () {
        return new SchemaCollector(-1, this.exclude);
    };
    return SchemaCollector;
}());
var NoOpSchemaCollector = /** @class */ (function () {
    function NoOpSchemaCollector() {
    }
    Object.defineProperty(NoOpSchemaCollector.prototype, "schemas", {
        get: function () { return []; },
        enumerable: true,
        configurable: true
    });
    NoOpSchemaCollector.prototype.add = function (schema) { };
    NoOpSchemaCollector.prototype.merge = function (other) { };
    NoOpSchemaCollector.prototype.include = function (node) { return true; };
    NoOpSchemaCollector.prototype.newSub = function () { return this; };
    NoOpSchemaCollector.instance = new NoOpSchemaCollector();
    return NoOpSchemaCollector;
}());
var jsonParser_ValidationResult = /** @class */ (function () {
    function ValidationResult() {
        this.problems = [];
        this.propertiesMatches = 0;
        this.propertiesValueMatches = 0;
        this.primaryValueMatches = 0;
        this.enumValueMatch = false;
        this.enumValues = null;
    }
    ValidationResult.prototype.hasProblems = function () {
        return !!this.problems.length;
    };
    ValidationResult.prototype.mergeAll = function (validationResults) {
        for (var _i = 0, validationResults_1 = validationResults; _i < validationResults_1.length; _i++) {
            var validationResult = validationResults_1[_i];
            this.merge(validationResult);
        }
    };
    ValidationResult.prototype.merge = function (validationResult) {
        this.problems = this.problems.concat(validationResult.problems);
    };
    ValidationResult.prototype.mergeEnumValues = function (validationResult) {
        if (!this.enumValueMatch && !validationResult.enumValueMatch && this.enumValues && validationResult.enumValues) {
            this.enumValues = this.enumValues.concat(validationResult.enumValues);
            for (var _i = 0, _a = this.problems; _i < _a.length; _i++) {
                var error = _a[_i];
                if (error.code === ErrorCode.EnumValueMismatch) {
                    error.message = jsonParser_localize('enumWarning', 'Value is not accepted. Valid values: {0}.', this.enumValues.map(function (v) { return JSON.stringify(v); }).join(', '));
                }
            }
        }
    };
    ValidationResult.prototype.mergePropertyMatch = function (propertyValidationResult) {
        this.merge(propertyValidationResult);
        this.propertiesMatches++;
        if (propertyValidationResult.enumValueMatch || !propertyValidationResult.hasProblems() && propertyValidationResult.propertiesMatches) {
            this.propertiesValueMatches++;
        }
        if (propertyValidationResult.enumValueMatch && propertyValidationResult.enumValues && propertyValidationResult.enumValues.length === 1) {
            this.primaryValueMatches++;
        }
    };
    ValidationResult.prototype.compare = function (other) {
        var hasProblems = this.hasProblems();
        if (hasProblems !== other.hasProblems()) {
            return hasProblems ? -1 : 1;
        }
        if (this.enumValueMatch !== other.enumValueMatch) {
            return other.enumValueMatch ? -1 : 1;
        }
        if (this.primaryValueMatches !== other.primaryValueMatches) {
            return this.primaryValueMatches - other.primaryValueMatches;
        }
        if (this.propertiesValueMatches !== other.propertiesValueMatches) {
            return this.propertiesValueMatches - other.propertiesValueMatches;
        }
        return this.propertiesMatches - other.propertiesMatches;
    };
    return ValidationResult;
}());

function newJSONDocument(root, diagnostics) {
    if (diagnostics === void 0) { diagnostics = []; }
    return new jsonParser_JSONDocument(root, diagnostics, []);
}
function jsonParser_getNodeValue(node) {
    return main_getNodeValue(node);
}
function jsonParser_getNodePath(node) {
    return main_getNodePath(node);
}
function jsonParser_contains(node, offset, includeRightBound) {
    if (includeRightBound === void 0) { includeRightBound = false; }
    return offset >= node.offset && offset < (node.offset + node.length) || includeRightBound && offset === (node.offset + node.length);
}
var jsonParser_JSONDocument = /** @class */ (function () {
    function JSONDocument(root, syntaxErrors, comments) {
        if (syntaxErrors === void 0) { syntaxErrors = []; }
        if (comments === void 0) { comments = []; }
        this.root = root;
        this.syntaxErrors = syntaxErrors;
        this.comments = comments;
    }
    JSONDocument.prototype.getNodeFromOffset = function (offset, includeRightBound) {
        if (includeRightBound === void 0) { includeRightBound = false; }
        if (this.root) {
            return main_findNodeAtOffset(this.root, offset, includeRightBound);
        }
        return void 0;
    };
    JSONDocument.prototype.visit = function (visitor) {
        if (this.root) {
            var doVisit_1 = function (node) {
                var ctn = visitor(node);
                var children = node.children;
                if (Array.isArray(children)) {
                    for (var i = 0; i < children.length && ctn; i++) {
                        ctn = doVisit_1(children[i]);
                    }
                }
                return ctn;
            };
            doVisit_1(this.root);
        }
    };
    JSONDocument.prototype.validate = function (textDocument, schema) {
        if (this.root && schema) {
            var validationResult = new jsonParser_ValidationResult();
            validate(this.root, schema, validationResult, NoOpSchemaCollector.instance);
            return validationResult.problems.map(function (p) {
                var range = vscode_languageserver_types_main_Range.create(textDocument.positionAt(p.location.offset), textDocument.positionAt(p.location.offset + p.location.length));
                return main_Diagnostic.create(range, p.message, p.severity, p.code);
            });
        }
        return null;
    };
    JSONDocument.prototype.getMatchingSchemas = function (schema, focusOffset, exclude) {
        if (focusOffset === void 0) { focusOffset = -1; }
        if (exclude === void 0) { exclude = null; }
        var matchingSchemas = new SchemaCollector(focusOffset, exclude);
        if (this.root && schema) {
            validate(this.root, schema, new jsonParser_ValidationResult(), matchingSchemas);
        }
        return matchingSchemas.schemas;
    };
    return JSONDocument;
}());

function validate(node, schema, validationResult, matchingSchemas) {
    if (!node || !matchingSchemas.include(node)) {
        return;
    }
    switch (node.type) {
        case 'object':
            _validateObjectNode(node, schema, validationResult, matchingSchemas);
            break;
        case 'array':
            _validateArrayNode(node, schema, validationResult, matchingSchemas);
            break;
        case 'string':
            _validateStringNode(node, schema, validationResult, matchingSchemas);
            break;
        case 'number':
            _validateNumberNode(node, schema, validationResult, matchingSchemas);
            break;
        case 'property':
            return validate(node.valueNode, schema, validationResult, matchingSchemas);
    }
    _validateNode();
    matchingSchemas.add({ node: node, schema: schema });
    function _validateNode() {
        function matchesType(type) {
            return node.type === type || (type === 'integer' && node.type === 'number' && node.isInteger);
        }
        if (Array.isArray(schema.type)) {
            if (!schema.type.some(matchesType)) {
                validationResult.problems.push({
                    location: { offset: node.offset, length: node.length },
                    severity: main_DiagnosticSeverity.Warning,
                    message: schema.errorMessage || jsonParser_localize('typeArrayMismatchWarning', 'Incorrect type. Expected one of {0}.', schema.type.join(', '))
                });
            }
        }
        else if (schema.type) {
            if (!matchesType(schema.type)) {
                validationResult.problems.push({
                    location: { offset: node.offset, length: node.length },
                    severity: main_DiagnosticSeverity.Warning,
                    message: schema.errorMessage || jsonParser_localize('typeMismatchWarning', 'Incorrect type. Expected "{0}".', schema.type)
                });
            }
        }
        if (Array.isArray(schema.allOf)) {
            for (var _i = 0, _a = schema.allOf; _i < _a.length; _i++) {
                var subSchemaRef = _a[_i];
                validate(node, asSchema(subSchemaRef), validationResult, matchingSchemas);
            }
        }
        var notSchema = asSchema(schema.not);
        if (notSchema) {
            var subValidationResult = new jsonParser_ValidationResult();
            var subMatchingSchemas = matchingSchemas.newSub();
            validate(node, notSchema, subValidationResult, subMatchingSchemas);
            if (!subValidationResult.hasProblems()) {
                validationResult.problems.push({
                    location: { offset: node.offset, length: node.length },
                    severity: main_DiagnosticSeverity.Warning,
                    message: jsonParser_localize('notSchemaWarning', "Matches a schema that is not allowed.")
                });
            }
            for (var _b = 0, _c = subMatchingSchemas.schemas; _b < _c.length; _b++) {
                var ms = _c[_b];
                ms.inverted = !ms.inverted;
                matchingSchemas.add(ms);
            }
        }
        var testAlternatives = function (alternatives, maxOneMatch) {
            var matches = [];
            // remember the best match that is used for error messages
            var bestMatch = null;
            for (var _i = 0, alternatives_1 = alternatives; _i < alternatives_1.length; _i++) {
                var subSchemaRef = alternatives_1[_i];
                var subSchema = asSchema(subSchemaRef);
                var subValidationResult = new jsonParser_ValidationResult();
                var subMatchingSchemas = matchingSchemas.newSub();
                validate(node, subSchema, subValidationResult, subMatchingSchemas);
                if (!subValidationResult.hasProblems()) {
                    matches.push(subSchema);
                }
                if (!bestMatch) {
                    bestMatch = { schema: subSchema, validationResult: subValidationResult, matchingSchemas: subMatchingSchemas };
                }
                else {
                    if (!maxOneMatch && !subValidationResult.hasProblems() && !bestMatch.validationResult.hasProblems()) {
                        // no errors, both are equally good matches
                        bestMatch.matchingSchemas.merge(subMatchingSchemas);
                        bestMatch.validationResult.propertiesMatches += subValidationResult.propertiesMatches;
                        bestMatch.validationResult.propertiesValueMatches += subValidationResult.propertiesValueMatches;
                    }
                    else {
                        var compareResult = subValidationResult.compare(bestMatch.validationResult);
                        if (compareResult > 0) {
                            // our node is the best matching so far
                            bestMatch = { schema: subSchema, validationResult: subValidationResult, matchingSchemas: subMatchingSchemas };
                        }
                        else if (compareResult === 0) {
                            // there's already a best matching but we are as good
                            bestMatch.matchingSchemas.merge(subMatchingSchemas);
                            bestMatch.validationResult.mergeEnumValues(subValidationResult);
                        }
                    }
                }
            }
            if (matches.length > 1 && maxOneMatch) {
                validationResult.problems.push({
                    location: { offset: node.offset, length: 1 },
                    severity: main_DiagnosticSeverity.Warning,
                    message: jsonParser_localize('oneOfWarning', "Matches multiple schemas when only one must validate.")
                });
            }
            if (bestMatch !== null) {
                validationResult.merge(bestMatch.validationResult);
                validationResult.propertiesMatches += bestMatch.validationResult.propertiesMatches;
                validationResult.propertiesValueMatches += bestMatch.validationResult.propertiesValueMatches;
                matchingSchemas.merge(bestMatch.matchingSchemas);
            }
            return matches.length;
        };
        if (Array.isArray(schema.anyOf)) {
            testAlternatives(schema.anyOf, false);
        }
        if (Array.isArray(schema.oneOf)) {
            testAlternatives(schema.oneOf, true);
        }
        var testBranch = function (schema) {
            var subValidationResult = new jsonParser_ValidationResult();
            var subMatchingSchemas = matchingSchemas.newSub();
            validate(node, asSchema(schema), subValidationResult, subMatchingSchemas);
            validationResult.merge(subValidationResult);
            validationResult.propertiesMatches += subValidationResult.propertiesMatches;
            validationResult.propertiesValueMatches += subValidationResult.propertiesValueMatches;
            matchingSchemas.merge(subMatchingSchemas);
        };
        var testCondition = function (ifSchema, thenSchema, elseSchema) {
            var subSchema = asSchema(ifSchema);
            var subValidationResult = new jsonParser_ValidationResult();
            var subMatchingSchemas = matchingSchemas.newSub();
            validate(node, subSchema, subValidationResult, subMatchingSchemas);
            matchingSchemas.merge(subMatchingSchemas);
            if (!subValidationResult.hasProblems()) {
                if (thenSchema) {
                    testBranch(thenSchema);
                }
            }
            else if (elseSchema) {
                testBranch(elseSchema);
            }
        };
        var ifSchema = asSchema(schema.if);
        if (ifSchema) {
            testCondition(ifSchema, asSchema(schema.then), asSchema(schema.else));
        }
        if (Array.isArray(schema.enum)) {
            var val = jsonParser_getNodeValue(node);
            var enumValueMatch = false;
            for (var _d = 0, _e = schema.enum; _d < _e.length; _d++) {
                var e = _e[_d];
                if (objects_equals(val, e)) {
                    enumValueMatch = true;
                    break;
                }
            }
            validationResult.enumValues = schema.enum;
            validationResult.enumValueMatch = enumValueMatch;
            if (!enumValueMatch) {
                validationResult.problems.push({
                    location: { offset: node.offset, length: node.length },
                    severity: main_DiagnosticSeverity.Warning,
                    code: ErrorCode.EnumValueMismatch,
                    message: schema.errorMessage || jsonParser_localize('enumWarning', 'Value is not accepted. Valid values: {0}.', schema.enum.map(function (v) { return JSON.stringify(v); }).join(', '))
                });
            }
        }
        if (isDefined(schema.const)) {
            var val = jsonParser_getNodeValue(node);
            if (!objects_equals(val, schema.const)) {
                validationResult.problems.push({
                    location: { offset: node.offset, length: node.length },
                    severity: main_DiagnosticSeverity.Warning,
                    code: ErrorCode.EnumValueMismatch,
                    message: schema.errorMessage || jsonParser_localize('constWarning', 'Value must be {0}.', JSON.stringify(schema.const))
                });
                validationResult.enumValueMatch = false;
            }
            else {
                validationResult.enumValueMatch = true;
            }
            validationResult.enumValues = [schema.const];
        }
        if (schema.deprecationMessage && node.parent) {
            validationResult.problems.push({
                location: { offset: node.parent.offset, length: node.parent.length },
                severity: main_DiagnosticSeverity.Warning,
                message: schema.deprecationMessage
            });
        }
    }
    function _validateNumberNode(node, schema, validationResult, matchingSchemas) {
        var val = node.value;
        if (objects_isNumber(schema.multipleOf)) {
            if (val % schema.multipleOf !== 0) {
                validationResult.problems.push({
                    location: { offset: node.offset, length: node.length },
                    severity: main_DiagnosticSeverity.Warning,
                    message: jsonParser_localize('multipleOfWarning', 'Value is not divisible by {0}.', schema.multipleOf)
                });
            }
        }
        function getExclusiveLimit(limit, exclusive) {
            if (objects_isNumber(exclusive)) {
                return exclusive;
            }
            if (objects_isBoolean(exclusive) && exclusive) {
                return limit;
            }
            return void 0;
        }
        function getLimit(limit, exclusive) {
            if (!objects_isBoolean(exclusive) || !exclusive) {
                return limit;
            }
            return void 0;
        }
        var exclusiveMinimum = getExclusiveLimit(schema.minimum, schema.exclusiveMinimum);
        if (objects_isNumber(exclusiveMinimum) && val <= exclusiveMinimum) {
            validationResult.problems.push({
                location: { offset: node.offset, length: node.length },
                severity: main_DiagnosticSeverity.Warning,
                message: jsonParser_localize('exclusiveMinimumWarning', 'Value is below the exclusive minimum of {0}.', exclusiveMinimum)
            });
        }
        var exclusiveMaximum = getExclusiveLimit(schema.maximum, schema.exclusiveMaximum);
        if (objects_isNumber(exclusiveMaximum) && val >= exclusiveMaximum) {
            validationResult.problems.push({
                location: { offset: node.offset, length: node.length },
                severity: main_DiagnosticSeverity.Warning,
                message: jsonParser_localize('exclusiveMaximumWarning', 'Value is above the exclusive maximum of {0}.', exclusiveMaximum)
            });
        }
        var minimum = getLimit(schema.minimum, schema.exclusiveMinimum);
        if (objects_isNumber(minimum) && val < minimum) {
            validationResult.problems.push({
                location: { offset: node.offset, length: node.length },
                severity: main_DiagnosticSeverity.Warning,
                message: jsonParser_localize('minimumWarning', 'Value is below the minimum of {0}.', minimum)
            });
        }
        var maximum = getLimit(schema.maximum, schema.exclusiveMaximum);
        if (objects_isNumber(maximum) && val > maximum) {
            validationResult.problems.push({
                location: { offset: node.offset, length: node.length },
                severity: main_DiagnosticSeverity.Warning,
                message: jsonParser_localize('maximumWarning', 'Value is above the maximum of {0}.', maximum)
            });
        }
    }
    function _validateStringNode(node, schema, validationResult, matchingSchemas) {
        if (objects_isNumber(schema.minLength) && node.value.length < schema.minLength) {
            validationResult.problems.push({
                location: { offset: node.offset, length: node.length },
                severity: main_DiagnosticSeverity.Warning,
                message: jsonParser_localize('minLengthWarning', 'String is shorter than the minimum length of {0}.', schema.minLength)
            });
        }
        if (objects_isNumber(schema.maxLength) && node.value.length > schema.maxLength) {
            validationResult.problems.push({
                location: { offset: node.offset, length: node.length },
                severity: main_DiagnosticSeverity.Warning,
                message: jsonParser_localize('maxLengthWarning', 'String is longer than the maximum length of {0}.', schema.maxLength)
            });
        }
        if (objects_isString(schema.pattern)) {
            var regex = new RegExp(schema.pattern);
            if (!regex.test(node.value)) {
                validationResult.problems.push({
                    location: { offset: node.offset, length: node.length },
                    severity: main_DiagnosticSeverity.Warning,
                    message: schema.patternErrorMessage || schema.errorMessage || jsonParser_localize('patternWarning', 'String does not match the pattern of "{0}".', schema.pattern)
                });
            }
        }
        if (schema.format) {
            switch (schema.format) {
                case 'uri':
                case 'uri-reference':
                    {
                        var errorMessage = void 0;
                        if (!node.value) {
                            errorMessage = jsonParser_localize('uriEmpty', 'URI expected.');
                        }
                        else {
                            var match = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/.exec(node.value);
                            if (!match) {
                                errorMessage = jsonParser_localize('uriMissing', 'URI is expected.');
                            }
                            else if (!match[2] && schema.format === 'uri') {
                                errorMessage = jsonParser_localize('uriSchemeMissing', 'URI with a scheme is expected.');
                            }
                        }
                        if (errorMessage) {
                            validationResult.problems.push({
                                location: { offset: node.offset, length: node.length },
                                severity: main_DiagnosticSeverity.Warning,
                                message: schema.patternErrorMessage || schema.errorMessage || jsonParser_localize('uriFormatWarning', 'String is not a URI: {0}', errorMessage)
                            });
                        }
                    }
                    break;
                case 'color-hex':
                case 'date-time':
                case 'date':
                case 'time':
                case 'email':
                    var format = formats[schema.format];
                    if (!node.value || !format.pattern.exec(node.value)) {
                        validationResult.problems.push({
                            location: { offset: node.offset, length: node.length },
                            severity: main_DiagnosticSeverity.Warning,
                            message: schema.patternErrorMessage || schema.errorMessage || format.errorMessage
                        });
                    }
                default:
            }
        }
    }
    function _validateArrayNode(node, schema, validationResult, matchingSchemas) {
        if (Array.isArray(schema.items)) {
            var subSchemas = schema.items;
            for (var index = 0; index < subSchemas.length; index++) {
                var subSchemaRef = subSchemas[index];
                var subSchema = asSchema(subSchemaRef);
                var itemValidationResult = new jsonParser_ValidationResult();
                var item = node.items[index];
                if (item) {
                    validate(item, subSchema, itemValidationResult, matchingSchemas);
                    validationResult.mergePropertyMatch(itemValidationResult);
                }
                else if (node.items.length >= subSchemas.length) {
                    validationResult.propertiesValueMatches++;
                }
            }
            if (node.items.length > subSchemas.length) {
                if (typeof schema.additionalItems === 'object') {
                    for (var i = subSchemas.length; i < node.items.length; i++) {
                        var itemValidationResult = new jsonParser_ValidationResult();
                        validate(node.items[i], schema.additionalItems, itemValidationResult, matchingSchemas);
                        validationResult.mergePropertyMatch(itemValidationResult);
                    }
                }
                else if (schema.additionalItems === false) {
                    validationResult.problems.push({
                        location: { offset: node.offset, length: node.length },
                        severity: main_DiagnosticSeverity.Warning,
                        message: jsonParser_localize('additionalItemsWarning', 'Array has too many items according to schema. Expected {0} or fewer.', subSchemas.length)
                    });
                }
            }
        }
        else {
            var itemSchema = asSchema(schema.items);
            if (itemSchema) {
                for (var _i = 0, _a = node.items; _i < _a.length; _i++) {
                    var item = _a[_i];
                    var itemValidationResult = new jsonParser_ValidationResult();
                    validate(item, itemSchema, itemValidationResult, matchingSchemas);
                    validationResult.mergePropertyMatch(itemValidationResult);
                }
            }
        }
        var containsSchema = asSchema(schema.contains);
        if (containsSchema) {
            var doesContain = node.items.some(function (item) {
                var itemValidationResult = new jsonParser_ValidationResult();
                validate(item, containsSchema, itemValidationResult, NoOpSchemaCollector.instance);
                return !itemValidationResult.hasProblems();
            });
            if (!doesContain) {
                validationResult.problems.push({
                    location: { offset: node.offset, length: node.length },
                    severity: main_DiagnosticSeverity.Warning,
                    message: schema.errorMessage || jsonParser_localize('requiredItemMissingWarning', 'Array does not contain required item.')
                });
            }
        }
        if (objects_isNumber(schema.minItems) && node.items.length < schema.minItems) {
            validationResult.problems.push({
                location: { offset: node.offset, length: node.length },
                severity: main_DiagnosticSeverity.Warning,
                message: jsonParser_localize('minItemsWarning', 'Array has too few items. Expected {0} or more.', schema.minItems)
            });
        }
        if (objects_isNumber(schema.maxItems) && node.items.length > schema.maxItems) {
            validationResult.problems.push({
                location: { offset: node.offset, length: node.length },
                severity: main_DiagnosticSeverity.Warning,
                message: jsonParser_localize('maxItemsWarning', 'Array has too many items. Expected {0} or fewer.', schema.maxItems)
            });
        }
        if (schema.uniqueItems === true) {
            var values_1 = jsonParser_getNodeValue(node);
            var duplicates = values_1.some(function (value, index) {
                return index !== values_1.lastIndexOf(value);
            });
            if (duplicates) {
                validationResult.problems.push({
                    location: { offset: node.offset, length: node.length },
                    severity: main_DiagnosticSeverity.Warning,
                    message: jsonParser_localize('uniqueItemsWarning', 'Array has duplicate items.')
                });
            }
        }
    }
    function _validateObjectNode(node, schema, validationResult, matchingSchemas) {
        var seenKeys = Object.create(null);
        var unprocessedProperties = [];
        for (var _i = 0, _a = node.properties; _i < _a.length; _i++) {
            var propertyNode = _a[_i];
            var key = propertyNode.keyNode.value;
            seenKeys[key] = propertyNode.valueNode;
            unprocessedProperties.push(key);
        }
        if (Array.isArray(schema.required)) {
            for (var _b = 0, _c = schema.required; _b < _c.length; _b++) {
                var propertyName = _c[_b];
                if (!seenKeys[propertyName]) {
                    var keyNode = node.parent && node.parent.type === 'property' && node.parent.keyNode;
                    var location = keyNode ? { offset: keyNode.offset, length: keyNode.length } : { offset: node.offset, length: 1 };
                    validationResult.problems.push({
                        location: location,
                        severity: main_DiagnosticSeverity.Warning,
                        message: jsonParser_localize('MissingRequiredPropWarning', 'Missing property "{0}".', propertyName)
                    });
                }
            }
        }
        var propertyProcessed = function (prop) {
            var index = unprocessedProperties.indexOf(prop);
            while (index >= 0) {
                unprocessedProperties.splice(index, 1);
                index = unprocessedProperties.indexOf(prop);
            }
        };
        if (schema.properties) {
            for (var _d = 0, _e = Object.keys(schema.properties); _d < _e.length; _d++) {
                var propertyName = _e[_d];
                propertyProcessed(propertyName);
                var propertySchema = schema.properties[propertyName];
                var child = seenKeys[propertyName];
                if (child) {
                    if (objects_isBoolean(propertySchema)) {
                        if (!propertySchema) {
                            var propertyNode = child.parent;
                            validationResult.problems.push({
                                location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },
                                severity: main_DiagnosticSeverity.Warning,
                                message: schema.errorMessage || jsonParser_localize('DisallowedExtraPropWarning', 'Property {0} is not allowed.', propertyName)
                            });
                        }
                        else {
                            validationResult.propertiesMatches++;
                            validationResult.propertiesValueMatches++;
                        }
                    }
                    else {
                        var propertyValidationResult = new jsonParser_ValidationResult();
                        validate(child, propertySchema, propertyValidationResult, matchingSchemas);
                        validationResult.mergePropertyMatch(propertyValidationResult);
                    }
                }
            }
        }
        if (schema.patternProperties) {
            for (var _f = 0, _g = Object.keys(schema.patternProperties); _f < _g.length; _f++) {
                var propertyPattern = _g[_f];
                var regex = new RegExp(propertyPattern);
                for (var _h = 0, _j = unprocessedProperties.slice(0); _h < _j.length; _h++) {
                    var propertyName = _j[_h];
                    if (regex.test(propertyName)) {
                        propertyProcessed(propertyName);
                        var child = seenKeys[propertyName];
                        if (child) {
                            var propertySchema = schema.patternProperties[propertyPattern];
                            if (objects_isBoolean(propertySchema)) {
                                if (!propertySchema) {
                                    var propertyNode = child.parent;
                                    validationResult.problems.push({
                                        location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },
                                        severity: main_DiagnosticSeverity.Warning,
                                        message: schema.errorMessage || jsonParser_localize('DisallowedExtraPropWarning', 'Property {0} is not allowed.', propertyName)
                                    });
                                }
                                else {
                                    validationResult.propertiesMatches++;
                                    validationResult.propertiesValueMatches++;
                                }
                            }
                            else {
                                var propertyValidationResult = new jsonParser_ValidationResult();
                                validate(child, propertySchema, propertyValidationResult, matchingSchemas);
                                validationResult.mergePropertyMatch(propertyValidationResult);
                            }
                        }
                    }
                }
            }
        }
        if (typeof schema.additionalProperties === 'object') {
            for (var _k = 0, unprocessedProperties_1 = unprocessedProperties; _k < unprocessedProperties_1.length; _k++) {
                var propertyName = unprocessedProperties_1[_k];
                var child = seenKeys[propertyName];
                if (child) {
                    var propertyValidationResult = new jsonParser_ValidationResult();
                    validate(child, schema.additionalProperties, propertyValidationResult, matchingSchemas);
                    validationResult.mergePropertyMatch(propertyValidationResult);
                }
            }
        }
        else if (schema.additionalProperties === false) {
            if (unprocessedProperties.length > 0) {
                for (var _l = 0, unprocessedProperties_2 = unprocessedProperties; _l < unprocessedProperties_2.length; _l++) {
                    var propertyName = unprocessedProperties_2[_l];
                    var child = seenKeys[propertyName];
                    if (child) {
                        var propertyNode = child.parent;
                        validationResult.problems.push({
                            location: { offset: propertyNode.keyNode.offset, length: propertyNode.keyNode.length },
                            severity: main_DiagnosticSeverity.Warning,
                            message: schema.errorMessage || jsonParser_localize('DisallowedExtraPropWarning', 'Property {0} is not allowed.', propertyName)
                        });
                    }
                }
            }
        }
        if (objects_isNumber(schema.maxProperties)) {
            if (node.properties.length > schema.maxProperties) {
                validationResult.problems.push({
                    location: { offset: node.offset, length: node.length },
                    severity: main_DiagnosticSeverity.Warning,
                    message: jsonParser_localize('MaxPropWarning', 'Object has more properties than limit of {0}.', schema.maxProperties)
                });
            }
        }
        if (objects_isNumber(schema.minProperties)) {
            if (node.properties.length < schema.minProperties) {
                validationResult.problems.push({
                    location: { offset: node.offset, length: node.length },
                    severity: main_DiagnosticSeverity.Warning,
                    message: jsonParser_localize('MinPropWarning', 'Object has fewer properties than the required number of {0}', schema.minProperties)
                });
            }
        }
        if (schema.dependencies) {
            for (var _m = 0, _o = Object.keys(schema.dependencies); _m < _o.length; _m++) {
                var key = _o[_m];
                var prop = seenKeys[key];
                if (prop) {
                    var propertyDep = schema.dependencies[key];
                    if (Array.isArray(propertyDep)) {
                        for (var _p = 0, propertyDep_1 = propertyDep; _p < propertyDep_1.length; _p++) {
                            var requiredProp = propertyDep_1[_p];
                            if (!seenKeys[requiredProp]) {
                                validationResult.problems.push({
                                    location: { offset: node.offset, length: node.length },
                                    severity: main_DiagnosticSeverity.Warning,
                                    message: jsonParser_localize('RequiredDependentPropWarning', 'Object is missing property {0} required by property {1}.', requiredProp, key)
                                });
                            }
                            else {
                                validationResult.propertiesValueMatches++;
                            }
                        }
                    }
                    else {
                        var propertySchema = asSchema(propertyDep);
                        if (propertySchema) {
                            var propertyValidationResult = new jsonParser_ValidationResult();
                            validate(node, propertySchema, propertyValidationResult, matchingSchemas);
                            validationResult.mergePropertyMatch(propertyValidationResult);
                        }
                    }
                }
            }
        }
        var propertyNames = asSchema(schema.propertyNames);
        if (propertyNames) {
            for (var _q = 0, _r = node.properties; _q < _r.length; _q++) {
                var f = _r[_q];
                var key = f.keyNode;
                if (key) {
                    validate(key, propertyNames, validationResult, NoOpSchemaCollector.instance);
                }
            }
        }
    }
}
function jsonParser_parse(textDocument, config) {
    var problems = [];
    var lastProblemOffset = -1;
    var text = textDocument.getText();
    var scanner = main_createScanner(text, false);
    var commentRanges = config && config.collectComments ? [] : void 0;
    function _scanNext() {
        while (true) {
            var token_1 = scanner.scan();
            _checkScanError();
            switch (token_1) {
                case 12 /* LineCommentTrivia */:
                case 13 /* BlockCommentTrivia */:
                    if (Array.isArray(commentRanges)) {
                        commentRanges.push(vscode_languageserver_types_main_Range.create(textDocument.positionAt(scanner.getTokenOffset()), textDocument.positionAt(scanner.getTokenOffset() + scanner.getTokenLength())));
                    }
                    break;
                case 15 /* Trivia */:
                case 14 /* LineBreakTrivia */:
                    break;
                default:
                    return token_1;
            }
        }
    }
    function _accept(token) {
        if (scanner.getToken() === token) {
            _scanNext();
            return true;
        }
        return false;
    }
    function _errorAtRange(message, code, startOffset, endOffset, severity) {
        if (severity === void 0) { severity = main_DiagnosticSeverity.Error; }
        if (problems.length === 0 || startOffset !== lastProblemOffset) {
            var range = vscode_languageserver_types_main_Range.create(textDocument.positionAt(startOffset), textDocument.positionAt(endOffset));
            problems.push(main_Diagnostic.create(range, message, severity, code, textDocument.languageId));
            lastProblemOffset = startOffset;
        }
    }
    function _error(message, code, node, skipUntilAfter, skipUntil) {
        if (node === void 0) { node = null; }
        if (skipUntilAfter === void 0) { skipUntilAfter = []; }
        if (skipUntil === void 0) { skipUntil = []; }
        var start = scanner.getTokenOffset();
        var end = scanner.getTokenOffset() + scanner.getTokenLength();
        if (start === end && start > 0) {
            start--;
            while (start > 0 && /\s/.test(text.charAt(start))) {
                start--;
            }
            end = start + 1;
        }
        _errorAtRange(message, code, start, end);
        if (node) {
            _finalize(node, false);
        }
        if (skipUntilAfter.length + skipUntil.length > 0) {
            var token_2 = scanner.getToken();
            while (token_2 !== 17 /* EOF */) {
                if (skipUntilAfter.indexOf(token_2) !== -1) {
                    _scanNext();
                    break;
                }
                else if (skipUntil.indexOf(token_2) !== -1) {
                    break;
                }
                token_2 = _scanNext();
            }
        }
        return node;
    }
    function _checkScanError() {
        switch (scanner.getTokenError()) {
            case 4 /* InvalidUnicode */:
                _error(jsonParser_localize('InvalidUnicode', 'Invalid unicode sequence in string.'), ErrorCode.InvalidUnicode);
                return true;
            case 5 /* InvalidEscapeCharacter */:
                _error(jsonParser_localize('InvalidEscapeCharacter', 'Invalid escape character in string.'), ErrorCode.InvalidEscapeCharacter);
                return true;
            case 3 /* UnexpectedEndOfNumber */:
                _error(jsonParser_localize('UnexpectedEndOfNumber', 'Unexpected end of number.'), ErrorCode.UnexpectedEndOfNumber);
                return true;
            case 1 /* UnexpectedEndOfComment */:
                _error(jsonParser_localize('UnexpectedEndOfComment', 'Unexpected end of comment.'), ErrorCode.UnexpectedEndOfComment);
                return true;
            case 2 /* UnexpectedEndOfString */:
                _error(jsonParser_localize('UnexpectedEndOfString', 'Unexpected end of string.'), ErrorCode.UnexpectedEndOfString);
                return true;
            case 6 /* InvalidCharacter */:
                _error(jsonParser_localize('InvalidCharacter', 'Invalid characters in string. Control characters must be escaped.'), ErrorCode.InvalidCharacter);
                return true;
        }
        return false;
    }
    function _finalize(node, scanNext) {
        node.length = scanner.getTokenOffset() + scanner.getTokenLength() - node.offset;
        if (scanNext) {
            _scanNext();
        }
        return node;
    }
    function _parseArray(parent) {
        if (scanner.getToken() !== 3 /* OpenBracketToken */) {
            return null;
        }
        var node = new ArrayASTNodeImpl(parent, scanner.getTokenOffset());
        _scanNext(); // consume OpenBracketToken
        var count = 0;
        var needsComma = false;
        while (scanner.getToken() !== 4 /* CloseBracketToken */ && scanner.getToken() !== 17 /* EOF */) {
            if (scanner.getToken() === 5 /* CommaToken */) {
                if (!needsComma) {
                    _error(jsonParser_localize('ValueExpected', 'Value expected'), ErrorCode.ValueExpected);
                }
                var commaOffset = scanner.getTokenOffset();
                _scanNext(); // consume comma
                if (scanner.getToken() === 4 /* CloseBracketToken */) {
                    if (needsComma) {
                        _errorAtRange(jsonParser_localize('TrailingComma', 'Trailing comma'), ErrorCode.TrailingComma, commaOffset, commaOffset + 1);
                    }
                    continue;
                }
            }
            else if (needsComma) {
                _error(jsonParser_localize('ExpectedComma', 'Expected comma'), ErrorCode.CommaExpected);
            }
            var item = _parseValue(node, count++);
            if (!item) {
                _error(jsonParser_localize('PropertyExpected', 'Value expected'), ErrorCode.ValueExpected, null, [], [4 /* CloseBracketToken */, 5 /* CommaToken */]);
            }
            else {
                node.items.push(item);
            }
            needsComma = true;
        }
        if (scanner.getToken() !== 4 /* CloseBracketToken */) {
            return _error(jsonParser_localize('ExpectedCloseBracket', 'Expected comma or closing bracket'), ErrorCode.CommaOrCloseBacketExpected, node);
        }
        return _finalize(node, true);
    }
    function _parseProperty(parent, keysSeen) {
        var node = new PropertyASTNodeImpl(parent, scanner.getTokenOffset());
        var key = _parseString(node);
        if (!key) {
            if (scanner.getToken() === 16 /* Unknown */) {
                // give a more helpful error message
                _error(jsonParser_localize('DoubleQuotesExpected', 'Property keys must be doublequoted'), ErrorCode.Undefined);
                var keyNode = new StringASTNodeImpl(node, scanner.getTokenOffset(), scanner.getTokenLength());
                keyNode.value = scanner.getTokenValue();
                key = keyNode;
                _scanNext(); // consume Unknown
            }
            else {
                return null;
            }
        }
        node.keyNode = key;
        var seen = keysSeen[key.value];
        if (seen) {
            _errorAtRange(jsonParser_localize('DuplicateKeyWarning', "Duplicate object key"), ErrorCode.DuplicateKey, node.keyNode.offset, node.keyNode.offset + node.keyNode.length, main_DiagnosticSeverity.Warning);
            if (typeof seen === 'object') {
                _errorAtRange(jsonParser_localize('DuplicateKeyWarning', "Duplicate object key"), ErrorCode.DuplicateKey, seen.keyNode.offset, seen.keyNode.offset + seen.keyNode.length, main_DiagnosticSeverity.Warning);
            }
            keysSeen[key.value] = true; // if the same key is duplicate again, avoid duplicate error reporting
        }
        else {
            keysSeen[key.value] = node;
        }
        if (scanner.getToken() === 6 /* ColonToken */) {
            node.colonOffset = scanner.getTokenOffset();
            _scanNext(); // consume ColonToken
        }
        else {
            _error(jsonParser_localize('ColonExpected', 'Colon expected'), ErrorCode.ColonExpected);
            if (scanner.getToken() === 10 /* StringLiteral */ && textDocument.positionAt(key.offset + key.length).line < textDocument.positionAt(scanner.getTokenOffset()).line) {
                node.length = key.length;
                return node;
            }
        }
        var value = _parseValue(node, key.value);
        if (!value) {
            return _error(jsonParser_localize('ValueExpected', 'Value expected'), ErrorCode.ValueExpected, node, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
        }
        node.valueNode = value;
        node.length = value.offset + value.length - node.offset;
        return node;
    }
    function _parseObject(parent) {
        if (scanner.getToken() !== 1 /* OpenBraceToken */) {
            return null;
        }
        var node = new ObjectASTNodeImpl(parent, scanner.getTokenOffset());
        var keysSeen = Object.create(null);
        _scanNext(); // consume OpenBraceToken
        var needsComma = false;
        while (scanner.getToken() !== 2 /* CloseBraceToken */ && scanner.getToken() !== 17 /* EOF */) {
            if (scanner.getToken() === 5 /* CommaToken */) {
                if (!needsComma) {
                    _error(jsonParser_localize('PropertyExpected', 'Property expected'), ErrorCode.PropertyExpected);
                }
                var commaOffset = scanner.getTokenOffset();
                _scanNext(); // consume comma
                if (scanner.getToken() === 2 /* CloseBraceToken */) {
                    if (needsComma) {
                        _errorAtRange(jsonParser_localize('TrailingComma', 'Trailing comma'), ErrorCode.TrailingComma, commaOffset, commaOffset + 1);
                    }
                    continue;
                }
            }
            else if (needsComma) {
                _error(jsonParser_localize('ExpectedComma', 'Expected comma'), ErrorCode.CommaExpected);
            }
            var property = _parseProperty(node, keysSeen);
            if (!property) {
                _error(jsonParser_localize('PropertyExpected', 'Property expected'), ErrorCode.PropertyExpected, null, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
            }
            else {
                node.properties.push(property);
            }
            needsComma = true;
        }
        if (scanner.getToken() !== 2 /* CloseBraceToken */) {
            return _error(jsonParser_localize('ExpectedCloseBrace', 'Expected comma or closing brace'), ErrorCode.CommaOrCloseBraceExpected, node);
        }
        return _finalize(node, true);
    }
    function _parseString(parent) {
        if (scanner.getToken() !== 10 /* StringLiteral */) {
            return null;
        }
        var node = new StringASTNodeImpl(parent, scanner.getTokenOffset());
        node.value = scanner.getTokenValue();
        return _finalize(node, true);
    }
    function _parseNumber(parent) {
        if (scanner.getToken() !== 11 /* NumericLiteral */) {
            return null;
        }
        var node = new NumberASTNodeImpl(parent, scanner.getTokenOffset());
        if (scanner.getTokenError() === 0 /* None */) {
            var tokenValue = scanner.getTokenValue();
            try {
                var numberValue = JSON.parse(tokenValue);
                if (!objects_isNumber(numberValue)) {
                    return _error(jsonParser_localize('InvalidNumberFormat', 'Invalid number format.'), ErrorCode.Undefined, node);
                }
                node.value = numberValue;
            }
            catch (e) {
                return _error(jsonParser_localize('InvalidNumberFormat', 'Invalid number format.'), ErrorCode.Undefined, node);
            }
            node.isInteger = tokenValue.indexOf('.') === -1;
        }
        return _finalize(node, true);
    }
    function _parseLiteral(parent) {
        var node;
        switch (scanner.getToken()) {
            case 7 /* NullKeyword */:
                return _finalize(new NullASTNodeImpl(parent, scanner.getTokenOffset()), true);
            case 8 /* TrueKeyword */:
                return _finalize(new BooleanASTNodeImpl(parent, true, scanner.getTokenOffset()), true);
            case 9 /* FalseKeyword */:
                return _finalize(new BooleanASTNodeImpl(parent, false, scanner.getTokenOffset()), true);
            default:
                return null;
        }
    }
    function _parseValue(parent, name) {
        return _parseArray(parent) || _parseObject(parent) || _parseString(parent) || _parseNumber(parent) || _parseLiteral(parent);
    }
    var _root = null;
    var token = _scanNext();
    if (token !== 17 /* EOF */) {
        _root = _parseValue(null, null);
        if (!_root) {
            _error(jsonParser_localize('Invalid symbol', 'Expected a JSON object, array or literal.'), ErrorCode.Undefined);
        }
        else if (scanner.getToken() !== 17 /* EOF */) {
            _error(jsonParser_localize('End of file expected', 'End of file expected.'), ErrorCode.Undefined);
        }
    }
    return new jsonParser_JSONDocument(_root, problems, commentRanges);
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/vscode-json-languageservice/lib/esm/services/jsonSchemaService.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





var jsonSchemaService_localize = loadMessageBundle();
var jsonSchemaService_FilePatternAssociation = /** @class */ (function () {
    function FilePatternAssociation(pattern) {
        try {
            this.patternRegExp = new RegExp(strings_convertSimple2RegExpPattern(pattern) + '$');
        }
        catch (e) {
            // invalid pattern
            this.patternRegExp = null;
        }
        this.schemas = [];
    }
    FilePatternAssociation.prototype.addSchema = function (id) {
        this.schemas.push(id);
    };
    FilePatternAssociation.prototype.matchesPattern = function (fileName) {
        return this.patternRegExp && this.patternRegExp.test(fileName);
    };
    FilePatternAssociation.prototype.getSchemas = function () {
        return this.schemas;
    };
    return FilePatternAssociation;
}());
var SchemaHandle = /** @class */ (function () {
    function SchemaHandle(service, url, unresolvedSchemaContent) {
        this.service = service;
        this.url = url;
        this.dependencies = {};
        if (unresolvedSchemaContent) {
            this.unresolvedSchema = this.service.promise.resolve(new UnresolvedSchema(unresolvedSchemaContent));
        }
    }
    SchemaHandle.prototype.getUnresolvedSchema = function () {
        if (!this.unresolvedSchema) {
            this.unresolvedSchema = this.service.loadSchema(this.url);
        }
        return this.unresolvedSchema;
    };
    SchemaHandle.prototype.getResolvedSchema = function () {
        var _this = this;
        if (!this.resolvedSchema) {
            this.resolvedSchema = this.getUnresolvedSchema().then(function (unresolved) {
                return _this.service.resolveSchemaContent(unresolved, _this.url, _this.dependencies);
            });
        }
        return this.resolvedSchema;
    };
    SchemaHandle.prototype.clearSchema = function () {
        this.resolvedSchema = null;
        this.unresolvedSchema = null;
        this.dependencies = {};
    };
    return SchemaHandle;
}());
var UnresolvedSchema = /** @class */ (function () {
    function UnresolvedSchema(schema, errors) {
        if (errors === void 0) { errors = []; }
        this.schema = schema;
        this.errors = errors;
    }
    return UnresolvedSchema;
}());

var jsonSchemaService_ResolvedSchema = /** @class */ (function () {
    function ResolvedSchema(schema, errors) {
        if (errors === void 0) { errors = []; }
        this.schema = schema;
        this.errors = errors;
    }
    ResolvedSchema.prototype.getSection = function (path) {
        return asSchema(this.getSectionRecursive(path, this.schema));
    };
    ResolvedSchema.prototype.getSectionRecursive = function (path, schema) {
        if (!schema || typeof schema === 'boolean' || path.length === 0) {
            return schema;
        }
        var next = path.shift();
        if (schema.properties && typeof schema.properties[next]) {
            return this.getSectionRecursive(path, schema.properties[next]);
        }
        else if (schema.patternProperties) {
            for (var _i = 0, _a = Object.keys(schema.patternProperties); _i < _a.length; _i++) {
                var pattern = _a[_i];
                var regex = new RegExp(pattern);
                if (regex.test(next)) {
                    return this.getSectionRecursive(path, schema.patternProperties[pattern]);
                }
            }
        }
        else if (typeof schema.additionalProperties === 'object') {
            return this.getSectionRecursive(path, schema.additionalProperties);
        }
        else if (next.match('[0-9]+')) {
            if (Array.isArray(schema.items)) {
                var index = parseInt(next, 10);
                if (!isNaN(index) && schema.items[index]) {
                    return this.getSectionRecursive(path, schema.items[index]);
                }
            }
            else if (schema.items) {
                return this.getSectionRecursive(path, schema.items);
            }
        }
        return null;
    };
    return ResolvedSchema;
}());

var jsonSchemaService_JSONSchemaService = /** @class */ (function () {
    function JSONSchemaService(requestService, contextService, promiseConstructor) {
        this.contextService = contextService;
        this.requestService = requestService;
        this.promiseConstructor = promiseConstructor || Promise;
        this.callOnDispose = [];
        this.contributionSchemas = {};
        this.contributionAssociations = {};
        this.schemasById = {};
        this.filePatternAssociations = [];
        this.filePatternAssociationById = {};
        this.registeredSchemasIds = {};
    }
    JSONSchemaService.prototype.getRegisteredSchemaIds = function (filter) {
        return Object.keys(this.registeredSchemasIds).filter(function (id) {
            var scheme = vscode_uri_URI.parse(id).scheme;
            return scheme !== 'schemaservice' && (!filter || filter(scheme));
        });
    };
    Object.defineProperty(JSONSchemaService.prototype, "promise", {
        get: function () {
            return this.promiseConstructor;
        },
        enumerable: true,
        configurable: true
    });
    JSONSchemaService.prototype.dispose = function () {
        while (this.callOnDispose.length > 0) {
            this.callOnDispose.pop()();
        }
    };
    JSONSchemaService.prototype.onResourceChange = function (uri) {
        var _this = this;
        var hasChanges = false;
        uri = this.normalizeId(uri);
        var toWalk = [uri];
        var all = Object.keys(this.schemasById).map(function (key) { return _this.schemasById[key]; });
        while (toWalk.length) {
            var curr = toWalk.pop();
            for (var i = 0; i < all.length; i++) {
                var handle = all[i];
                if (handle && (handle.url === curr || handle.dependencies[curr])) {
                    if (handle.url !== curr) {
                        toWalk.push(handle.url);
                    }
                    handle.clearSchema();
                    all[i] = undefined;
                    hasChanges = true;
                }
            }
        }
        return hasChanges;
    };
    JSONSchemaService.prototype.normalizeId = function (id) {
        // remove trailing '#', normalize drive capitalization
        try {
            return vscode_uri_URI.parse(id).toString();
        }
        catch (e) {
            return id;
        }
    };
    JSONSchemaService.prototype.setSchemaContributions = function (schemaContributions) {
        if (schemaContributions.schemas) {
            var schemas = schemaContributions.schemas;
            for (var id in schemas) {
                var normalizedId = this.normalizeId(id);
                this.contributionSchemas[normalizedId] = this.addSchemaHandle(normalizedId, schemas[id]);
            }
        }
        if (schemaContributions.schemaAssociations) {
            var schemaAssociations = schemaContributions.schemaAssociations;
            for (var pattern in schemaAssociations) {
                var associations = schemaAssociations[pattern];
                this.contributionAssociations[pattern] = associations;
                var fpa = this.getOrAddFilePatternAssociation(pattern);
                for (var _i = 0, associations_1 = associations; _i < associations_1.length; _i++) {
                    var schemaId = associations_1[_i];
                    var id = this.normalizeId(schemaId);
                    fpa.addSchema(id);
                }
            }
        }
    };
    JSONSchemaService.prototype.addSchemaHandle = function (id, unresolvedSchemaContent) {
        var schemaHandle = new SchemaHandle(this, id, unresolvedSchemaContent);
        this.schemasById[id] = schemaHandle;
        return schemaHandle;
    };
    JSONSchemaService.prototype.getOrAddSchemaHandle = function (id, unresolvedSchemaContent) {
        return this.schemasById[id] || this.addSchemaHandle(id, unresolvedSchemaContent);
    };
    JSONSchemaService.prototype.getOrAddFilePatternAssociation = function (pattern) {
        var fpa = this.filePatternAssociationById[pattern];
        if (!fpa) {
            fpa = new jsonSchemaService_FilePatternAssociation(pattern);
            this.filePatternAssociationById[pattern] = fpa;
            this.filePatternAssociations.push(fpa);
        }
        return fpa;
    };
    JSONSchemaService.prototype.registerExternalSchema = function (uri, filePatterns, unresolvedSchemaContent) {
        if (filePatterns === void 0) { filePatterns = null; }
        var id = this.normalizeId(uri);
        this.registeredSchemasIds[id] = true;
        if (filePatterns) {
            for (var _i = 0, filePatterns_1 = filePatterns; _i < filePatterns_1.length; _i++) {
                var pattern = filePatterns_1[_i];
                this.getOrAddFilePatternAssociation(pattern).addSchema(id);
            }
        }
        return unresolvedSchemaContent ? this.addSchemaHandle(id, unresolvedSchemaContent) : this.getOrAddSchemaHandle(id);
    };
    JSONSchemaService.prototype.clearExternalSchemas = function () {
        this.schemasById = {};
        this.filePatternAssociations = [];
        this.filePatternAssociationById = {};
        this.registeredSchemasIds = {};
        for (var id in this.contributionSchemas) {
            this.schemasById[id] = this.contributionSchemas[id];
            this.registeredSchemasIds[id] = true;
        }
        for (var pattern in this.contributionAssociations) {
            var fpa = this.getOrAddFilePatternAssociation(pattern);
            for (var _i = 0, _a = this.contributionAssociations[pattern]; _i < _a.length; _i++) {
                var schemaId = _a[_i];
                var id = this.normalizeId(schemaId);
                fpa.addSchema(id);
            }
        }
    };
    JSONSchemaService.prototype.getResolvedSchema = function (schemaId) {
        var id = this.normalizeId(schemaId);
        var schemaHandle = this.schemasById[id];
        if (schemaHandle) {
            return schemaHandle.getResolvedSchema();
        }
        return this.promise.resolve(null);
    };
    JSONSchemaService.prototype.loadSchema = function (url) {
        if (!this.requestService) {
            var errorMessage = jsonSchemaService_localize('json.schema.norequestservice', 'Unable to load schema from \'{0}\'. No schema request service available', toDisplayString(url));
            return this.promise.resolve(new UnresolvedSchema({}, [errorMessage]));
        }
        return this.requestService(url).then(function (content) {
            if (!content) {
                var errorMessage = jsonSchemaService_localize('json.schema.nocontent', 'Unable to load schema from \'{0}\': No content.', toDisplayString(url));
                return new UnresolvedSchema({}, [errorMessage]);
            }
            var schemaContent = {};
            var jsonErrors = [];
            schemaContent = main_parse(content, jsonErrors);
            var errors = jsonErrors.length ? [jsonSchemaService_localize('json.schema.invalidFormat', 'Unable to parse content from \'{0}\': Parse error at offset {1}.', toDisplayString(url), jsonErrors[0].offset)] : [];
            return new UnresolvedSchema(schemaContent, errors);
        }, function (error) {
            var errorMessage = error.toString();
            var errorSplit = error.toString().split('Error: ');
            if (errorSplit.length > 1) {
                // more concise error message, URL and context are attached by caller anyways
                errorMessage = errorSplit[1];
            }
            if (strings_endsWith(errorMessage, '.')) {
                errorMessage = errorMessage.substr(0, errorMessage.length - 1);
            }
            return new UnresolvedSchema({}, [jsonSchemaService_localize('json.schema.nocontent', 'Unable to load schema from \'{0}\': {1}.', toDisplayString(url), errorMessage)]);
        });
    };
    JSONSchemaService.prototype.resolveSchemaContent = function (schemaToResolve, schemaURL, dependencies) {
        var _this = this;
        var resolveErrors = schemaToResolve.errors.slice(0);
        var schema = schemaToResolve.schema;
        if (schema.$schema) {
            var id = this.normalizeId(schema.$schema);
            if (id === 'http://json-schema.org/draft-03/schema') {
                return this.promise.resolve(new jsonSchemaService_ResolvedSchema({}, [jsonSchemaService_localize('json.schema.draft03.notsupported', "Draft-03 schemas are not supported.")]));
            }
            else if (id === 'https://json-schema.org/draft/2019-09/schema') {
                schemaToResolve.errors.push(jsonSchemaService_localize('json.schema.draft201909.notsupported', "Draft 2019-09 schemas are not yet fully supported."));
            }
        }
        var contextService = this.contextService;
        var findSection = function (schema, path) {
            if (!path) {
                return schema;
            }
            var current = schema;
            if (path[0] === '/') {
                path = path.substr(1);
            }
            path.split('/').some(function (part) {
                current = current[part];
                return !current;
            });
            return current;
        };
        var merge = function (target, sourceRoot, sourceURI, path) {
            var section = findSection(sourceRoot, path);
            if (section) {
                for (var key in section) {
                    if (section.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
                        target[key] = section[key];
                    }
                }
            }
            else {
                resolveErrors.push(jsonSchemaService_localize('json.schema.invalidref', '$ref \'{0}\' in \'{1}\' can not be resolved.', path, sourceURI));
            }
        };
        var resolveExternalLink = function (node, uri, linkPath, parentSchemaURL, parentSchemaDependencies) {
            if (contextService && !/^\w+:\/\/.*/.test(uri)) {
                uri = contextService.resolveRelativePath(uri, parentSchemaURL);
            }
            uri = _this.normalizeId(uri);
            var referencedHandle = _this.getOrAddSchemaHandle(uri);
            return referencedHandle.getUnresolvedSchema().then(function (unresolvedSchema) {
                parentSchemaDependencies[uri] = true;
                if (unresolvedSchema.errors.length) {
                    var loc = linkPath ? uri + '#' + linkPath : uri;
                    resolveErrors.push(jsonSchemaService_localize('json.schema.problemloadingref', 'Problems loading reference \'{0}\': {1}', loc, unresolvedSchema.errors[0]));
                }
                merge(node, unresolvedSchema.schema, uri, linkPath);
                return resolveRefs(node, unresolvedSchema.schema, uri, referencedHandle.dependencies);
            });
        };
        var resolveRefs = function (node, parentSchema, parentSchemaURL, parentSchemaDependencies) {
            if (!node || typeof node !== 'object') {
                return Promise.resolve(null);
            }
            var toWalk = [node];
            var seen = [];
            var openPromises = [];
            var collectEntries = function () {
                var entries = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    entries[_i] = arguments[_i];
                }
                for (var _a = 0, entries_1 = entries; _a < entries_1.length; _a++) {
                    var entry = entries_1[_a];
                    if (typeof entry === 'object') {
                        toWalk.push(entry);
                    }
                }
            };
            var collectMapEntries = function () {
                var maps = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    maps[_i] = arguments[_i];
                }
                for (var _a = 0, maps_1 = maps; _a < maps_1.length; _a++) {
                    var map = maps_1[_a];
                    if (typeof map === 'object') {
                        for (var key in map) {
                            var entry = map[key];
                            if (typeof entry === 'object') {
                                toWalk.push(entry);
                            }
                        }
                    }
                }
            };
            var collectArrayEntries = function () {
                var arrays = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    arrays[_i] = arguments[_i];
                }
                for (var _a = 0, arrays_1 = arrays; _a < arrays_1.length; _a++) {
                    var array = arrays_1[_a];
                    if (Array.isArray(array)) {
                        for (var _b = 0, array_1 = array; _b < array_1.length; _b++) {
                            var entry = array_1[_b];
                            if (typeof entry === 'object') {
                                toWalk.push(entry);
                            }
                        }
                    }
                }
            };
            var handleRef = function (next) {
                var seenRefs = [];
                while (next.$ref) {
                    var ref = next.$ref;
                    var segments = ref.split('#', 2);
                    delete next.$ref;
                    if (segments[0].length > 0) {
                        openPromises.push(resolveExternalLink(next, segments[0], segments[1], parentSchemaURL, parentSchemaDependencies));
                        return;
                    }
                    else {
                        if (seenRefs.indexOf(ref) === -1) {
                            merge(next, parentSchema, parentSchemaURL, segments[1]); // can set next.$ref again, use seenRefs to avoid circle
                            seenRefs.push(ref);
                        }
                    }
                }
                collectEntries(next.items, next.additionalProperties, next.not, next.contains, next.propertyNames, next.if, next.then, next.else);
                collectMapEntries(next.definitions, next.properties, next.patternProperties, next.dependencies);
                collectArrayEntries(next.anyOf, next.allOf, next.oneOf, next.items);
            };
            while (toWalk.length) {
                var next = toWalk.pop();
                if (seen.indexOf(next) >= 0) {
                    continue;
                }
                seen.push(next);
                handleRef(next);
            }
            return _this.promise.all(openPromises);
        };
        return resolveRefs(schema, schema, schemaURL, dependencies).then(function (_) { return new jsonSchemaService_ResolvedSchema(schema, resolveErrors); });
    };
    JSONSchemaService.prototype.getSchemaForResource = function (resource, document) {
        // first use $schema if present
        if (document && document.root && document.root.type === 'object') {
            var schemaProperties = document.root.properties.filter(function (p) { return (p.keyNode.value === '$schema') && p.valueNode && p.valueNode.type === 'string'; });
            if (schemaProperties.length > 0) {
                var schemeId = jsonParser_getNodeValue(schemaProperties[0].valueNode);
                if (schemeId && strings_startsWith(schemeId, '.') && this.contextService) {
                    schemeId = this.contextService.resolveRelativePath(schemeId, resource);
                }
                if (schemeId) {
                    var id = this.normalizeId(schemeId);
                    return this.getOrAddSchemaHandle(id).getResolvedSchema();
                }
            }
        }
        var seen = Object.create(null);
        var schemas = [];
        for (var _i = 0, _a = this.filePatternAssociations; _i < _a.length; _i++) {
            var entry = _a[_i];
            if (entry.matchesPattern(resource)) {
                for (var _b = 0, _c = entry.getSchemas(); _b < _c.length; _b++) {
                    var schemaId = _c[_b];
                    if (!seen[schemaId]) {
                        schemas.push(schemaId);
                        seen[schemaId] = true;
                    }
                }
            }
        }
        if (schemas.length > 0) {
            return this.createCombinedSchema(resource, schemas).getResolvedSchema();
        }
        return this.promise.resolve(null);
    };
    JSONSchemaService.prototype.createCombinedSchema = function (resource, schemaIds) {
        if (schemaIds.length === 1) {
            return this.getOrAddSchemaHandle(schemaIds[0]);
        }
        else {
            var combinedSchemaId = 'schemaservice://combinedSchema/' + encodeURIComponent(resource);
            var combinedSchema = {
                allOf: schemaIds.map(function (schemaId) { return ({ $ref: schemaId }); })
            };
            return this.addSchemaHandle(combinedSchemaId, combinedSchema);
        }
    };
    return JSONSchemaService;
}());

function toDisplayString(url) {
    try {
        var uri = vscode_uri_URI.parse(url);
        if (uri.scheme === 'file') {
            return uri.fsPath;
        }
    }
    catch (e) {
        // ignore
    }
    return url;
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/languageservice/utils/strings.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

function utils_strings_startsWith(haystack, needle) {
    if (haystack.length < needle.length) {
        return false;
    }
    for (var i = 0; i < needle.length; i++) {
        if (haystack[i] !== needle[i]) {
            return false;
        }
    }
    return true;
}
/**
 * Determines if haystack ends with needle.
 */
function utils_strings_endsWith(haystack, needle) {
    var diff = haystack.length - needle.length;
    if (diff > 0) {
        return haystack.lastIndexOf(needle) === diff;
    }
    else if (diff === 0) {
        return haystack === needle;
    }
    else {
        return false;
    }
}
function convertSimple2RegExp(pattern) {
    var match = pattern.match(new RegExp('^/(.*?)/([gimy]*)$'));
    return match
        ? convertRegexString2RegExp(match[1], match[2])
        : convertGlobalPattern2RegExp(pattern);
}
function convertGlobalPattern2RegExp(pattern) {
    return new RegExp(pattern
        .replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&')
        .replace(/[\*]/g, '.*') + '$');
}
function convertRegexString2RegExp(pattern, flag) {
    return new RegExp(pattern, flag);
}
function utils_strings_convertSimple2RegExpPattern(pattern) {
    return pattern
        .replace(/[\-\\\{\}\+\?\|\^\$\.\,\[\]\(\)\#\s]/g, '\\$&')
        .replace(/[\*]/g, '.*');
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/languageservice/services/yamlSchemaService.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Red Hat, Inc. All rights reserved.
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

var yamlSchemaService_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};



var yamlSchemaService_localize = loadMessageBundle();
var yamlSchemaService_FilePatternAssociation = /** @class */ (function () {
    function FilePatternAssociation(pattern) {
        try {
            this.patternRegExp = new RegExp(utils_strings_convertSimple2RegExpPattern(pattern) + '$');
        }
        catch (e) {
            // invalid pattern
            this.patternRegExp = null;
        }
        this.schemas = [];
    }
    FilePatternAssociation.prototype.addSchema = function (id) {
        this.schemas.push(id);
    };
    FilePatternAssociation.prototype.matchesPattern = function (fileName) {
        return this.patternRegExp && this.patternRegExp.test(fileName);
    };
    FilePatternAssociation.prototype.getSchemas = function () {
        return this.schemas;
    };
    return FilePatternAssociation;
}());

var yamlSchemaService_YAMLSchemaService = /** @class */ (function (_super) {
    yamlSchemaService_extends(YAMLSchemaService, _super);
    function YAMLSchemaService(requestService, contextService, promiseConstructor) {
        var _this = _super.call(this, requestService, contextService, promiseConstructor) || this;
        _this.customSchemaProvider = undefined;
        return _this;
    }
    YAMLSchemaService.prototype.registerCustomSchemaProvider = function (customSchemaProvider) {
        this.customSchemaProvider = customSchemaProvider;
    };
    //tslint:disable
    YAMLSchemaService.prototype.resolveSchemaContent = function (schemaToResolve, schemaURL, dependencies) {
        var _this = this;
        var resolveErrors = schemaToResolve.errors.slice(0);
        var schema = schemaToResolve.schema;
        var contextService = this.contextService;
        var findSection = function (schema, path) {
            if (!path) {
                return schema;
            }
            var current = schema;
            if (path[0] === '/') {
                path = path.substr(1);
            }
            path.split('/').some(function (part) {
                current = current[part];
                return !current;
            });
            return current;
        };
        var merge = function (target, sourceRoot, sourceURI, path) {
            var section = findSection(sourceRoot, path);
            if (section) {
                for (var key in section) {
                    if (section.hasOwnProperty(key) && !target.hasOwnProperty(key)) {
                        target[key] = section[key];
                    }
                }
            }
            else {
                resolveErrors.push(yamlSchemaService_localize('json.schema.invalidref', "$ref '{0}' in '{1}' can not be resolved.", path, sourceURI));
            }
        };
        var resolveExternalLink = function (node, uri, linkPath, parentSchemaURL, parentSchemaDependencies) {
            if (contextService && !/^\w+:\/\/.*/.test(uri)) {
                uri = contextService.resolveRelativePath(uri, parentSchemaURL);
            }
            uri = _this.normalizeId(uri);
            var referencedHandle = _this.getOrAddSchemaHandle(uri);
            return referencedHandle.getUnresolvedSchema().then(function (unresolvedSchema) {
                parentSchemaDependencies[uri] = true;
                if (unresolvedSchema.errors.length) {
                    var loc = linkPath ? uri + '#' + linkPath : uri;
                    resolveErrors.push(yamlSchemaService_localize('json.schema.problemloadingref', "Problems loading reference '{0}': {1}", loc, unresolvedSchema.errors[0]));
                }
                merge(node, unresolvedSchema.schema, uri, linkPath);
                return resolveRefs(node, unresolvedSchema.schema, uri, referencedHandle.dependencies);
            });
        };
        var resolveRefs = function (node, parentSchema, parentSchemaURL, parentSchemaDependencies) {
            if (!node || typeof node !== 'object') {
                return Promise.resolve(null);
            }
            var toWalk = [node];
            var seen = [];
            var openPromises = [];
            var collectEntries = function () {
                var e_1, _a;
                var entries = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    entries[_i] = arguments[_i];
                }
                try {
                    for (var entries_1 = __values(entries), entries_1_1 = entries_1.next(); !entries_1_1.done; entries_1_1 = entries_1.next()) {
                        var entry = entries_1_1.value;
                        if (typeof entry === 'object') {
                            toWalk.push(entry);
                        }
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (entries_1_1 && !entries_1_1.done && (_a = entries_1.return)) _a.call(entries_1);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            };
            var collectMapEntries = function () {
                var e_2, _a;
                var maps = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    maps[_i] = arguments[_i];
                }
                try {
                    for (var maps_1 = __values(maps), maps_1_1 = maps_1.next(); !maps_1_1.done; maps_1_1 = maps_1.next()) {
                        var map = maps_1_1.value;
                        if (typeof map === 'object') {
                            for (var key in map) {
                                var entry = map[key];
                                if (typeof entry === 'object') {
                                    toWalk.push(entry);
                                }
                            }
                        }
                    }
                }
                catch (e_2_1) { e_2 = { error: e_2_1 }; }
                finally {
                    try {
                        if (maps_1_1 && !maps_1_1.done && (_a = maps_1.return)) _a.call(maps_1);
                    }
                    finally { if (e_2) throw e_2.error; }
                }
            };
            var collectArrayEntries = function () {
                var e_3, _a, e_4, _b;
                var arrays = [];
                for (var _i = 0; _i < arguments.length; _i++) {
                    arrays[_i] = arguments[_i];
                }
                try {
                    for (var arrays_1 = __values(arrays), arrays_1_1 = arrays_1.next(); !arrays_1_1.done; arrays_1_1 = arrays_1.next()) {
                        var array = arrays_1_1.value;
                        if (Array.isArray(array)) {
                            try {
                                for (var array_1 = (e_4 = void 0, __values(array)), array_1_1 = array_1.next(); !array_1_1.done; array_1_1 = array_1.next()) {
                                    var entry = array_1_1.value;
                                    if (typeof entry === 'object') {
                                        toWalk.push(entry);
                                    }
                                }
                            }
                            catch (e_4_1) { e_4 = { error: e_4_1 }; }
                            finally {
                                try {
                                    if (array_1_1 && !array_1_1.done && (_b = array_1.return)) _b.call(array_1);
                                }
                                finally { if (e_4) throw e_4.error; }
                            }
                        }
                    }
                }
                catch (e_3_1) { e_3 = { error: e_3_1 }; }
                finally {
                    try {
                        if (arrays_1_1 && !arrays_1_1.done && (_a = arrays_1.return)) _a.call(arrays_1);
                    }
                    finally { if (e_3) throw e_3.error; }
                }
            };
            var handleRef = function (next) {
                var seenRefs = [];
                while (next.$ref) {
                    var ref = next.$ref;
                    var segments = ref.split('#', 2);
                    delete next.$ref;
                    if (segments[0].length > 0) {
                        openPromises.push(resolveExternalLink(next, segments[0], segments[1], parentSchemaURL, parentSchemaDependencies));
                        return;
                    }
                    else {
                        if (seenRefs.indexOf(ref) === -1) {
                            merge(next, parentSchema, parentSchemaURL, segments[1]); // can set next.$ref again, use seenRefs to avoid circle
                            seenRefs.push(ref);
                        }
                    }
                }
                collectEntries(next.items, next.additionalProperties, next.not, next.contains, next.propertyNames, next.if, next.then, next.else);
                collectMapEntries(next.definitions, next.properties, next.patternProperties, next.dependencies);
                collectArrayEntries(next.anyOf, next.allOf, next.oneOf, next.items, next.schemaSequence);
            };
            while (toWalk.length) {
                var next = toWalk.pop();
                if (seen.indexOf(next) >= 0) {
                    continue;
                }
                seen.push(next);
                handleRef(next);
            }
            return Promise.all(openPromises);
        };
        return resolveRefs(schema, schema, schemaURL, dependencies).then(function (_) { return new jsonSchemaService_ResolvedSchema(schema, resolveErrors); });
    };
    //tslint:enable
    YAMLSchemaService.prototype.getSchemaForResource = function (resource, doc) {
        var _this = this;
        if (doc === void 0) { doc = undefined; }
        var resolveSchema = function () {
            var e_5, _a, e_6, _b;
            var seen = Object.create(null);
            var schemas = [];
            try {
                for (var _c = __values(_this.filePatternAssociations), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var entry = _d.value;
                    if (entry.matchesPattern(resource)) {
                        try {
                            for (var _e = (e_6 = void 0, __values(entry.getSchemas())), _f = _e.next(); !_f.done; _f = _e.next()) {
                                var schemaId = _f.value;
                                if (!seen[schemaId]) {
                                    schemas.push(schemaId);
                                    seen[schemaId] = true;
                                }
                            }
                        }
                        catch (e_6_1) { e_6 = { error: e_6_1 }; }
                        finally {
                            try {
                                if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                            }
                            finally { if (e_6) throw e_6.error; }
                        }
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_5) throw e_5.error; }
            }
            if (schemas.length > 0) {
                return _super.prototype.createCombinedSchema.call(_this, resource, schemas)
                    .getResolvedSchema()
                    .then(function (schema) {
                    if (schema.schema &&
                        schema.schema.schemaSequence &&
                        schema.schema.schemaSequence[doc.currentDocIndex]) {
                        return new jsonSchemaService_ResolvedSchema(schema.schema.schemaSequence[doc.currentDocIndex]);
                    }
                    return schema;
                });
            }
            return Promise.resolve(null);
        };
        if (this.customSchemaProvider) {
            return this.customSchemaProvider(resource)
                .then(function (schemaUri) {
                if (!schemaUri) {
                    return resolveSchema();
                }
                return _this.loadSchema(schemaUri).then(function (unsolvedSchema) {
                    return _this.resolveSchemaContent(unsolvedSchema, schemaUri, []).then(function (schema) {
                        if (schema.schema &&
                            schema.schema.schemaSequence &&
                            schema.schema.schemaSequence[doc.currentDocIndex]) {
                            return new jsonSchemaService_ResolvedSchema(schema.schema.schemaSequence[doc.currentDocIndex]);
                        }
                        return schema;
                    });
                });
            })
                .then(function (schema) { return schema; }, function (err) { return resolveSchema(); });
        }
        else {
            return resolveSchema();
        }
    };
    /**
     * Everything below here is needed because we're importing from vscode-json-languageservice umd and we need
     * to provide a wrapper around the javascript methods we are calling since they have no type
     */
    YAMLSchemaService.prototype.normalizeId = function (id) {
        return _super.prototype.normalizeId.call(this, id);
    };
    YAMLSchemaService.prototype.getOrAddSchemaHandle = function (id, unresolvedSchemaContent) {
        return _super.prototype.getOrAddSchemaHandle.call(this, id, unresolvedSchemaContent);
    };
    // tslint:disable-next-line: no-any
    YAMLSchemaService.prototype.loadSchema = function (schemaUri) {
        return _super.prototype.loadSchema.call(this, schemaUri);
    };
    YAMLSchemaService.prototype.registerExternalSchema = function (uri, filePatterns, unresolvedSchema) {
        return _super.prototype.registerExternalSchema.call(this, uri, filePatterns, unresolvedSchema);
    };
    YAMLSchemaService.prototype.clearExternalSchemas = function () {
        _super.prototype.clearExternalSchemas.call(this);
    };
    YAMLSchemaService.prototype.setSchemaContributions = function (schemaContributions) {
        _super.prototype.setSchemaContributions.call(this, schemaContributions);
    };
    YAMLSchemaService.prototype.getRegisteredSchemaIds = function (filter) {
        return _super.prototype.getRegisteredSchemaIds.call(this, filter);
    };
    YAMLSchemaService.prototype.getResolvedSchema = function (schemaId) {
        return _super.prototype.getResolvedSchema.call(this, schemaId);
    };
    YAMLSchemaService.prototype.onResourceChange = function (uri) {
        return _super.prototype.onResourceChange.call(this, uri);
    };
    return YAMLSchemaService;
}(jsonSchemaService_JSONSchemaService));


// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/jsonc-parser/impl/scanner.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

/**
 * Creates a JSON scanner on the given text.
 * If ignoreTrivia is set, whitespaces or comments are ignored.
 */
function scanner_createScanner(text, ignoreTrivia) {
    if (ignoreTrivia === void 0) { ignoreTrivia = false; }
    var pos = 0, len = text.length, value = '', tokenOffset = 0, token = 16 /* Unknown */, scanError = 0 /* None */;
    function scanHexDigits(count, exact) {
        var digits = 0;
        var value = 0;
        while (digits < count || !exact) {
            var ch = text.charCodeAt(pos);
            if (ch >= 48 /* _0 */ && ch <= 57 /* _9 */) {
                value = value * 16 + ch - 48 /* _0 */;
            }
            else if (ch >= 65 /* A */ && ch <= 70 /* F */) {
                value = value * 16 + ch - 65 /* A */ + 10;
            }
            else if (ch >= 97 /* a */ && ch <= 102 /* f */) {
                value = value * 16 + ch - 97 /* a */ + 10;
            }
            else {
                break;
            }
            pos++;
            digits++;
        }
        if (digits < count) {
            value = -1;
        }
        return value;
    }
    function setPosition(newPosition) {
        pos = newPosition;
        value = '';
        tokenOffset = 0;
        token = 16 /* Unknown */;
        scanError = 0 /* None */;
    }
    function scanNumber() {
        var start = pos;
        if (text.charCodeAt(pos) === 48 /* _0 */) {
            pos++;
        }
        else {
            pos++;
            while (pos < text.length && scanner_isDigit(text.charCodeAt(pos))) {
                pos++;
            }
        }
        if (pos < text.length && text.charCodeAt(pos) === 46 /* dot */) {
            pos++;
            if (pos < text.length && scanner_isDigit(text.charCodeAt(pos))) {
                pos++;
                while (pos < text.length && scanner_isDigit(text.charCodeAt(pos))) {
                    pos++;
                }
            }
            else {
                scanError = 3 /* UnexpectedEndOfNumber */;
                return text.substring(start, pos);
            }
        }
        var end = pos;
        if (pos < text.length && (text.charCodeAt(pos) === 69 /* E */ || text.charCodeAt(pos) === 101 /* e */)) {
            pos++;
            if (pos < text.length && text.charCodeAt(pos) === 43 /* plus */ || text.charCodeAt(pos) === 45 /* minus */) {
                pos++;
            }
            if (pos < text.length && scanner_isDigit(text.charCodeAt(pos))) {
                pos++;
                while (pos < text.length && scanner_isDigit(text.charCodeAt(pos))) {
                    pos++;
                }
                end = pos;
            }
            else {
                scanError = 3 /* UnexpectedEndOfNumber */;
            }
        }
        return text.substring(start, end);
    }
    function scanString() {
        var result = '', start = pos;
        while (true) {
            if (pos >= len) {
                result += text.substring(start, pos);
                scanError = 2 /* UnexpectedEndOfString */;
                break;
            }
            var ch = text.charCodeAt(pos);
            if (ch === 34 /* doubleQuote */) {
                result += text.substring(start, pos);
                pos++;
                break;
            }
            if (ch === 92 /* backslash */) {
                result += text.substring(start, pos);
                pos++;
                if (pos >= len) {
                    scanError = 2 /* UnexpectedEndOfString */;
                    break;
                }
                ch = text.charCodeAt(pos++);
                switch (ch) {
                    case 34 /* doubleQuote */:
                        result += '\"';
                        break;
                    case 92 /* backslash */:
                        result += '\\';
                        break;
                    case 47 /* slash */:
                        result += '/';
                        break;
                    case 98 /* b */:
                        result += '\b';
                        break;
                    case 102 /* f */:
                        result += '\f';
                        break;
                    case 110 /* n */:
                        result += '\n';
                        break;
                    case 114 /* r */:
                        result += '\r';
                        break;
                    case 116 /* t */:
                        result += '\t';
                        break;
                    case 117 /* u */:
                        var ch_1 = scanHexDigits(4, true);
                        if (ch_1 >= 0) {
                            result += String.fromCharCode(ch_1);
                        }
                        else {
                            scanError = 4 /* InvalidUnicode */;
                        }
                        break;
                    default:
                        scanError = 5 /* InvalidEscapeCharacter */;
                }
                start = pos;
                continue;
            }
            if (ch >= 0 && ch <= 0x1f) {
                if (scanner_isLineBreak(ch)) {
                    result += text.substring(start, pos);
                    scanError = 2 /* UnexpectedEndOfString */;
                    break;
                }
                else {
                    scanError = 6 /* InvalidCharacter */;
                    // mark as error but continue with string
                }
            }
            pos++;
        }
        return result;
    }
    function scanNext() {
        value = '';
        scanError = 0 /* None */;
        tokenOffset = pos;
        if (pos >= len) {
            // at the end
            tokenOffset = len;
            return token = 17 /* EOF */;
        }
        var code = text.charCodeAt(pos);
        // trivia: whitespace
        if (scanner_isWhiteSpace(code)) {
            do {
                pos++;
                value += String.fromCharCode(code);
                code = text.charCodeAt(pos);
            } while (scanner_isWhiteSpace(code));
            return token = 15 /* Trivia */;
        }
        // trivia: newlines
        if (scanner_isLineBreak(code)) {
            pos++;
            value += String.fromCharCode(code);
            if (code === 13 /* carriageReturn */ && text.charCodeAt(pos) === 10 /* lineFeed */) {
                pos++;
                value += '\n';
            }
            return token = 14 /* LineBreakTrivia */;
        }
        switch (code) {
            // tokens: []{}:,
            case 123 /* openBrace */:
                pos++;
                return token = 1 /* OpenBraceToken */;
            case 125 /* closeBrace */:
                pos++;
                return token = 2 /* CloseBraceToken */;
            case 91 /* openBracket */:
                pos++;
                return token = 3 /* OpenBracketToken */;
            case 93 /* closeBracket */:
                pos++;
                return token = 4 /* CloseBracketToken */;
            case 58 /* colon */:
                pos++;
                return token = 6 /* ColonToken */;
            case 44 /* comma */:
                pos++;
                return token = 5 /* CommaToken */;
            // strings
            case 34 /* doubleQuote */:
                pos++;
                value = scanString();
                return token = 10 /* StringLiteral */;
            // comments
            case 47 /* slash */:
                var start = pos - 1;
                // Single-line comment
                if (text.charCodeAt(pos + 1) === 47 /* slash */) {
                    pos += 2;
                    while (pos < len) {
                        if (scanner_isLineBreak(text.charCodeAt(pos))) {
                            break;
                        }
                        pos++;
                    }
                    value = text.substring(start, pos);
                    return token = 12 /* LineCommentTrivia */;
                }
                // Multi-line comment
                if (text.charCodeAt(pos + 1) === 42 /* asterisk */) {
                    pos += 2;
                    var commentClosed = false;
                    while (pos < len) {
                        var ch = text.charCodeAt(pos);
                        if (ch === 42 /* asterisk */ && (pos + 1 < len) && text.charCodeAt(pos + 1) === 47 /* slash */) {
                            pos += 2;
                            commentClosed = true;
                            break;
                        }
                        pos++;
                    }
                    if (!commentClosed) {
                        pos++;
                        scanError = 1 /* UnexpectedEndOfComment */;
                    }
                    value = text.substring(start, pos);
                    return token = 13 /* BlockCommentTrivia */;
                }
                // just a single slash
                value += String.fromCharCode(code);
                pos++;
                return token = 16 /* Unknown */;
            // numbers
            case 45 /* minus */:
                value += String.fromCharCode(code);
                pos++;
                if (pos === len || !scanner_isDigit(text.charCodeAt(pos))) {
                    return token = 16 /* Unknown */;
                }
            // found a minus, followed by a number so
            // we fall through to proceed with scanning
            // numbers
            case 48 /* _0 */:
            case 49 /* _1 */:
            case 50 /* _2 */:
            case 51 /* _3 */:
            case 52 /* _4 */:
            case 53 /* _5 */:
            case 54 /* _6 */:
            case 55 /* _7 */:
            case 56 /* _8 */:
            case 57 /* _9 */:
                value += scanNumber();
                return token = 11 /* NumericLiteral */;
            // literals and unknown symbols
            default:
                // is a literal? Read the full word.
                while (pos < len && isUnknownContentCharacter(code)) {
                    pos++;
                    code = text.charCodeAt(pos);
                }
                if (tokenOffset !== pos) {
                    value = text.substring(tokenOffset, pos);
                    // keywords: true, false, null
                    switch (value) {
                        case 'true': return token = 8 /* TrueKeyword */;
                        case 'false': return token = 9 /* FalseKeyword */;
                        case 'null': return token = 7 /* NullKeyword */;
                    }
                    return token = 16 /* Unknown */;
                }
                // some
                value += String.fromCharCode(code);
                pos++;
                return token = 16 /* Unknown */;
        }
    }
    function isUnknownContentCharacter(code) {
        if (scanner_isWhiteSpace(code) || scanner_isLineBreak(code)) {
            return false;
        }
        switch (code) {
            case 125 /* closeBrace */:
            case 93 /* closeBracket */:
            case 123 /* openBrace */:
            case 91 /* openBracket */:
            case 34 /* doubleQuote */:
            case 58 /* colon */:
            case 44 /* comma */:
            case 47 /* slash */:
                return false;
        }
        return true;
    }
    function scanNextNonTrivia() {
        var result;
        do {
            result = scanNext();
        } while (result >= 12 /* LineCommentTrivia */ && result <= 15 /* Trivia */);
        return result;
    }
    return {
        setPosition: setPosition,
        getPosition: function () { return pos; },
        scan: ignoreTrivia ? scanNextNonTrivia : scanNext,
        getToken: function () { return token; },
        getTokenValue: function () { return value; },
        getTokenOffset: function () { return tokenOffset; },
        getTokenLength: function () { return pos - tokenOffset; },
        getTokenError: function () { return scanError; }
    };
}
function scanner_isWhiteSpace(ch) {
    return ch === 32 /* space */ || ch === 9 /* tab */ || ch === 11 /* verticalTab */ || ch === 12 /* formFeed */ ||
        ch === 160 /* nonBreakingSpace */ || ch === 5760 /* ogham */ || ch >= 8192 /* enQuad */ && ch <= 8203 /* zeroWidthSpace */ ||
        ch === 8239 /* narrowNoBreakSpace */ || ch === 8287 /* mathematicalSpace */ || ch === 12288 /* ideographicSpace */ || ch === 65279 /* byteOrderMark */;
}
function scanner_isLineBreak(ch) {
    return ch === 10 /* lineFeed */ || ch === 13 /* carriageReturn */ || ch === 8232 /* lineSeparator */ || ch === 8233 /* paragraphSeparator */;
}
function scanner_isDigit(ch) {
    return ch >= 48 /* _0 */ && ch <= 57 /* _9 */;
}
//# sourceMappingURL=scanner.js.map
// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/jsonc-parser/impl/format.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


function impl_format_format(documentText, range, options) {
    var initialIndentLevel;
    var formatText;
    var formatTextStart;
    var rangeStart;
    var rangeEnd;
    if (range) {
        rangeStart = range.offset;
        rangeEnd = rangeStart + range.length;
        formatTextStart = rangeStart;
        while (formatTextStart > 0 && !format_isEOL(documentText, formatTextStart - 1)) {
            formatTextStart--;
        }
        var endOffset = rangeEnd;
        while (endOffset < documentText.length && !format_isEOL(documentText, endOffset)) {
            endOffset++;
        }
        formatText = documentText.substring(formatTextStart, endOffset);
        initialIndentLevel = format_computeIndentLevel(formatText, options);
    }
    else {
        formatText = documentText;
        initialIndentLevel = 0;
        formatTextStart = 0;
        rangeStart = 0;
        rangeEnd = documentText.length;
    }
    var eol = format_getEOL(options, documentText);
    var lineBreak = false;
    var indentLevel = 0;
    var indentValue;
    if (options.insertSpaces) {
        indentValue = impl_format_repeat(' ', options.tabSize || 4);
    }
    else {
        indentValue = '\t';
    }
    var scanner = scanner_createScanner(formatText, false);
    var hasError = false;
    function newLineAndIndent() {
        return eol + impl_format_repeat(indentValue, initialIndentLevel + indentLevel);
    }
    function scanNext() {
        var token = scanner.scan();
        lineBreak = false;
        while (token === 15 /* Trivia */ || token === 14 /* LineBreakTrivia */) {
            lineBreak = lineBreak || (token === 14 /* LineBreakTrivia */);
            token = scanner.scan();
        }
        hasError = token === 16 /* Unknown */ || scanner.getTokenError() !== 0 /* None */;
        return token;
    }
    var editOperations = [];
    function addEdit(text, startOffset, endOffset) {
        if (!hasError && startOffset < rangeEnd && endOffset > rangeStart && documentText.substring(startOffset, endOffset) !== text) {
            editOperations.push({ offset: startOffset, length: endOffset - startOffset, content: text });
        }
    }
    var firstToken = scanNext();
    if (firstToken !== 17 /* EOF */) {
        var firstTokenStart = scanner.getTokenOffset() + formatTextStart;
        var initialIndent = impl_format_repeat(indentValue, initialIndentLevel);
        addEdit(initialIndent, formatTextStart, firstTokenStart);
    }
    while (firstToken !== 17 /* EOF */) {
        var firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
        var secondToken = scanNext();
        var replaceContent = '';
        while (!lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {
            // comments on the same line: keep them on the same line, but ignore them otherwise
            var commentTokenStart = scanner.getTokenOffset() + formatTextStart;
            addEdit(' ', firstTokenEnd, commentTokenStart);
            firstTokenEnd = scanner.getTokenOffset() + scanner.getTokenLength() + formatTextStart;
            replaceContent = secondToken === 12 /* LineCommentTrivia */ ? newLineAndIndent() : '';
            secondToken = scanNext();
        }
        if (secondToken === 2 /* CloseBraceToken */) {
            if (firstToken !== 1 /* OpenBraceToken */) {
                indentLevel--;
                replaceContent = newLineAndIndent();
            }
        }
        else if (secondToken === 4 /* CloseBracketToken */) {
            if (firstToken !== 3 /* OpenBracketToken */) {
                indentLevel--;
                replaceContent = newLineAndIndent();
            }
        }
        else {
            switch (firstToken) {
                case 3 /* OpenBracketToken */:
                case 1 /* OpenBraceToken */:
                    indentLevel++;
                    replaceContent = newLineAndIndent();
                    break;
                case 5 /* CommaToken */:
                case 12 /* LineCommentTrivia */:
                    replaceContent = newLineAndIndent();
                    break;
                case 13 /* BlockCommentTrivia */:
                    if (lineBreak) {
                        replaceContent = newLineAndIndent();
                    }
                    else {
                        // symbol following comment on the same line: keep on same line, separate with ' '
                        replaceContent = ' ';
                    }
                    break;
                case 6 /* ColonToken */:
                    replaceContent = ' ';
                    break;
                case 10 /* StringLiteral */:
                    if (secondToken === 6 /* ColonToken */) {
                        replaceContent = '';
                        break;
                    }
                // fall through
                case 7 /* NullKeyword */:
                case 8 /* TrueKeyword */:
                case 9 /* FalseKeyword */:
                case 11 /* NumericLiteral */:
                case 2 /* CloseBraceToken */:
                case 4 /* CloseBracketToken */:
                    if (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */) {
                        replaceContent = ' ';
                    }
                    else if (secondToken !== 5 /* CommaToken */ && secondToken !== 17 /* EOF */) {
                        hasError = true;
                    }
                    break;
                case 16 /* Unknown */:
                    hasError = true;
                    break;
            }
            if (lineBreak && (secondToken === 12 /* LineCommentTrivia */ || secondToken === 13 /* BlockCommentTrivia */)) {
                replaceContent = newLineAndIndent();
            }
        }
        var secondTokenStart = scanner.getTokenOffset() + formatTextStart;
        addEdit(replaceContent, firstTokenEnd, secondTokenStart);
        firstToken = secondToken;
    }
    return editOperations;
}
function impl_format_repeat(s, count) {
    var result = '';
    for (var i = 0; i < count; i++) {
        result += s;
    }
    return result;
}
function format_computeIndentLevel(content, options) {
    var i = 0;
    var nChars = 0;
    var tabSize = options.tabSize || 4;
    while (i < content.length) {
        var ch = content.charAt(i);
        if (ch === ' ') {
            nChars++;
        }
        else if (ch === '\t') {
            nChars += tabSize;
        }
        else {
            break;
        }
        i++;
    }
    return Math.floor(nChars / tabSize);
}
function format_getEOL(options, text) {
    for (var i = 0; i < text.length; i++) {
        var ch = text.charAt(i);
        if (ch === '\r') {
            if (i + 1 < text.length && text.charAt(i + 1) === '\n') {
                return '\r\n';
            }
            return '\r';
        }
        else if (ch === '\n') {
            return '\n';
        }
    }
    return (options && options.eol) || '\n';
}
function format_isEOL(text, offset) {
    return '\r\n'.indexOf(text.charAt(offset)) !== -1;
}
//# sourceMappingURL=format.js.map
// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/jsonc-parser/impl/parser.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


/**
 * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.
 */
function parser_getLocation(text, position) {
    var segments = []; // strings or numbers
    var earlyReturnException = new Object();
    var previousNode = void 0;
    var previousNodeInst = {
        value: {},
        offset: 0,
        length: 0,
        type: 'object',
        parent: void 0
    };
    var isAtPropertyKey = false;
    function setPreviousNode(value, offset, length, type) {
        previousNodeInst.value = value;
        previousNodeInst.offset = offset;
        previousNodeInst.length = length;
        previousNodeInst.type = type;
        previousNodeInst.colonOffset = void 0;
        previousNode = previousNodeInst;
    }
    try {
        parser_visit(text, {
            onObjectBegin: function (offset, length) {
                if (position <= offset) {
                    throw earlyReturnException;
                }
                previousNode = void 0;
                isAtPropertyKey = position > offset;
                segments.push(''); // push a placeholder (will be replaced)
            },
            onObjectProperty: function (name, offset, length) {
                if (position < offset) {
                    throw earlyReturnException;
                }
                setPreviousNode(name, offset, length, 'property');
                segments[segments.length - 1] = name;
                if (position <= offset + length) {
                    throw earlyReturnException;
                }
            },
            onObjectEnd: function (offset, length) {
                if (position <= offset) {
                    throw earlyReturnException;
                }
                previousNode = void 0;
                segments.pop();
            },
            onArrayBegin: function (offset, length) {
                if (position <= offset) {
                    throw earlyReturnException;
                }
                previousNode = void 0;
                segments.push(0);
            },
            onArrayEnd: function (offset, length) {
                if (position <= offset) {
                    throw earlyReturnException;
                }
                previousNode = void 0;
                segments.pop();
            },
            onLiteralValue: function (value, offset, length) {
                if (position < offset) {
                    throw earlyReturnException;
                }
                setPreviousNode(value, offset, length, getLiteralNodeType(value));
                if (position <= offset + length) {
                    throw earlyReturnException;
                }
            },
            onSeparator: function (sep, offset, length) {
                if (position <= offset) {
                    throw earlyReturnException;
                }
                if (sep === ':' && previousNode && previousNode.type === 'property') {
                    previousNode.colonOffset = offset;
                    isAtPropertyKey = false;
                    previousNode = void 0;
                }
                else if (sep === ',') {
                    var last = segments[segments.length - 1];
                    if (typeof last === 'number') {
                        segments[segments.length - 1] = last + 1;
                    }
                    else {
                        isAtPropertyKey = true;
                        segments[segments.length - 1] = '';
                    }
                    previousNode = void 0;
                }
            }
        });
    }
    catch (e) {
        if (e !== earlyReturnException) {
            throw e;
        }
    }
    return {
        path: segments,
        previousNode: previousNode,
        isAtPropertyKey: isAtPropertyKey,
        matches: function (pattern) {
            var k = 0;
            for (var i = 0; k < pattern.length && i < segments.length; i++) {
                if (pattern[k] === segments[i] || pattern[k] === '*') {
                    k++;
                }
                else if (pattern[k] !== '**') {
                    return false;
                }
            }
            return k === pattern.length;
        }
    };
}
/**
 * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 * Therefore always check the errors list to find out if the input was valid.
 */
function parser_parse(text, errors, options) {
    if (errors === void 0) { errors = []; }
    var currentProperty = null;
    var currentParent = [];
    var previousParents = [];
    function onValue(value) {
        if (Array.isArray(currentParent)) {
            currentParent.push(value);
        }
        else if (currentProperty) {
            currentParent[currentProperty] = value;
        }
    }
    var visitor = {
        onObjectBegin: function () {
            var object = {};
            onValue(object);
            previousParents.push(currentParent);
            currentParent = object;
            currentProperty = null;
        },
        onObjectProperty: function (name) {
            currentProperty = name;
        },
        onObjectEnd: function () {
            currentParent = previousParents.pop();
        },
        onArrayBegin: function () {
            var array = [];
            onValue(array);
            previousParents.push(currentParent);
            currentParent = array;
            currentProperty = null;
        },
        onArrayEnd: function () {
            currentParent = previousParents.pop();
        },
        onLiteralValue: onValue,
        onError: function (error, offset, length) {
            errors.push({ error: error, offset: offset, length: length });
        }
    };
    parser_visit(text, visitor, options);
    return currentParent[0];
}
/**
 * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 */
function parser_parseTree(text, errors, options) {
    if (errors === void 0) { errors = []; }
    var currentParent = { type: 'array', offset: -1, length: -1, children: [], parent: void 0 }; // artificial root
    function ensurePropertyComplete(endOffset) {
        if (currentParent.type === 'property') {
            currentParent.length = endOffset - currentParent.offset;
            currentParent = currentParent.parent;
        }
    }
    function onValue(valueNode) {
        currentParent.children.push(valueNode);
        return valueNode;
    }
    var visitor = {
        onObjectBegin: function (offset) {
            currentParent = onValue({ type: 'object', offset: offset, length: -1, parent: currentParent, children: [] });
        },
        onObjectProperty: function (name, offset, length) {
            currentParent = onValue({ type: 'property', offset: offset, length: -1, parent: currentParent, children: [] });
            currentParent.children.push({ type: 'string', value: name, offset: offset, length: length, parent: currentParent });
        },
        onObjectEnd: function (offset, length) {
            currentParent.length = offset + length - currentParent.offset;
            currentParent = currentParent.parent;
            ensurePropertyComplete(offset + length);
        },
        onArrayBegin: function (offset, length) {
            currentParent = onValue({ type: 'array', offset: offset, length: -1, parent: currentParent, children: [] });
        },
        onArrayEnd: function (offset, length) {
            currentParent.length = offset + length - currentParent.offset;
            currentParent = currentParent.parent;
            ensurePropertyComplete(offset + length);
        },
        onLiteralValue: function (value, offset, length) {
            onValue({ type: getLiteralNodeType(value), offset: offset, length: length, parent: currentParent, value: value });
            ensurePropertyComplete(offset + length);
        },
        onSeparator: function (sep, offset, length) {
            if (currentParent.type === 'property') {
                if (sep === ':') {
                    currentParent.colonOffset = offset;
                }
                else if (sep === ',') {
                    ensurePropertyComplete(offset);
                }
            }
        },
        onError: function (error, offset, length) {
            errors.push({ error: error, offset: offset, length: length });
        }
    };
    parser_visit(text, visitor, options);
    var result = currentParent.children[0];
    if (result) {
        delete result.parent;
    }
    return result;
}
/**
 * Finds the node at the given path in a JSON DOM.
 */
function parser_findNodeAtLocation(root, path) {
    if (!root) {
        return void 0;
    }
    var node = root;
    for (var _i = 0, path_1 = path; _i < path_1.length; _i++) {
        var segment = path_1[_i];
        if (typeof segment === 'string') {
            if (node.type !== 'object' || !Array.isArray(node.children)) {
                return void 0;
            }
            var found = false;
            for (var _a = 0, _b = node.children; _a < _b.length; _a++) {
                var propertyNode = _b[_a];
                if (Array.isArray(propertyNode.children) && propertyNode.children[0].value === segment) {
                    node = propertyNode.children[1];
                    found = true;
                    break;
                }
            }
            if (!found) {
                return void 0;
            }
        }
        else {
            var index = segment;
            if (node.type !== 'array' || index < 0 || !Array.isArray(node.children) || index >= node.children.length) {
                return void 0;
            }
            node = node.children[index];
        }
    }
    return node;
}
/**
 * Gets the JSON path of the given JSON DOM node
 */
function parser_getNodePath(node) {
    if (!node.parent || !node.parent.children) {
        return [];
    }
    var path = parser_getNodePath(node.parent);
    if (node.parent.type === 'property') {
        var key = node.parent.children[0].value;
        path.push(key);
    }
    else if (node.parent.type === 'array') {
        var index = node.parent.children.indexOf(node);
        if (index !== -1) {
            path.push(index);
        }
    }
    return path;
}
/**
 * Evaluates the JavaScript object of the given JSON DOM node
 */
function parser_getNodeValue(node) {
    switch (node.type) {
        case 'array':
            return node.children.map(parser_getNodeValue);
        case 'object':
            var obj = Object.create(null);
            for (var _i = 0, _a = node.children; _i < _a.length; _i++) {
                var prop = _a[_i];
                var valueNode = prop.children[1];
                if (valueNode) {
                    obj[prop.children[0].value] = parser_getNodeValue(valueNode);
                }
            }
            return obj;
        case 'null':
        case 'string':
        case 'number':
        case 'boolean':
            return node.value;
        default:
            return void 0;
    }
}
function parser_contains(node, offset, includeRightBound) {
    if (includeRightBound === void 0) { includeRightBound = false; }
    return (offset >= node.offset && offset < (node.offset + node.length)) || includeRightBound && (offset === (node.offset + node.length));
}
/**
 * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.
 */
function parser_findNodeAtOffset(node, offset, includeRightBound) {
    if (includeRightBound === void 0) { includeRightBound = false; }
    if (parser_contains(node, offset, includeRightBound)) {
        var children = node.children;
        if (Array.isArray(children)) {
            for (var i = 0; i < children.length && children[i].offset <= offset; i++) {
                var item = parser_findNodeAtOffset(children[i], offset, includeRightBound);
                if (item) {
                    return item;
                }
            }
        }
        return node;
    }
    return void 0;
}
/**
 * Parses the given text and invokes the visitor functions for each object, array and literal reached.
 */
function parser_visit(text, visitor, options) {
    var _scanner = scanner_createScanner(text, false);
    function toNoArgVisit(visitFunction) {
        return visitFunction ? function () { return visitFunction(_scanner.getTokenOffset(), _scanner.getTokenLength()); } : function () { return true; };
    }
    function toOneArgVisit(visitFunction) {
        return visitFunction ? function (arg) { return visitFunction(arg, _scanner.getTokenOffset(), _scanner.getTokenLength()); } : function () { return true; };
    }
    var onObjectBegin = toNoArgVisit(visitor.onObjectBegin), onObjectProperty = toOneArgVisit(visitor.onObjectProperty), onObjectEnd = toNoArgVisit(visitor.onObjectEnd), onArrayBegin = toNoArgVisit(visitor.onArrayBegin), onArrayEnd = toNoArgVisit(visitor.onArrayEnd), onLiteralValue = toOneArgVisit(visitor.onLiteralValue), onSeparator = toOneArgVisit(visitor.onSeparator), onComment = toNoArgVisit(visitor.onComment), onError = toOneArgVisit(visitor.onError);
    var disallowComments = options && options.disallowComments;
    var allowTrailingComma = options && options.allowTrailingComma;
    function scanNext() {
        while (true) {
            var token = _scanner.scan();
            switch (_scanner.getTokenError()) {
                case 4 /* InvalidUnicode */:
                    handleError(14 /* InvalidUnicode */);
                    break;
                case 5 /* InvalidEscapeCharacter */:
                    handleError(15 /* InvalidEscapeCharacter */);
                    break;
                case 3 /* UnexpectedEndOfNumber */:
                    handleError(13 /* UnexpectedEndOfNumber */);
                    break;
                case 1 /* UnexpectedEndOfComment */:
                    if (!disallowComments) {
                        handleError(11 /* UnexpectedEndOfComment */);
                    }
                    break;
                case 2 /* UnexpectedEndOfString */:
                    handleError(12 /* UnexpectedEndOfString */);
                    break;
                case 6 /* InvalidCharacter */:
                    handleError(16 /* InvalidCharacter */);
                    break;
            }
            switch (token) {
                case 12 /* LineCommentTrivia */:
                case 13 /* BlockCommentTrivia */:
                    if (disallowComments) {
                        handleError(10 /* InvalidCommentToken */);
                    }
                    else {
                        onComment();
                    }
                    break;
                case 16 /* Unknown */:
                    handleError(1 /* InvalidSymbol */);
                    break;
                case 15 /* Trivia */:
                case 14 /* LineBreakTrivia */:
                    break;
                default:
                    return token;
            }
        }
    }
    function handleError(error, skipUntilAfter, skipUntil) {
        if (skipUntilAfter === void 0) { skipUntilAfter = []; }
        if (skipUntil === void 0) { skipUntil = []; }
        onError(error);
        if (skipUntilAfter.length + skipUntil.length > 0) {
            var token = _scanner.getToken();
            while (token !== 17 /* EOF */) {
                if (skipUntilAfter.indexOf(token) !== -1) {
                    scanNext();
                    break;
                }
                else if (skipUntil.indexOf(token) !== -1) {
                    break;
                }
                token = scanNext();
            }
        }
    }
    function parseString(isValue) {
        var value = _scanner.getTokenValue();
        if (isValue) {
            onLiteralValue(value);
        }
        else {
            onObjectProperty(value);
        }
        scanNext();
        return true;
    }
    function parseLiteral() {
        switch (_scanner.getToken()) {
            case 11 /* NumericLiteral */:
                var value = 0;
                try {
                    value = JSON.parse(_scanner.getTokenValue());
                    if (typeof value !== 'number') {
                        handleError(2 /* InvalidNumberFormat */);
                        value = 0;
                    }
                }
                catch (e) {
                    handleError(2 /* InvalidNumberFormat */);
                }
                onLiteralValue(value);
                break;
            case 7 /* NullKeyword */:
                onLiteralValue(null);
                break;
            case 8 /* TrueKeyword */:
                onLiteralValue(true);
                break;
            case 9 /* FalseKeyword */:
                onLiteralValue(false);
                break;
            default:
                return false;
        }
        scanNext();
        return true;
    }
    function parseProperty() {
        if (_scanner.getToken() !== 10 /* StringLiteral */) {
            handleError(3 /* PropertyNameExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
            return false;
        }
        parseString(false);
        if (_scanner.getToken() === 6 /* ColonToken */) {
            onSeparator(':');
            scanNext(); // consume colon
            if (!parseValue()) {
                handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
            }
        }
        else {
            handleError(5 /* ColonExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
        }
        return true;
    }
    function parseObject() {
        onObjectBegin();
        scanNext(); // consume open brace
        var needsComma = false;
        while (_scanner.getToken() !== 2 /* CloseBraceToken */ && _scanner.getToken() !== 17 /* EOF */) {
            if (_scanner.getToken() === 5 /* CommaToken */) {
                if (!needsComma) {
                    handleError(4 /* ValueExpected */, [], []);
                }
                onSeparator(',');
                scanNext(); // consume comma
                if (_scanner.getToken() === 2 /* CloseBraceToken */ && allowTrailingComma) {
                    break;
                }
            }
            else if (needsComma) {
                handleError(6 /* CommaExpected */, [], []);
            }
            if (!parseProperty()) {
                handleError(4 /* ValueExpected */, [], [2 /* CloseBraceToken */, 5 /* CommaToken */]);
            }
            needsComma = true;
        }
        onObjectEnd();
        if (_scanner.getToken() !== 2 /* CloseBraceToken */) {
            handleError(7 /* CloseBraceExpected */, [2 /* CloseBraceToken */], []);
        }
        else {
            scanNext(); // consume close brace
        }
        return true;
    }
    function parseArray() {
        onArrayBegin();
        scanNext(); // consume open bracket
        var needsComma = false;
        while (_scanner.getToken() !== 4 /* CloseBracketToken */ && _scanner.getToken() !== 17 /* EOF */) {
            if (_scanner.getToken() === 5 /* CommaToken */) {
                if (!needsComma) {
                    handleError(4 /* ValueExpected */, [], []);
                }
                onSeparator(',');
                scanNext(); // consume comma
                if (_scanner.getToken() === 4 /* CloseBracketToken */ && allowTrailingComma) {
                    break;
                }
            }
            else if (needsComma) {
                handleError(6 /* CommaExpected */, [], []);
            }
            if (!parseValue()) {
                handleError(4 /* ValueExpected */, [], [4 /* CloseBracketToken */, 5 /* CommaToken */]);
            }
            needsComma = true;
        }
        onArrayEnd();
        if (_scanner.getToken() !== 4 /* CloseBracketToken */) {
            handleError(8 /* CloseBracketExpected */, [4 /* CloseBracketToken */], []);
        }
        else {
            scanNext(); // consume close bracket
        }
        return true;
    }
    function parseValue() {
        switch (_scanner.getToken()) {
            case 3 /* OpenBracketToken */:
                return parseArray();
            case 1 /* OpenBraceToken */:
                return parseObject();
            case 10 /* StringLiteral */:
                return parseString(true);
            default:
                return parseLiteral();
        }
    }
    scanNext();
    if (_scanner.getToken() === 17 /* EOF */) {
        return true;
    }
    if (!parseValue()) {
        handleError(4 /* ValueExpected */, [], []);
        return false;
    }
    if (_scanner.getToken() !== 17 /* EOF */) {
        handleError(9 /* EndOfFileExpected */, [], []);
    }
    return true;
}
/**
 * Takes JSON with JavaScript-style comments and remove
 * them. Optionally replaces every none-newline character
 * of comments with a replaceCharacter
 */
function parser_stripComments(text, replaceCh) {
    var _scanner = scanner_createScanner(text), parts = [], kind, offset = 0, pos;
    do {
        pos = _scanner.getPosition();
        kind = _scanner.scan();
        switch (kind) {
            case 12 /* LineCommentTrivia */:
            case 13 /* BlockCommentTrivia */:
            case 17 /* EOF */:
                if (offset !== pos) {
                    parts.push(text.substring(offset, pos));
                }
                if (replaceCh !== void 0) {
                    parts.push(_scanner.getTokenValue().replace(/[^\r\n]/g, replaceCh));
                }
                offset = _scanner.getPosition();
                break;
        }
    } while (kind !== 17 /* EOF */);
    return parts.join('');
}
function getLiteralNodeType(value) {
    switch (typeof value) {
        case 'boolean': return 'boolean';
        case 'number': return 'number';
        case 'string': return 'string';
        default: return 'null';
    }
}
//# sourceMappingURL=parser.js.map
// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/jsonc-parser/impl/edit.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



function edit_removeProperty(text, path, formattingOptions) {
    return edit_setProperty(text, path, void 0, formattingOptions);
}
function edit_setProperty(text, originalPath, value, formattingOptions, getInsertionIndex) {
    var path = originalPath.slice();
    var errors = [];
    var root = parser_parseTree(text, errors);
    var parent = void 0;
    var lastSegment = void 0;
    while (path.length > 0) {
        lastSegment = path.pop();
        parent = parser_findNodeAtLocation(root, path);
        if (parent === void 0 && value !== void 0) {
            if (typeof lastSegment === 'string') {
                value = (_a = {}, _a[lastSegment] = value, _a);
            }
            else {
                value = [value];
            }
        }
        else {
            break;
        }
    }
    if (!parent) {
        // empty document
        if (value === void 0) { // delete
            throw new Error('Can not delete in empty document');
        }
        return edit_withFormatting(text, { offset: root ? root.offset : 0, length: root ? root.length : 0, content: JSON.stringify(value) }, formattingOptions);
    }
    else if (parent.type === 'object' && typeof lastSegment === 'string' && Array.isArray(parent.children)) {
        var existing = parser_findNodeAtLocation(parent, [lastSegment]);
        if (existing !== void 0) {
            if (value === void 0) { // delete
                if (!existing.parent) {
                    throw new Error('Malformed AST');
                }
                var propertyIndex = parent.children.indexOf(existing.parent);
                var removeBegin = void 0;
                var removeEnd = existing.parent.offset + existing.parent.length;
                if (propertyIndex > 0) {
                    // remove the comma of the previous node
                    var previous = parent.children[propertyIndex - 1];
                    removeBegin = previous.offset + previous.length;
                }
                else {
                    removeBegin = parent.offset + 1;
                    if (parent.children.length > 1) {
                        // remove the comma of the next node
                        var next = parent.children[1];
                        removeEnd = next.offset;
                    }
                }
                return edit_withFormatting(text, { offset: removeBegin, length: removeEnd - removeBegin, content: '' }, formattingOptions);
            }
            else {
                // set value of existing property
                return edit_withFormatting(text, { offset: existing.offset, length: existing.length, content: JSON.stringify(value) }, formattingOptions);
            }
        }
        else {
            if (value === void 0) { // delete
                return []; // property does not exist, nothing to do
            }
            var newProperty = JSON.stringify(lastSegment) + ": " + JSON.stringify(value);
            var index = getInsertionIndex ? getInsertionIndex(parent.children.map(function (p) { return p.children[0].value; })) : parent.children.length;
            var edit = void 0;
            if (index > 0) {
                var previous = parent.children[index - 1];
                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };
            }
            else if (parent.children.length === 0) {
                edit = { offset: parent.offset + 1, length: 0, content: newProperty };
            }
            else {
                edit = { offset: parent.offset + 1, length: 0, content: newProperty + ',' };
            }
            return edit_withFormatting(text, edit, formattingOptions);
        }
    }
    else if (parent.type === 'array' && typeof lastSegment === 'number' && Array.isArray(parent.children)) {
        var insertIndex = lastSegment;
        if (insertIndex === -1) {
            // Insert
            var newProperty = "" + JSON.stringify(value);
            var edit = void 0;
            if (parent.children.length === 0) {
                edit = { offset: parent.offset + 1, length: 0, content: newProperty };
            }
            else {
                var previous = parent.children[parent.children.length - 1];
                edit = { offset: previous.offset + previous.length, length: 0, content: ',' + newProperty };
            }
            return edit_withFormatting(text, edit, formattingOptions);
        }
        else {
            if (value === void 0 && parent.children.length >= 0) {
                //Removal
                var removalIndex = lastSegment;
                var toRemove = parent.children[removalIndex];
                var edit = void 0;
                if (parent.children.length === 1) {
                    // only item
                    edit = { offset: parent.offset + 1, length: parent.length - 2, content: '' };
                }
                else if (parent.children.length - 1 === removalIndex) {
                    // last item
                    var previous = parent.children[removalIndex - 1];
                    var offset = previous.offset + previous.length;
                    var parentEndOffset = parent.offset + parent.length;
                    edit = { offset: offset, length: parentEndOffset - 2 - offset, content: '' };
                }
                else {
                    edit = { offset: toRemove.offset, length: parent.children[removalIndex + 1].offset - toRemove.offset, content: '' };
                }
                return edit_withFormatting(text, edit, formattingOptions);
            }
            else {
                throw new Error('Array modification not supported yet');
            }
        }
    }
    else {
        throw new Error("Can not add " + (typeof lastSegment !== 'number' ? 'index' : 'property') + " to parent of type " + parent.type);
    }
    var _a;
}
function edit_withFormatting(text, edit, formattingOptions) {
    // apply the edit
    var newText = edit_applyEdit(text, edit);
    // format the new text
    var begin = edit.offset;
    var end = edit.offset + edit.content.length;
    if (edit.length === 0 || edit.content.length === 0) { // insert or remove
        while (begin > 0 && !format_isEOL(newText, begin - 1)) {
            begin--;
        }
        while (end < newText.length && !format_isEOL(newText, end)) {
            end++;
        }
    }
    var edits = impl_format_format(newText, { offset: begin, length: end - begin }, formattingOptions);
    // apply the formatting edits and track the begin and end offsets of the changes
    for (var i = edits.length - 1; i >= 0; i--) {
        var edit_1 = edits[i];
        newText = edit_applyEdit(newText, edit_1);
        begin = Math.min(begin, edit_1.offset);
        end = Math.max(end, edit_1.offset + edit_1.length);
        end += edit_1.content.length - edit_1.length;
    }
    // create a single edit with all changes
    var editLength = text.length - (newText.length - end) - begin;
    return [{ offset: begin, length: editLength, content: newText.substring(begin, end) }];
}
function edit_applyEdit(text, edit) {
    return text.substring(0, edit.offset) + edit.content + text.substring(edit.offset + edit.length);
}
function edit_isWS(text, offset) {
    return '\r\n \t'.indexOf(text.charAt(offset)) !== -1;
}
//# sourceMappingURL=edit.js.map
// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/jsonc-parser/main.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/





/**
 * Creates a JSON scanner on the given text.
 * If ignoreTrivia is set, whitespaces or comments are ignored.
 */
var jsonc_parser_main_createScanner = scanner_createScanner;
/**
 * For a given offset, evaluate the location in the JSON document. Each segment in the location path is either a property name or an array index.
 */
var jsonc_parser_main_getLocation = parser_getLocation;
/**
 * Parses the given text and returns the object the JSON content represents. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 * Therefore always check the errors list to find out if the input was valid.
 */
var jsonc_parser_main_parse = parser_parse;
/**
 * Parses the given text and returns a tree representation the JSON content. On invalid input, the parser tries to be as fault tolerant as possible, but still return a result.
 */
var jsonc_parser_main_parseTree = parser_parseTree;
/**
 * Finds the node at the given path in a JSON DOM.
 */
var jsonc_parser_main_findNodeAtLocation = parser_findNodeAtLocation;
/**
 * Finds the most inner node at the given offset. If includeRightBound is set, also finds nodes that end at the given offset.
 */
var jsonc_parser_main_findNodeAtOffset = parser_findNodeAtOffset;
/**
 * Gets the JSON path of the given JSON DOM node
 */
var jsonc_parser_main_getNodePath = parser_getNodePath;
/**
 * Evaluates the JavaScript object of the given JSON DOM node
 */
var jsonc_parser_main_getNodeValue = parser_getNodeValue;
/**
 * Parses the given text and invokes the visitor functions for each object, array and literal reached.
 */
var jsonc_parser_main_visit = parser_visit;
/**
 * Takes JSON with JavaScript-style comments and remove
 * them. Optionally replaces every none-newline character
 * of comments with a replaceCharacter
 */
var jsonc_parser_main_stripComments = parser_stripComments;
/**
 * Computes the edits needed to format a JSON document.
 *
 * @param documentText The input text
 * @param range The range to format or `undefined` to format the full content
 * @param options The formatting options
 * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or
 * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of
 * text in the original document. However, multiple edits can have
 * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.
 * To apply edits to an input, you can use `applyEdits`
 */
function jsonc_parser_main_format(documentText, range, options) {
    return impl_format_format(documentText, range, options);
}
/**
 * Computes the edits needed to modify a value in the JSON document.
 *
 * @param documentText The input text
 * @param path The path of the value to change. The path represents either to the document root, a property or an array item.
 * If the path points to an non-existing property or item, it will be created.
 * @param value The new value for the specified property or item. If the value is undefined,
 * the property or item will be removed.
 * @param options Options
 * @returns A list of edit operations describing the formatting changes to the original document. Edits can be either inserts, replacements or
 * removals of text segments. All offsets refer to the original state of the document. No two edits must change or remove the same range of
 * text in the original document. However, multiple edits can have
 * the same offset, for example multiple inserts, or an insert followed by a remove or replace. The order in the array defines which edit is applied first.
 * To apply edits to an input, you can use `applyEdits`
 */
function main_modify(text, path, value, options) {
    return edit_setProperty(text, path, value, options.formattingOptions, options.getInsertionIndex);
}
/**
 * Applies edits to a input string.
 */
function main_applyEdits(text, edits) {
    for (var i = edits.length - 1; i >= 0; i--) {
        text = edit_applyEdit(text, edits[i]);
    }
    return text;
}
//# sourceMappingURL=main.js.map
// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/languageservice/utils/objects.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

// tslint:disable-next-line: no-any
function utils_objects_equals(one, other) {
    if (one === other) {
        return true;
    }
    if (one === null ||
        one === undefined ||
        other === null ||
        other === undefined) {
        return false;
    }
    if (typeof one !== typeof other) {
        return false;
    }
    if (typeof one !== 'object') {
        return false;
    }
    if (Array.isArray(one) !== Array.isArray(other)) {
        return false;
    }
    var i, key;
    if (Array.isArray(one)) {
        if (one.length !== other.length) {
            return false;
        }
        for (i = 0; i < one.length; i++) {
            if (!utils_objects_equals(one[i], other[i])) {
                return false;
            }
        }
    }
    else {
        var oneKeys = [];
        for (key in one) {
            oneKeys.push(key);
        }
        oneKeys.sort();
        var otherKeys = [];
        for (key in other) {
            otherKeys.push(key);
        }
        otherKeys.sort();
        if (!utils_objects_equals(oneKeys, otherKeys)) {
            return false;
        }
        for (i = 0; i < oneKeys.length; i++) {
            if (!utils_objects_equals(one[oneKeys[i]], other[oneKeys[i]])) {
                return false;
            }
        }
    }
    return true;
}
// tslint:disable-next-line: no-any
function utils_objects_isNumber(val) {
    return typeof val === 'number';
}
// tslint:disable-next-line: no-any
function objects_isDefined(val) {
    return typeof val !== 'undefined';
}
// tslint:disable-next-line: no-any
function utils_objects_isBoolean(val) {
    return typeof val === 'boolean';
}
// tslint:disable-next-line: no-any
function utils_objects_isString(val) {
    return typeof val === 'string';
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/vscode-json-languageservice/lib/esm/utils/json.js
/*---------------------------------------------------------------------------------------------
*  Copyright (c) Microsoft Corporation. All rights reserved.
*  Licensed under the MIT License. See License.txt in the project root for license information.
*--------------------------------------------------------------------------------------------*/
function stringifyObject(obj, indent, stringifyLiteral) {
    if (obj !== null && typeof obj === 'object') {
        var newIndent = indent + '\t';
        if (Array.isArray(obj)) {
            if (obj.length === 0) {
                return '[]';
            }
            var result = '[\n';
            for (var i = 0; i < obj.length; i++) {
                result += newIndent + stringifyObject(obj[i], newIndent, stringifyLiteral);
                if (i < obj.length - 1) {
                    result += ',';
                }
                result += '\n';
            }
            result += indent + ']';
            return result;
        }
        else {
            var keys = Object.keys(obj);
            if (keys.length === 0) {
                return '{}';
            }
            var result = '{\n';
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                result += newIndent + JSON.stringify(key) + ': ' + stringifyObject(obj[key], newIndent, stringifyLiteral);
                if (i < keys.length - 1) {
                    result += ',';
                }
                result += '\n';
            }
            result += indent + '}';
            return result;
        }
    }
    return stringifyLiteral(obj);
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/vscode-json-languageservice/lib/esm/services/jsonCompletion.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/







var jsonCompletion_localize = loadMessageBundle();
var valueCommitCharacters = [',', '}', ']'];
var propertyCommitCharacters = [':'];
var jsonCompletion_JSONCompletion = /** @class */ (function () {
    function JSONCompletion(schemaService, contributions, promiseConstructor, clientCapabilities) {
        if (contributions === void 0) { contributions = []; }
        if (promiseConstructor === void 0) { promiseConstructor = Promise; }
        if (clientCapabilities === void 0) { clientCapabilities = {}; }
        this.schemaService = schemaService;
        this.contributions = contributions;
        this.promiseConstructor = promiseConstructor;
        this.clientCapabilities = clientCapabilities;
        this.templateVarIdCounter = 0;
    }
    JSONCompletion.prototype.doResolve = function (item) {
        for (var i = this.contributions.length - 1; i >= 0; i--) {
            if (this.contributions[i].resolveCompletion) {
                var resolver = this.contributions[i].resolveCompletion(item);
                if (resolver) {
                    return resolver;
                }
            }
        }
        return this.promiseConstructor.resolve(item);
    };
    JSONCompletion.prototype.doComplete = function (document, position, doc) {
        var _this = this;
        var result = {
            items: [],
            isIncomplete: false
        };
        var text = document.getText();
        var offset = document.offsetAt(position);
        var node = doc.getNodeFromOffset(offset, true);
        if (this.isInComment(document, node ? node.offset : 0, offset)) {
            return Promise.resolve(result);
        }
        if (node && (offset === node.offset + node.length) && offset > 0) {
            var ch = text[offset - 1];
            if (node.type === 'object' && ch === '}' || node.type === 'array' && ch === ']') {
                // after ] or }
                node = node.parent;
            }
        }
        var currentWord = this.getCurrentWord(document, offset);
        var overwriteRange = null;
        if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {
            overwriteRange = vscode_languageserver_types_main_Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));
        }
        else {
            var overwriteStart = offset - currentWord.length;
            if (overwriteStart > 0 && text[overwriteStart - 1] === '"') {
                overwriteStart--;
            }
            overwriteRange = vscode_languageserver_types_main_Range.create(document.positionAt(overwriteStart), position);
        }
        var supportsCommitCharacters = false; //this.doesSupportsCommitCharacters(); disabled for now, waiting for new API: https://github.com/microsoft/vscode/issues/42544
        var proposed = {};
        var collector = {
            add: function (suggestion) {
                var label = suggestion.label;
                var existing = proposed[label];
                if (!existing) {
                    label = label.replace(/[\n]/g, '');
                    if (label.length > 60) {
                        var shortendedLabel = label.substr(0, 57).trim() + '...';
                        if (!proposed[shortendedLabel]) {
                            label = shortendedLabel;
                        }
                    }
                    if (overwriteRange) {
                        suggestion.textEdit = main_TextEdit.replace(overwriteRange, suggestion.insertText);
                    }
                    if (supportsCommitCharacters) {
                        suggestion.commitCharacters = suggestion.kind === vscode_languageserver_types_main_CompletionItemKind.Property ? propertyCommitCharacters : valueCommitCharacters;
                    }
                    suggestion.label = label;
                    proposed[label] = suggestion;
                    result.items.push(suggestion);
                }
                else if (!existing.documentation) {
                    existing.documentation = suggestion.documentation;
                }
            },
            setAsIncomplete: function () {
                result.isIncomplete = true;
            },
            error: function (message) {
                console.error(message);
            },
            log: function (message) {
                console.log(message);
            },
            getNumberOfProposals: function () {
                return result.items.length;
            }
        };
        return this.schemaService.getSchemaForResource(document.uri, doc).then(function (schema) {
            var collectionPromises = [];
            var addValue = true;
            var currentKey = '';
            var currentProperty = null;
            if (node) {
                if (node.type === 'string') {
                    var parent = node.parent;
                    if (parent && parent.type === 'property' && parent.keyNode === node) {
                        addValue = !parent.valueNode;
                        currentProperty = parent;
                        currentKey = text.substr(node.offset + 1, node.length - 2);
                        if (parent) {
                            node = parent.parent;
                        }
                    }
                }
            }
            // proposals for properties
            if (node && node.type === 'object') {
                // don't suggest keys when the cursor is just before the opening curly brace
                if (node.offset === offset) {
                    return result;
                }
                // don't suggest properties that are already present
                var properties = node.properties;
                properties.forEach(function (p) {
                    if (!currentProperty || currentProperty !== p) {
                        proposed[p.keyNode.value] = main_CompletionItem.create('__');
                    }
                });
                var separatorAfter_1 = '';
                if (addValue) {
                    separatorAfter_1 = _this.evaluateSeparatorAfter(document, document.offsetAt(overwriteRange.end));
                }
                if (schema) {
                    // property proposals with schema
                    _this.getPropertyCompletions(schema, doc, node, addValue, separatorAfter_1, collector);
                }
                else {
                    // property proposals without schema
                    _this.getSchemaLessPropertyCompletions(doc, node, currentKey, collector);
                }
                var location_1 = jsonParser_getNodePath(node);
                _this.contributions.forEach(function (contribution) {
                    var collectPromise = contribution.collectPropertyCompletions(document.uri, location_1, currentWord, addValue, separatorAfter_1 === '', collector);
                    if (collectPromise) {
                        collectionPromises.push(collectPromise);
                    }
                });
                if ((!schema && currentWord.length > 0 && text.charAt(offset - currentWord.length - 1) !== '"')) {
                    collector.add({
                        kind: vscode_languageserver_types_main_CompletionItemKind.Property,
                        label: _this.getLabelForValue(currentWord),
                        insertText: _this.getInsertTextForProperty(currentWord, null, false, separatorAfter_1),
                        insertTextFormat: main_InsertTextFormat.Snippet, documentation: '',
                    });
                    collector.setAsIncomplete();
                }
            }
            // proposals for values
            var types = {};
            if (schema) {
                // value proposals with schema
                _this.getValueCompletions(schema, doc, node, offset, document, collector, types);
            }
            else {
                // value proposals without schema
                _this.getSchemaLessValueCompletions(doc, node, offset, document, collector);
            }
            if (_this.contributions.length > 0) {
                _this.getContributedValueCompletions(doc, node, offset, document, collector, collectionPromises);
            }
            return _this.promiseConstructor.all(collectionPromises).then(function () {
                if (collector.getNumberOfProposals() === 0) {
                    var offsetForSeparator = offset;
                    if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {
                        offsetForSeparator = node.offset + node.length;
                    }
                    var separatorAfter = _this.evaluateSeparatorAfter(document, offsetForSeparator);
                    _this.addFillerValueCompletions(types, separatorAfter, collector);
                }
                return result;
            });
        });
    };
    JSONCompletion.prototype.getPropertyCompletions = function (schema, doc, node, addValue, separatorAfter, collector) {
        var _this = this;
        var matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset);
        matchingSchemas.forEach(function (s) {
            if (s.node === node && !s.inverted) {
                var schemaProperties_1 = s.schema.properties;
                if (schemaProperties_1) {
                    Object.keys(schemaProperties_1).forEach(function (key) {
                        var propertySchema = schemaProperties_1[key];
                        if (typeof propertySchema === 'object' && !propertySchema.deprecationMessage && !propertySchema.doNotSuggest) {
                            var proposal = {
                                kind: vscode_languageserver_types_main_CompletionItemKind.Property,
                                label: key,
                                insertText: _this.getInsertTextForProperty(key, propertySchema, addValue, separatorAfter),
                                insertTextFormat: main_InsertTextFormat.Snippet,
                                filterText: _this.getFilterTextForValue(key),
                                documentation: _this.fromMarkup(propertySchema.markdownDescription) || propertySchema.description || '',
                            };
                            if (strings_endsWith(proposal.insertText, "$1" + separatorAfter)) {
                                proposal.command = {
                                    title: 'Suggest',
                                    command: 'editor.action.triggerSuggest'
                                };
                            }
                            collector.add(proposal);
                        }
                    });
                }
            }
        });
    };
    JSONCompletion.prototype.getSchemaLessPropertyCompletions = function (doc, node, currentKey, collector) {
        var _this = this;
        var collectCompletionsForSimilarObject = function (obj) {
            obj.properties.forEach(function (p) {
                var key = p.keyNode.value;
                collector.add({
                    kind: vscode_languageserver_types_main_CompletionItemKind.Property,
                    label: key,
                    insertText: _this.getInsertTextForValue(key, ''),
                    insertTextFormat: main_InsertTextFormat.Snippet,
                    filterText: _this.getFilterTextForValue(key),
                    documentation: ''
                });
            });
        };
        if (node.parent) {
            if (node.parent.type === 'property') {
                // if the object is a property value, check the tree for other objects that hang under a property of the same name
                var parentKey_1 = node.parent.keyNode.value;
                doc.visit(function (n) {
                    if (n.type === 'property' && n !== node.parent && n.keyNode.value === parentKey_1 && n.valueNode && n.valueNode.type === 'object') {
                        collectCompletionsForSimilarObject(n.valueNode);
                    }
                    return true;
                });
            }
            else if (node.parent.type === 'array') {
                // if the object is in an array, use all other array elements as similar objects
                node.parent.items.forEach(function (n) {
                    if (n.type === 'object' && n !== node) {
                        collectCompletionsForSimilarObject(n);
                    }
                });
            }
        }
        else if (node.type === 'object') {
            collector.add({
                kind: vscode_languageserver_types_main_CompletionItemKind.Property,
                label: '$schema',
                insertText: this.getInsertTextForProperty('$schema', null, true, ''),
                insertTextFormat: main_InsertTextFormat.Snippet, documentation: '',
                filterText: this.getFilterTextForValue("$schema")
            });
        }
    };
    JSONCompletion.prototype.getSchemaLessValueCompletions = function (doc, node, offset, document, collector) {
        var _this = this;
        var offsetForSeparator = offset;
        if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {
            offsetForSeparator = node.offset + node.length;
            node = node.parent;
        }
        if (!node) {
            collector.add({
                kind: this.getSuggestionKind('object'),
                label: 'Empty object',
                insertText: this.getInsertTextForValue({}, ''),
                insertTextFormat: main_InsertTextFormat.Snippet,
                documentation: ''
            });
            collector.add({
                kind: this.getSuggestionKind('array'),
                label: 'Empty array',
                insertText: this.getInsertTextForValue([], ''),
                insertTextFormat: main_InsertTextFormat.Snippet,
                documentation: ''
            });
            return;
        }
        var separatorAfter = this.evaluateSeparatorAfter(document, offsetForSeparator);
        var collectSuggestionsForValues = function (value) {
            if (!jsonParser_contains(value.parent, offset, true)) {
                collector.add({
                    kind: _this.getSuggestionKind(value.type),
                    label: _this.getLabelTextForMatchingNode(value, document),
                    insertText: _this.getInsertTextForMatchingNode(value, document, separatorAfter),
                    insertTextFormat: main_InsertTextFormat.Snippet, documentation: ''
                });
            }
            if (value.type === 'boolean') {
                _this.addBooleanValueCompletion(!value.value, separatorAfter, collector);
            }
        };
        if (node.type === 'property') {
            if (offset > node.colonOffset) {
                var valueNode = node.valueNode;
                if (valueNode && (offset > (valueNode.offset + valueNode.length) || valueNode.type === 'object' || valueNode.type === 'array')) {
                    return;
                }
                // suggest values at the same key
                var parentKey_2 = node.keyNode.value;
                doc.visit(function (n) {
                    if (n.type === 'property' && n.keyNode.value === parentKey_2 && n.valueNode) {
                        collectSuggestionsForValues(n.valueNode);
                    }
                    return true;
                });
                if (parentKey_2 === '$schema' && node.parent && !node.parent.parent) {
                    this.addDollarSchemaCompletions(separatorAfter, collector);
                }
            }
        }
        if (node.type === 'array') {
            if (node.parent && node.parent.type === 'property') {
                // suggest items of an array at the same key
                var parentKey_3 = node.parent.keyNode.value;
                doc.visit(function (n) {
                    if (n.type === 'property' && n.keyNode.value === parentKey_3 && n.valueNode && n.valueNode.type === 'array') {
                        n.valueNode.items.forEach(collectSuggestionsForValues);
                    }
                    return true;
                });
            }
            else {
                // suggest items in the same array
                node.items.forEach(collectSuggestionsForValues);
            }
        }
    };
    JSONCompletion.prototype.getValueCompletions = function (schema, doc, node, offset, document, collector, types) {
        var _this = this;
        var offsetForSeparator = offset;
        var parentKey = null;
        var valueNode = null;
        if (node && (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null')) {
            offsetForSeparator = node.offset + node.length;
            valueNode = node;
            node = node.parent;
        }
        if (!node) {
            this.addSchemaValueCompletions(schema.schema, '', collector, types);
            return;
        }
        if ((node.type === 'property') && offset > node.colonOffset) {
            var valueNode_1 = node.valueNode;
            if (valueNode_1 && offset > (valueNode_1.offset + valueNode_1.length)) {
                return; // we are past the value node
            }
            parentKey = node.keyNode.value;
            node = node.parent;
        }
        if (node && (parentKey !== null || node.type === 'array')) {
            var separatorAfter_2 = this.evaluateSeparatorAfter(document, offsetForSeparator);
            var matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset, valueNode);
            matchingSchemas.forEach(function (s) {
                if (s.node === node && !s.inverted && s.schema) {
                    if (node.type === 'array' && s.schema.items) {
                        if (Array.isArray(s.schema.items)) {
                            var index = _this.findItemAtOffset(node, document, offset);
                            if (index < s.schema.items.length) {
                                _this.addSchemaValueCompletions(s.schema.items[index], separatorAfter_2, collector, types);
                            }
                        }
                        else {
                            _this.addSchemaValueCompletions(s.schema.items, separatorAfter_2, collector, types);
                        }
                    }
                    if (s.schema.properties) {
                        var propertySchema = s.schema.properties[parentKey];
                        if (propertySchema) {
                            _this.addSchemaValueCompletions(propertySchema, separatorAfter_2, collector, types);
                        }
                    }
                }
            });
            if (parentKey === '$schema' && !node.parent) {
                this.addDollarSchemaCompletions(separatorAfter_2, collector);
            }
            if (types['boolean']) {
                this.addBooleanValueCompletion(true, separatorAfter_2, collector);
                this.addBooleanValueCompletion(false, separatorAfter_2, collector);
            }
            if (types['null']) {
                this.addNullValueCompletion(separatorAfter_2, collector);
            }
        }
    };
    JSONCompletion.prototype.getContributedValueCompletions = function (doc, node, offset, document, collector, collectionPromises) {
        if (!node) {
            this.contributions.forEach(function (contribution) {
                var collectPromise = contribution.collectDefaultCompletions(document.uri, collector);
                if (collectPromise) {
                    collectionPromises.push(collectPromise);
                }
            });
        }
        else {
            if (node.type === 'string' || node.type === 'number' || node.type === 'boolean' || node.type === 'null') {
                node = node.parent;
            }
            if ((node.type === 'property') && offset > node.colonOffset) {
                var parentKey_4 = node.keyNode.value;
                var valueNode = node.valueNode;
                if (!valueNode || offset <= (valueNode.offset + valueNode.length)) {
                    var location_2 = jsonParser_getNodePath(node.parent);
                    this.contributions.forEach(function (contribution) {
                        var collectPromise = contribution.collectValueCompletions(document.uri, location_2, parentKey_4, collector);
                        if (collectPromise) {
                            collectionPromises.push(collectPromise);
                        }
                    });
                }
            }
        }
    };
    JSONCompletion.prototype.addSchemaValueCompletions = function (schema, separatorAfter, collector, types) {
        var _this = this;
        if (typeof schema === 'object') {
            this.addEnumValueCompletions(schema, separatorAfter, collector);
            this.addDefaultValueCompletions(schema, separatorAfter, collector);
            this.collectTypes(schema, types);
            if (Array.isArray(schema.allOf)) {
                schema.allOf.forEach(function (s) { return _this.addSchemaValueCompletions(s, separatorAfter, collector, types); });
            }
            if (Array.isArray(schema.anyOf)) {
                schema.anyOf.forEach(function (s) { return _this.addSchemaValueCompletions(s, separatorAfter, collector, types); });
            }
            if (Array.isArray(schema.oneOf)) {
                schema.oneOf.forEach(function (s) { return _this.addSchemaValueCompletions(s, separatorAfter, collector, types); });
            }
        }
    };
    JSONCompletion.prototype.addDefaultValueCompletions = function (schema, separatorAfter, collector, arrayDepth) {
        var _this = this;
        if (arrayDepth === void 0) { arrayDepth = 0; }
        var hasProposals = false;
        if (isDefined(schema.default)) {
            var type = schema.type;
            var value = schema.default;
            for (var i = arrayDepth; i > 0; i--) {
                value = [value];
                type = 'array';
            }
            collector.add({
                kind: this.getSuggestionKind(type),
                label: this.getLabelForValue(value),
                insertText: this.getInsertTextForValue(value, separatorAfter),
                insertTextFormat: main_InsertTextFormat.Snippet,
                detail: jsonCompletion_localize('json.suggest.default', 'Default value')
            });
            hasProposals = true;
        }
        if (Array.isArray(schema.examples)) {
            schema.examples.forEach(function (example) {
                var type = schema.type;
                var value = example;
                for (var i = arrayDepth; i > 0; i--) {
                    value = [value];
                    type = 'array';
                }
                collector.add({
                    kind: _this.getSuggestionKind(type),
                    label: _this.getLabelForValue(value),
                    insertText: _this.getInsertTextForValue(value, separatorAfter),
                    insertTextFormat: main_InsertTextFormat.Snippet
                });
                hasProposals = true;
            });
        }
        if (Array.isArray(schema.defaultSnippets)) {
            schema.defaultSnippets.forEach(function (s) {
                var type = schema.type;
                var value = s.body;
                var label = s.label;
                var insertText;
                var filterText;
                if (isDefined(value)) {
                    var type_1 = schema.type;
                    for (var i = arrayDepth; i > 0; i--) {
                        value = [value];
                        type_1 = 'array';
                    }
                    insertText = _this.getInsertTextForSnippetValue(value, separatorAfter);
                    filterText = _this.getFilterTextForSnippetValue(value);
                    label = label || _this.getLabelForSnippetValue(value);
                }
                else if (typeof s.bodyText === 'string') {
                    var prefix = '', suffix = '', indent = '';
                    for (var i = arrayDepth; i > 0; i--) {
                        prefix = prefix + indent + '[\n';
                        suffix = suffix + '\n' + indent + ']';
                        indent += '\t';
                        type = 'array';
                    }
                    insertText = prefix + indent + s.bodyText.split('\n').join('\n' + indent) + suffix + separatorAfter;
                    label = label || insertText,
                        filterText = insertText.replace(/[\n]/g, ''); // remove new lines
                }
                collector.add({
                    kind: _this.getSuggestionKind(type),
                    label: label,
                    documentation: _this.fromMarkup(s.markdownDescription) || s.description,
                    insertText: insertText,
                    insertTextFormat: main_InsertTextFormat.Snippet,
                    filterText: filterText
                });
                hasProposals = true;
            });
        }
        if (!hasProposals && typeof schema.items === 'object' && !Array.isArray(schema.items)) {
            this.addDefaultValueCompletions(schema.items, separatorAfter, collector, arrayDepth + 1);
        }
    };
    JSONCompletion.prototype.addEnumValueCompletions = function (schema, separatorAfter, collector) {
        if (isDefined(schema.const)) {
            collector.add({
                kind: this.getSuggestionKind(schema.type),
                label: this.getLabelForValue(schema.const),
                insertText: this.getInsertTextForValue(schema.const, separatorAfter),
                insertTextFormat: main_InsertTextFormat.Snippet,
                documentation: this.fromMarkup(schema.markdownDescription) || schema.description
            });
        }
        if (Array.isArray(schema.enum)) {
            for (var i = 0, length = schema.enum.length; i < length; i++) {
                var enm = schema.enum[i];
                var documentation = this.fromMarkup(schema.markdownDescription) || schema.description;
                if (schema.markdownEnumDescriptions && i < schema.markdownEnumDescriptions.length && this.doesSupportMarkdown()) {
                    documentation = this.fromMarkup(schema.markdownEnumDescriptions[i]);
                }
                else if (schema.enumDescriptions && i < schema.enumDescriptions.length) {
                    documentation = schema.enumDescriptions[i];
                }
                collector.add({
                    kind: this.getSuggestionKind(schema.type),
                    label: this.getLabelForValue(enm),
                    insertText: this.getInsertTextForValue(enm, separatorAfter),
                    insertTextFormat: main_InsertTextFormat.Snippet,
                    documentation: documentation
                });
            }
        }
    };
    JSONCompletion.prototype.collectTypes = function (schema, types) {
        if (Array.isArray(schema.enum) || isDefined(schema.const)) {
            return;
        }
        var type = schema.type;
        if (Array.isArray(type)) {
            type.forEach(function (t) { return types[t] = true; });
        }
        else {
            types[type] = true;
        }
    };
    JSONCompletion.prototype.addFillerValueCompletions = function (types, separatorAfter, collector) {
        if (types['object']) {
            collector.add({
                kind: this.getSuggestionKind('object'),
                label: '{}',
                insertText: this.getInsertTextForGuessedValue({}, separatorAfter),
                insertTextFormat: main_InsertTextFormat.Snippet,
                detail: jsonCompletion_localize('defaults.object', 'New object'),
                documentation: ''
            });
        }
        if (types['array']) {
            collector.add({
                kind: this.getSuggestionKind('array'),
                label: '[]',
                insertText: this.getInsertTextForGuessedValue([], separatorAfter),
                insertTextFormat: main_InsertTextFormat.Snippet,
                detail: jsonCompletion_localize('defaults.array', 'New array'),
                documentation: ''
            });
        }
    };
    JSONCompletion.prototype.addBooleanValueCompletion = function (value, separatorAfter, collector) {
        collector.add({
            kind: this.getSuggestionKind('boolean'),
            label: value ? 'true' : 'false',
            insertText: this.getInsertTextForValue(value, separatorAfter),
            insertTextFormat: main_InsertTextFormat.Snippet,
            documentation: ''
        });
    };
    JSONCompletion.prototype.addNullValueCompletion = function (separatorAfter, collector) {
        collector.add({
            kind: this.getSuggestionKind('null'),
            label: 'null',
            insertText: 'null' + separatorAfter,
            insertTextFormat: main_InsertTextFormat.Snippet,
            documentation: ''
        });
    };
    JSONCompletion.prototype.addDollarSchemaCompletions = function (separatorAfter, collector) {
        var _this = this;
        var schemaIds = this.schemaService.getRegisteredSchemaIds(function (schema) { return schema === 'http' || schema === 'https'; });
        schemaIds.forEach(function (schemaId) { return collector.add({
            kind: vscode_languageserver_types_main_CompletionItemKind.Module,
            label: _this.getLabelForValue(schemaId),
            filterText: _this.getFilterTextForValue(schemaId),
            insertText: _this.getInsertTextForValue(schemaId, separatorAfter),
            insertTextFormat: main_InsertTextFormat.Snippet, documentation: ''
        }); });
    };
    JSONCompletion.prototype.getLabelForValue = function (value) {
        return JSON.stringify(value);
    };
    JSONCompletion.prototype.getFilterTextForValue = function (value) {
        return JSON.stringify(value);
    };
    JSONCompletion.prototype.getFilterTextForSnippetValue = function (value) {
        return JSON.stringify(value).replace(/\$\{\d+:([^}]+)\}|\$\d+/g, '$1');
    };
    JSONCompletion.prototype.getLabelForSnippetValue = function (value) {
        var label = JSON.stringify(value);
        return label.replace(/\$\{\d+:([^}]+)\}|\$\d+/g, '$1');
    };
    JSONCompletion.prototype.getInsertTextForPlainText = function (text) {
        return text.replace(/[\\\$\}]/g, '\\$&'); // escape $, \ and } 
    };
    JSONCompletion.prototype.getInsertTextForValue = function (value, separatorAfter) {
        var text = JSON.stringify(value, null, '\t');
        if (text === '{}') {
            return '{$1}' + separatorAfter;
        }
        else if (text === '[]') {
            return '[$1]' + separatorAfter;
        }
        return this.getInsertTextForPlainText(text + separatorAfter);
    };
    JSONCompletion.prototype.getInsertTextForSnippetValue = function (value, separatorAfter) {
        var replacer = function (value) {
            if (typeof value === 'string') {
                if (value[0] === '^') {
                    return value.substr(1);
                }
            }
            return JSON.stringify(value);
        };
        return stringifyObject(value, '', replacer) + separatorAfter;
    };
    JSONCompletion.prototype.getInsertTextForGuessedValue = function (value, separatorAfter) {
        switch (typeof value) {
            case 'object':
                if (value === null) {
                    return '${1:null}' + separatorAfter;
                }
                return this.getInsertTextForValue(value, separatorAfter);
            case 'string':
                var snippetValue = JSON.stringify(value);
                snippetValue = snippetValue.substr(1, snippetValue.length - 2); // remove quotes
                snippetValue = this.getInsertTextForPlainText(snippetValue); // escape \ and }
                return '"${1:' + snippetValue + '}"' + separatorAfter;
            case 'number':
            case 'boolean':
                return '${1:' + JSON.stringify(value) + '}' + separatorAfter;
        }
        return this.getInsertTextForValue(value, separatorAfter);
    };
    JSONCompletion.prototype.getSuggestionKind = function (type) {
        if (Array.isArray(type)) {
            var array = type;
            type = array.length > 0 ? array[0] : null;
        }
        if (!type) {
            return vscode_languageserver_types_main_CompletionItemKind.Value;
        }
        switch (type) {
            case 'string': return vscode_languageserver_types_main_CompletionItemKind.Value;
            case 'object': return vscode_languageserver_types_main_CompletionItemKind.Module;
            case 'property': return vscode_languageserver_types_main_CompletionItemKind.Property;
            default: return vscode_languageserver_types_main_CompletionItemKind.Value;
        }
    };
    JSONCompletion.prototype.getLabelTextForMatchingNode = function (node, document) {
        switch (node.type) {
            case 'array':
                return '[]';
            case 'object':
                return '{}';
            default:
                var content = document.getText().substr(node.offset, node.length);
                return content;
        }
    };
    JSONCompletion.prototype.getInsertTextForMatchingNode = function (node, document, separatorAfter) {
        switch (node.type) {
            case 'array':
                return this.getInsertTextForValue([], separatorAfter);
            case 'object':
                return this.getInsertTextForValue({}, separatorAfter);
            default:
                var content = document.getText().substr(node.offset, node.length) + separatorAfter;
                return this.getInsertTextForPlainText(content);
        }
    };
    JSONCompletion.prototype.getInsertTextForProperty = function (key, propertySchema, addValue, separatorAfter) {
        var propertyText = this.getInsertTextForValue(key, '');
        if (!addValue) {
            return propertyText;
        }
        var resultText = propertyText + ': ';
        var value;
        var nValueProposals = 0;
        if (propertySchema) {
            if (Array.isArray(propertySchema.defaultSnippets)) {
                if (propertySchema.defaultSnippets.length === 1) {
                    var body = propertySchema.defaultSnippets[0].body;
                    if (isDefined(body)) {
                        value = this.getInsertTextForSnippetValue(body, '');
                    }
                }
                nValueProposals += propertySchema.defaultSnippets.length;
            }
            if (propertySchema.enum) {
                if (!value && propertySchema.enum.length === 1) {
                    value = this.getInsertTextForGuessedValue(propertySchema.enum[0], '');
                }
                nValueProposals += propertySchema.enum.length;
            }
            if (isDefined(propertySchema.default)) {
                if (!value) {
                    value = this.getInsertTextForGuessedValue(propertySchema.default, '');
                }
                nValueProposals++;
            }
            if (Array.isArray(propertySchema.examples) && propertySchema.examples.length) {
                if (!value) {
                    value = this.getInsertTextForGuessedValue(propertySchema.examples[0], '');
                }
                nValueProposals += propertySchema.examples.length;
            }
            if (nValueProposals === 0) {
                var type = Array.isArray(propertySchema.type) ? propertySchema.type[0] : propertySchema.type;
                if (!type) {
                    if (propertySchema.properties) {
                        type = 'object';
                    }
                    else if (propertySchema.items) {
                        type = 'array';
                    }
                }
                switch (type) {
                    case 'boolean':
                        value = '$1';
                        break;
                    case 'string':
                        value = '"$1"';
                        break;
                    case 'object':
                        value = '{$1}';
                        break;
                    case 'array':
                        value = '[$1]';
                        break;
                    case 'number':
                    case 'integer':
                        value = '${1:0}';
                        break;
                    case 'null':
                        value = '${1:null}';
                        break;
                    default:
                        return propertyText;
                }
            }
        }
        if (!value || nValueProposals > 1) {
            value = '$1';
        }
        return resultText + value + separatorAfter;
    };
    JSONCompletion.prototype.getCurrentWord = function (document, offset) {
        var i = offset - 1;
        var text = document.getText();
        while (i >= 0 && ' \t\n\r\v":{[,]}'.indexOf(text.charAt(i)) === -1) {
            i--;
        }
        return text.substring(i + 1, offset);
    };
    JSONCompletion.prototype.evaluateSeparatorAfter = function (document, offset) {
        var scanner = main_createScanner(document.getText(), true);
        scanner.setPosition(offset);
        var token = scanner.scan();
        switch (token) {
            case 5 /* CommaToken */:
            case 2 /* CloseBraceToken */:
            case 4 /* CloseBracketToken */:
            case 17 /* EOF */:
                return '';
            default:
                return ',';
        }
    };
    JSONCompletion.prototype.findItemAtOffset = function (node, document, offset) {
        var scanner = main_createScanner(document.getText(), true);
        var children = node.items;
        for (var i = children.length - 1; i >= 0; i--) {
            var child = children[i];
            if (offset > child.offset + child.length) {
                scanner.setPosition(child.offset + child.length);
                var token = scanner.scan();
                if (token === 5 /* CommaToken */ && offset >= scanner.getTokenOffset() + scanner.getTokenLength()) {
                    return i + 1;
                }
                return i;
            }
            else if (offset >= child.offset) {
                return i;
            }
        }
        return 0;
    };
    JSONCompletion.prototype.isInComment = function (document, start, offset) {
        var scanner = main_createScanner(document.getText(), false);
        scanner.setPosition(start);
        var token = scanner.scan();
        while (token !== 17 /* EOF */ && (scanner.getTokenOffset() + scanner.getTokenLength() < offset)) {
            token = scanner.scan();
        }
        return (token === 12 /* LineCommentTrivia */ || token === 13 /* BlockCommentTrivia */) && scanner.getTokenOffset() <= offset;
    };
    JSONCompletion.prototype.fromMarkup = function (markupString) {
        if (markupString && this.doesSupportMarkdown()) {
            return {
                kind: main_MarkupKind.Markdown,
                value: markupString
            };
        }
        return undefined;
    };
    JSONCompletion.prototype.doesSupportMarkdown = function () {
        if (!isDefined(this.supportsMarkdown)) {
            var completion = this.clientCapabilities.textDocument && this.clientCapabilities.textDocument.completion;
            this.supportsMarkdown = completion && completion.completionItem && Array.isArray(completion.completionItem.documentationFormat) && completion.completionItem.documentationFormat.indexOf(main_MarkupKind.Markdown) !== -1;
        }
        return this.supportsMarkdown;
    };
    JSONCompletion.prototype.doesSupportsCommitCharacters = function () {
        if (!isDefined(this.supportsCommitCharacters)) {
            var completion = this.clientCapabilities.textDocument && this.clientCapabilities.textDocument.completion;
            this.supportsCommitCharacters = completion && completion.completionItem && !!completion.completionItem.commitCharactersSupport;
        }
        return this.supportsCommitCharacters;
    };
    return JSONCompletion;
}());


// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/vscode-json-languageservice/lib/esm/services/jsonHover.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


var jsonHover_JSONHover = /** @class */ (function () {
    function JSONHover(schemaService, contributions, promiseConstructor) {
        if (contributions === void 0) { contributions = []; }
        this.schemaService = schemaService;
        this.contributions = contributions;
        this.promise = promiseConstructor || Promise;
    }
    JSONHover.prototype.doHover = function (document, position, doc) {
        var offset = document.offsetAt(position);
        var node = doc.getNodeFromOffset(offset);
        if (!node || (node.type === 'object' || node.type === 'array') && offset > node.offset + 1 && offset < node.offset + node.length - 1) {
            return this.promise.resolve(null);
        }
        var hoverRangeNode = node;
        // use the property description when hovering over an object key
        if (node.type === 'string') {
            var parent = node.parent;
            if (parent && parent.type === 'property' && parent.keyNode === node) {
                node = parent.valueNode;
                if (!node) {
                    return this.promise.resolve(null);
                }
            }
        }
        var hoverRange = vscode_languageserver_types_main_Range.create(document.positionAt(hoverRangeNode.offset), document.positionAt(hoverRangeNode.offset + hoverRangeNode.length));
        var createHover = function (contents) {
            var result = {
                contents: contents,
                range: hoverRange
            };
            return result;
        };
        var location = jsonParser_getNodePath(node);
        for (var i = this.contributions.length - 1; i >= 0; i--) {
            var contribution = this.contributions[i];
            var promise = contribution.getInfoContribution(document.uri, location);
            if (promise) {
                return promise.then(function (htmlContent) { return createHover(htmlContent); });
            }
        }
        return this.schemaService.getSchemaForResource(document.uri, doc).then(function (schema) {
            if (schema) {
                var matchingSchemas = doc.getMatchingSchemas(schema.schema, node.offset);
                var title_1 = null;
                var markdownDescription_1 = null;
                var markdownEnumValueDescription_1 = null, enumValue_1 = null;
                matchingSchemas.every(function (s) {
                    if (s.node === node && !s.inverted && s.schema) {
                        title_1 = title_1 || s.schema.title;
                        markdownDescription_1 = markdownDescription_1 || s.schema.markdownDescription || toMarkdown(s.schema.description);
                        if (s.schema.enum) {
                            var idx = s.schema.enum.indexOf(jsonParser_getNodeValue(node));
                            if (s.schema.markdownEnumDescriptions) {
                                markdownEnumValueDescription_1 = s.schema.markdownEnumDescriptions[idx];
                            }
                            else if (s.schema.enumDescriptions) {
                                markdownEnumValueDescription_1 = toMarkdown(s.schema.enumDescriptions[idx]);
                            }
                            if (markdownEnumValueDescription_1) {
                                enumValue_1 = s.schema.enum[idx];
                                if (typeof enumValue_1 !== 'string') {
                                    enumValue_1 = JSON.stringify(enumValue_1);
                                }
                            }
                        }
                    }
                    return true;
                });
                var result = '';
                if (title_1) {
                    result = toMarkdown(title_1);
                }
                if (markdownDescription_1) {
                    if (result.length > 0) {
                        result += "\n\n";
                    }
                    result += markdownDescription_1;
                }
                if (markdownEnumValueDescription_1) {
                    if (result.length > 0) {
                        result += "\n\n";
                    }
                    result += "`" + toMarkdownCodeBlock(enumValue_1) + "`: " + markdownEnumValueDescription_1;
                }
                return createHover([result]);
            }
            return null;
        });
    };
    return JSONHover;
}());

function toMarkdown(plain) {
    if (plain) {
        var res = plain.replace(/([^\n\r])(\r?\n)([^\n\r])/gm, '$1\n\n$3'); // single new lines to \n\n (Markdown paragraph)
        return res.replace(/[\\`*_{}[\]()#+\-.!]/g, "\\$&"); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
    }
    return void 0;
}
function toMarkdownCodeBlock(content) {
    // see https://daringfireball.net/projects/markdown/syntax#precode
    if (content.indexOf('`') !== -1) {
        return '`` ' + content + ' ``';
    }
    return content;
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/vscode-json-languageservice/lib/esm/services/jsonValidation.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/




var jsonValidation_localize = loadMessageBundle();
var jsonValidation_JSONValidation = /** @class */ (function () {
    function JSONValidation(jsonSchemaService, promiseConstructor) {
        this.jsonSchemaService = jsonSchemaService;
        this.promise = promiseConstructor;
        this.validationEnabled = true;
    }
    JSONValidation.prototype.configure = function (raw) {
        if (raw) {
            this.validationEnabled = raw.validate;
            this.commentSeverity = raw.allowComments ? void 0 : main_DiagnosticSeverity.Error;
        }
    };
    JSONValidation.prototype.doValidation = function (textDocument, jsonDocument, documentSettings, schema) {
        var _this = this;
        if (!this.validationEnabled) {
            return this.promise.resolve([]);
        }
        var diagnostics = [];
        var added = {};
        var addProblem = function (problem) {
            // remove duplicated messages
            var signature = problem.range.start.line + ' ' + problem.range.start.character + ' ' + problem.message;
            if (!added[signature]) {
                added[signature] = true;
                diagnostics.push(problem);
            }
        };
        var getDiagnostics = function (schema) {
            var trailingCommaSeverity = documentSettings ? toDiagnosticSeverity(documentSettings.trailingCommas) : main_DiagnosticSeverity.Error;
            var commentSeverity = documentSettings ? toDiagnosticSeverity(documentSettings.comments) : _this.commentSeverity;
            if (schema) {
                if (schema.errors.length && jsonDocument.root) {
                    var astRoot = jsonDocument.root;
                    var property = astRoot.type === 'object' ? astRoot.properties[0] : null;
                    if (property && property.keyNode.value === '$schema') {
                        var node = property.valueNode || property;
                        var range = vscode_languageserver_types_main_Range.create(textDocument.positionAt(node.offset), textDocument.positionAt(node.offset + node.length));
                        addProblem(main_Diagnostic.create(range, schema.errors[0], main_DiagnosticSeverity.Warning, ErrorCode.SchemaResolveError));
                    }
                    else {
                        var range = vscode_languageserver_types_main_Range.create(textDocument.positionAt(astRoot.offset), textDocument.positionAt(astRoot.offset + 1));
                        addProblem(main_Diagnostic.create(range, schema.errors[0], main_DiagnosticSeverity.Warning, ErrorCode.SchemaResolveError));
                    }
                }
                else {
                    var semanticErrors = jsonDocument.validate(textDocument, schema.schema);
                    if (semanticErrors) {
                        semanticErrors.forEach(addProblem);
                    }
                }
                if (schemaAllowsComments(schema.schema)) {
                    commentSeverity = void 0;
                }
                if (schemaAllowsTrailingCommas(schema.schema)) {
                    trailingCommaSeverity = void 0;
                }
            }
            for (var _i = 0, _a = jsonDocument.syntaxErrors; _i < _a.length; _i++) {
                var p = _a[_i];
                if (p.code === ErrorCode.TrailingComma) {
                    if (typeof trailingCommaSeverity !== 'number') {
                        continue;
                    }
                    p.severity = trailingCommaSeverity;
                }
                addProblem(p);
            }
            if (typeof commentSeverity === 'number') {
                var message_1 = jsonValidation_localize('InvalidCommentToken', 'Comments are not permitted in JSON.');
                jsonDocument.comments.forEach(function (c) {
                    addProblem(main_Diagnostic.create(c, message_1, commentSeverity, ErrorCode.CommentNotPermitted));
                });
            }
            return diagnostics;
        };
        if (schema) {
            var id = schema.id || ('schemaservice://untitled/' + idCounter++);
            return this.jsonSchemaService.resolveSchemaContent(new UnresolvedSchema(schema), id, {}).then(function (resolvedSchema) {
                return getDiagnostics(resolvedSchema);
            });
        }
        return this.jsonSchemaService.getSchemaForResource(textDocument.uri, jsonDocument).then(function (schema) {
            return getDiagnostics(schema);
        });
    };
    return JSONValidation;
}());

var idCounter = 0;
function schemaAllowsComments(schemaRef) {
    if (schemaRef && typeof schemaRef === 'object') {
        if (objects_isBoolean(schemaRef.allowComments)) {
            return schemaRef.allowComments;
        }
        if (schemaRef.allOf) {
            for (var _i = 0, _a = schemaRef.allOf; _i < _a.length; _i++) {
                var schema = _a[_i];
                var allow = schemaAllowsComments(schema);
                if (objects_isBoolean(allow)) {
                    return allow;
                }
            }
        }
    }
    return undefined;
}
function schemaAllowsTrailingCommas(schemaRef) {
    if (schemaRef && typeof schemaRef === 'object') {
        if (objects_isBoolean(schemaRef.allowTrailingCommas)) {
            return schemaRef.allowTrailingCommas;
        }
        if (objects_isBoolean(schemaRef['allowsTrailingCommas'])) { // deprecated
            return schemaRef['allowsTrailingCommas'];
        }
        if (schemaRef.allOf) {
            for (var _i = 0, _a = schemaRef.allOf; _i < _a.length; _i++) {
                var schema = _a[_i];
                var allow = schemaAllowsTrailingCommas(schema);
                if (objects_isBoolean(allow)) {
                    return allow;
                }
            }
        }
    }
    return undefined;
}
function toDiagnosticSeverity(severityLevel) {
    switch (severityLevel) {
        case 'error': return main_DiagnosticSeverity.Error;
        case 'warning': return main_DiagnosticSeverity.Warning;
        case 'ignore': return void 0;
    }
    return void 0;
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/vscode-json-languageservice/lib/esm/utils/colors.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var Digit0 = 48;
var Digit9 = 57;
var A = 65;
var colors_a = 97;
var colors_f = 102;
function hexDigit(charCode) {
    if (charCode < Digit0) {
        return 0;
    }
    if (charCode <= Digit9) {
        return charCode - Digit0;
    }
    if (charCode < colors_a) {
        charCode += (colors_a - A);
    }
    if (charCode >= colors_a && charCode <= colors_f) {
        return charCode - colors_a + 10;
    }
    return 0;
}
function colorFromHex(text) {
    if (text[0] !== '#') {
        return null;
    }
    switch (text.length) {
        case 4:
            return {
                red: (hexDigit(text.charCodeAt(1)) * 0x11) / 255.0,
                green: (hexDigit(text.charCodeAt(2)) * 0x11) / 255.0,
                blue: (hexDigit(text.charCodeAt(3)) * 0x11) / 255.0,
                alpha: 1
            };
        case 5:
            return {
                red: (hexDigit(text.charCodeAt(1)) * 0x11) / 255.0,
                green: (hexDigit(text.charCodeAt(2)) * 0x11) / 255.0,
                blue: (hexDigit(text.charCodeAt(3)) * 0x11) / 255.0,
                alpha: (hexDigit(text.charCodeAt(4)) * 0x11) / 255.0,
            };
        case 7:
            return {
                red: (hexDigit(text.charCodeAt(1)) * 0x10 + hexDigit(text.charCodeAt(2))) / 255.0,
                green: (hexDigit(text.charCodeAt(3)) * 0x10 + hexDigit(text.charCodeAt(4))) / 255.0,
                blue: (hexDigit(text.charCodeAt(5)) * 0x10 + hexDigit(text.charCodeAt(6))) / 255.0,
                alpha: 1
            };
        case 9:
            return {
                red: (hexDigit(text.charCodeAt(1)) * 0x10 + hexDigit(text.charCodeAt(2))) / 255.0,
                green: (hexDigit(text.charCodeAt(3)) * 0x10 + hexDigit(text.charCodeAt(4))) / 255.0,
                blue: (hexDigit(text.charCodeAt(5)) * 0x10 + hexDigit(text.charCodeAt(6))) / 255.0,
                alpha: (hexDigit(text.charCodeAt(7)) * 0x10 + hexDigit(text.charCodeAt(8))) / 255.0
            };
    }
    return null;
}
function colorFrom256RGB(red, green, blue, alpha) {
    if (alpha === void 0) { alpha = 1.0; }
    return {
        red: red / 255.0,
        green: green / 255.0,
        blue: blue / 255.0,
        alpha: alpha
    };
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/vscode-json-languageservice/lib/esm/services/jsonDocumentSymbols.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/




var jsonDocumentSymbols_JSONDocumentSymbols = /** @class */ (function () {
    function JSONDocumentSymbols(schemaService) {
        this.schemaService = schemaService;
    }
    JSONDocumentSymbols.prototype.findDocumentSymbols = function (document, doc, context) {
        var _this = this;
        if (context === void 0) { context = { resultLimit: Number.MAX_VALUE }; }
        var root = doc.root;
        if (!root) {
            return null;
        }
        var limit = context.resultLimit;
        // special handling for key bindings
        var resourceString = document.uri;
        if ((resourceString === 'vscode://defaultsettings/keybindings.json') || strings_endsWith(resourceString.toLowerCase(), '/user/keybindings.json')) {
            if (root.type === 'array') {
                var result_1 = [];
                for (var _i = 0, _a = root.items; _i < _a.length; _i++) {
                    var item = _a[_i];
                    if (item.type === 'object') {
                        for (var _b = 0, _c = item.properties; _b < _c.length; _b++) {
                            var property = _c[_b];
                            if (property.keyNode.value === 'key' && property.valueNode) {
                                var location = main_Location.create(document.uri, getRange(document, item));
                                result_1.push({ name: jsonParser_getNodeValue(property.valueNode), kind: vscode_languageserver_types_main_SymbolKind.Function, location: location });
                                limit--;
                                if (limit <= 0) {
                                    if (context && context.onResultLimitExceeded) {
                                        context.onResultLimitExceeded(resourceString);
                                    }
                                    return result_1;
                                }
                            }
                        }
                    }
                }
                return result_1;
            }
        }
        var toVisit = [
            { node: root, containerName: '' }
        ];
        var nextToVisit = 0;
        var limitExceeded = false;
        var result = [];
        var collectOutlineEntries = function (node, containerName) {
            if (node.type === 'array') {
                node.items.forEach(function (node) {
                    if (node) {
                        toVisit.push({ node: node, containerName: containerName });
                    }
                });
            }
            else if (node.type === 'object') {
                node.properties.forEach(function (property) {
                    var valueNode = property.valueNode;
                    if (valueNode) {
                        if (limit > 0) {
                            limit--;
                            var location = main_Location.create(document.uri, getRange(document, property));
                            var childContainerName = containerName ? containerName + '.' + property.keyNode.value : property.keyNode.value;
                            result.push({ name: _this.getKeyLabel(property), kind: _this.getSymbolKind(valueNode.type), location: location, containerName: containerName });
                            toVisit.push({ node: valueNode, containerName: childContainerName });
                        }
                        else {
                            limitExceeded = true;
                        }
                    }
                });
            }
        };
        // breath first traversal
        while (nextToVisit < toVisit.length) {
            var next = toVisit[nextToVisit++];
            collectOutlineEntries(next.node, next.containerName);
        }
        if (limitExceeded && context && context.onResultLimitExceeded) {
            context.onResultLimitExceeded(resourceString);
        }
        return result;
    };
    JSONDocumentSymbols.prototype.findDocumentSymbols2 = function (document, doc, context) {
        var _this = this;
        if (context === void 0) { context = { resultLimit: Number.MAX_VALUE }; }
        var root = doc.root;
        if (!root) {
            return null;
        }
        var limit = context.resultLimit;
        // special handling for key bindings
        var resourceString = document.uri;
        if ((resourceString === 'vscode://defaultsettings/keybindings.json') || strings_endsWith(resourceString.toLowerCase(), '/user/keybindings.json')) {
            if (root.type === 'array') {
                var result_2 = [];
                for (var _i = 0, _a = root.items; _i < _a.length; _i++) {
                    var item = _a[_i];
                    if (item.type === 'object') {
                        for (var _b = 0, _c = item.properties; _b < _c.length; _b++) {
                            var property = _c[_b];
                            if (property.keyNode.value === 'key' && property.valueNode) {
                                var range = getRange(document, item);
                                var selectionRange = getRange(document, property.keyNode);
                                result_2.push({ name: jsonParser_getNodeValue(property.valueNode), kind: vscode_languageserver_types_main_SymbolKind.Function, range: range, selectionRange: selectionRange });
                                limit--;
                                if (limit <= 0) {
                                    if (context && context.onResultLimitExceeded) {
                                        context.onResultLimitExceeded(resourceString);
                                    }
                                    return result_2;
                                }
                            }
                        }
                    }
                }
                return result_2;
            }
        }
        var result = [];
        var toVisit = [
            { node: root, result: result }
        ];
        var nextToVisit = 0;
        var limitExceeded = false;
        var collectOutlineEntries = function (node, result) {
            if (node.type === 'array') {
                node.items.forEach(function (node, index) {
                    if (node) {
                        if (limit > 0) {
                            limit--;
                            var range = getRange(document, node);
                            var selectionRange = range;
                            var name = String(index);
                            var symbol = { name: name, kind: _this.getSymbolKind(node.type), range: range, selectionRange: selectionRange, children: [] };
                            result.push(symbol);
                            toVisit.push({ result: symbol.children, node: node });
                        }
                        else {
                            limitExceeded = true;
                        }
                    }
                });
            }
            else if (node.type === 'object') {
                node.properties.forEach(function (property) {
                    var valueNode = property.valueNode;
                    if (valueNode) {
                        if (limit > 0) {
                            limit--;
                            var range = getRange(document, property);
                            var selectionRange = getRange(document, property.keyNode);
                            var symbol = { name: _this.getKeyLabel(property), kind: _this.getSymbolKind(valueNode.type), range: range, selectionRange: selectionRange, children: [] };
                            result.push(symbol);
                            toVisit.push({ result: symbol.children, node: valueNode });
                        }
                        else {
                            limitExceeded = true;
                        }
                    }
                });
            }
        };
        // breath first traversal
        while (nextToVisit < toVisit.length) {
            var next = toVisit[nextToVisit++];
            collectOutlineEntries(next.node, next.result);
        }
        if (limitExceeded && context && context.onResultLimitExceeded) {
            context.onResultLimitExceeded(resourceString);
        }
        return result;
    };
    JSONDocumentSymbols.prototype.getSymbolKind = function (nodeType) {
        switch (nodeType) {
            case 'object':
                return vscode_languageserver_types_main_SymbolKind.Module;
            case 'string':
                return vscode_languageserver_types_main_SymbolKind.String;
            case 'number':
                return vscode_languageserver_types_main_SymbolKind.Number;
            case 'array':
                return vscode_languageserver_types_main_SymbolKind.Array;
            case 'boolean':
                return vscode_languageserver_types_main_SymbolKind.Boolean;
            default: // 'null'
                return vscode_languageserver_types_main_SymbolKind.Variable;
        }
    };
    JSONDocumentSymbols.prototype.getKeyLabel = function (property) {
        var name = property.keyNode.value;
        if (name) {
            name = name.replace(/[\n]/g, '');
        }
        if (name && name.trim()) {
            return name;
        }
        return "\"" + name + "\"";
    };
    JSONDocumentSymbols.prototype.findDocumentColors = function (document, doc, context) {
        return this.schemaService.getSchemaForResource(document.uri, doc).then(function (schema) {
            var result = [];
            if (schema) {
                var limit = context && typeof context.resultLimit === 'number' ? context.resultLimit : Number.MAX_VALUE;
                var matchingSchemas = doc.getMatchingSchemas(schema.schema);
                var visitedNode = {};
                for (var _i = 0, matchingSchemas_1 = matchingSchemas; _i < matchingSchemas_1.length; _i++) {
                    var s = matchingSchemas_1[_i];
                    if (!s.inverted && s.schema && (s.schema.format === 'color' || s.schema.format === 'color-hex') && s.node && s.node.type === 'string') {
                        var nodeId = String(s.node.offset);
                        if (!visitedNode[nodeId]) {
                            var color = colorFromHex(jsonParser_getNodeValue(s.node));
                            if (color) {
                                var range = getRange(document, s.node);
                                result.push({ color: color, range: range });
                            }
                            visitedNode[nodeId] = true;
                            limit--;
                            if (limit <= 0) {
                                if (context && context.onResultLimitExceeded) {
                                    context.onResultLimitExceeded(document.uri);
                                }
                                return result;
                            }
                        }
                    }
                }
            }
            return result;
        });
    };
    JSONDocumentSymbols.prototype.getColorPresentations = function (document, doc, color, range) {
        var result = [];
        var red256 = Math.round(color.red * 255), green256 = Math.round(color.green * 255), blue256 = Math.round(color.blue * 255);
        function toTwoDigitHex(n) {
            var r = n.toString(16);
            return r.length !== 2 ? '0' + r : r;
        }
        var label;
        if (color.alpha === 1) {
            label = "#" + toTwoDigitHex(red256) + toTwoDigitHex(green256) + toTwoDigitHex(blue256);
        }
        else {
            label = "#" + toTwoDigitHex(red256) + toTwoDigitHex(green256) + toTwoDigitHex(blue256) + toTwoDigitHex(Math.round(color.alpha * 255));
        }
        result.push({ label: label, textEdit: main_TextEdit.replace(range, JSON.stringify(label)) });
        return result;
    };
    return JSONDocumentSymbols;
}());

function getRange(document, node) {
    return vscode_languageserver_types_main_Range.create(document.positionAt(node.offset), document.positionAt(node.offset + node.length));
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/vscode-json-languageservice/lib/esm/services/configuration.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

var configuration_localize = loadMessageBundle();
var schemaContributions = {
    schemaAssociations: {},
    schemas: {
        // bundle the schema-schema to include (localized) descriptions
        'http://json-schema.org/draft-04/schema#': {
            'title': configuration_localize('schema.json', 'Describes a JSON file using a schema. See json-schema.org for more info.'),
            '$schema': 'http://json-schema.org/draft-04/schema#',
            'definitions': {
                'schemaArray': {
                    'type': 'array',
                    'minItems': 1,
                    'items': {
                        '$ref': '#'
                    }
                },
                'positiveInteger': {
                    'type': 'integer',
                    'minimum': 0
                },
                'positiveIntegerDefault0': {
                    'allOf': [
                        {
                            '$ref': '#/definitions/positiveInteger'
                        },
                        {
                            'default': 0
                        }
                    ]
                },
                'simpleTypes': {
                    'type': 'string',
                    'enum': [
                        'array',
                        'boolean',
                        'integer',
                        'null',
                        'number',
                        'object',
                        'string'
                    ]
                },
                'stringArray': {
                    'type': 'array',
                    'items': {
                        'type': 'string'
                    },
                    'minItems': 1,
                    'uniqueItems': true
                }
            },
            'type': 'object',
            'properties': {
                'id': {
                    'type': 'string',
                    'format': 'uri'
                },
                '$schema': {
                    'type': 'string',
                    'format': 'uri'
                },
                'title': {
                    'type': 'string'
                },
                'description': {
                    'type': 'string'
                },
                'default': {},
                'multipleOf': {
                    'type': 'number',
                    'minimum': 0,
                    'exclusiveMinimum': true
                },
                'maximum': {
                    'type': 'number'
                },
                'exclusiveMaximum': {
                    'type': 'boolean',
                    'default': false
                },
                'minimum': {
                    'type': 'number'
                },
                'exclusiveMinimum': {
                    'type': 'boolean',
                    'default': false
                },
                'maxLength': {
                    'allOf': [
                        {
                            '$ref': '#/definitions/positiveInteger'
                        }
                    ]
                },
                'minLength': {
                    'allOf': [
                        {
                            '$ref': '#/definitions/positiveIntegerDefault0'
                        }
                    ]
                },
                'pattern': {
                    'type': 'string',
                    'format': 'regex'
                },
                'additionalItems': {
                    'anyOf': [
                        {
                            'type': 'boolean'
                        },
                        {
                            '$ref': '#'
                        }
                    ],
                    'default': {}
                },
                'items': {
                    'anyOf': [
                        {
                            '$ref': '#'
                        },
                        {
                            '$ref': '#/definitions/schemaArray'
                        }
                    ],
                    'default': {}
                },
                'maxItems': {
                    'allOf': [
                        {
                            '$ref': '#/definitions/positiveInteger'
                        }
                    ]
                },
                'minItems': {
                    'allOf': [
                        {
                            '$ref': '#/definitions/positiveIntegerDefault0'
                        }
                    ]
                },
                'uniqueItems': {
                    'type': 'boolean',
                    'default': false
                },
                'maxProperties': {
                    'allOf': [
                        {
                            '$ref': '#/definitions/positiveInteger'
                        }
                    ]
                },
                'minProperties': {
                    'allOf': [
                        {
                            '$ref': '#/definitions/positiveIntegerDefault0'
                        }
                    ]
                },
                'required': {
                    'allOf': [
                        {
                            '$ref': '#/definitions/stringArray'
                        }
                    ]
                },
                'additionalProperties': {
                    'anyOf': [
                        {
                            'type': 'boolean'
                        },
                        {
                            '$ref': '#'
                        }
                    ],
                    'default': {}
                },
                'definitions': {
                    'type': 'object',
                    'additionalProperties': {
                        '$ref': '#'
                    },
                    'default': {}
                },
                'properties': {
                    'type': 'object',
                    'additionalProperties': {
                        '$ref': '#'
                    },
                    'default': {}
                },
                'patternProperties': {
                    'type': 'object',
                    'additionalProperties': {
                        '$ref': '#'
                    },
                    'default': {}
                },
                'dependencies': {
                    'type': 'object',
                    'additionalProperties': {
                        'anyOf': [
                            {
                                '$ref': '#'
                            },
                            {
                                '$ref': '#/definitions/stringArray'
                            }
                        ]
                    }
                },
                'enum': {
                    'type': 'array',
                    'minItems': 1,
                    'uniqueItems': true
                },
                'type': {
                    'anyOf': [
                        {
                            '$ref': '#/definitions/simpleTypes'
                        },
                        {
                            'type': 'array',
                            'items': {
                                '$ref': '#/definitions/simpleTypes'
                            },
                            'minItems': 1,
                            'uniqueItems': true
                        }
                    ]
                },
                'format': {
                    'anyOf': [
                        {
                            'type': 'string',
                            'enum': [
                                'date-time',
                                'uri',
                                'email',
                                'hostname',
                                'ipv4',
                                'ipv6',
                                'regex'
                            ]
                        },
                        {
                            'type': 'string'
                        }
                    ]
                },
                'allOf': {
                    'allOf': [
                        {
                            '$ref': '#/definitions/schemaArray'
                        }
                    ]
                },
                'anyOf': {
                    'allOf': [
                        {
                            '$ref': '#/definitions/schemaArray'
                        }
                    ]
                },
                'oneOf': {
                    'allOf': [
                        {
                            '$ref': '#/definitions/schemaArray'
                        }
                    ]
                },
                'not': {
                    'allOf': [
                        {
                            '$ref': '#'
                        }
                    ]
                }
            },
            'dependencies': {
                'exclusiveMaximum': [
                    'maximum'
                ],
                'exclusiveMinimum': [
                    'minimum'
                ]
            },
            'default': {}
        },
        'http://json-schema.org/draft-07/schema#': {
            'title': configuration_localize('schema.json', 'Describes a JSON file using a schema. See json-schema.org for more info.'),
            'definitions': {
                'schemaArray': {
                    'type': 'array',
                    'minItems': 1,
                    'items': { '$ref': '#' }
                },
                'nonNegativeInteger': {
                    'type': 'integer',
                    'minimum': 0
                },
                'nonNegativeIntegerDefault0': {
                    'allOf': [
                        { '$ref': '#/definitions/nonNegativeInteger' },
                        { 'default': 0 }
                    ]
                },
                'simpleTypes': {
                    'enum': [
                        'array',
                        'boolean',
                        'integer',
                        'null',
                        'number',
                        'object',
                        'string'
                    ]
                },
                'stringArray': {
                    'type': 'array',
                    'items': { 'type': 'string' },
                    'uniqueItems': true,
                    'default': []
                }
            },
            'type': ['object', 'boolean'],
            'properties': {
                '$id': {
                    'type': 'string',
                    'format': 'uri-reference'
                },
                '$schema': {
                    'type': 'string',
                    'format': 'uri'
                },
                '$ref': {
                    'type': 'string',
                    'format': 'uri-reference'
                },
                '$comment': {
                    'type': 'string'
                },
                'title': {
                    'type': 'string'
                },
                'description': {
                    'type': 'string'
                },
                'default': true,
                'readOnly': {
                    'type': 'boolean',
                    'default': false
                },
                'examples': {
                    'type': 'array',
                    'items': true
                },
                'multipleOf': {
                    'type': 'number',
                    'exclusiveMinimum': 0
                },
                'maximum': {
                    'type': 'number'
                },
                'exclusiveMaximum': {
                    'type': 'number'
                },
                'minimum': {
                    'type': 'number'
                },
                'exclusiveMinimum': {
                    'type': 'number'
                },
                'maxLength': { '$ref': '#/definitions/nonNegativeInteger' },
                'minLength': { '$ref': '#/definitions/nonNegativeIntegerDefault0' },
                'pattern': {
                    'type': 'string',
                    'format': 'regex'
                },
                'additionalItems': { '$ref': '#' },
                'items': {
                    'anyOf': [
                        { '$ref': '#' },
                        { '$ref': '#/definitions/schemaArray' }
                    ],
                    'default': true
                },
                'maxItems': { '$ref': '#/definitions/nonNegativeInteger' },
                'minItems': { '$ref': '#/definitions/nonNegativeIntegerDefault0' },
                'uniqueItems': {
                    'type': 'boolean',
                    'default': false
                },
                'contains': { '$ref': '#' },
                'maxProperties': { '$ref': '#/definitions/nonNegativeInteger' },
                'minProperties': { '$ref': '#/definitions/nonNegativeIntegerDefault0' },
                'required': { '$ref': '#/definitions/stringArray' },
                'additionalProperties': { '$ref': '#' },
                'definitions': {
                    'type': 'object',
                    'additionalProperties': { '$ref': '#' },
                    'default': {}
                },
                'properties': {
                    'type': 'object',
                    'additionalProperties': { '$ref': '#' },
                    'default': {}
                },
                'patternProperties': {
                    'type': 'object',
                    'additionalProperties': { '$ref': '#' },
                    'propertyNames': { 'format': 'regex' },
                    'default': {}
                },
                'dependencies': {
                    'type': 'object',
                    'additionalProperties': {
                        'anyOf': [
                            { '$ref': '#' },
                            { '$ref': '#/definitions/stringArray' }
                        ]
                    }
                },
                'propertyNames': { '$ref': '#' },
                'const': true,
                'enum': {
                    'type': 'array',
                    'items': true,
                    'minItems': 1,
                    'uniqueItems': true
                },
                'type': {
                    'anyOf': [
                        { '$ref': '#/definitions/simpleTypes' },
                        {
                            'type': 'array',
                            'items': { '$ref': '#/definitions/simpleTypes' },
                            'minItems': 1,
                            'uniqueItems': true
                        }
                    ]
                },
                'format': { 'type': 'string' },
                'contentMediaType': { 'type': 'string' },
                'contentEncoding': { 'type': 'string' },
                'if': { '$ref': '#' },
                'then': { '$ref': '#' },
                'else': { '$ref': '#' },
                'allOf': { '$ref': '#/definitions/schemaArray' },
                'anyOf': { '$ref': '#/definitions/schemaArray' },
                'oneOf': { '$ref': '#/definitions/schemaArray' },
                'not': { '$ref': '#' }
            },
            'default': true
        }
    }
};
var descriptions = {
    id: configuration_localize('schema.json.id', "A unique identifier for the schema."),
    $schema: configuration_localize('schema.json.$schema', "The schema to verify this document against."),
    title: configuration_localize('schema.json.title', "A descriptive title of the element."),
    description: configuration_localize('schema.json.description', "A long description of the element. Used in hover menus and suggestions."),
    default: configuration_localize('schema.json.default', "A default value. Used by suggestions."),
    multipleOf: configuration_localize('schema.json.multipleOf', "A number that should cleanly divide the current value (i.e. have no remainder)."),
    maximum: configuration_localize('schema.json.maximum', "The maximum numerical value, inclusive by default."),
    exclusiveMaximum: configuration_localize('schema.json.exclusiveMaximum', "Makes the maximum property exclusive."),
    minimum: configuration_localize('schema.json.minimum', "The minimum numerical value, inclusive by default."),
    exclusiveMinimum: configuration_localize('schema.json.exclusiveMininum', "Makes the minimum property exclusive."),
    maxLength: configuration_localize('schema.json.maxLength', "The maximum length of a string."),
    minLength: configuration_localize('schema.json.minLength', "The minimum length of a string."),
    pattern: configuration_localize('schema.json.pattern', "A regular expression to match the string against. It is not implicitly anchored."),
    additionalItems: configuration_localize('schema.json.additionalItems', "For arrays, only when items is set as an array. If it is a schema, then this schema validates items after the ones specified by the items array. If it is false, then additional items will cause validation to fail."),
    items: configuration_localize('schema.json.items', "For arrays. Can either be a schema to validate every element against or an array of schemas to validate each item against in order (the first schema will validate the first element, the second schema will validate the second element, and so on."),
    maxItems: configuration_localize('schema.json.maxItems', "The maximum number of items that can be inside an array. Inclusive."),
    minItems: configuration_localize('schema.json.minItems', "The minimum number of items that can be inside an array. Inclusive."),
    uniqueItems: configuration_localize('schema.json.uniqueItems', "If all of the items in the array must be unique. Defaults to false."),
    maxProperties: configuration_localize('schema.json.maxProperties', "The maximum number of properties an object can have. Inclusive."),
    minProperties: configuration_localize('schema.json.minProperties', "The minimum number of properties an object can have. Inclusive."),
    required: configuration_localize('schema.json.required', "An array of strings that lists the names of all properties required on this object."),
    additionalProperties: configuration_localize('schema.json.additionalProperties', "Either a schema or a boolean. If a schema, then used to validate all properties not matched by 'properties' or 'patternProperties'. If false, then any properties not matched by either will cause this schema to fail."),
    definitions: configuration_localize('schema.json.definitions', "Not used for validation. Place subschemas here that you wish to reference inline with $ref."),
    properties: configuration_localize('schema.json.properties', "A map of property names to schemas for each property."),
    patternProperties: configuration_localize('schema.json.patternProperties', "A map of regular expressions on property names to schemas for matching properties."),
    dependencies: configuration_localize('schema.json.dependencies', "A map of property names to either an array of property names or a schema. An array of property names means the property named in the key depends on the properties in the array being present in the object in order to be valid. If the value is a schema, then the schema is only applied to the object if the property in the key exists on the object."),
    enum: configuration_localize('schema.json.enum', "The set of literal values that are valid."),
    type: configuration_localize('schema.json.type', "Either a string of one of the basic schema types (number, integer, null, array, object, boolean, string) or an array of strings specifying a subset of those types."),
    format: configuration_localize('schema.json.format', "Describes the format expected for the value."),
    allOf: configuration_localize('schema.json.allOf', "An array of schemas, all of which must match."),
    anyOf: configuration_localize('schema.json.anyOf', "An array of schemas, where at least one must match."),
    oneOf: configuration_localize('schema.json.oneOf', "An array of schemas, exactly one of which must match."),
    not: configuration_localize('schema.json.not', "A schema which must not match."),
    $id: configuration_localize('schema.json.$id', "A unique identifier for the schema."),
    $ref: configuration_localize('schema.json.$ref', "Reference a definition hosted on any location."),
    $comment: configuration_localize('schema.json.$comment', "Comments from schema authors to readers or maintainers of the schema."),
    readOnly: configuration_localize('schema.json.readOnly', "Indicates that the value of the instance is managed exclusively by the owning authority."),
    examples: configuration_localize('schema.json.examples', "Sample JSON values associated with a particular schema, for the purpose of illustrating usage."),
    contains: configuration_localize('schema.json.contains', "An array instance is valid against \"contains\" if at least one of its elements is valid against the given schema."),
    propertyNames: configuration_localize('schema.json.propertyNames', "If the instance is an object, this keyword validates if every property name in the instance validates against the provided schema."),
    const: configuration_localize('schema.json.const', "An instance validates successfully against this keyword if its value is equal to the value of the keyword."),
    contentMediaType: configuration_localize('schema.json.contentMediaType', "Describes the media type of a string property."),
    contentEncoding: configuration_localize('schema.json.contentEncoding', "Describes the content encoding of a string property."),
    if: configuration_localize('schema.json.if', "The validation outcome of the \"if\" subschema controls which of the \"then\" or \"else\" keywords are evaluated."),
    then: configuration_localize('schema.json.then', "The \"if\" subschema is used for validation when the \"if\" subschema succeeds."),
    else: configuration_localize('schema.json.else', "The \"else\" subschema is used for validation when the \"if\" subschema fails.")
};
for (var schemaName in schemaContributions.schemas) {
    var configuration_schema = schemaContributions.schemas[schemaName];
    for (var configuration_property in configuration_schema.properties) {
        var propertyObject = configuration_schema.properties[configuration_property];
        if (propertyObject === true) {
            propertyObject = configuration_schema.properties[configuration_property] = {};
        }
        var description = descriptions[configuration_property];
        if (description) {
            propertyObject['description'] = description;
        }
        else {
            console.log(configuration_property + ": localize('schema.json." + configuration_property + "', \"\")");
        }
    }
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/vscode-json-languageservice/lib/esm/services/jsonFolding.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


function getFoldingRanges(document, context) {
    var ranges = [];
    var nestingLevels = [];
    var stack = [];
    var prevStart = -1;
    var scanner = main_createScanner(document.getText(), false);
    var token = scanner.scan();
    function addRange(range) {
        ranges.push(range);
        nestingLevels.push(stack.length);
    }
    while (token !== 17 /* EOF */) {
        switch (token) {
            case 1 /* OpenBraceToken */:
            case 3 /* OpenBracketToken */: {
                var startLine = document.positionAt(scanner.getTokenOffset()).line;
                var range = { startLine: startLine, endLine: startLine, kind: token === 1 /* OpenBraceToken */ ? 'object' : 'array' };
                stack.push(range);
                break;
            }
            case 2 /* CloseBraceToken */:
            case 4 /* CloseBracketToken */: {
                var kind = token === 2 /* CloseBraceToken */ ? 'object' : 'array';
                if (stack.length > 0 && stack[stack.length - 1].kind === kind) {
                    var range = stack.pop();
                    var line = document.positionAt(scanner.getTokenOffset()).line;
                    if (range && line > range.startLine + 1 && prevStart !== range.startLine) {
                        range.endLine = line - 1;
                        addRange(range);
                        prevStart = range.startLine;
                    }
                }
                break;
            }
            case 13 /* BlockCommentTrivia */: {
                var startLine = document.positionAt(scanner.getTokenOffset()).line;
                var endLine = document.positionAt(scanner.getTokenOffset() + scanner.getTokenLength()).line;
                if (scanner.getTokenError() === 1 /* UnexpectedEndOfComment */ && startLine + 1 < document.lineCount) {
                    scanner.setPosition(document.offsetAt(vscode_languageserver_types_main_Position.create(startLine + 1, 0)));
                }
                else {
                    if (startLine < endLine) {
                        addRange({ startLine: startLine, endLine: endLine, kind: main_FoldingRangeKind.Comment });
                        prevStart = startLine;
                    }
                }
                break;
            }
            case 12 /* LineCommentTrivia */: {
                var text = document.getText().substr(scanner.getTokenOffset(), scanner.getTokenLength());
                var m = text.match(/^\/\/\s*#(region\b)|(endregion\b)/);
                if (m) {
                    var line = document.positionAt(scanner.getTokenOffset()).line;
                    if (m[1]) { // start pattern match
                        var range = { startLine: line, endLine: line, kind: main_FoldingRangeKind.Region };
                        stack.push(range);
                    }
                    else {
                        var i = stack.length - 1;
                        while (i >= 0 && stack[i].kind !== main_FoldingRangeKind.Region) {
                            i--;
                        }
                        if (i >= 0) {
                            var range = stack[i];
                            stack.length = i;
                            if (line > range.startLine && prevStart !== range.startLine) {
                                range.endLine = line;
                                addRange(range);
                                prevStart = range.startLine;
                            }
                        }
                    }
                }
                break;
            }
        }
        token = scanner.scan();
    }
    var rangeLimit = context && context.rangeLimit;
    if (typeof rangeLimit !== 'number' || ranges.length <= rangeLimit) {
        return ranges;
    }
    if (context && context.onRangeLimitExceeded) {
        context.onRangeLimitExceeded(document.uri);
    }
    var counts = [];
    for (var _i = 0, nestingLevels_1 = nestingLevels; _i < nestingLevels_1.length; _i++) {
        var level = nestingLevels_1[_i];
        if (level < 30) {
            counts[level] = (counts[level] || 0) + 1;
        }
    }
    var entries = 0;
    var maxLevel = 0;
    for (var i = 0; i < counts.length; i++) {
        var n = counts[i];
        if (n) {
            if (n + entries > rangeLimit) {
                maxLevel = i;
                break;
            }
            entries += n;
        }
    }
    var result = [];
    for (var i = 0; i < ranges.length; i++) {
        var level = nestingLevels[i];
        if (typeof level === 'number') {
            if (level < maxLevel || (level === maxLevel && entries++ < rangeLimit)) {
                result.push(ranges[i]);
            }
        }
    }
    return result;
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/vscode-json-languageservice/lib/esm/services/jsonSelectionRanges.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


function getSelectionRanges(document, positions, doc) {
    function getSelectionRange(position) {
        var offset = document.offsetAt(position);
        var node = doc.getNodeFromOffset(offset, true);
        var result = [];
        while (node) {
            switch (node.type) {
                case 'string':
                case 'object':
                case 'array':
                    // range without ", [ or {
                    var cStart = node.offset + 1, cEnd = node.offset + node.length - 1;
                    if (cStart < cEnd && offset >= cStart && offset <= cEnd) {
                        result.push(newRange(cStart, cEnd));
                    }
                    result.push(newRange(node.offset, node.offset + node.length));
                    break;
                case 'number':
                case 'boolean':
                case 'null':
                case 'property':
                    result.push(newRange(node.offset, node.offset + node.length));
                    break;
            }
            if (node.type === 'property' || node.parent && node.parent.type === 'array') {
                var afterCommaOffset = getOffsetAfterNextToken(node.offset + node.length, 5 /* CommaToken */);
                if (afterCommaOffset !== -1) {
                    result.push(newRange(node.offset, afterCommaOffset));
                }
            }
            node = node.parent;
        }
        var current = undefined;
        for (var index = result.length - 1; index >= 0; index--) {
            current = SelectionRange.create(result[index], current);
        }
        if (!current) {
            current = SelectionRange.create(vscode_languageserver_types_main_Range.create(position, position));
        }
        return current;
    }
    function newRange(start, end) {
        return vscode_languageserver_types_main_Range.create(document.positionAt(start), document.positionAt(end));
    }
    var scanner = main_createScanner(document.getText(), true);
    function getOffsetAfterNextToken(offset, expectedToken) {
        scanner.setPosition(offset);
        var token = scanner.scan();
        if (token === expectedToken) {
            return scanner.getTokenOffset() + scanner.getTokenLength();
        }
        return -1;
    }
    return positions.map(getSelectionRange);
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/_deps/vscode-json-languageservice/lib/esm/jsonLanguageService.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/












function getLanguageService(params) {
    var promise = params.promiseConstructor || Promise;
    var jsonSchemaService = new jsonSchemaService_JSONSchemaService(params.schemaRequestService, params.workspaceContext, promise);
    jsonSchemaService.setSchemaContributions(schemaContributions);
    var jsonCompletion = new jsonCompletion_JSONCompletion(jsonSchemaService, params.contributions, promise, params.clientCapabilities);
    var jsonHover = new jsonHover_JSONHover(jsonSchemaService, params.contributions, promise);
    var jsonDocumentSymbols = new jsonDocumentSymbols_JSONDocumentSymbols(jsonSchemaService);
    var jsonValidation = new jsonValidation_JSONValidation(jsonSchemaService, promise);
    return {
        configure: function (settings) {
            jsonSchemaService.clearExternalSchemas();
            if (settings.schemas) {
                settings.schemas.forEach(function (settings) {
                    jsonSchemaService.registerExternalSchema(settings.uri, settings.fileMatch, settings.schema);
                });
            }
            jsonValidation.configure(settings);
        },
        resetSchema: function (uri) { return jsonSchemaService.onResourceChange(uri); },
        doValidation: jsonValidation.doValidation.bind(jsonValidation),
        parseJSONDocument: function (document) { return jsonParser_parse(document, { collectComments: true }); },
        newJSONDocument: function (root, diagnostics) { return newJSONDocument(root, diagnostics); },
        doResolve: jsonCompletion.doResolve.bind(jsonCompletion),
        doComplete: jsonCompletion.doComplete.bind(jsonCompletion),
        findDocumentSymbols: jsonDocumentSymbols.findDocumentSymbols.bind(jsonDocumentSymbols),
        findDocumentSymbols2: jsonDocumentSymbols.findDocumentSymbols2.bind(jsonDocumentSymbols),
        findColorSymbols: function (d, s) { return jsonDocumentSymbols.findDocumentColors(d, s).then(function (s) { return s.map(function (s) { return s.range; }); }); },
        findDocumentColors: jsonDocumentSymbols.findDocumentColors.bind(jsonDocumentSymbols),
        getColorPresentations: jsonDocumentSymbols.getColorPresentations.bind(jsonDocumentSymbols),
        doHover: jsonHover.doHover.bind(jsonHover),
        getFoldingRanges: getFoldingRanges,
        getSelectionRanges: getSelectionRanges,
        format: function (d, r, o) {
            var range = void 0;
            if (r) {
                var offset = d.offsetAt(r.start);
                var length = d.offsetAt(r.end) - offset;
                range = { offset: offset, length: length };
            }
            var options = { tabSize: o ? o.tabSize : 4, insertSpaces: o ? o.insertSpaces : true, eol: '\n' };
            return main_format(d.getText(), range, options).map(function (e) {
                return main_TextEdit.replace(vscode_languageserver_types_main_Range.create(d.positionAt(e.offset), d.positionAt(e.offset + e.length)), e.content);
            });
        }
    };
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/languageservice/parser/jsonParser07.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Red Hat, Inc. All rights reserved.
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/
var jsonParser07_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(__read(arguments[i]));
    return ar;
};
var jsonParser07_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};






var jsonParser07_localize = loadMessageBundle();
var colorHexPattern = /^#([0-9A-Fa-f]{3,4}|([0-9A-Fa-f]{2}){3,4})$/;
var emailPattern = /^(([^<>()\[\]\\.,;:\s@"]+(\.[^<>()\[\]\\.,;:\s@"]+)*)|(".+"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/;
var jsonParser07_ASTNodeImpl = /** @class */ (function () {
    function ASTNodeImpl(parent, offset, length) {
        this.offset = offset;
        this.length = length;
        this.parent = parent;
    }
    Object.defineProperty(ASTNodeImpl.prototype, "children", {
        get: function () {
            return [];
        },
        enumerable: true,
        configurable: true
    });
    ASTNodeImpl.prototype.toString = function () {
        return ('type: ' +
            this.type +
            ' (' +
            this.offset +
            '/' +
            this.length +
            ')' +
            (this.parent ? ' parent: {' + this.parent.toString() + '}' : ''));
    };
    return ASTNodeImpl;
}());

var jsonParser07_NullASTNodeImpl = /** @class */ (function (_super) {
    jsonParser07_extends(NullASTNodeImpl, _super);
    function NullASTNodeImpl(parent, offset, length) {
        var _this = _super.call(this, parent, offset, length) || this;
        _this.type = 'null';
        _this.value = null;
        return _this;
    }
    return NullASTNodeImpl;
}(jsonParser07_ASTNodeImpl));

var jsonParser07_BooleanASTNodeImpl = /** @class */ (function (_super) {
    jsonParser07_extends(BooleanASTNodeImpl, _super);
    function BooleanASTNodeImpl(parent, boolValue, offset, length) {
        var _this = _super.call(this, parent, offset, length) || this;
        _this.type = 'boolean';
        _this.value = boolValue;
        return _this;
    }
    return BooleanASTNodeImpl;
}(jsonParser07_ASTNodeImpl));

var jsonParser07_ArrayASTNodeImpl = /** @class */ (function (_super) {
    jsonParser07_extends(ArrayASTNodeImpl, _super);
    function ArrayASTNodeImpl(parent, offset, length) {
        var _this = _super.call(this, parent, offset, length) || this;
        _this.type = 'array';
        _this.items = [];
        return _this;
    }
    Object.defineProperty(ArrayASTNodeImpl.prototype, "children", {
        get: function () {
            return this.items;
        },
        enumerable: true,
        configurable: true
    });
    return ArrayASTNodeImpl;
}(jsonParser07_ASTNodeImpl));

var jsonParser07_NumberASTNodeImpl = /** @class */ (function (_super) {
    jsonParser07_extends(NumberASTNodeImpl, _super);
    function NumberASTNodeImpl(parent, offset, length) {
        var _this = _super.call(this, parent, offset, length) || this;
        _this.type = 'number';
        _this.isInteger = true;
        _this.value = Number.NaN;
        return _this;
    }
    return NumberASTNodeImpl;
}(jsonParser07_ASTNodeImpl));

var jsonParser07_StringASTNodeImpl = /** @class */ (function (_super) {
    jsonParser07_extends(StringASTNodeImpl, _super);
    function StringASTNodeImpl(parent, offset, length) {
        var _this = _super.call(this, parent, offset, length) || this;
        _this.type = 'string';
        _this.value = '';
        return _this;
    }
    return StringASTNodeImpl;
}(jsonParser07_ASTNodeImpl));

var jsonParser07_PropertyASTNodeImpl = /** @class */ (function (_super) {
    jsonParser07_extends(PropertyASTNodeImpl, _super);
    function PropertyASTNodeImpl(parent, offset, length) {
        var _this = _super.call(this, parent, offset, length) || this;
        _this.type = 'property';
        _this.colonOffset = -1;
        return _this;
    }
    Object.defineProperty(PropertyASTNodeImpl.prototype, "children", {
        get: function () {
            return this.valueNode ? [this.keyNode, this.valueNode] : [this.keyNode];
        },
        enumerable: true,
        configurable: true
    });
    return PropertyASTNodeImpl;
}(jsonParser07_ASTNodeImpl));

var jsonParser07_ObjectASTNodeImpl = /** @class */ (function (_super) {
    jsonParser07_extends(ObjectASTNodeImpl, _super);
    function ObjectASTNodeImpl(parent, offset, length) {
        var _this = _super.call(this, parent, offset, length) || this;
        _this.type = 'object';
        _this.properties = [];
        return _this;
    }
    Object.defineProperty(ObjectASTNodeImpl.prototype, "children", {
        get: function () {
            return this.properties;
        },
        enumerable: true,
        configurable: true
    });
    return ObjectASTNodeImpl;
}(jsonParser07_ASTNodeImpl));

function jsonParser07_asSchema(schema) {
    if (utils_objects_isBoolean(schema)) {
        return schema ? {} : { not: {} };
    }
    return schema;
}
var jsonParser07_EnumMatch;
(function (EnumMatch) {
    EnumMatch[EnumMatch["Key"] = 0] = "Key";
    EnumMatch[EnumMatch["Enum"] = 1] = "Enum";
})(jsonParser07_EnumMatch || (jsonParser07_EnumMatch = {}));
var jsonParser07_SchemaCollector = /** @class */ (function () {
    function SchemaCollector(focusOffset, exclude) {
        if (focusOffset === void 0) { focusOffset = -1; }
        if (exclude === void 0) { exclude = null; }
        this.focusOffset = focusOffset;
        this.exclude = exclude;
        this.schemas = [];
    }
    SchemaCollector.prototype.add = function (schema) {
        this.schemas.push(schema);
    };
    SchemaCollector.prototype.merge = function (other) {
        var _a;
        (_a = this.schemas).push.apply(_a, __spread(other.schemas));
    };
    SchemaCollector.prototype.include = function (node) {
        return ((this.focusOffset === -1 || jsonParser07_contains(node, this.focusOffset)) &&
            node !== this.exclude);
    };
    SchemaCollector.prototype.newSub = function () {
        return new SchemaCollector(-1, this.exclude);
    };
    return SchemaCollector;
}());
var jsonParser07_NoOpSchemaCollector = /** @class */ (function () {
    function NoOpSchemaCollector() {
    }
    Object.defineProperty(NoOpSchemaCollector.prototype, "schemas", {
        get: function () {
            return [];
        },
        enumerable: true,
        configurable: true
    });
    NoOpSchemaCollector.prototype.add = function (schema) { };
    NoOpSchemaCollector.prototype.merge = function (other) { };
    NoOpSchemaCollector.prototype.include = function (node) {
        return true;
    };
    NoOpSchemaCollector.prototype.newSub = function () {
        return this;
    };
    NoOpSchemaCollector.instance = new NoOpSchemaCollector();
    return NoOpSchemaCollector;
}());
var jsonParser07_ValidationResult = /** @class */ (function () {
    function ValidationResult(isKubernetes) {
        this.problems = [];
        this.propertiesMatches = 0;
        this.propertiesValueMatches = 0;
        this.primaryValueMatches = 0;
        this.enumValueMatch = false;
        if (isKubernetes) {
            this.enumValues = [];
        }
        else {
            this.enumValues = null;
        }
    }
    ValidationResult.prototype.hasProblems = function () {
        return !!this.problems.length;
    };
    ValidationResult.prototype.mergeAll = function (validationResults) {
        var e_1, _a;
        try {
            for (var validationResults_1 = jsonParser07_values(validationResults), validationResults_1_1 = validationResults_1.next(); !validationResults_1_1.done; validationResults_1_1 = validationResults_1.next()) {
                var validationResult = validationResults_1_1.value;
                this.merge(validationResult);
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (validationResults_1_1 && !validationResults_1_1.done && (_a = validationResults_1.return)) _a.call(validationResults_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
    };
    ValidationResult.prototype.merge = function (validationResult) {
        this.problems = this.problems.concat(validationResult.problems);
    };
    ValidationResult.prototype.mergeEnumValues = function (validationResult) {
        var e_2, _a;
        if (!this.enumValueMatch &&
            !validationResult.enumValueMatch &&
            this.enumValues &&
            validationResult.enumValues) {
            this.enumValues = this.enumValues.concat(validationResult.enumValues);
            try {
                for (var _b = jsonParser07_values(this.problems), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var error = _c.value;
                    if (error.code === ErrorCode.EnumValueMismatch) {
                        error.message = jsonParser07_localize('enumWarning', 'Value is not accepted. Valid values: {0}.', __spread(new Set(this.enumValues)).map(function (v) { return JSON.stringify(v); }).join(', '));
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    };
    ValidationResult.prototype.mergePropertyMatch = function (propertyValidationResult) {
        this.merge(propertyValidationResult);
        this.propertiesMatches++;
        if (propertyValidationResult.enumValueMatch ||
            (!propertyValidationResult.hasProblems() &&
                propertyValidationResult.propertiesMatches)) {
            this.propertiesValueMatches++;
        }
        if (propertyValidationResult.enumValueMatch &&
            propertyValidationResult.enumValues) {
            this.primaryValueMatches++;
        }
    };
    ValidationResult.prototype.compareGeneric = function (other) {
        var hasProblems = this.hasProblems();
        if (hasProblems !== other.hasProblems()) {
            return hasProblems ? -1 : 1;
        }
        if (this.enumValueMatch !== other.enumValueMatch) {
            return other.enumValueMatch ? -1 : 1;
        }
        if (this.propertiesValueMatches !== other.propertiesValueMatches) {
            return this.propertiesValueMatches - other.propertiesValueMatches;
        }
        if (this.primaryValueMatches !== other.primaryValueMatches) {
            return this.primaryValueMatches - other.primaryValueMatches;
        }
        return this.propertiesMatches - other.propertiesMatches;
    };
    ValidationResult.prototype.compareKubernetes = function (other) {
        var hasProblems = this.hasProblems();
        if (this.propertiesMatches !== other.propertiesMatches) {
            return this.propertiesMatches - other.propertiesMatches;
        }
        if (this.enumValueMatch !== other.enumValueMatch) {
            return other.enumValueMatch ? -1 : 1;
        }
        if (this.primaryValueMatches !== other.primaryValueMatches) {
            return this.primaryValueMatches - other.primaryValueMatches;
        }
        if (this.propertiesValueMatches !== other.propertiesValueMatches) {
            return this.propertiesValueMatches - other.propertiesValueMatches;
        }
        if (hasProblems !== other.hasProblems()) {
            return hasProblems ? -1 : 1;
        }
        return this.propertiesMatches - other.propertiesMatches;
    };
    return ValidationResult;
}());

function jsonParser07_newJSONDocument(root, diagnostics) {
    if (diagnostics === void 0) { diagnostics = []; }
    return new jsonParser07_JSONDocument(root, diagnostics, []);
}
// tslint:disable-next-line: no-any
function jsonParser07_getNodeValue(node) {
    return jsonc_parser_main_getNodeValue(node);
}
function jsonParser07_getNodePath(node) {
    return jsonc_parser_main_getNodePath(node);
}
function jsonParser07_contains(node, offset, includeRightBound) {
    if (includeRightBound === void 0) { includeRightBound = false; }
    return ((offset >= node.offset && offset < node.offset + node.length) ||
        (includeRightBound && offset === node.offset + node.length));
}
var jsonParser07_JSONDocument = /** @class */ (function () {
    function JSONDocument(root, syntaxErrors, comments) {
        if (syntaxErrors === void 0) { syntaxErrors = []; }
        if (comments === void 0) { comments = []; }
        this.root = root;
        this.syntaxErrors = syntaxErrors;
        this.comments = comments;
    }
    JSONDocument.prototype.getNodeFromOffset = function (offset, includeRightBound) {
        if (includeRightBound === void 0) { includeRightBound = false; }
        if (this.root) {
            return (jsonc_parser_main_findNodeAtOffset(this.root, offset, includeRightBound));
        }
        return void 0;
    };
    JSONDocument.prototype.visit = function (visitor) {
        if (this.root) {
            var doVisit_1 = function (node) {
                var ctn = visitor(node);
                var children = node.children;
                if (Array.isArray(children)) {
                    for (var i = 0; i < children.length && ctn; i++) {
                        ctn = doVisit_1(children[i]);
                    }
                }
                return ctn;
            };
            doVisit_1(this.root);
        }
    };
    JSONDocument.prototype.validate = function (textDocument, schema) {
        if (this.root && schema) {
            var validationResult = new jsonParser07_ValidationResult(this.isKubernetes);
            jsonParser07_validate(this.root, schema, validationResult, jsonParser07_NoOpSchemaCollector.instance, this.isKubernetes);
            return validationResult.problems.map(function (p) {
                var range = main_Range.create(textDocument.positionAt(p.location.offset), textDocument.positionAt(p.location.offset + p.location.length));
                return Diagnostic.create(range, p.message, p.severity, p.code);
            });
        }
        return null;
    };
    JSONDocument.prototype.getMatchingSchemas = function (schema, focusOffset, exclude) {
        if (focusOffset === void 0) { focusOffset = -1; }
        if (exclude === void 0) { exclude = null; }
        var matchingSchemas = new jsonParser07_SchemaCollector(focusOffset, exclude);
        if (this.root && schema) {
            jsonParser07_validate(this.root, schema, new jsonParser07_ValidationResult(this.isKubernetes), matchingSchemas, this.isKubernetes);
        }
        return matchingSchemas.schemas;
    };
    return JSONDocument;
}());

function jsonParser07_validate(node, schema, validationResult, matchingSchemas, isKubernetes) {
    if (!node || !matchingSchemas.include(node)) {
        return;
    }
    switch (node.type) {
        case 'object':
            _validateObjectNode(node, schema, validationResult, matchingSchemas);
            break;
        case 'array':
            _validateArrayNode(node, schema, validationResult, matchingSchemas);
            break;
        case 'string':
            _validateStringNode(node, schema, validationResult, matchingSchemas);
            break;
        case 'number':
            _validateNumberNode(node, schema, validationResult, matchingSchemas);
            break;
        case 'property':
            return jsonParser07_validate(node.valueNode, schema, validationResult, matchingSchemas, isKubernetes);
    }
    _validateNode();
    matchingSchemas.add({ node: node, schema: schema });
    function _validateNode() {
        var e_3, _a, e_4, _b, e_5, _c;
        function matchesType(type) {
            return (node.type === type ||
                (type === 'integer' && node.type === 'number' && node.isInteger));
        }
        if (Array.isArray(schema.type)) {
            if (!schema.type.some(matchesType)) {
                validationResult.problems.push({
                    location: { offset: node.offset, length: node.length },
                    severity: DiagnosticSeverity.Warning,
                    message: schema.errorMessage ||
                        jsonParser07_localize('typeArrayMismatchWarning', 'Incorrect type. Expected one of {0}.', schema.type.join(', ')),
                });
            }
        }
        else if (schema.type) {
            if (!matchesType(schema.type)) {
                validationResult.problems.push({
                    location: { offset: node.offset, length: node.length },
                    severity: DiagnosticSeverity.Warning,
                    message: schema.errorMessage ||
                        jsonParser07_localize('typeMismatchWarning', 'Incorrect type. Expected "{0}".', schema.type),
                });
            }
        }
        if (Array.isArray(schema.allOf)) {
            try {
                for (var _d = jsonParser07_values(schema.allOf), _e = _d.next(); !_e.done; _e = _d.next()) {
                    var subSchemaRef = _e.value;
                    jsonParser07_validate(node, jsonParser07_asSchema(subSchemaRef), validationResult, matchingSchemas, isKubernetes);
                }
            }
            catch (e_3_1) { e_3 = { error: e_3_1 }; }
            finally {
                try {
                    if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
                }
                finally { if (e_3) throw e_3.error; }
            }
        }
        var notSchema = jsonParser07_asSchema(schema.not);
        if (notSchema) {
            var subValidationResult = new jsonParser07_ValidationResult(isKubernetes);
            var subMatchingSchemas = matchingSchemas.newSub();
            jsonParser07_validate(node, notSchema, subValidationResult, subMatchingSchemas, isKubernetes);
            if (!subValidationResult.hasProblems()) {
                validationResult.problems.push({
                    location: { offset: node.offset, length: node.length },
                    severity: DiagnosticSeverity.Warning,
                    message: jsonParser07_localize('notSchemaWarning', 'Matches a schema that is not allowed.'),
                });
            }
            try {
                for (var _f = jsonParser07_values(subMatchingSchemas.schemas), _g = _f.next(); !_g.done; _g = _f.next()) {
                    var ms = _g.value;
                    ms.inverted = !ms.inverted;
                    matchingSchemas.add(ms);
                }
            }
            catch (e_4_1) { e_4 = { error: e_4_1 }; }
            finally {
                try {
                    if (_g && !_g.done && (_b = _f.return)) _b.call(_f);
                }
                finally { if (e_4) throw e_4.error; }
            }
        }
        var testAlternatives = function (alternatives, maxOneMatch) {
            var e_6, _a;
            var matches = [];
            // remember the best match that is used for error messages
            var bestMatch = null;
            try {
                for (var alternatives_1 = jsonParser07_values(alternatives), alternatives_1_1 = alternatives_1.next(); !alternatives_1_1.done; alternatives_1_1 = alternatives_1.next()) {
                    var subSchemaRef = alternatives_1_1.value;
                    var subSchema = jsonParser07_asSchema(subSchemaRef);
                    var subValidationResult = new jsonParser07_ValidationResult(isKubernetes);
                    var subMatchingSchemas = matchingSchemas.newSub();
                    jsonParser07_validate(node, subSchema, subValidationResult, subMatchingSchemas, isKubernetes);
                    if (!subValidationResult.hasProblems()) {
                        matches.push(subSchema);
                    }
                    if (!bestMatch) {
                        bestMatch = {
                            schema: subSchema,
                            validationResult: subValidationResult,
                            matchingSchemas: subMatchingSchemas,
                        };
                    }
                    else if (isKubernetes) {
                        bestMatch = alternativeComparison(subValidationResult, bestMatch, subSchema, subMatchingSchemas);
                    }
                    else {
                        bestMatch = genericComparison(maxOneMatch, subValidationResult, bestMatch, subSchema, subMatchingSchemas);
                    }
                }
            }
            catch (e_6_1) { e_6 = { error: e_6_1 }; }
            finally {
                try {
                    if (alternatives_1_1 && !alternatives_1_1.done && (_a = alternatives_1.return)) _a.call(alternatives_1);
                }
                finally { if (e_6) throw e_6.error; }
            }
            if (matches.length > 1 && maxOneMatch) {
                validationResult.problems.push({
                    location: { offset: node.offset, length: 1 },
                    severity: DiagnosticSeverity.Warning,
                    message: jsonParser07_localize('oneOfWarning', 'Matches multiple schemas when only one must validate.'),
                });
            }
            if (bestMatch !== null) {
                validationResult.merge(bestMatch.validationResult);
                validationResult.propertiesMatches +=
                    bestMatch.validationResult.propertiesMatches;
                validationResult.propertiesValueMatches +=
                    bestMatch.validationResult.propertiesValueMatches;
                matchingSchemas.merge(bestMatch.matchingSchemas);
            }
            return matches.length;
        };
        if (Array.isArray(schema.anyOf)) {
            testAlternatives(schema.anyOf, false);
        }
        if (Array.isArray(schema.oneOf)) {
            testAlternatives(schema.oneOf, true);
        }
        var testBranch = function (schema) {
            var subValidationResult = new jsonParser07_ValidationResult(isKubernetes);
            var subMatchingSchemas = matchingSchemas.newSub();
            jsonParser07_validate(node, jsonParser07_asSchema(schema), subValidationResult, subMatchingSchemas, isKubernetes);
            validationResult.merge(subValidationResult);
            validationResult.propertiesMatches +=
                subValidationResult.propertiesMatches;
            validationResult.propertiesValueMatches +=
                subValidationResult.propertiesValueMatches;
            matchingSchemas.merge(subMatchingSchemas);
        };
        var testCondition = function (ifSchema, thenSchema, elseSchema) {
            var subSchema = jsonParser07_asSchema(ifSchema);
            var subValidationResult = new jsonParser07_ValidationResult(isKubernetes);
            var subMatchingSchemas = matchingSchemas.newSub();
            jsonParser07_validate(node, subSchema, subValidationResult, subMatchingSchemas, isKubernetes);
            matchingSchemas.merge(subMatchingSchemas);
            if (!subValidationResult.hasProblems()) {
                if (thenSchema) {
                    testBranch(thenSchema);
                }
            }
            else if (elseSchema) {
                testBranch(elseSchema);
            }
        };
        var ifSchema = jsonParser07_asSchema(schema.if);
        if (ifSchema) {
            testCondition(ifSchema, jsonParser07_asSchema(schema.then), jsonParser07_asSchema(schema.else));
        }
        if (Array.isArray(schema.enum)) {
            var val = jsonParser07_getNodeValue(node);
            var enumValueMatch = false;
            try {
                for (var _h = jsonParser07_values(schema.enum), _j = _h.next(); !_j.done; _j = _h.next()) {
                    var e = _j.value;
                    if (utils_objects_equals(val, e)) {
                        enumValueMatch = true;
                        break;
                    }
                }
            }
            catch (e_5_1) { e_5 = { error: e_5_1 }; }
            finally {
                try {
                    if (_j && !_j.done && (_c = _h.return)) _c.call(_h);
                }
                finally { if (e_5) throw e_5.error; }
            }
            validationResult.enumValues = schema.enum;
            validationResult.enumValueMatch = enumValueMatch;
            if (!enumValueMatch) {
                validationResult.problems.push({
                    location: { offset: node.offset, length: node.length },
                    severity: DiagnosticSeverity.Warning,
                    code: ErrorCode.EnumValueMismatch,
                    message: schema.errorMessage ||
                        jsonParser07_localize('enumWarning', 'Value is not accepted. Valid values: {0}.', schema.enum.map(function (v) { return JSON.stringify(v); }).join(', ')),
                });
            }
        }
        if (objects_isDefined(schema.const)) {
            var val = jsonParser07_getNodeValue(node);
            if (!utils_objects_equals(val, schema.const)) {
                validationResult.problems.push({
                    location: { offset: node.offset, length: node.length },
                    severity: DiagnosticSeverity.Warning,
                    code: ErrorCode.EnumValueMismatch,
                    message: schema.errorMessage ||
                        jsonParser07_localize('constWarning', 'Value must be {0}.', JSON.stringify(schema.const)),
                });
                validationResult.enumValueMatch = false;
            }
            else {
                validationResult.enumValueMatch = true;
            }
            validationResult.enumValues = [schema.const];
        }
        if (schema.deprecationMessage && node.parent) {
            validationResult.problems.push({
                location: { offset: node.parent.offset, length: node.parent.length },
                severity: DiagnosticSeverity.Warning,
                message: schema.deprecationMessage,
            });
        }
    }
    function _validateNumberNode(node, schema, validationResult, matchingSchemas) {
        var val = node.value;
        if (utils_objects_isNumber(schema.multipleOf)) {
            if (val % schema.multipleOf !== 0) {
                validationResult.problems.push({
                    location: { offset: node.offset, length: node.length },
                    severity: DiagnosticSeverity.Warning,
                    message: jsonParser07_localize('multipleOfWarning', 'Value is not divisible by {0}.', schema.multipleOf),
                });
            }
        }
        function getExclusiveLimit(limit, exclusive) {
            if (utils_objects_isNumber(exclusive)) {
                return exclusive;
            }
            if (utils_objects_isBoolean(exclusive) && exclusive) {
                return limit;
            }
            return void 0;
        }
        function getLimit(limit, exclusive) {
            if (!utils_objects_isBoolean(exclusive) || !exclusive) {
                return limit;
            }
            return void 0;
        }
        var exclusiveMinimum = getExclusiveLimit(schema.minimum, schema.exclusiveMinimum);
        if (utils_objects_isNumber(exclusiveMinimum) && val <= exclusiveMinimum) {
            validationResult.problems.push({
                location: { offset: node.offset, length: node.length },
                severity: DiagnosticSeverity.Warning,
                message: jsonParser07_localize('exclusiveMinimumWarning', 'Value is below the exclusive minimum of {0}.', exclusiveMinimum),
            });
        }
        var exclusiveMaximum = getExclusiveLimit(schema.maximum, schema.exclusiveMaximum);
        if (utils_objects_isNumber(exclusiveMaximum) && val >= exclusiveMaximum) {
            validationResult.problems.push({
                location: { offset: node.offset, length: node.length },
                severity: DiagnosticSeverity.Warning,
                message: jsonParser07_localize('exclusiveMaximumWarning', 'Value is above the exclusive maximum of {0}.', exclusiveMaximum),
            });
        }
        var minimum = getLimit(schema.minimum, schema.exclusiveMinimum);
        if (utils_objects_isNumber(minimum) && val < minimum) {
            validationResult.problems.push({
                location: { offset: node.offset, length: node.length },
                severity: DiagnosticSeverity.Warning,
                message: jsonParser07_localize('minimumWarning', 'Value is below the minimum of {0}.', minimum),
            });
        }
        var maximum = getLimit(schema.maximum, schema.exclusiveMaximum);
        if (utils_objects_isNumber(maximum) && val > maximum) {
            validationResult.problems.push({
                location: { offset: node.offset, length: node.length },
                severity: DiagnosticSeverity.Warning,
                message: jsonParser07_localize('maximumWarning', 'Value is above the maximum of {0}.', maximum),
            });
        }
    }
    function _validateStringNode(node, schema, validationResult, matchingSchemas) {
        if (utils_objects_isNumber(schema.minLength) && node.value.length < schema.minLength) {
            validationResult.problems.push({
                location: { offset: node.offset, length: node.length },
                severity: DiagnosticSeverity.Warning,
                message: jsonParser07_localize('minLengthWarning', 'String is shorter than the minimum length of {0}.', schema.minLength),
            });
        }
        if (utils_objects_isNumber(schema.maxLength) && node.value.length > schema.maxLength) {
            validationResult.problems.push({
                location: { offset: node.offset, length: node.length },
                severity: DiagnosticSeverity.Warning,
                message: jsonParser07_localize('maxLengthWarning', 'String is longer than the maximum length of {0}.', schema.maxLength),
            });
        }
        if (utils_objects_isString(schema.pattern)) {
            var regex = new RegExp(schema.pattern);
            if (!regex.test(node.value)) {
                validationResult.problems.push({
                    location: { offset: node.offset, length: node.length },
                    severity: DiagnosticSeverity.Warning,
                    message: schema.patternErrorMessage ||
                        schema.errorMessage ||
                        jsonParser07_localize('patternWarning', 'String does not match the pattern of "{0}".', schema.pattern),
                });
            }
        }
        if (schema.format) {
            switch (schema.format) {
                case 'uri':
                case 'uri-reference':
                    {
                        var errorMessage = void 0;
                        if (!node.value) {
                            errorMessage = jsonParser07_localize('uriEmpty', 'URI expected.');
                        }
                        else {
                            try {
                                var uri = vscode_uri_URI.parse(node.value);
                                if (!uri.scheme && schema.format === 'uri') {
                                    errorMessage = jsonParser07_localize('uriSchemeMissing', 'URI with a scheme is expected.');
                                }
                            }
                            catch (e) {
                                errorMessage = e.message;
                            }
                        }
                        if (errorMessage) {
                            validationResult.problems.push({
                                location: { offset: node.offset, length: node.length },
                                severity: DiagnosticSeverity.Warning,
                                message: schema.patternErrorMessage ||
                                    schema.errorMessage ||
                                    jsonParser07_localize('uriFormatWarning', 'String is not a URI: {0}', errorMessage),
                            });
                        }
                    }
                    break;
                case 'email':
                    {
                        if (!node.value.match(emailPattern)) {
                            validationResult.problems.push({
                                location: { offset: node.offset, length: node.length },
                                severity: DiagnosticSeverity.Warning,
                                message: schema.patternErrorMessage ||
                                    schema.errorMessage ||
                                    jsonParser07_localize('emailFormatWarning', 'String is not an e-mail address.'),
                            });
                        }
                    }
                    break;
                case 'color-hex':
                    {
                        if (!node.value.match(colorHexPattern)) {
                            validationResult.problems.push({
                                location: { offset: node.offset, length: node.length },
                                severity: DiagnosticSeverity.Warning,
                                // tslint:disable-next-line: max-line-length
                                message: schema.patternErrorMessage ||
                                    schema.errorMessage ||
                                    jsonParser07_localize('colorHexFormatWarning', 'Invalid color format. Use #RGB, #RGBA, #RRGGBB or #RRGGBBAA.'),
                            });
                        }
                    }
                    break;
                default:
            }
        }
    }
    function _validateArrayNode(node, schema, validationResult, matchingSchemas) {
        var e_7, _a;
        if (Array.isArray(schema.items)) {
            var subSchemas = schema.items;
            for (var index = 0; index < subSchemas.length; index++) {
                var subSchemaRef = subSchemas[index];
                var subSchema = jsonParser07_asSchema(subSchemaRef);
                var itemValidationResult = new jsonParser07_ValidationResult(isKubernetes);
                var item = node.items[index];
                if (item) {
                    jsonParser07_validate(item, subSchema, itemValidationResult, matchingSchemas, isKubernetes);
                    validationResult.mergePropertyMatch(itemValidationResult);
                    validationResult.mergeEnumValues(itemValidationResult);
                }
                else if (node.items.length >= subSchemas.length) {
                    validationResult.propertiesValueMatches++;
                }
            }
            if (node.items.length > subSchemas.length) {
                if (typeof schema.additionalItems === 'object') {
                    for (var i = subSchemas.length; i < node.items.length; i++) {
                        var itemValidationResult = new jsonParser07_ValidationResult(isKubernetes);
                        // tslint:disable-next-line: no-any
                        jsonParser07_validate(node.items[i], schema.additionalItems, itemValidationResult, matchingSchemas, isKubernetes);
                        validationResult.mergePropertyMatch(itemValidationResult);
                        validationResult.mergeEnumValues(itemValidationResult);
                    }
                }
                else if (schema.additionalItems === false) {
                    validationResult.problems.push({
                        location: { offset: node.offset, length: node.length },
                        severity: DiagnosticSeverity.Warning,
                        message: jsonParser07_localize('additionalItemsWarning', 'Array has too many items according to schema. Expected {0} or fewer.', subSchemas.length),
                    });
                }
            }
        }
        else {
            var itemSchema = jsonParser07_asSchema(schema.items);
            if (itemSchema) {
                try {
                    for (var _b = jsonParser07_values(node.items), _c = _b.next(); !_c.done; _c = _b.next()) {
                        var item = _c.value;
                        var itemValidationResult = new jsonParser07_ValidationResult(isKubernetes);
                        jsonParser07_validate(item, itemSchema, itemValidationResult, matchingSchemas, isKubernetes);
                        validationResult.mergePropertyMatch(itemValidationResult);
                        validationResult.mergeEnumValues(itemValidationResult);
                    }
                }
                catch (e_7_1) { e_7 = { error: e_7_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                    }
                    finally { if (e_7) throw e_7.error; }
                }
            }
        }
        var containsSchema = jsonParser07_asSchema(schema.contains);
        if (containsSchema) {
            var doesContain = node.items.some(function (item) {
                var itemValidationResult = new jsonParser07_ValidationResult(isKubernetes);
                jsonParser07_validate(item, containsSchema, itemValidationResult, jsonParser07_NoOpSchemaCollector.instance, isKubernetes);
                return !itemValidationResult.hasProblems();
            });
            if (!doesContain) {
                validationResult.problems.push({
                    location: { offset: node.offset, length: node.length },
                    severity: DiagnosticSeverity.Warning,
                    message: schema.errorMessage ||
                        jsonParser07_localize('requiredItemMissingWarning', 'Array does not contain required item.'),
                });
            }
        }
        if (utils_objects_isNumber(schema.minItems) && node.items.length < schema.minItems) {
            validationResult.problems.push({
                location: { offset: node.offset, length: node.length },
                severity: DiagnosticSeverity.Warning,
                message: jsonParser07_localize('minItemsWarning', 'Array has too few items. Expected {0} or more.', schema.minItems),
            });
        }
        if (utils_objects_isNumber(schema.maxItems) && node.items.length > schema.maxItems) {
            validationResult.problems.push({
                location: { offset: node.offset, length: node.length },
                severity: DiagnosticSeverity.Warning,
                message: jsonParser07_localize('maxItemsWarning', 'Array has too many items. Expected {0} or fewer.', schema.maxItems),
            });
        }
        if (schema.uniqueItems === true) {
            var values_1 = jsonParser07_getNodeValue(node);
            var duplicates = values_1.some(function (value, index) { return index !== values_1.lastIndexOf(value); });
            if (duplicates) {
                validationResult.problems.push({
                    location: { offset: node.offset, length: node.length },
                    severity: DiagnosticSeverity.Warning,
                    message: jsonParser07_localize('uniqueItemsWarning', 'Array has duplicate items.'),
                });
            }
        }
    }
    function _validateObjectNode(node, schema, validationResult, matchingSchemas) {
        var e_8, _a, e_9, _b, e_10, _c, e_11, _d, e_12, _e, e_13, _f, e_14, _g, e_15, _h, e_16, _j, e_17, _k;
        var seenKeys = Object.create(null);
        var unprocessedProperties = [];
        try {
            for (var _l = jsonParser07_values(node.properties), _m = _l.next(); !_m.done; _m = _l.next()) {
                var propertyNode = _m.value;
                var key = propertyNode.keyNode.value;
                seenKeys[key] = propertyNode.valueNode;
                unprocessedProperties.push(key);
            }
        }
        catch (e_8_1) { e_8 = { error: e_8_1 }; }
        finally {
            try {
                if (_m && !_m.done && (_a = _l.return)) _a.call(_l);
            }
            finally { if (e_8) throw e_8.error; }
        }
        if (Array.isArray(schema.required)) {
            try {
                for (var _o = jsonParser07_values(schema.required), _p = _o.next(); !_p.done; _p = _o.next()) {
                    var propertyName = _p.value;
                    if (!seenKeys[propertyName]) {
                        var keyNode = node.parent &&
                            node.parent.type === 'property' &&
                            node.parent.keyNode;
                        var location_1 = keyNode
                            ? { offset: keyNode.offset, length: keyNode.length }
                            : { offset: node.offset, length: 1 };
                        validationResult.problems.push({
                            location: location_1,
                            severity: DiagnosticSeverity.Warning,
                            message: jsonParser07_localize('MissingRequiredPropWarning', 'Missing property "{0}".', propertyName),
                        });
                    }
                }
            }
            catch (e_9_1) { e_9 = { error: e_9_1 }; }
            finally {
                try {
                    if (_p && !_p.done && (_b = _o.return)) _b.call(_o);
                }
                finally { if (e_9) throw e_9.error; }
            }
        }
        var propertyProcessed = function (prop) {
            var index = unprocessedProperties.indexOf(prop);
            while (index >= 0) {
                unprocessedProperties.splice(index, 1);
                index = unprocessedProperties.indexOf(prop);
            }
        };
        if (schema.properties) {
            try {
                for (var _q = jsonParser07_values(Object.keys(schema.properties)), _r = _q.next(); !_r.done; _r = _q.next()) {
                    var propertyName = _r.value;
                    propertyProcessed(propertyName);
                    var propertySchema = schema.properties[propertyName];
                    var child = seenKeys[propertyName];
                    if (child) {
                        if (utils_objects_isBoolean(propertySchema)) {
                            if (!propertySchema) {
                                var propertyNode = child.parent;
                                validationResult.problems.push({
                                    location: {
                                        offset: propertyNode.keyNode.offset,
                                        length: propertyNode.keyNode.length,
                                    },
                                    severity: DiagnosticSeverity.Warning,
                                    message: schema.errorMessage ||
                                        jsonParser07_localize('DisallowedExtraPropWarning', 'Property {0} is not allowed.', propertyName),
                                });
                            }
                            else {
                                validationResult.propertiesMatches++;
                                validationResult.propertiesValueMatches++;
                            }
                        }
                        else {
                            var propertyValidationResult = new jsonParser07_ValidationResult(isKubernetes);
                            jsonParser07_validate(child, propertySchema, propertyValidationResult, matchingSchemas, isKubernetes);
                            validationResult.mergePropertyMatch(propertyValidationResult);
                            validationResult.mergeEnumValues(propertyValidationResult);
                        }
                    }
                }
            }
            catch (e_10_1) { e_10 = { error: e_10_1 }; }
            finally {
                try {
                    if (_r && !_r.done && (_c = _q.return)) _c.call(_q);
                }
                finally { if (e_10) throw e_10.error; }
            }
        }
        if (schema.patternProperties) {
            try {
                for (var _s = jsonParser07_values(Object.keys(schema.patternProperties)), _t = _s.next(); !_t.done; _t = _s.next()) {
                    var propertyPattern = _t.value;
                    var regex = new RegExp(propertyPattern);
                    try {
                        for (var _u = (e_12 = void 0, jsonParser07_values(unprocessedProperties.slice(0))), _v = _u.next(); !_v.done; _v = _u.next()) {
                            var propertyName = _v.value;
                            if (regex.test(propertyName)) {
                                propertyProcessed(propertyName);
                                var child = seenKeys[propertyName];
                                if (child) {
                                    var propertySchema = schema.patternProperties[propertyPattern];
                                    if (utils_objects_isBoolean(propertySchema)) {
                                        if (!propertySchema) {
                                            var propertyNode = child.parent;
                                            validationResult.problems.push({
                                                location: {
                                                    offset: propertyNode.keyNode.offset,
                                                    length: propertyNode.keyNode.length,
                                                },
                                                severity: DiagnosticSeverity.Warning,
                                                message: schema.errorMessage ||
                                                    jsonParser07_localize('DisallowedExtraPropWarning', 'Property {0} is not allowed.', propertyName),
                                            });
                                        }
                                        else {
                                            validationResult.propertiesMatches++;
                                            validationResult.propertiesValueMatches++;
                                        }
                                    }
                                    else {
                                        var propertyValidationResult = new jsonParser07_ValidationResult(isKubernetes);
                                        jsonParser07_validate(child, propertySchema, propertyValidationResult, matchingSchemas, isKubernetes);
                                        validationResult.mergePropertyMatch(propertyValidationResult);
                                        validationResult.mergeEnumValues(propertyValidationResult);
                                    }
                                }
                            }
                        }
                    }
                    catch (e_12_1) { e_12 = { error: e_12_1 }; }
                    finally {
                        try {
                            if (_v && !_v.done && (_e = _u.return)) _e.call(_u);
                        }
                        finally { if (e_12) throw e_12.error; }
                    }
                }
            }
            catch (e_11_1) { e_11 = { error: e_11_1 }; }
            finally {
                try {
                    if (_t && !_t.done && (_d = _s.return)) _d.call(_s);
                }
                finally { if (e_11) throw e_11.error; }
            }
        }
        if (typeof schema.additionalProperties === 'object') {
            try {
                for (var unprocessedProperties_1 = jsonParser07_values(unprocessedProperties), unprocessedProperties_1_1 = unprocessedProperties_1.next(); !unprocessedProperties_1_1.done; unprocessedProperties_1_1 = unprocessedProperties_1.next()) {
                    var propertyName = unprocessedProperties_1_1.value;
                    var child = seenKeys[propertyName];
                    if (child) {
                        var propertyValidationResult = new jsonParser07_ValidationResult(isKubernetes);
                        // tslint:disable-next-line: no-any
                        jsonParser07_validate(child, schema.additionalProperties, propertyValidationResult, matchingSchemas, isKubernetes);
                        validationResult.mergePropertyMatch(propertyValidationResult);
                        validationResult.mergeEnumValues(propertyValidationResult);
                    }
                }
            }
            catch (e_13_1) { e_13 = { error: e_13_1 }; }
            finally {
                try {
                    if (unprocessedProperties_1_1 && !unprocessedProperties_1_1.done && (_f = unprocessedProperties_1.return)) _f.call(unprocessedProperties_1);
                }
                finally { if (e_13) throw e_13.error; }
            }
        }
        else if (schema.additionalProperties === false) {
            if (unprocessedProperties.length > 0) {
                try {
                    for (var unprocessedProperties_2 = jsonParser07_values(unprocessedProperties), unprocessedProperties_2_1 = unprocessedProperties_2.next(); !unprocessedProperties_2_1.done; unprocessedProperties_2_1 = unprocessedProperties_2.next()) {
                        var propertyName = unprocessedProperties_2_1.value;
                        var child = seenKeys[propertyName];
                        if (child) {
                            var propertyNode = null;
                            if (child.type !== 'property') {
                                propertyNode = child.parent;
                                if (propertyNode.type === 'object') {
                                    propertyNode = propertyNode.properties[0];
                                }
                            }
                            else {
                                propertyNode = child;
                            }
                            validationResult.problems.push({
                                location: {
                                    offset: propertyNode.keyNode.offset,
                                    length: propertyNode.keyNode.length,
                                },
                                severity: DiagnosticSeverity.Warning,
                                message: schema.errorMessage ||
                                    jsonParser07_localize('DisallowedExtraPropWarning', 'Property {0} is not allowed.', propertyName),
                            });
                        }
                    }
                }
                catch (e_14_1) { e_14 = { error: e_14_1 }; }
                finally {
                    try {
                        if (unprocessedProperties_2_1 && !unprocessedProperties_2_1.done && (_g = unprocessedProperties_2.return)) _g.call(unprocessedProperties_2);
                    }
                    finally { if (e_14) throw e_14.error; }
                }
            }
        }
        if (utils_objects_isNumber(schema.maxProperties)) {
            if (node.properties.length > schema.maxProperties) {
                validationResult.problems.push({
                    location: { offset: node.offset, length: node.length },
                    severity: DiagnosticSeverity.Warning,
                    message: jsonParser07_localize('MaxPropWarning', 'Object has more properties than limit of {0}.', schema.maxProperties),
                });
            }
        }
        if (utils_objects_isNumber(schema.minProperties)) {
            if (node.properties.length < schema.minProperties) {
                validationResult.problems.push({
                    location: { offset: node.offset, length: node.length },
                    severity: DiagnosticSeverity.Warning,
                    message: jsonParser07_localize('MinPropWarning', 'Object has fewer properties than the required number of {0}', schema.minProperties),
                });
            }
        }
        if (schema.dependencies) {
            try {
                for (var _w = jsonParser07_values(Object.keys(schema.dependencies)), _x = _w.next(); !_x.done; _x = _w.next()) {
                    var key = _x.value;
                    var prop = seenKeys[key];
                    if (prop) {
                        var propertyDep = schema.dependencies[key];
                        if (Array.isArray(propertyDep)) {
                            try {
                                for (var propertyDep_1 = (e_16 = void 0, jsonParser07_values(propertyDep)), propertyDep_1_1 = propertyDep_1.next(); !propertyDep_1_1.done; propertyDep_1_1 = propertyDep_1.next()) {
                                    var requiredProp = propertyDep_1_1.value;
                                    if (!seenKeys[requiredProp]) {
                                        validationResult.problems.push({
                                            location: { offset: node.offset, length: node.length },
                                            severity: DiagnosticSeverity.Warning,
                                            message: jsonParser07_localize('RequiredDependentPropWarning', 'Object is missing property {0} required by property {1}.', requiredProp, key),
                                        });
                                    }
                                    else {
                                        validationResult.propertiesValueMatches++;
                                    }
                                }
                            }
                            catch (e_16_1) { e_16 = { error: e_16_1 }; }
                            finally {
                                try {
                                    if (propertyDep_1_1 && !propertyDep_1_1.done && (_j = propertyDep_1.return)) _j.call(propertyDep_1);
                                }
                                finally { if (e_16) throw e_16.error; }
                            }
                        }
                        else {
                            var propertySchema = jsonParser07_asSchema(propertyDep);
                            if (propertySchema) {
                                var propertyValidationResult = new jsonParser07_ValidationResult(isKubernetes);
                                jsonParser07_validate(node, propertySchema, propertyValidationResult, matchingSchemas, isKubernetes);
                                validationResult.mergePropertyMatch(propertyValidationResult);
                                validationResult.mergeEnumValues(propertyValidationResult);
                            }
                        }
                    }
                }
            }
            catch (e_15_1) { e_15 = { error: e_15_1 }; }
            finally {
                try {
                    if (_x && !_x.done && (_h = _w.return)) _h.call(_w);
                }
                finally { if (e_15) throw e_15.error; }
            }
        }
        var propertyNames = jsonParser07_asSchema(schema.propertyNames);
        if (propertyNames) {
            try {
                for (var _y = jsonParser07_values(node.properties), _z = _y.next(); !_z.done; _z = _y.next()) {
                    var f = _z.value;
                    var key = f.keyNode;
                    if (key) {
                        jsonParser07_validate(key, propertyNames, validationResult, jsonParser07_NoOpSchemaCollector.instance, isKubernetes);
                    }
                }
            }
            catch (e_17_1) { e_17 = { error: e_17_1 }; }
            finally {
                try {
                    if (_z && !_z.done && (_k = _y.return)) _k.call(_y);
                }
                finally { if (e_17) throw e_17.error; }
            }
        }
    }
    //Alternative comparison is specifically used by the kubernetes/openshift schema but may lead to better results then genericComparison depending on the schema
    function alternativeComparison(subValidationResult, bestMatch, subSchema, subMatchingSchemas) {
        var compareResult = subValidationResult.compareKubernetes(bestMatch.validationResult);
        if (compareResult > 0) {
            // our node is the best matching so far
            bestMatch = {
                schema: subSchema,
                validationResult: subValidationResult,
                matchingSchemas: subMatchingSchemas,
            };
        }
        else if (compareResult === 0) {
            // there's already a best matching but we are as good
            bestMatch.matchingSchemas.merge(subMatchingSchemas);
            bestMatch.validationResult.mergeEnumValues(subValidationResult);
        }
        return bestMatch;
    }
    //genericComparison tries to find the best matching schema using a generic comparison
    function genericComparison(maxOneMatch, subValidationResult, bestMatch, subSchema, subMatchingSchemas) {
        if (!maxOneMatch &&
            !subValidationResult.hasProblems() &&
            !bestMatch.validationResult.hasProblems()) {
            // no errors, both are equally good matches
            bestMatch.matchingSchemas.merge(subMatchingSchemas);
            bestMatch.validationResult.propertiesMatches +=
                subValidationResult.propertiesMatches;
            bestMatch.validationResult.propertiesValueMatches +=
                subValidationResult.propertiesValueMatches;
        }
        else {
            var compareResult = subValidationResult.compareGeneric(bestMatch.validationResult);
            if (compareResult > 0) {
                // our node is the best matching so far
                bestMatch = {
                    schema: subSchema,
                    validationResult: subValidationResult,
                    matchingSchemas: subMatchingSchemas,
                };
            }
            else if (compareResult === 0) {
                // there's already a best matching but we are as good
                bestMatch.matchingSchemas.merge(subMatchingSchemas);
                bestMatch.validationResult.mergeEnumValues(subValidationResult);
            }
        }
        return bestMatch;
    }
}

// EXTERNAL MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/yamlAST.js
var yamlAST = __webpack_require__(2);

// EXTERNAL MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/common.js
var common = __webpack_require__(1);

// EXTERNAL MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/exception.js
var exception = __webpack_require__(4);

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/mark.js


var mark_Mark = /** @class */ (function () {
    function Mark(name, buffer, position, line, column) {
        this.name = name;
        this.buffer = buffer;
        this.position = position;
        this.line = line;
        this.column = column;
    }
    Mark.prototype.getSnippet = function (indent, maxLength) {
        if (indent === void 0) { indent = 0; }
        if (maxLength === void 0) { maxLength = 75; }
        var head, start, tail, end, snippet;
        if (!this.buffer) {
            return null;
        }
        indent = indent || 4;
        maxLength = maxLength || 75;
        head = '';
        start = this.position;
        while (start > 0 &&
            -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(start - 1))) {
            start -= 1;
            if (this.position - start > maxLength / 2 - 1) {
                head = ' ... ';
                start += 5;
                break;
            }
        }
        tail = '';
        end = this.position;
        while (end < this.buffer.length &&
            -1 === '\x00\r\n\x85\u2028\u2029'.indexOf(this.buffer.charAt(end))) {
            end += 1;
            if (end - this.position > maxLength / 2 - 1) {
                tail = ' ... ';
                end -= 5;
                break;
            }
        }
        snippet = this.buffer.slice(start, end);
        return (common["repeat"](' ', indent) +
            head +
            snippet +
            tail +
            '\n' +
            common["repeat"](' ', indent + this.position - start + head.length) +
            '^');
    };
    Mark.prototype.toString = function (compact) {
        if (compact === void 0) { compact = true; }
        var snippet, where = '';
        if (this.name) {
            where += 'in "' + this.name + '" ';
        }
        where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);
        if (!compact) {
            snippet = this.getSnippet();
            if (snippet) {
                where += ':\n' + snippet;
            }
        }
        return where;
    };
    return Mark;
}());
/* harmony default export */ var yaml_ast_parser_custom_tags_mark = (mark_Mark);

// EXTERNAL MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/schema/default_safe.js + 16 modules
var default_safe = __webpack_require__(9);

// EXTERNAL MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/schema/default_full.js + 2 modules
var default_full = __webpack_require__(14);

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/loader.js
var loader_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};

'use strict';
/*eslint-disable max-len,no-use-before-define*/





var _hasOwnProperty = Object.prototype.hasOwnProperty;
var CONTEXT_FLOW_IN = 1;
var CONTEXT_FLOW_OUT = 2;
var CONTEXT_BLOCK_IN = 3;
var CONTEXT_BLOCK_OUT = 4;
var CHOMPING_CLIP = 1;
var CHOMPING_STRIP = 2;
var CHOMPING_KEEP = 3;
var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
function is_EOL(c) {
    return c === 0x0a /* LF */ || c === 0x0d /* CR */;
}
function is_WHITE_SPACE(c) {
    return c === 0x09 /* Tab */ || c === 0x20 /* Space */;
}
function is_WS_OR_EOL(c) {
    return (c === 0x09 /* Tab */ ||
        c === 0x20 /* Space */ ||
        c === 0x0a /* LF */ ||
        c === 0x0d /* CR */);
}
function is_FLOW_INDICATOR(c) {
    return (0x2c /* , */ === c ||
        0x5b /* [ */ === c ||
        0x5d /* ] */ === c ||
        0x7b /* { */ === c ||
        0x7d /* } */ === c);
}
function fromHexCode(c) {
    var lc;
    if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
        return c - 0x30;
    }
    /*eslint-disable no-bitwise*/
    lc = c | 0x20;
    if (0x61 /* a */ <= lc && lc <= 0x66 /* f */) {
        return lc - 0x61 + 10;
    }
    return -1;
}
function escapedHexLen(c) {
    if (c === 0x78 /* x */) {
        return 2;
    }
    if (c === 0x75 /* u */) {
        return 4;
    }
    if (c === 0x55 /* U */) {
        return 8;
    }
    return 0;
}
function fromDecimalCode(c) {
    if (0x30 /* 0 */ <= c && c <= 0x39 /* 9 */) {
        return c - 0x30;
    }
    return -1;
}
function simpleEscapeSequence(c) {
    return c === 0x30 /* 0 */
        ? '\x00'
        : c === 0x61 /* a */
            ? '\x07'
            : c === 0x62 /* b */
                ? '\x08'
                : c === 0x74 /* t */
                    ? '\x09'
                    : c === 0x09 /* Tab */
                        ? '\x09'
                        : c === 0x6e /* n */
                            ? '\x0A'
                            : c === 0x76 /* v */
                                ? '\x0B'
                                : c === 0x66 /* f */
                                    ? '\x0C'
                                    : c === 0x72 /* r */
                                        ? '\x0D'
                                        : c === 0x65 /* e */
                                            ? '\x1B'
                                            : c === 0x20 /* Space */
                                                ? ' '
                                                : c === 0x22 /* " */
                                                    ? '\x22'
                                                    : c === 0x2f /* / */
                                                        ? '/'
                                                        : c === 0x5c /* \ */
                                                            ? '\x5C'
                                                            : c === 0x4e /* N */
                                                                ? '\x85'
                                                                : c === 0x5f /* _ */
                                                                    ? '\xA0'
                                                                    : c === 0x4c /* L */
                                                                        ? '\u2028'
                                                                        : c === 0x50 /* P */
                                                                            ? '\u2029'
                                                                            : '';
}
function charFromCodepoint(c) {
    if (c <= 0xffff) {
        return String.fromCharCode(c);
    }
    // Encode UTF-16 surrogate pair
    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF
    return String.fromCharCode(((c - 0x010000) >> 10) + 0xd800, ((c - 0x010000) & 0x03ff) + 0xdc00);
}
var simpleEscapeCheck = new Array(256); // integer, for fast access
var simpleEscapeMap = new Array(256);
var customEscapeCheck = new Array(256); // integer, for fast access
var customEscapeMap = new Array(256);
for (var loader_i = 0; loader_i < 256; loader_i++) {
    customEscapeMap[loader_i] = simpleEscapeMap[loader_i] = simpleEscapeSequence(loader_i);
    simpleEscapeCheck[loader_i] = simpleEscapeMap[loader_i] ? 1 : 0;
    customEscapeCheck[loader_i] = 1;
    if (!simpleEscapeCheck[loader_i]) {
        customEscapeMap[loader_i] = '\\' + String.fromCharCode(loader_i);
    }
}
var loader_State = /** @class */ (function () {
    function State(input, options) {
        this.errorMap = {};
        this.errors = [];
        this.lines = [];
        this.input = input;
        this.filename = options['filename'] || null;
        this.schema = options['schema'] || default_full["default"];
        this.onWarning = options['onWarning'] || null;
        this.legacy = options['legacy'] || false;
        this.allowAnyEscape = options['allowAnyEscape'] || false;
        this.ignoreDuplicateKeys = options['ignoreDuplicateKeys'] || false;
        this.implicitTypes = this.schema.compiledImplicit;
        this.typeMap = this.schema.compiledTypeMap;
        this.length = input.length;
        this.position = 0;
        this.line = 0;
        this.lineStart = 0;
        this.lineIndent = 0;
        this.documents = [];
    }
    return State;
}());
function generateError(state, message, isWarning) {
    if (isWarning === void 0) { isWarning = false; }
    return new exception["default"](message, new yaml_ast_parser_custom_tags_mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart), isWarning);
}
function throwErrorFromPosition(state, position, message, isWarning, toLineEnd) {
    if (isWarning === void 0) { isWarning = false; }
    if (toLineEnd === void 0) { toLineEnd = false; }
    var line = positionToLine(state, position);
    if (!line) {
        return;
    }
    var hash = message + position;
    if (state.errorMap[hash]) {
        return;
    }
    var mark = new yaml_ast_parser_custom_tags_mark(state.filename, state.input, position, line.line, position - line.start);
    if (toLineEnd) {
        mark.toLineEnd = true;
    }
    var error = new exception["default"](message, mark, isWarning);
    state.errors.push(error);
}
function throwError(state, message) {
    //FIXME
    var error = generateError(state, message);
    var hash = error.message + error.mark.position;
    if (state.errorMap[hash]) {
        return;
    }
    state.errors.push(error);
    state.errorMap[hash] = 1;
    var or = state.position;
    while (true) {
        if (state.position >= state.input.length - 1) {
            return;
        }
        var c = state.input.charAt(state.position);
        if (c == '\n') {
            state.position--;
            if (state.position == or) {
                state.position += 1;
            }
            return;
        }
        if (c == '\r') {
            state.position--;
            if (state.position == or) {
                state.position += 1;
            }
            return;
        }
        state.position++;
    }
    //throw generateError(state, message);
}
function throwWarning(state, message) {
    var error = generateError(state, message);
    if (state.onWarning) {
        state.onWarning.call(null, error);
    }
    else {
        //throw error;
    }
}
var directiveHandlers = {
    YAML: function handleYamlDirective(state, name, args) {
        var match, major, minor;
        if (null !== state.version) {
            throwError(state, 'duplication of %YAML directive');
        }
        if (1 !== args.length) {
            throwError(state, 'YAML directive accepts exactly one argument');
        }
        match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);
        if (null === match) {
            throwError(state, 'ill-formed argument of the YAML directive');
        }
        major = parseInt(match[1], 10);
        minor = parseInt(match[2], 10);
        if (1 !== major) {
            throwError(state, 'found incompatible YAML document (version 1.2 is required)');
        }
        state.version = args[0];
        state.checkLineBreaks = minor < 2;
        if (2 !== minor) {
            throwError(state, 'found incompatible YAML document (version 1.2 is required)');
        }
    },
    TAG: function handleTagDirective(state, name, args) {
        var handle, prefix;
        if (2 !== args.length) {
            throwError(state, 'TAG directive accepts exactly two arguments');
        }
        handle = args[0];
        prefix = args[1];
        if (!PATTERN_TAG_HANDLE.test(handle)) {
            throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
        }
        if (_hasOwnProperty.call(state.tagMap, handle)) {
            throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
        }
        if (!PATTERN_TAG_URI.test(prefix)) {
            throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
        }
        state.tagMap[handle] = prefix;
    },
};
function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;
    var scalar = state.result;
    if (scalar.startPosition == -1) {
        scalar.startPosition = start;
    }
    if (start <= end) {
        _result = state.input.slice(start, end);
        if (checkJson) {
            for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
                _character = _result.charCodeAt(_position);
                if (!(0x09 === _character ||
                    (0x20 <= _character && _character <= 0x10ffff))) {
                    throwError(state, 'expected valid JSON character');
                }
            }
        }
        else if (PATTERN_NON_PRINTABLE.test(_result)) {
            throwError(state, 'the stream contains non-printable characters');
        }
        scalar.value += _result;
        scalar.endPosition = end;
    }
}
function mergeMappings(state, destination, source) {
    var sourceKeys, key, index, quantity;
    if (!common["isObject"](source)) {
        throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
    }
    sourceKeys = Object.keys(source);
    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
        key = sourceKeys[index];
        if (!_hasOwnProperty.call(destination, key)) {
            destination[key] = source[key];
        }
    }
}
function storeMappingPair(state, _result, keyTag, keyNode, valueNode) {
    var index, quantity;
    if (keyNode == null) {
        return;
    }
    //keyNode = String(keyNode);
    if (null === _result) {
        _result = {
            startPosition: keyNode.startPosition,
            endPosition: valueNode.endPosition,
            parent: null,
            errors: [],
            mappings: [],
            kind: yamlAST["a" /* Kind */].MAP,
        };
    }
    // if ('tag:yaml.org,2002:merge' === keyTag) {
    //   if (Array.isArray(valueNode)) {
    //    for (index = 0, quantity = (<any>valueNode).length; index < quantity; index += 1) {
    //      mergeMappings(state, _result, valueNode[index]);
    //    }
    //   } else {
    //    mergeMappings(state, _result, valueNode);
    //   }
    // } else {
    var mapping = yamlAST["e" /* newMapping */](keyNode, valueNode);
    mapping.parent = _result;
    keyNode.parent = mapping;
    if (valueNode != null) {
        valueNode.parent = mapping;
    }
    !state.ignoreDuplicateKeys &&
        _result.mappings.forEach(function (sibling) {
            if (sibling.key &&
                sibling.key.value === (mapping.key && mapping.key.value)) {
                throwErrorFromPosition(state, mapping.key.startPosition, 'duplicate key');
                throwErrorFromPosition(state, sibling.key.startPosition, 'duplicate key');
            }
        });
    _result.mappings.push(mapping);
    _result.endPosition = valueNode
        ? valueNode.endPosition
        : keyNode.endPosition + 1; //FIXME.workaround should be position of ':' indeed
    // }
    return _result;
}
function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position);
    if (0x0a /* LF */ === ch) {
        state.position++;
    }
    else if (0x0d /* CR */ === ch) {
        state.position++;
        if (0x0a /* LF */ === state.input.charCodeAt(state.position)) {
            state.position++;
        }
    }
    else {
        throwError(state, 'a line break is expected');
    }
    state.line += 1;
    state.lineStart = state.position;
    state.lines.push({
        start: state.lineStart,
        line: state.line,
    });
}
var Line = /** @class */ (function () {
    function Line() {
    }
    return Line;
}());
function positionToLine(state, position) {
    var line;
    for (var i = 0; i < state.lines.length; i++) {
        if (state.lines[i].start > position) {
            break;
        }
        line = state.lines[i];
    }
    if (!line) {
        return {
            start: 0,
            line: 0,
        };
    }
    return line;
}
function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0, ch = state.input.charCodeAt(state.position);
    while (0 !== ch) {
        while (is_WHITE_SPACE(ch)) {
            if (ch === 0x09 /*Tab*/) {
                state.errors.push(generateError(state, 'Using tabs can lead to unpredictable results', true));
            }
            ch = state.input.charCodeAt(++state.position);
        }
        if (allowComments && 0x23 /* # */ === ch) {
            do {
                ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0x0a /* LF */ && ch !== 0x0d /* CR */ && 0 !== ch);
        }
        if (is_EOL(ch)) {
            readLineBreak(state);
            ch = state.input.charCodeAt(state.position);
            lineBreaks++;
            state.lineIndent = 0;
            while (0x20 /* Space */ === ch) {
                state.lineIndent++;
                ch = state.input.charCodeAt(++state.position);
            }
        }
        else {
            break;
        }
    }
    if (-1 !== checkIndent &&
        0 !== lineBreaks &&
        state.lineIndent < checkIndent) {
        throwWarning(state, 'deficient indentation');
    }
    return lineBreaks;
}
function testDocumentSeparator(state) {
    var _position = state.position, ch;
    ch = state.input.charCodeAt(_position);
    // Condition state.position === state.lineStart is tested
    // in parent on each call, for efficiency. No needs to test here again.
    if ((0x2d /* - */ === ch || 0x2e /* . */ === ch) &&
        state.input.charCodeAt(_position + 1) === ch &&
        state.input.charCodeAt(_position + 2) === ch) {
        _position += 3;
        ch = state.input.charCodeAt(_position);
        if (ch === 0 || is_WS_OR_EOL(ch)) {
            return true;
        }
    }
    return false;
}
function writeFoldedLines(state, scalar, count) {
    if (1 === count) {
        scalar.value += ' ';
    }
    else if (count > 1) {
        scalar.value += common["repeat"]('\n', count - 1);
    }
}
function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding, following, captureStart, captureEnd, hasPendingContent, _line, _lineStart, _lineIndent, _kind = state.kind, _result = state.result, ch;
    var state_result = yamlAST["f" /* newScalar */]();
    state_result.plainScalar = true;
    state.result = state_result;
    ch = state.input.charCodeAt(state.position);
    if (is_WS_OR_EOL(ch) ||
        is_FLOW_INDICATOR(ch) ||
        0x23 /* # */ === ch ||
        0x26 /* & */ === ch ||
        0x2a /* * */ === ch ||
        0x21 /* ! */ === ch ||
        0x7c /* | */ === ch ||
        0x3e /* > */ === ch ||
        0x27 /* ' */ === ch ||
        0x22 /* " */ === ch ||
        0x25 /* % */ === ch ||
        0x40 /* @ */ === ch ||
        0x60 /* ` */ === ch) {
        return false;
    }
    if (0x3f /* ? */ === ch || 0x2d /* - */ === ch) {
        following = state.input.charCodeAt(state.position + 1);
        if (is_WS_OR_EOL(following) ||
            (withinFlowCollection && is_FLOW_INDICATOR(following))) {
            return false;
        }
    }
    state.kind = 'scalar';
    //state.result = '';
    captureStart = captureEnd = state.position;
    hasPendingContent = false;
    while (0 !== ch) {
        if (0x3a /* : */ === ch) {
            following = state.input.charCodeAt(state.position + 1);
            if (is_WS_OR_EOL(following) ||
                (withinFlowCollection && is_FLOW_INDICATOR(following))) {
                break;
            }
        }
        else if (0x23 /* # */ === ch) {
            preceding = state.input.charCodeAt(state.position - 1);
            if (is_WS_OR_EOL(preceding)) {
                break;
            }
        }
        else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||
            (withinFlowCollection && is_FLOW_INDICATOR(ch))) {
            break;
        }
        else if (is_EOL(ch)) {
            _line = state.line;
            _lineStart = state.lineStart;
            _lineIndent = state.lineIndent;
            skipSeparationSpace(state, false, -1);
            if (state.lineIndent >= nodeIndent) {
                hasPendingContent = true;
                ch = state.input.charCodeAt(state.position);
                continue;
            }
            else {
                state.position = captureEnd;
                state.line = _line;
                state.lineStart = _lineStart;
                state.lineIndent = _lineIndent;
                break;
            }
        }
        if (hasPendingContent) {
            captureSegment(state, captureStart, captureEnd, false);
            writeFoldedLines(state, state_result, state.line - _line);
            captureStart = captureEnd = state.position;
            hasPendingContent = false;
        }
        if (!is_WHITE_SPACE(ch)) {
            captureEnd = state.position + 1;
        }
        ch = state.input.charCodeAt(++state.position);
        if (state.position >= state.input.length) {
            return false;
        }
    }
    captureSegment(state, captureStart, captureEnd, false);
    if (state.result.startPosition != -1) {
        state_result.rawValue = state.input.substring(state_result.startPosition, state_result.endPosition);
        return true;
    }
    state.kind = _kind;
    state.result = _result;
    return false;
}
function readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    ch = state.input.charCodeAt(state.position);
    if (0x27 /* ' */ !== ch) {
        return false;
    }
    var scalar = yamlAST["f" /* newScalar */]();
    scalar.singleQuoted = true;
    state.kind = 'scalar';
    state.result = scalar;
    scalar.startPosition = state.position;
    state.position++;
    captureStart = captureEnd = state.position;
    while (0 !== (ch = state.input.charCodeAt(state.position))) {
        //console.log('ch: <' + String.fromCharCode(ch) + '>');
        if (0x27 /* ' */ === ch) {
            captureSegment(state, captureStart, state.position, true);
            ch = state.input.charCodeAt(++state.position);
            //console.log('next: <' + String.fromCharCode(ch) + '>');
            scalar.endPosition = state.position;
            if (0x27 /* ' */ === ch) {
                captureStart = captureEnd = state.position;
                state.position++;
            }
            else {
                return true;
            }
        }
        else if (is_EOL(ch)) {
            captureSegment(state, captureStart, captureEnd, true);
            writeFoldedLines(state, scalar, skipSeparationSpace(state, false, nodeIndent));
            captureStart = captureEnd = state.position;
        }
        else if (state.position === state.lineStart &&
            testDocumentSeparator(state)) {
            throwError(state, 'unexpected end of the document within a single quoted scalar');
        }
        else {
            state.position++;
            captureEnd = state.position;
            scalar.endPosition = state.position;
        }
    }
    throwError(state, 'unexpected end of the stream within a single quoted scalar');
}
function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, tmpEsc, ch;
    ch = state.input.charCodeAt(state.position);
    if (0x22 /* " */ !== ch) {
        return false;
    }
    state.kind = 'scalar';
    var scalar = yamlAST["f" /* newScalar */]();
    scalar.doubleQuoted = true;
    state.result = scalar;
    scalar.startPosition = state.position;
    state.position++;
    captureStart = captureEnd = state.position;
    while (0 !== (ch = state.input.charCodeAt(state.position))) {
        if (0x22 /* " */ === ch) {
            captureSegment(state, captureStart, state.position, true);
            state.position++;
            scalar.endPosition = state.position;
            scalar.rawValue = state.input.substring(scalar.startPosition, scalar.endPosition);
            return true;
        }
        else if (0x5c /* \ */ === ch) {
            captureSegment(state, captureStart, state.position, true);
            ch = state.input.charCodeAt(++state.position);
            if (is_EOL(ch)) {
                skipSeparationSpace(state, false, nodeIndent);
                // TODO: rework to inline fn with no type cast?
            }
            else if (ch < 256 &&
                (state.allowAnyEscape ? customEscapeCheck[ch] : simpleEscapeCheck[ch])) {
                scalar.value += state.allowAnyEscape
                    ? customEscapeMap[ch]
                    : simpleEscapeMap[ch];
                state.position++;
            }
            else if ((tmp = escapedHexLen(ch)) > 0) {
                hexLength = tmp;
                hexResult = 0;
                for (; hexLength > 0; hexLength--) {
                    ch = state.input.charCodeAt(++state.position);
                    if ((tmp = fromHexCode(ch)) >= 0) {
                        hexResult = (hexResult << 4) + tmp;
                    }
                    else {
                        throwError(state, 'expected hexadecimal character');
                    }
                }
                scalar.value += charFromCodepoint(hexResult);
                state.position++;
            }
            else {
                throwError(state, 'unknown escape sequence');
            }
            captureStart = captureEnd = state.position;
        }
        else if (is_EOL(ch)) {
            captureSegment(state, captureStart, captureEnd, true);
            writeFoldedLines(state, scalar, skipSeparationSpace(state, false, nodeIndent));
            captureStart = captureEnd = state.position;
        }
        else if (state.position === state.lineStart &&
            testDocumentSeparator(state)) {
            throwError(state, 'unexpected end of the document within a double quoted scalar');
        }
        else {
            state.position++;
            captureEnd = state.position;
        }
    }
    throwError(state, 'unexpected end of the stream within a double quoted scalar');
}
function readFlowCollection(state, nodeIndent) {
    var readNext = true, _line, _tag = state.tag, _result, _anchor = state.anchor, following, terminator, isPair, isExplicitPair, isMapping, keyNode, keyTag, valueNode, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 0x5b /* [ */) {
        terminator = 0x5d; /* ] */
        isMapping = false;
        _result = yamlAST["c" /* newItems */]();
        _result.startPosition = state.position;
    }
    else if (ch === 0x7b /* { */) {
        terminator = 0x7d; /* } */
        isMapping = true;
        _result = yamlAST["d" /* newMap */]();
        _result.startPosition = state.position;
    }
    else {
        return false;
    }
    if (null !== state.anchor) {
        _result.anchorId = state.anchor;
        state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(++state.position);
    while (0 !== ch) {
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (ch === terminator) {
            state.position++;
            state.tag = _tag;
            state.anchor = _anchor;
            state.kind = isMapping ? 'mapping' : 'sequence';
            state.result = _result;
            _result.endPosition = state.position;
            return true;
        }
        else if (!readNext) {
            var p = state.position;
            throwError(state, 'missed comma between flow collection entries');
            state.position = p + 1;
        }
        keyTag = keyNode = valueNode = null;
        isPair = isExplicitPair = false;
        if (0x3f /* ? */ === ch) {
            following = state.input.charCodeAt(state.position + 1);
            if (is_WS_OR_EOL(following)) {
                isPair = isExplicitPair = true;
                state.position++;
                skipSeparationSpace(state, true, nodeIndent);
            }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
        keyTag = state.tag;
        keyNode = state.result;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if ((isExplicitPair || state.line === _line) && 0x3a /* : */ === ch) {
            isPair = true;
            ch = state.input.charCodeAt(++state.position);
            skipSeparationSpace(state, true, nodeIndent);
            composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
            valueNode = state.result;
        }
        if (isMapping) {
            storeMappingPair(state, _result, keyTag, keyNode, valueNode);
        }
        else if (isPair) {
            var mp = storeMappingPair(state, null, keyTag, keyNode, valueNode);
            mp.parent = _result;
            _result.items.push(mp);
        }
        else {
            if (keyNode) {
                keyNode.parent = _result;
            }
            _result.items.push(keyNode);
        }
        _result.endPosition = state.position + 1 /*need to add one more char*/;
        skipSeparationSpace(state, true, nodeIndent);
        ch = state.input.charCodeAt(state.position);
        if (0x2c /* , */ === ch) {
            readNext = true;
            ch = state.input.charCodeAt(++state.position);
        }
        else {
            readNext = false;
        }
    }
    throwError(state, 'unexpected end of the stream within a flow collection');
}
function readBlockScalar(state, nodeIndent) {
    var captureStart, folding, chomping = CHOMPING_CLIP, detectedIndent = false, textIndent = nodeIndent, emptyLines = 0, atMoreIndented = false, tmp, ch;
    ch = state.input.charCodeAt(state.position);
    if (ch === 0x7c /* | */) {
        folding = false;
    }
    else if (ch === 0x3e /* > */) {
        folding = true;
    }
    else {
        return false;
    }
    var sc = yamlAST["f" /* newScalar */]();
    state.kind = 'scalar';
    state.result = sc;
    sc.startPosition = state.position;
    while (0 !== ch) {
        ch = state.input.charCodeAt(++state.position);
        if (0x2b /* + */ === ch || 0x2d /* - */ === ch) {
            if (CHOMPING_CLIP === chomping) {
                chomping = 0x2b /* + */ === ch ? CHOMPING_KEEP : CHOMPING_STRIP;
            }
            else {
                throwError(state, 'repeat of a chomping mode identifier');
            }
        }
        else if ((tmp = fromDecimalCode(ch)) >= 0) {
            if (tmp === 0) {
                throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
            }
            else if (!detectedIndent) {
                textIndent = nodeIndent + tmp - 1;
                detectedIndent = true;
            }
            else {
                throwError(state, 'repeat of an indentation width identifier');
            }
        }
        else {
            break;
        }
    }
    if (is_WHITE_SPACE(ch)) {
        do {
            ch = state.input.charCodeAt(++state.position);
        } while (is_WHITE_SPACE(ch));
        if (0x23 /* # */ === ch) {
            do {
                ch = state.input.charCodeAt(++state.position);
            } while (!is_EOL(ch) && 0 !== ch);
        }
    }
    while (0 !== ch) {
        readLineBreak(state);
        state.lineIndent = 0;
        ch = state.input.charCodeAt(state.position);
        while ((!detectedIndent || state.lineIndent < textIndent) &&
            0x20 /* Space */ === ch) {
            state.lineIndent++;
            ch = state.input.charCodeAt(++state.position);
        }
        if (!detectedIndent && state.lineIndent > textIndent) {
            textIndent = state.lineIndent;
        }
        if (is_EOL(ch)) {
            emptyLines++;
            continue;
        }
        // End of the scalar.
        if (state.lineIndent < textIndent) {
            // Perform the chomping.
            if (chomping === CHOMPING_KEEP) {
                sc.value += common["repeat"]('\n', emptyLines);
            }
            else if (chomping === CHOMPING_CLIP) {
                if (detectedIndent) {
                    // i.e. only if the scalar is not empty.
                    sc.value += '\n';
                }
            }
            // Break this `while` cycle and go to the funciton's epilogue.
            break;
        }
        // Folded style: use fancy rules to handle line breaks.
        if (folding) {
            // Lines starting with white space characters (more-indented lines) are not folded.
            if (is_WHITE_SPACE(ch)) {
                atMoreIndented = true;
                sc.value += common["repeat"]('\n', emptyLines + 1);
                // End of more-indented block.
            }
            else if (atMoreIndented) {
                atMoreIndented = false;
                sc.value += common["repeat"]('\n', emptyLines + 1);
                // Just one line break - perceive as the same line.
            }
            else if (0 === emptyLines) {
                if (detectedIndent) {
                    // i.e. only if we have already read some scalar content.
                    sc.value += ' ';
                }
                // Several line breaks - perceive as different lines.
            }
            else {
                sc.value += common["repeat"]('\n', emptyLines);
            }
            // Literal style: just add exact number of line breaks between content lines.
        }
        else if (detectedIndent) {
            // If current line isn't the first one - count line break from the last content line.
            sc.value += common["repeat"]('\n', emptyLines + 1);
        }
        else {
            // In case of the first content line - count only empty lines.
        }
        detectedIndent = true;
        emptyLines = 0;
        captureStart = state.position;
        while (!is_EOL(ch) && 0 !== ch) {
            ch = state.input.charCodeAt(++state.position);
        }
        captureSegment(state, captureStart, state.position, false);
    }
    sc.endPosition = state.position;
    var i = state.position - 1;
    var needMinus = false;
    while (true) {
        var c = state.input[i];
        if (c == '\r' || c == '\n') {
            if (needMinus) {
                i--;
            }
            break;
        }
        if (c != ' ' && c != '\t') {
            break;
        }
        i--;
        //needMinus=true;
    }
    sc.endPosition = i;
    sc.rawValue = state.input.substring(sc.startPosition, sc.endPosition);
    return true;
}
function readBlockSequence(state, nodeIndent) {
    var _line, _tag = state.tag, _anchor = state.anchor, _result = yamlAST["c" /* newItems */](), following, detected = false, ch;
    if (null !== state.anchor) {
        _result.anchorId = state.anchor;
        state.anchorMap[state.anchor] = _result;
    }
    _result.startPosition = state.position;
    ch = state.input.charCodeAt(state.position);
    while (0 !== ch) {
        if (0x2d /* - */ !== ch) {
            break;
        }
        following = state.input.charCodeAt(state.position + 1);
        if (!is_WS_OR_EOL(following)) {
            break;
        }
        detected = true;
        state.position++;
        if (skipSeparationSpace(state, true, -1)) {
            if (state.lineIndent <= nodeIndent) {
                _result.items.push(null);
                ch = state.input.charCodeAt(state.position);
                continue;
            }
        }
        _line = state.line;
        composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);
        if (state.result) {
            state.result.parent = _result;
            _result.items.push(state.result);
        }
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if ((state.line === _line || state.lineIndent > nodeIndent) && 0 !== ch) {
            throwError(state, 'bad indentation of a sequence entry');
        }
        else if (state.lineIndent < nodeIndent) {
            break;
        }
    }
    _result.endPosition = state.position;
    if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = 'sequence';
        state.result = _result;
        _result.endPosition = state.position;
        return true;
    }
    return false;
}
function readBlockMapping(state, nodeIndent, flowIndent) {
    var following, allowCompact, _line, _tag = state.tag, _anchor = state.anchor, _result = yamlAST["d" /* newMap */](), keyTag = null, keyNode = null, valueNode = null, atExplicitKey = false, detected = false, ch;
    _result.startPosition = state.position;
    if (null !== state.anchor) {
        _result.anchorId = state.anchor;
        state.anchorMap[state.anchor] = _result;
    }
    ch = state.input.charCodeAt(state.position);
    while (0 !== ch) {
        following = state.input.charCodeAt(state.position + 1);
        _line = state.line; // Save the current line.
        //
        // Explicit notation case. There are two separate blocks:
        // first for the key (denoted by "?") and second for the value (denoted by ":")
        //
        if ((0x3f /* ? */ === ch || 0x3a /* : */ === ch) &&
            is_WS_OR_EOL(following)) {
            if (0x3f /* ? */ === ch) {
                if (atExplicitKey) {
                    storeMappingPair(state, _result, keyTag, keyNode, null);
                    keyTag = keyNode = valueNode = null;
                }
                detected = true;
                atExplicitKey = true;
                allowCompact = true;
            }
            else if (atExplicitKey) {
                // i.e. 0x3A/* : */ === character after the explicit key.
                atExplicitKey = false;
                allowCompact = true;
            }
            else {
                throwError(state, 'incomplete explicit mapping pair; a key node is missed');
            }
            state.position += 1;
            ch = following;
            //
            // Implicit notation case. Flow-style node as the key first, then ":", and the value.
            //
        }
        else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
            if (state.line === _line) {
                ch = state.input.charCodeAt(state.position);
                while (is_WHITE_SPACE(ch)) {
                    ch = state.input.charCodeAt(++state.position);
                }
                if (0x3a /* : */ === ch) {
                    ch = state.input.charCodeAt(++state.position);
                    if (!is_WS_OR_EOL(ch)) {
                        throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
                    }
                    if (atExplicitKey) {
                        storeMappingPair(state, _result, keyTag, keyNode, null);
                        keyTag = keyNode = valueNode = null;
                    }
                    detected = true;
                    atExplicitKey = false;
                    allowCompact = false;
                    keyTag = state.tag;
                    keyNode = state.result;
                }
                else if (state.position == state.lineStart &&
                    testDocumentSeparator(state)) {
                    break; // Reading is done. Go to the epilogue.
                }
                else if (detected) {
                    throwError(state, 'can not read an implicit mapping pair; a colon is missed');
                }
                else {
                    state.tag = _tag;
                    state.anchor = _anchor;
                    return true; // Keep the result of `composeNode`.
                }
            }
            else if (detected) {
                throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
                while (state.position > 0) {
                    ch = state.input.charCodeAt(--state.position);
                    if (is_EOL(ch)) {
                        state.position++;
                        break;
                    }
                }
            }
            else {
                state.tag = _tag;
                state.anchor = _anchor;
                return true; // Keep the result of `composeNode`.
            }
        }
        else {
            break; // Reading is done. Go to the epilogue.
        }
        //
        // Common reading code for both explicit and implicit notations.
        //
        if (state.line === _line || state.lineIndent > nodeIndent) {
            if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
                if (atExplicitKey) {
                    keyNode = state.result;
                }
                else {
                    valueNode = state.result;
                }
            }
            if (!atExplicitKey) {
                storeMappingPair(state, _result, keyTag, keyNode, valueNode);
                keyTag = keyNode = valueNode = null;
            }
            skipSeparationSpace(state, true, -1);
            ch = state.input.charCodeAt(state.position);
        }
        if (state.lineIndent > nodeIndent && 0 !== ch) {
            throwError(state, 'bad indentation of a mapping entry');
        }
        else if (state.lineIndent < nodeIndent) {
            break;
        }
    }
    //
    // Epilogue.
    //
    // Special case: last mapping's node contains only the key in explicit notation.
    if (atExplicitKey) {
        storeMappingPair(state, _result, keyTag, keyNode, null);
    }
    // Expose the resulting mapping.
    if (detected) {
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = 'mapping';
        state.result = _result;
    }
    return detected;
}
function readTagProperty(state) {
    var _position, isVerbatim = false, isNamed = false, tagHandle, tagName, ch;
    ch = state.input.charCodeAt(state.position);
    if (0x21 /* ! */ !== ch) {
        return false;
    }
    if (null !== state.tag) {
        throwError(state, 'duplication of a tag property');
    }
    ch = state.input.charCodeAt(++state.position);
    if (0x3c /* < */ === ch) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
    }
    else if (0x21 /* ! */ === ch) {
        isNamed = true;
        tagHandle = '!!';
        ch = state.input.charCodeAt(++state.position);
    }
    else {
        tagHandle = '!';
    }
    _position = state.position;
    if (isVerbatim) {
        do {
            ch = state.input.charCodeAt(++state.position);
        } while (0 !== ch && 0x3e /* > */ !== ch);
        if (state.position < state.length) {
            tagName = state.input.slice(_position, state.position);
            ch = state.input.charCodeAt(++state.position);
        }
        else {
            throwError(state, 'unexpected end of the stream within a verbatim tag');
        }
    }
    else {
        while (0 !== ch && !is_WS_OR_EOL(ch)) {
            if (0x21 /* ! */ === ch) {
                if (!isNamed) {
                    tagHandle = state.input.slice(_position - 1, state.position + 1);
                    if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                        throwError(state, 'named tag handle cannot contain such characters');
                    }
                    isNamed = true;
                    _position = state.position + 1;
                }
                else {
                    throwError(state, 'tag suffix cannot contain exclamation marks');
                }
            }
            ch = state.input.charCodeAt(++state.position);
        }
        tagName = state.input.slice(_position, state.position);
        if (PATTERN_FLOW_INDICATORS.test(tagName)) {
            throwError(state, 'tag suffix cannot contain flow indicator characters');
        }
    }
    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
        throwError(state, 'tag name cannot contain such characters: ' + tagName);
    }
    if (isVerbatim) {
        state.tag = tagName;
    }
    else if (_hasOwnProperty.call(state.tagMap, tagHandle)) {
        state.tag = state.tagMap[tagHandle] + tagName;
    }
    else if ('!' === tagHandle) {
        state.tag = '!' + tagName;
    }
    else if ('!!' === tagHandle) {
        state.tag = 'tag:yaml.org,2002:' + tagName;
    }
    else {
        throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    }
    return true;
}
function readAnchorProperty(state) {
    var _position, ch;
    ch = state.input.charCodeAt(state.position);
    if (0x26 /* & */ !== ch) {
        return false;
    }
    if (null !== state.anchor) {
        throwError(state, 'duplication of an anchor property');
    }
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
    }
    if (state.position === _position) {
        throwError(state, 'name of an anchor node must contain at least one character');
    }
    state.anchor = state.input.slice(_position, state.position);
    return true;
}
function readAlias(state) {
    var _position, alias, len = state.length, input = state.input, ch;
    ch = state.input.charCodeAt(state.position);
    if (0x2a /* * */ !== ch) {
        return false;
    }
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;
    while (0 !== ch && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
        ch = state.input.charCodeAt(++state.position);
    }
    if (state.position <= _position) {
        throwError(state, 'name of an alias node must contain at least one character');
        state.position = _position + 1;
    }
    alias = state.input.slice(_position, state.position);
    if (!state.anchorMap.hasOwnProperty(alias)) {
        throwError(state, 'unidentified alias "' + alias + '"');
        if (state.position <= _position) {
            state.position = _position + 1;
        }
    }
    state.result = yamlAST["b" /* newAnchorRef */](alias, _position, state.position, state.anchorMap[alias]);
    skipSeparationSpace(state, true, -1);
    return true;
}
function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles, allowBlockScalars, allowBlockCollections, indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent
    atNewLine = false, hasContent = false, typeIndex, typeQuantity, type, flowIndent, blockIndent, _result;
    state.tag = null;
    state.anchor = null;
    state.kind = null;
    state.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections =
        CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;
    if (allowToSeek) {
        if (skipSeparationSpace(state, true, -1)) {
            atNewLine = true;
            if (state.lineIndent > parentIndent) {
                indentStatus = 1;
            }
            else if (state.lineIndent === parentIndent) {
                indentStatus = 0;
            }
            else if (state.lineIndent < parentIndent) {
                indentStatus = -1;
            }
        }
    }
    var tagStart = state.position;
    var tagColumn = state.position - state.lineStart;
    if (1 === indentStatus) {
        while (readTagProperty(state) || readAnchorProperty(state)) {
            if (skipSeparationSpace(state, true, -1)) {
                atNewLine = true;
                allowBlockCollections = allowBlockStyles;
                if (state.lineIndent > parentIndent) {
                    indentStatus = 1;
                }
                else if (state.lineIndent === parentIndent) {
                    indentStatus = 0;
                }
                else if (state.lineIndent < parentIndent) {
                    indentStatus = -1;
                }
            }
            else {
                allowBlockCollections = false;
            }
        }
    }
    if (allowBlockCollections) {
        allowBlockCollections = atNewLine || allowCompact;
    }
    if (1 === indentStatus || CONTEXT_BLOCK_OUT === nodeContext) {
        if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
            flowIndent = parentIndent;
        }
        else {
            flowIndent = parentIndent + 1;
        }
        blockIndent = state.position - state.lineStart;
        if (1 === indentStatus) {
            if ((allowBlockCollections &&
                (readBlockSequence(state, blockIndent) ||
                    readBlockMapping(state, blockIndent, flowIndent))) ||
                readFlowCollection(state, flowIndent)) {
                hasContent = true;
            }
            else {
                if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||
                    readSingleQuotedScalar(state, flowIndent) ||
                    readDoubleQuotedScalar(state, flowIndent)) {
                    hasContent = true;
                }
                else if (readAlias(state)) {
                    hasContent = true;
                    if (null !== state.tag || null !== state.anchor) {
                        throwError(state, 'alias node should not have any properties');
                    }
                }
                else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
                    hasContent = true;
                    if (null === state.tag) {
                        state.tag = '?';
                    }
                }
                if (null !== state.anchor) {
                    state.anchorMap[state.anchor] = state.result;
                    state.result.anchorId = state.anchor;
                }
            }
        }
        else if (0 === indentStatus) {
            // Special case: block sequences are allowed to have same indentation level as the parent.
            // http://www.yaml.org/spec/1.2/spec.html#id2799784
            hasContent =
                allowBlockCollections && readBlockSequence(state, blockIndent);
        }
    }
    if (null !== state.tag && '!' !== state.tag) {
        if (state.tag == '!include') {
            if (!state.result) {
                state.result = yamlAST["f" /* newScalar */]();
                state.result.startPosition = state.position;
                state.result.endPosition = state.position;
                throwError(state, '!include without value');
            }
            state.result.kind = yamlAST["a" /* Kind */].INCLUDE_REF;
        }
        else if ('?' === state.tag) {
            for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
                type = state.implicitTypes[typeIndex];
                // Implicit resolving is not allowed for non-scalar types, and '?'
                // non-specific tag is only assigned to plain scalars. So, it isn't
                // needed to check for 'kind' conformity.
                var vl = state.result['value'];
                if (type.resolve(vl)) {
                    // `state.result` updated in resolver if matched
                    state.result.valueObject = type.construct(state.result['value']);
                    state.tag = type.tag;
                    if (null !== state.anchor) {
                        state.result.anchorId = state.anchor;
                        state.anchorMap[state.anchor] = state.result;
                    }
                    break;
                }
            }
        }
        else if (_hasOwnProperty.call(state.typeMap, state.tag)) {
            type = state.typeMap[state.tag];
            if (null !== state.result &&
                type.kind !== state.kind &&
                (!type.additionalKinds ||
                    (type.additionalKinds &&
                        type.additionalKinds.indexOf(state.kind) === -1))) {
                throwError(state, 'unacceptable node kind for !<' +
                    state.tag +
                    '> tag; it should be "' +
                    type.kind +
                    '", not "' +
                    state.kind +
                    '"');
            }
            if (!type.resolve(state.result)) {
                // `state.result` updated in resolver if matched
                throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
            }
            else {
                state.result = type.construct(state.result);
                if (null !== state.anchor) {
                    state.result.anchorId = state.anchor;
                    state.anchorMap[state.anchor] = state.result;
                }
            }
        }
        else {
            throwErrorFromPosition(state, tagStart, 'unknown tag <' + state.tag + '>', false, true);
        }
    }
    return null !== state.tag || null !== state.anchor || hasContent;
}
function readDocument(state) {
    var documentStart = state.position, _position, directiveName, directiveArgs, hasDirectives = false, ch;
    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = {};
    state.anchorMap = {};
    while (0 !== (ch = state.input.charCodeAt(state.position))) {
        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
        if (state.lineIndent > 0 || 0x25 /* % */ !== ch) {
            break;
        }
        hasDirectives = true;
        ch = state.input.charCodeAt(++state.position);
        _position = state.position;
        while (0 !== ch && !is_WS_OR_EOL(ch)) {
            ch = state.input.charCodeAt(++state.position);
        }
        directiveName = state.input.slice(_position, state.position);
        directiveArgs = [];
        if (directiveName.length < 1) {
            throwError(state, 'directive name must not be less than one character in length');
        }
        while (0 !== ch) {
            while (is_WHITE_SPACE(ch)) {
                ch = state.input.charCodeAt(++state.position);
            }
            if (0x23 /* # */ === ch) {
                do {
                    ch = state.input.charCodeAt(++state.position);
                } while (0 !== ch && !is_EOL(ch));
                break;
            }
            if (is_EOL(ch)) {
                break;
            }
            _position = state.position;
            while (0 !== ch && !is_WS_OR_EOL(ch)) {
                ch = state.input.charCodeAt(++state.position);
            }
            directiveArgs.push(state.input.slice(_position, state.position));
        }
        if (0 !== ch) {
            readLineBreak(state);
        }
        if (_hasOwnProperty.call(directiveHandlers, directiveName)) {
            directiveHandlers[directiveName](state, directiveName, directiveArgs);
        }
        else {
            throwWarning(state, 'unknown document directive "' + directiveName + '"');
            state.position++;
        }
    }
    skipSeparationSpace(state, true, -1);
    if (0 === state.lineIndent &&
        0x2d /* - */ === state.input.charCodeAt(state.position) &&
        0x2d /* - */ === state.input.charCodeAt(state.position + 1) &&
        0x2d /* - */ === state.input.charCodeAt(state.position + 2)) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
    }
    else if (hasDirectives) {
        throwError(state, 'directives end mark is expected');
    }
    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);
    if (state.checkLineBreaks &&
        PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
        throwWarning(state, 'non-ASCII line breaks are interpreted as content');
    }
    state.documents.push(state.result);
    if (state.position === state.lineStart && testDocumentSeparator(state)) {
        if (0x2e /* . */ === state.input.charCodeAt(state.position)) {
            state.position += 3;
            skipSeparationSpace(state, true, -1);
        }
        return;
    }
    if (state.position < state.length - 1) {
        throwError(state, 'end of the stream or a document separator is expected');
    }
    else {
        return;
    }
}
function loadDocuments(input, options) {
    var e_1, _a;
    input = String(input);
    options = options || {};
    var inputLength = input.length;
    if (inputLength !== 0) {
        // Add tailing `\n` if not exists
        if (0x0a /* LF */ !== input.charCodeAt(inputLength - 1) &&
            0x0d /* CR */ !== input.charCodeAt(inputLength - 1)) {
            input += '\n';
        }
        // Strip BOM
        if (input.charCodeAt(0) === 0xfeff) {
            input = input.slice(1);
        }
    }
    var state = new loader_State(input, options);
    // Use 0 as string terminator. That significantly simplifies bounds check.
    state.input += '\0';
    while (0x20 /* Space */ === state.input.charCodeAt(state.position)) {
        state.lineIndent += 1;
        state.position += 1;
    }
    while (state.position < state.length - 1) {
        var q = state.position;
        readDocument(state);
        if (state.position <= q) {
            for (; state.position < state.length - 1; state.position++) {
                var c = state.input.charAt(state.position);
                if (c == '\n') {
                    break;
                }
            }
            //skip to the new lne
        }
    }
    var documents = state.documents;
    var docsCount = documents.length;
    if (docsCount > 0) {
        //last document takes the file till the end
        documents[docsCount - 1].endPosition = inputLength;
    }
    try {
        for (var documents_1 = loader_values(documents), documents_1_1 = documents_1.next(); !documents_1_1.done; documents_1_1 = documents_1.next()) {
            var x = documents_1_1.value;
            x.errors = state.errors;
            if (x.startPosition > x.endPosition) {
                x.startPosition = x.endPosition;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (documents_1_1 && !documents_1_1.done && (_a = documents_1.return)) _a.call(documents_1);
        }
        finally { if (e_1) throw e_1.error; }
    }
    return documents;
}
function loadAll(input, iterator, options) {
    if (options === void 0) { options = {}; }
    var documents = loadDocuments(input, options), index, length;
    for (index = 0, length = documents.length; index < length; index += 1) {
        iterator(documents[index]);
    }
}
function load(input, options) {
    if (options === void 0) { options = {}; }
    var documents = loadDocuments(input, options), index, length;
    if (0 === documents.length) {
        /*eslint-disable no-undefined*/
        return undefined;
    }
    else if (1 === documents.length) {
        return documents[0];
    }
    var e = new exception["default"]('expected a single document in the stream, but found more');
    e.mark = new yaml_ast_parser_custom_tags_mark('', '', 0, 0, 0);
    e.mark.position = documents[0].endPosition;
    documents[0].errors.push(e);
    //it is an artifact which is caused by the fact that we are checking next char before stopping parse
    return documents[0];
}
function safeLoadAll(input, output, options) {
    if (options === void 0) { options = {}; }
    loadAll(input, output, common["extend"]({ schema: default_safe["default"] }, options));
}
function safeLoad(input, options) {
    if (options === void 0) { options = {}; }
    return load(input, common["extend"]({ schema: default_safe["default"] }, options));
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/dumper.js

/*eslint-disable no-use-before-define*/
var dumper_common = __webpack_require__(1);
var YAMLException = __webpack_require__(4);
var DEFAULT_FULL_SCHEMA = __webpack_require__(14);
var DEFAULT_SAFE_SCHEMA = __webpack_require__(9);
var _toString = Object.prototype.toString;
var dumper_hasOwnProperty = Object.prototype.hasOwnProperty;
var CHAR_TAB = 0x09; /* Tab */
var CHAR_LINE_FEED = 0x0a; /* LF */
var CHAR_CARRIAGE_RETURN = 0x0d; /* CR */
var CHAR_SPACE = 0x20; /* Space */
var CHAR_EXCLAMATION = 0x21; /* ! */
var CHAR_DOUBLE_QUOTE = 0x22; /* " */
var CHAR_SHARP = 0x23; /* # */
var CHAR_PERCENT = 0x25; /* % */
var CHAR_AMPERSAND = 0x26; /* & */
var CHAR_SINGLE_QUOTE = 0x27; /* ' */
var CHAR_ASTERISK = 0x2a; /* * */
var CHAR_COMMA = 0x2c; /* , */
var CHAR_MINUS = 0x2d; /* - */
var CHAR_COLON = 0x3a; /* : */
var CHAR_GREATER_THAN = 0x3e; /* > */
var CHAR_QUESTION = 0x3f; /* ? */
var CHAR_COMMERCIAL_AT = 0x40; /* @ */
var CHAR_LEFT_SQUARE_BRACKET = 0x5b; /* [ */
var CHAR_RIGHT_SQUARE_BRACKET = 0x5d; /* ] */
var CHAR_GRAVE_ACCENT = 0x60; /* ` */
var CHAR_LEFT_CURLY_BRACKET = 0x7b; /* { */
var CHAR_VERTICAL_LINE = 0x7c; /* | */
var CHAR_RIGHT_CURLY_BRACKET = 0x7d; /* } */
var ESCAPE_SEQUENCES = {};
ESCAPE_SEQUENCES[0x00] = '\\0';
ESCAPE_SEQUENCES[0x07] = '\\a';
ESCAPE_SEQUENCES[0x08] = '\\b';
ESCAPE_SEQUENCES[0x09] = '\\t';
ESCAPE_SEQUENCES[0x0a] = '\\n';
ESCAPE_SEQUENCES[0x0b] = '\\v';
ESCAPE_SEQUENCES[0x0c] = '\\f';
ESCAPE_SEQUENCES[0x0d] = '\\r';
ESCAPE_SEQUENCES[0x1b] = '\\e';
ESCAPE_SEQUENCES[0x22] = '\\"';
ESCAPE_SEQUENCES[0x5c] = '\\\\';
ESCAPE_SEQUENCES[0x85] = '\\N';
ESCAPE_SEQUENCES[0xa0] = '\\_';
ESCAPE_SEQUENCES[0x2028] = '\\L';
ESCAPE_SEQUENCES[0x2029] = '\\P';
var DEPRECATED_BOOLEANS_SYNTAX = [
    'y',
    'Y',
    'yes',
    'Yes',
    'YES',
    'on',
    'On',
    'ON',
    'n',
    'N',
    'no',
    'No',
    'NO',
    'off',
    'Off',
    'OFF',
];
function compileStyleMap(schema, map) {
    var result, keys, index, length, tag, style, type;
    if (null === map) {
        return {};
    }
    result = {};
    keys = Object.keys(map);
    for (index = 0, length = keys.length; index < length; index += 1) {
        tag = keys[index];
        style = String(map[tag]);
        if ('!!' === tag.slice(0, 2)) {
            tag = 'tag:yaml.org,2002:' + tag.slice(2);
        }
        type = schema.compiledTypeMap[tag];
        if (type && dumper_hasOwnProperty.call(type.styleAliases, style)) {
            style = type.styleAliases[style];
        }
        result[tag] = style;
    }
    return result;
}
function encodeHex(character) {
    var string, handle, length;
    string = character.toString(16).toUpperCase();
    if (character <= 0xff) {
        handle = 'x';
        length = 2;
    }
    else if (character <= 0xffff) {
        handle = 'u';
        length = 4;
    }
    else if (character <= 0xffffffff) {
        handle = 'U';
        length = 8;
    }
    else {
        throw new YAMLException('code point within a string may not be greater than 0xFFFFFFFF');
    }
    return '\\' + handle + dumper_common.repeat('0', length - string.length) + string;
}
function dumper_State(options) {
    this.schema = options['schema'] || DEFAULT_FULL_SCHEMA;
    this.indent = Math.max(1, options['indent'] || 2);
    this.skipInvalid = options['skipInvalid'] || false;
    this.flowLevel = dumper_common.isNothing(options['flowLevel'])
        ? -1
        : options['flowLevel'];
    this.styleMap = compileStyleMap(this.schema, options['styles'] || null);
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = '';
    this.duplicates = [];
    this.usedDuplicates = null;
}
function indentString(string, spaces) {
    var ind = dumper_common.repeat(' ', spaces), position = 0, next = -1, result = '', line, length = string.length;
    while (position < length) {
        next = string.indexOf('\n', position);
        if (next === -1) {
            line = string.slice(position);
            position = length;
        }
        else {
            line = string.slice(position, next + 1);
            position = next + 1;
        }
        if (line.length && line !== '\n') {
            result += ind;
        }
        result += line;
    }
    return result;
}
function generateNextLine(state, level) {
    return '\n' + dumper_common.repeat(' ', state.indent * level);
}
function testImplicitResolving(state, str) {
    var index, length, type;
    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
        type = state.implicitTypes[index];
        if (type.resolve(str)) {
            return true;
        }
    }
    return false;
}
function StringBuilder(source) {
    this.source = source;
    this.result = '';
    this.checkpoint = 0;
}
StringBuilder.prototype.takeUpTo = function (position) {
    var er;
    if (position < this.checkpoint) {
        er = new Error('position should be > checkpoint');
        er.position = position;
        er.checkpoint = this.checkpoint;
        throw er;
    }
    this.result += this.source.slice(this.checkpoint, position);
    this.checkpoint = position;
    return this;
};
StringBuilder.prototype.escapeChar = function () {
    var character, esc;
    character = this.source.charCodeAt(this.checkpoint);
    esc = ESCAPE_SEQUENCES[character] || encodeHex(character);
    this.result += esc;
    this.checkpoint += 1;
    return this;
};
StringBuilder.prototype.finish = function () {
    if (this.source.length > this.checkpoint) {
        this.takeUpTo(this.source.length);
    }
};
function writeScalar(state, object, level) {
    var simple, first, spaceWrap, folded, literal, single, double, sawLineFeed, linePosition, longestLine, indent, max, character, position, escapeSeq, hexEsc, previous, lineLength, modifier, trailingLineBreaks, result;
    if (0 === object.length) {
        state.dump = "''";
        return;
    }
    if (object.indexOf('!include') == 0) {
        state.dump = '' + object; //FIXME
        return;
    }
    if (object.indexOf('!$$$novalue') == 0) {
        state.dump = ''; //FIXME
        return;
    }
    if (-1 !== DEPRECATED_BOOLEANS_SYNTAX.indexOf(object)) {
        state.dump = "'" + object + "'";
        return;
    }
    simple = true;
    first = object.length ? object.charCodeAt(0) : 0;
    spaceWrap =
        CHAR_SPACE === first || CHAR_SPACE === object.charCodeAt(object.length - 1);
    // Simplified check for restricted first characters
    // http://www.yaml.org/spec/1.2/spec.html#ns-plain-first%28c%29
    if (CHAR_MINUS === first ||
        CHAR_QUESTION === first ||
        CHAR_COMMERCIAL_AT === first ||
        CHAR_GRAVE_ACCENT === first) {
        simple = false;
    }
    // can only use > and | if not wrapped in spaces.
    if (spaceWrap) {
        simple = false;
        folded = false;
        literal = false;
    }
    else {
        folded = true;
        literal = true;
    }
    single = true;
    double = new StringBuilder(object);
    sawLineFeed = false;
    linePosition = 0;
    longestLine = 0;
    indent = state.indent * level;
    max = 80;
    if (indent < 40) {
        max -= indent;
    }
    else {
        max = 40;
    }
    for (position = 0; position < object.length; position++) {
        character = object.charCodeAt(position);
        if (simple) {
            // Characters that can never appear in the simple scalar
            if (!simpleChar(character)) {
                simple = false;
            }
            else {
                // Still simple.  If we make it all the way through like
                // this, then we can just dump the string as-is.
                continue;
            }
        }
        if (single && character === CHAR_SINGLE_QUOTE) {
            single = false;
        }
        escapeSeq = ESCAPE_SEQUENCES[character];
        hexEsc = needsHexEscape(character);
        if (!escapeSeq && !hexEsc) {
            continue;
        }
        if (character !== CHAR_LINE_FEED &&
            character !== CHAR_DOUBLE_QUOTE &&
            character !== CHAR_SINGLE_QUOTE) {
            folded = false;
            literal = false;
        }
        else if (character === CHAR_LINE_FEED) {
            sawLineFeed = true;
            single = false;
            if (position > 0) {
                previous = object.charCodeAt(position - 1);
                if (previous === CHAR_SPACE) {
                    literal = false;
                    folded = false;
                }
            }
            if (folded) {
                lineLength = position - linePosition;
                linePosition = position;
                if (lineLength > longestLine) {
                    longestLine = lineLength;
                }
            }
        }
        if (character !== CHAR_DOUBLE_QUOTE) {
            single = false;
        }
        double.takeUpTo(position);
        double.escapeChar();
    }
    if (simple && testImplicitResolving(state, object)) {
        simple = false;
    }
    modifier = '';
    if (folded || literal) {
        trailingLineBreaks = 0;
        if (object.charCodeAt(object.length - 1) === CHAR_LINE_FEED) {
            trailingLineBreaks += 1;
            if (object.charCodeAt(object.length - 2) === CHAR_LINE_FEED) {
                trailingLineBreaks += 1;
            }
        }
        if (trailingLineBreaks === 0) {
            modifier = '-';
        }
        else if (trailingLineBreaks === 2) {
            modifier = '+';
        }
    }
    if (literal && longestLine < max) {
        folded = false;
    }
    // If it's literally one line, then don't bother with the literal.
    // We may still want to do a fold, though, if it's a super long line.
    if (!sawLineFeed) {
        literal = false;
    }
    if (simple) {
        state.dump = object;
    }
    else if (single) {
        state.dump = "'" + object + "'";
    }
    else if (folded) {
        result = fold(object, max);
        state.dump = '>' + modifier + '\n' + indentString(result, indent);
    }
    else if (literal) {
        if (!modifier) {
            object = object.replace(/\n$/, '');
        }
        state.dump = '|' + modifier + '\n' + indentString(object, indent);
    }
    else if (double) {
        double.finish();
        state.dump = '"' + double.result + '"';
    }
    else {
        throw new Error('Failed to dump scalar value');
    }
    return;
}
// The `trailing` var is a regexp match of any trailing `\n` characters.
//
// There are three cases we care about:
//
// 1. One trailing `\n` on the string.  Just use `|` or `>`.
//    This is the assumed default. (trailing = null)
// 2. No trailing `\n` on the string.  Use `|-` or `>-` to "chomp" the end.
// 3. More than one trailing `\n` on the string.  Use `|+` or `>+`.
//
// In the case of `>+`, these line breaks are *not* doubled (like the line
// breaks within the string), so it's important to only end with the exact
// same number as we started.
function fold(object, max) {
    var result = '', position = 0, length = object.length, trailing = /\n+$/.exec(object), newLine;
    if (trailing) {
        length = trailing.index + 1;
    }
    while (position < length) {
        newLine = object.indexOf('\n', position);
        if (newLine > length || newLine === -1) {
            if (result) {
                result += '\n\n';
            }
            result += foldLine(object.slice(position, length), max);
            position = length;
        }
        else {
            if (result) {
                result += '\n\n';
            }
            result += foldLine(object.slice(position, newLine), max);
            position = newLine + 1;
        }
    }
    if (trailing && trailing[0] !== '\n') {
        result += trailing[0];
    }
    return result;
}
function foldLine(line, max) {
    if (line === '') {
        return line;
    }
    var foldRe = /[^\s] [^\s]/g, result = '', prevMatch = 0, foldStart = 0, match = foldRe.exec(line), index, foldEnd, folded;
    while (match) {
        index = match.index;
        // when we cross the max len, if the previous match would've
        // been ok, use that one, and carry on.  If there was no previous
        // match on this fold section, then just have a long line.
        if (index - foldStart > max) {
            if (prevMatch !== foldStart) {
                foldEnd = prevMatch;
            }
            else {
                foldEnd = index;
            }
            if (result) {
                result += '\n';
            }
            folded = line.slice(foldStart, foldEnd);
            result += folded;
            foldStart = foldEnd + 1;
        }
        prevMatch = index + 1;
        match = foldRe.exec(line);
    }
    if (result) {
        result += '\n';
    }
    // if we end up with one last word at the end, then the last bit might
    // be slightly bigger than we wanted, because we exited out of the loop.
    if (foldStart !== prevMatch && line.length - foldStart > max) {
        result +=
            line.slice(foldStart, prevMatch) + '\n' + line.slice(prevMatch + 1);
    }
    else {
        result += line.slice(foldStart);
    }
    return result;
}
// Returns true if character can be found in a simple scalar
function simpleChar(character) {
    return (CHAR_TAB !== character &&
        CHAR_LINE_FEED !== character &&
        CHAR_CARRIAGE_RETURN !== character &&
        CHAR_COMMA !== character &&
        CHAR_LEFT_SQUARE_BRACKET !== character &&
        CHAR_RIGHT_SQUARE_BRACKET !== character &&
        CHAR_LEFT_CURLY_BRACKET !== character &&
        CHAR_RIGHT_CURLY_BRACKET !== character &&
        CHAR_SHARP !== character &&
        CHAR_AMPERSAND !== character &&
        CHAR_ASTERISK !== character &&
        CHAR_EXCLAMATION !== character &&
        CHAR_VERTICAL_LINE !== character &&
        CHAR_GREATER_THAN !== character &&
        CHAR_SINGLE_QUOTE !== character &&
        CHAR_DOUBLE_QUOTE !== character &&
        CHAR_PERCENT !== character &&
        CHAR_COLON !== character &&
        !ESCAPE_SEQUENCES[character] &&
        !needsHexEscape(character));
}
// Returns true if the character code needs to be escaped.
function needsHexEscape(character) {
    return !((0x00020 <= character && character <= 0x00007e) ||
        0x00085 === character ||
        (0x000a0 <= character && character <= 0x00d7ff) ||
        (0x0e000 <= character && character <= 0x00fffd) ||
        (0x10000 <= character && character <= 0x10ffff));
}
function writeFlowSequence(state, level, object) {
    var _result = '', _tag = state.tag, index, length;
    for (index = 0, length = object.length; index < length; index += 1) {
        // Write only valid elements.
        if (writeNode(state, level, object[index], false, false)) {
            if (0 !== index) {
                _result += ', ';
            }
            _result += state.dump;
        }
    }
    state.tag = _tag;
    state.dump = '[' + _result + ']';
}
function writeBlockSequence(state, level, object, compact) {
    var _result = '', _tag = state.tag, index, length;
    for (index = 0, length = object.length; index < length; index += 1) {
        // Write only valid elements.
        if (writeNode(state, level + 1, object[index], true, true)) {
            if (!compact || 0 !== index) {
                _result += generateNextLine(state, level);
            }
            _result += '- ' + state.dump;
        }
    }
    state.tag = _tag;
    state.dump = _result || '[]'; // Empty sequence if no valid values.
}
function writeFlowMapping(state, level, object) {
    var _result = '', _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, pairBuffer;
    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = '';
        if (0 !== index) {
            pairBuffer += ', ';
        }
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!writeNode(state, level, objectKey, false, false)) {
            continue; // Skip this pair because of invalid key;
        }
        if (state.dump.length > 1024) {
            pairBuffer += '? ';
        }
        pairBuffer += state.dump + ': ';
        if (!writeNode(state, level, objectValue, false, false)) {
            continue; // Skip this pair because of invalid value.
        }
        pairBuffer += state.dump;
        // Both key and value are valid.
        _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = '{' + _result + '}';
}
function writeBlockMapping(state, level, object, compact) {
    var _result = '', _tag = state.tag, objectKeyList = Object.keys(object), index, length, objectKey, objectValue, explicitPair, pairBuffer;
    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
        pairBuffer = '';
        if (!compact || 0 !== index) {
            pairBuffer += generateNextLine(state, level);
        }
        objectKey = objectKeyList[index];
        objectValue = object[objectKey];
        if (!writeNode(state, level + 1, objectKey, true, true)) {
            continue; // Skip this pair because of invalid key.
        }
        explicitPair =
            (null !== state.tag && '?' !== state.tag) ||
                (state.dump && state.dump.length > 1024);
        if (explicitPair) {
            if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
                pairBuffer += '?';
            }
            else {
                pairBuffer += '? ';
            }
        }
        pairBuffer += state.dump;
        if (explicitPair) {
            pairBuffer += generateNextLine(state, level);
        }
        if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
            continue; // Skip this pair because of invalid value.
        }
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
            pairBuffer += ':';
        }
        else {
            pairBuffer += ': ';
        }
        pairBuffer += state.dump;
        // Both key and value are valid.
        _result += pairBuffer;
    }
    state.tag = _tag;
    state.dump = _result || '{}'; // Empty mapping if no valid pairs.
}
function detectType(state, object, explicit) {
    var _result, typeList, index, length, type, style;
    typeList = explicit ? state.explicitTypes : state.implicitTypes;
    for (index = 0, length = typeList.length; index < length; index += 1) {
        type = typeList[index];
        if ((type.instanceOf || type.predicate) &&
            (!type.instanceOf ||
                ('object' === typeof object && object instanceof type.instanceOf)) &&
            (!type.predicate || type.predicate(object))) {
            state.tag = explicit ? type.tag : '?';
            if (type.represent) {
                style = state.styleMap[type.tag] || type.defaultStyle;
                if ('[object Function]' === _toString.call(type.represent)) {
                    _result = type.represent(object, style);
                }
                else if (dumper_hasOwnProperty.call(type.represent, style)) {
                    _result = type.represent[style](object, style);
                }
                else {
                    throw new YAMLException('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
                }
                state.dump = _result;
            }
            return true;
        }
    }
    return false;
}
// Serializes `object` and writes it to global `result`.
// Returns true on success, or false on invalid object.
//
function writeNode(state, level, object, block, compact) {
    state.tag = null;
    state.dump = object;
    if (!detectType(state, object, false)) {
        detectType(state, object, true);
    }
    var type = _toString.call(state.dump);
    if (block) {
        block = 0 > state.flowLevel || state.flowLevel > level;
    }
    if ((null !== state.tag && '?' !== state.tag) ||
        (2 !== state.indent && level > 0)) {
        compact = false;
    }
    var objectOrArray = '[object Object]' === type || '[object Array]' === type, duplicateIndex, duplicate;
    if (objectOrArray) {
        duplicateIndex = state.duplicates.indexOf(object);
        duplicate = duplicateIndex !== -1;
    }
    if (duplicate && state.usedDuplicates[duplicateIndex]) {
        state.dump = '*ref_' + duplicateIndex;
    }
    else {
        if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
            state.usedDuplicates[duplicateIndex] = true;
        }
        if ('[object Object]' === type) {
            if (block && 0 !== Object.keys(state.dump).length) {
                writeBlockMapping(state, level, state.dump, compact);
                if (duplicate) {
                    state.dump =
                        '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
                }
            }
            else {
                writeFlowMapping(state, level, state.dump);
                if (duplicate) {
                    state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
                }
            }
        }
        else if ('[object Array]' === type) {
            if (block && 0 !== state.dump.length) {
                writeBlockSequence(state, level, state.dump, compact);
                if (duplicate) {
                    state.dump =
                        '&ref_' + duplicateIndex + (0 === level ? '\n' : '') + state.dump;
                }
            }
            else {
                writeFlowSequence(state, level, state.dump);
                if (duplicate) {
                    state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
                }
            }
        }
        else if ('[object String]' === type) {
            if ('?' !== state.tag) {
                writeScalar(state, state.dump, level);
            }
        }
        else {
            if (state.skipInvalid) {
                return false;
            }
            throw new YAMLException('unacceptable kind of an object to dump ' + type);
        }
        if (null !== state.tag && '?' !== state.tag) {
            state.dump = '!<' + state.tag + '> ' + state.dump;
        }
    }
    return true;
}
function getDuplicateReferences(object, state) {
    var objects = [], duplicatesIndexes = [], index, length;
    inspectNode(object, objects, duplicatesIndexes);
    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
        state.duplicates.push(objects[duplicatesIndexes[index]]);
    }
    state.usedDuplicates = new Array(length);
}
function inspectNode(object, objects, duplicatesIndexes) {
    var type = _toString.call(object), objectKeyList, index, length;
    if (null !== object && 'object' === typeof object) {
        index = objects.indexOf(object);
        if (-1 !== index) {
            if (-1 === duplicatesIndexes.indexOf(index)) {
                duplicatesIndexes.push(index);
            }
        }
        else {
            objects.push(object);
            if (Array.isArray(object)) {
                for (index = 0, length = object.length; index < length; index += 1) {
                    inspectNode(object[index], objects, duplicatesIndexes);
                }
            }
            else {
                objectKeyList = Object.keys(object);
                for (index = 0, length = objectKeyList.length; index < length; index += 1) {
                    inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
                }
            }
        }
    }
}
function dump(input, options) {
    options = options || {};
    var state = new dumper_State(options);
    getDuplicateReferences(input, state);
    if (writeNode(state, 0, input, true, true)) {
        return state.dump + '\n';
    }
    return '';
}
function safeDump(input, options) {
    return dump(input, dumper_common.extend({ schema: DEFAULT_SAFE_SCHEMA }, options));
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/scalarInference.js
function parseYamlBoolean(input) {
    if (['true', 'True', 'TRUE'].lastIndexOf(input) >= 0) {
        return true;
    }
    else if (['false', 'False', 'FALSE'].lastIndexOf(input) >= 0) {
        return false;
    }
    throw "Invalid boolean \"" + input + "\"";
}
function safeParseYamlInteger(input) {
    // Use startsWith when es6 methods becomes available
    if (input.lastIndexOf('0o', 0) === 0) {
        return parseInt(input.substring(2), 8);
    }
    return parseInt(input);
}
function parseYamlInteger(input) {
    var result = safeParseYamlInteger(input);
    if (isNaN(result)) {
        throw "Invalid integer \"" + input + "\"";
    }
    return result;
}
function parseYamlFloat(input) {
    if (['.nan', '.NaN', '.NAN'].lastIndexOf(input) >= 0) {
        return NaN;
    }
    var infinity = /^([-+])?(?:\.inf|\.Inf|\.INF)$/;
    var match = infinity.exec(input);
    if (match) {
        return match[1] === '-' ? -Infinity : Infinity;
    }
    var result = parseFloat(input);
    if (!isNaN(result)) {
        return result;
    }
    throw "Invalid float \"" + input + "\"";
}
var ScalarType;
(function (ScalarType) {
    ScalarType[ScalarType["null"] = 0] = "null";
    ScalarType[ScalarType["bool"] = 1] = "bool";
    ScalarType[ScalarType["int"] = 2] = "int";
    ScalarType[ScalarType["float"] = 3] = "float";
    ScalarType[ScalarType["string"] = 4] = "string";
})(ScalarType || (ScalarType = {}));
/** Determines the type of a scalar according to
 * the YAML 1.2 Core Schema (http://www.yaml.org/spec/1.2/spec.html#id2804923)
 */
function determineScalarType(node) {
    if (node === undefined) {
        return ScalarType.null;
    }
    if (node.doubleQuoted || !node.plainScalar || node['singleQuoted']) {
        return ScalarType.string;
    }
    var value = node.value;
    if (['null', 'Null', 'NULL', '~', ''].indexOf(value) >= 0) {
        return ScalarType.null;
    }
    if (value === null || value === undefined) {
        return ScalarType.null;
    }
    if (['true', 'True', 'TRUE', 'false', 'False', 'FALSE'].indexOf(value) >= 0) {
        return ScalarType.bool;
    }
    var base10 = /^[-+]?[0-9]+$/;
    var base8 = /^0o[0-7]+$/;
    var base16 = /^0x[0-9a-fA-F]+$/;
    if (base10.test(value) || base8.test(value) || base16.test(value)) {
        return ScalarType.int;
    }
    var float = /^[-+]?(\.[0-9]+|[0-9]+(\.[0-9]*)?)([eE][-+]?[0-9]+)?$/;
    var infinity = /^[-+]?(\.inf|\.Inf|\.INF)$/;
    if (float.test(value) ||
        infinity.test(value) ||
        ['.nan', '.NaN', '.NAN'].indexOf(value) >= 0) {
        return ScalarType.float;
    }
    return ScalarType.string;
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml-ast-parser-custom-tags/index.js
/**
 * Created by kor on 06/05/15.
 */



function deprecated(name) {
    return function () {
        throw new Error('Function ' + name + ' is deprecated and cannot be used.');
    };
}


// EXTERNAL MODULE: ../node_modules/js-yaml/index.js
var js_yaml = __webpack_require__(6);

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/languageservice/utils/documentPositionCalculator.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Red Hat, Inc. All rights reserved.
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

function insertionPointReturnValue(pt) {
    return -pt - 1;
}
function documentPositionCalculator_binarySearch(array, sought) {
    var lower = 0;
    var upper = array.length - 1;
    while (lower <= upper) {
        var idx = Math.floor((lower + upper) / 2);
        var value = array[idx];
        if (value === sought) {
            return idx;
        }
        if (lower === upper) {
            var insertionPoint = value < sought ? idx + 1 : idx;
            return insertionPointReturnValue(insertionPoint);
        }
        if (sought > value) {
            lower = idx + 1;
        }
        else if (sought < value) {
            upper = idx - 1;
        }
    }
}
function getLineStartPositions(text) {
    var lineStartPositions = [0];
    for (var i = 0; i < text.length; i++) {
        var c = text[i];
        if (c === '\r') {
            // Check for Windows encoding, otherwise we are old Mac
            if (i + 1 < text.length && text[i + 1] === '\n') {
                i++;
            }
            lineStartPositions.push(i + 1);
        }
        else if (c === '\n') {
            lineStartPositions.push(i + 1);
        }
    }
    return lineStartPositions;
}
function getPosition(pos, lineStartPositions) {
    var line = documentPositionCalculator_binarySearch(lineStartPositions, pos);
    if (line < 0) {
        var insertionPoint = -1 * line - 1;
        line = insertionPoint - 1;
    }
    return { line: line, column: pos - lineStartPositions[line] };
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/languageservice/parser/scalar-type.js
/**
 * Parse a boolean according to the specification
 *
 * Return:
 *  true if its a true value
 *  false if its a false value
 */
function scalar_type_parseYamlBoolean(input) {
    if ([
        'true',
        'True',
        'TRUE',
        'y',
        'Y',
        'yes',
        'Yes',
        'YES',
        'on',
        'On',
        'ON',
    ].lastIndexOf(input) >= 0) {
        return true;
    }
    else if ([
        'false',
        'False',
        'FALSE',
        'n',
        'N',
        'no',
        'No',
        'NO',
        'off',
        'Off',
        'OFF',
    ].lastIndexOf(input) >= 0) {
        return false;
    }
    throw "Invalid boolean \"" + input + "\"";
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/languageservice/utils/arrUtils.js
var arrUtils_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function removeDuplicates(arr, prop) {
    var new_arr = [];
    var lookup = {};
    for (var i in arr) {
        lookup[arr[i][prop]] = arr[i];
    }
    for (var i in lookup) {
        new_arr.push(lookup[i]);
    }
    return new_arr;
}
function getLineOffsets(textDocString) {
    var lineOffsets = [];
    var text = textDocString;
    var isLineStart = true;
    for (var i = 0; i < text.length; i++) {
        if (isLineStart) {
            lineOffsets.push(i);
            isLineStart = false;
        }
        var ch = text.charAt(i);
        isLineStart = ch === '\r' || ch === '\n';
        if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
            i++;
        }
    }
    if (isLineStart && text.length > 0) {
        lineOffsets.push(text.length);
    }
    return lineOffsets;
}
function removeDuplicatesObj(objArray) {
    var nonDuplicateSet = new Set();
    var nonDuplicateArr = [];
    for (var obj in objArray) {
        var currObj = objArray[obj];
        var stringifiedObj = JSON.stringify(currObj);
        if (!nonDuplicateSet.has(stringifiedObj)) {
            nonDuplicateArr.push(currObj);
            nonDuplicateSet.add(stringifiedObj);
        }
    }
    return nonDuplicateArr;
}
function matchOffsetToDocument(offset, jsonDocuments) {
    for (var jsonDoc in jsonDocuments.documents) {
        var currJsonDoc = jsonDocuments.documents[jsonDoc];
        if (currJsonDoc.root &&
            currJsonDoc.root.end >= offset &&
            currJsonDoc.root.start <= offset) {
            return currJsonDoc;
        }
    }
    // TODO: Fix this so that it returns the correct document
    return jsonDocuments.documents[0];
}
function matchOffsetToDocument2(offset, jsonDocuments) {
    var e_1, _a;
    try {
        for (var _b = arrUtils_values(jsonDocuments.documents), _c = _b.next(); !_c.done; _c = _b.next()) {
            var jsonDoc = _c.value;
            if (jsonDoc.root &&
                jsonDoc.root.offset <= offset &&
                jsonDoc.root.length + jsonDoc.root.offset >= offset) {
                return jsonDoc;
            }
        }
    }
    catch (e_1_1) { e_1 = { error: e_1_1 }; }
    finally {
        try {
            if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
        }
        finally { if (e_1) throw e_1.error; }
    }
    // TODO: Fix this so that it returns the correct document
    return null;
}
function filterInvalidCustomTags(customTags) {
    var validCustomTags = ['mapping', 'scalar', 'sequence'];
    return customTags.filter(function (tag) {
        if (typeof tag === 'string') {
            var typeInfo = tag.split(' ');
            var type = (typeInfo[1] && typeInfo[1].toLowerCase()) || 'scalar';
            // We need to check if map is a type because map will throw an error within the yaml-ast-parser
            if (type === 'map') {
                return false;
            }
            return validCustomTags.indexOf(type) !== -1;
        }
        return false;
    });
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/languageservice/parser/yamlParser07.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Red Hat, Inc. All rights reserved.
 *  Copyright (c) Adam Voss. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

var yamlParser07_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var yamlParser07_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};


var yamlParser07_localize = loadMessageBundle();






var SingleYAMLDocument = /** @class */ (function (_super) {
    yamlParser07_extends(SingleYAMLDocument, _super);
    function SingleYAMLDocument(lines) {
        var _this = _super.call(this, null, []) || this;
        _this.lines = lines;
        _this.root = null;
        _this.errors = [];
        _this.warnings = [];
        return _this;
    }
    SingleYAMLDocument.prototype.getSchemas = function (schema, doc, node) {
        var matchingSchemas = [];
        doc.validate(schema, matchingSchemas, node.start);
        return matchingSchemas;
    };
    return SingleYAMLDocument;
}(jsonParser07_JSONDocument));

function recursivelyBuildAst(parent, node) {
    var e_1, _a, e_2, _b;
    if (!node) {
        return;
    }
    switch (node.kind) {
        case yamlAST["a" /* Kind */].MAP: {
            var instance = node;
            var result = new jsonParser07_ObjectASTNodeImpl(parent, node.startPosition, node.endPosition - node.startPosition);
            try {
                for (var _c = yamlParser07_values(instance.mappings), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var mapping = _d.value;
                    result.properties.push(recursivelyBuildAst(result, mapping));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return result;
        }
        case yamlAST["a" /* Kind */].MAPPING: {
            var instance = node;
            var key = instance.key;
            var result = new jsonParser07_PropertyASTNodeImpl(parent, instance.startPosition, instance.endPosition - instance.startPosition);
            // Technically, this is an arbitrary node in YAML
            // I doubt we would get a better string representation by parsing it
            var keyNode = new jsonParser07_StringASTNodeImpl(result, key.startPosition, key.endPosition - key.startPosition);
            keyNode.value = key.value;
            var valueNode = instance.value
                ? recursivelyBuildAst(result, instance.value)
                : new jsonParser07_NullASTNodeImpl(parent, instance.endPosition, 0);
            //valueNode.location = key.value;
            result.keyNode = keyNode;
            result.valueNode = valueNode;
            return result;
        }
        case yamlAST["a" /* Kind */].SEQ: {
            var instance = node;
            var result = new jsonParser07_ArrayASTNodeImpl(parent, instance.startPosition, instance.endPosition - instance.startPosition);
            var count = 0;
            try {
                for (var _e = yamlParser07_values(instance.items), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var item = _f.value;
                    if (item === null && count === instance.items.length - 1) {
                        break;
                    }
                    // Be aware of https://github.com/nodeca/js-yaml/issues/321
                    // Cannot simply work around it here because we need to know if we are in Flow or Block
                    var itemNode = item === null
                        ? new jsonParser07_NullASTNodeImpl(parent, instance.endPosition, 0)
                        : recursivelyBuildAst(result, item);
                    // itemNode.location = count++;
                    result.children.push(itemNode);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return result;
        }
        case yamlAST["a" /* Kind */].SCALAR: {
            var instance = node;
            var type = determineScalarType(instance);
            // The name is set either by the sequence or the mapping case.
            var name_1 = null;
            var value = instance.value;
            //This is a patch for redirecting values with these strings to be boolean nodes because its not supported in the parser.
            var possibleBooleanValues = [
                'y',
                'Y',
                'yes',
                'Yes',
                'YES',
                'n',
                'N',
                'no',
                'No',
                'NO',
                'on',
                'On',
                'ON',
                'off',
                'Off',
                'OFF',
            ];
            if (instance.plainScalar &&
                possibleBooleanValues.indexOf(value.toString()) !== -1) {
                return new jsonParser07_BooleanASTNodeImpl(parent, scalar_type_parseYamlBoolean(value), node.startPosition, node.endPosition - node.startPosition);
            }
            switch (type) {
                case ScalarType.null: {
                    return new jsonParser07_StringASTNodeImpl(parent, instance.startPosition, instance.endPosition - instance.startPosition);
                }
                case ScalarType.bool: {
                    return new jsonParser07_BooleanASTNodeImpl(parent, parseYamlBoolean(value), node.startPosition, node.endPosition - node.startPosition);
                }
                case ScalarType.int: {
                    var result = new jsonParser07_NumberASTNodeImpl(parent, node.startPosition, node.endPosition - node.startPosition);
                    result.value = parseYamlInteger(value);
                    result.isInteger = true;
                    return result;
                }
                case ScalarType.float: {
                    var result = new jsonParser07_NumberASTNodeImpl(parent, node.startPosition, node.endPosition - node.startPosition);
                    result.value = parseYamlFloat(value);
                    result.isInteger = false;
                    return result;
                }
                case ScalarType.string: {
                    var result = new jsonParser07_StringASTNodeImpl(parent, node.startPosition, node.endPosition - node.startPosition);
                    result.value = node.value;
                    return result;
                }
            }
            break;
        }
        case yamlAST["a" /* Kind */].ANCHOR_REF: {
            var instance = node.value;
            return (recursivelyBuildAst(parent, instance) ||
                new jsonParser07_NullASTNodeImpl(parent, node.startPosition, node.endPosition - node.startPosition));
        }
        case yamlAST["a" /* Kind */].INCLUDE_REF: {
            var result = new jsonParser07_StringASTNodeImpl(parent, node.startPosition, node.endPosition - node.startPosition);
            result.value = node.value;
            return result;
        }
    }
}
function convertError(e) {
    var line = e.mark.line === 0 ? 0 : e.mark.line - 1;
    var character = e.mark.position + e.mark.column === 0
        ? 0
        : e.mark.position + e.mark.column - 1;
    return {
        message: "" + e.reason,
        range: {
            start: {
                line: line,
                character: character,
            },
            end: {
                line: line,
                character: character,
            },
        },
        severity: 2,
    };
}
function createJSONDocument(yamlDoc, startPositions, text) {
    var _doc = new SingleYAMLDocument(startPositions);
    _doc.root = recursivelyBuildAst(null, yamlDoc);
    if (!_doc.root) {
        // TODO: When this is true, consider not pushing the other errors.
        _doc.errors.push({
            message: yamlParser07_localize('Invalid symbol', 'Expected a YAML object, array or literal'),
            code: ErrorCode.Undefined,
            location: { start: yamlDoc.startPosition, end: yamlDoc.endPosition },
        });
    }
    var duplicateKeyReason = 'duplicate key';
    //Patch ontop of yaml-ast-parser to disable duplicate key message on merge key
    var isDuplicateAndNotMergeKey = function (error, yamlText) {
        var errorConverted = convertError(error);
        var errorStart = errorConverted.range.start.character;
        var errorEnd = errorConverted.range.end.character;
        if (error.reason === duplicateKeyReason &&
            yamlText.substring(errorStart, errorEnd).startsWith('<<')) {
            return false;
        }
        return true;
    };
    var errors = yamlDoc.errors
        .filter(function (e) { return e.reason !== duplicateKeyReason && !e.isWarning; })
        .map(function (e) { return convertError(e); });
    var warnings = yamlDoc.errors
        .filter(function (e) {
        return (e.reason === duplicateKeyReason &&
            isDuplicateAndNotMergeKey(e, text)) ||
            e.isWarning;
    })
        .map(function (e) { return convertError(e); });
    errors.forEach(function (e) { return _doc.errors.push(e); });
    warnings.forEach(function (e) { return _doc.warnings.push(e); });
    return _doc;
}
var YAMLDocument = /** @class */ (function () {
    function YAMLDocument(documents) {
        this.documents = documents;
        this.errors = [];
        this.warnings = [];
    }
    return YAMLDocument;
}());

function yamlParser07_parse(text, customTags) {
    if (customTags === void 0) { customTags = []; }
    var startPositions = getLineStartPositions(text);
    // This is documented to return a YAMLNode even though the
    // typing only returns a YAMLDocument
    var yamlDocs = [];
    var filteredTags = filterInvalidCustomTags(customTags);
    var schemaWithAdditionalTags = js_yaml["Schema"].create(filteredTags.map(function (tag) {
        var typeInfo = tag.split(' ');
        return new js_yaml["Type"](typeInfo[0], {
            kind: (typeInfo[1] && typeInfo[1].toLowerCase()) || 'scalar',
        });
    }));
    /**
     * Collect the additional tags into a map of string to possible tag types
     */
    var tagWithAdditionalItems = new Map();
    filteredTags.forEach(function (tag) {
        var typeInfo = tag.split(' ');
        var tagName = typeInfo[0];
        var tagType = (typeInfo[1] && typeInfo[1].toLowerCase()) || 'scalar';
        if (tagWithAdditionalItems.has(tagName)) {
            tagWithAdditionalItems.set(tagName, tagWithAdditionalItems.get(tagName).concat([tagType]));
        }
        else {
            tagWithAdditionalItems.set(tagName, [tagType]);
        }
    });
    tagWithAdditionalItems.forEach(function (additionalTagKinds, key) {
        var newTagType = new js_yaml["Type"](key, {
            kind: additionalTagKinds[0] || 'scalar',
        });
        newTagType.additionalKinds = additionalTagKinds;
        schemaWithAdditionalTags.compiledTypeMap[key] = newTagType;
    });
    var additionalOptions = {
        schema: schemaWithAdditionalTags,
    };
    loadAll(text, function (doc) { return yamlDocs.push(doc); }, additionalOptions);
    return new YAMLDocument(yamlDocs.map(function (doc) { return createJSONDocument(doc, startPositions, text); }));
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/languageservice/services/documentSymbols.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Red Hat, Inc. All rights reserved.
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

var documentSymbols_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};


var documentSymbols_YAMLDocumentSymbols = /** @class */ (function () {
    function YAMLDocumentSymbols(schemaService) {
        this.jsonDocumentSymbols = new jsonDocumentSymbols_JSONDocumentSymbols(schemaService);
    }
    YAMLDocumentSymbols.prototype.findDocumentSymbols = function (document) {
        var e_1, _a;
        var doc = yamlParser07_parse(document.getText());
        if (!doc || doc['documents'].length === 0) {
            return null;
        }
        var results = [];
        try {
            for (var _b = documentSymbols_values(doc['documents']), _c = _b.next(); !_c.done; _c = _b.next()) {
                var yamlDoc = _c.value;
                if (yamlDoc.root) {
                    results = results.concat(this.jsonDocumentSymbols.findDocumentSymbols(document, yamlDoc));
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return results;
    };
    YAMLDocumentSymbols.prototype.findHierarchicalDocumentSymbols = function (document) {
        var e_2, _a;
        var doc = yamlParser07_parse(document.getText());
        if (!doc || doc['documents'].length === 0) {
            return null;
        }
        var results = [];
        try {
            for (var _b = documentSymbols_values(doc['documents']), _c = _b.next(); !_c.done; _c = _b.next()) {
                var yamlDoc = _c.value;
                if (yamlDoc.root) {
                    results = results.concat(this.jsonDocumentSymbols.findDocumentSymbols2(document, yamlDoc));
                }
            }
        }
        catch (e_2_1) { e_2 = { error: e_2_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_2) throw e_2.error; }
        }
        return results;
    };
    return YAMLDocumentSymbols;
}());


// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/languageservice/parser/jsonParser04.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Red Hat, Inc. All rights reserved.
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

var jsonParser04_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var jsonParser04_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var jsonParser04_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var jsonParser04_spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(jsonParser04_read(arguments[i]));
    return ar;
};


var jsonParser04_localize = loadMessageBundle();
var jsonParser04_ErrorCode;
(function (ErrorCode) {
    ErrorCode[ErrorCode["Undefined"] = 0] = "Undefined";
    ErrorCode[ErrorCode["EnumValueMismatch"] = 1] = "EnumValueMismatch";
    ErrorCode[ErrorCode["CommentsNotAllowed"] = 2] = "CommentsNotAllowed";
})(jsonParser04_ErrorCode || (jsonParser04_ErrorCode = {}));
var ProblemSeverity;
(function (ProblemSeverity) {
    ProblemSeverity[ProblemSeverity["Error"] = 0] = "Error";
    ProblemSeverity[ProblemSeverity["Warning"] = 1] = "Warning";
})(ProblemSeverity || (ProblemSeverity = {}));
var jsonParser04_ASTNode = /** @class */ (function () {
    function ASTNode(parent, type, location, start, end) {
        this.type = type;
        this.location = location;
        this.start = start;
        this.end = end;
        this.parent = parent;
        this.parserSettings = {
            isKubernetes: false,
        };
    }
    ASTNode.prototype.setParserSettings = function (parserSettings) {
        this.parserSettings = parserSettings;
    };
    ASTNode.prototype.getPath = function () {
        var path = this.parent ? this.parent.getPath() : [];
        if (this.location !== null) {
            path.push(this.location);
        }
        return path;
    };
    ASTNode.prototype.getChildNodes = function () {
        return [];
    };
    ASTNode.prototype.getLastChild = function () {
        return null;
    };
    // tslint:disable-next-line: no-any
    ASTNode.prototype.getValue = function () {
        // override in children
        return;
    };
    ASTNode.prototype.contains = function (offset, includeRightBound) {
        if (includeRightBound === void 0) { includeRightBound = false; }
        return ((offset >= this.start && offset < this.end) ||
            (includeRightBound && offset === this.end));
    };
    ASTNode.prototype.toString = function () {
        return ('type: ' +
            this.type +
            ' (' +
            this.start +
            '/' +
            this.end +
            ')' +
            (this.parent ? ' parent: {' + this.parent.toString() + '}' : ''));
    };
    ASTNode.prototype.visit = function (visitor) {
        return visitor(this);
    };
    ASTNode.prototype.getNodeFromOffset = function (offset) {
        var findNode = function (node) {
            if (offset >= node.start && offset < node.end) {
                var children = node.getChildNodes();
                for (var i = 0; i < children.length && children[i].start <= offset; i++) {
                    var item = findNode(children[i]);
                    if (item) {
                        return item;
                    }
                }
                return node;
            }
            return null;
        };
        return findNode(this);
    };
    ASTNode.prototype.getNodeCollectorCount = function (offset) {
        var collector = [];
        var findNode = function (node) {
            var children = node.getChildNodes();
            for (var i = 0; i < children.length; i++) {
                var item = findNode(children[i]);
                if (item && item.type === 'property') {
                    collector.push(item);
                }
            }
            return node;
        };
        var foundNode = findNode(this);
        return collector.length;
    };
    ASTNode.prototype.getNodeFromOffsetEndInclusive = function (offset) {
        var collector = [];
        var findNode = function (node) {
            if (offset >= node.start && offset <= node.end) {
                var children = node.getChildNodes();
                for (var i = 0; i < children.length && children[i].start <= offset; i++) {
                    var item = findNode(children[i]);
                    if (item) {
                        collector.push(item);
                    }
                }
                return node;
            }
            return null;
        };
        var foundNode = findNode(this);
        var currMinDist = Number.MAX_VALUE;
        var currMinNode = null;
        for (var possibleNode in collector) {
            var currNode = collector[possibleNode];
            var minDist = currNode.end - offset + (offset - currNode.start);
            if (minDist < currMinDist) {
                currMinNode = currNode;
                currMinDist = minDist;
            }
        }
        return currMinNode || foundNode;
    };
    ASTNode.prototype.validate = function (schema, validationResult, matchingSchemas) {
        var e_1, _a;
        var _this = this;
        if (!matchingSchemas.include(this)) {
            return;
        }
        if (Array.isArray(schema.type)) {
            if (schema.type.indexOf(this.type) === -1) {
                validationResult.problems.push({
                    location: { start: this.start, end: this.end },
                    severity: ProblemSeverity.Warning,
                    message: schema.errorMessage ||
                        jsonParser04_localize('typeArrayMismatchWarning', 'Incorrect type. Expected one of {0}.', schema.type.join(', ')),
                });
            }
        }
        else if (schema.type) {
            if (this.type !== schema.type) {
                validationResult.problems.push({
                    location: { start: this.start, end: this.end },
                    severity: ProblemSeverity.Warning,
                    message: schema.errorMessage ||
                        jsonParser04_localize('typeMismatchWarning', 'Incorrect type. Expected "{0}".', schema.type),
                });
            }
        }
        if (Array.isArray(schema.allOf)) {
            schema.allOf.forEach(function (subSchema) {
                _this.validate(subSchema, validationResult, matchingSchemas);
            });
        }
        if (schema.not) {
            var subValidationResult = new jsonParser04_ValidationResult();
            var subMatchingSchemas = matchingSchemas.newSub();
            this.validate(schema.not, subValidationResult, subMatchingSchemas);
            if (!subValidationResult.hasProblems()) {
                validationResult.problems.push({
                    location: { start: this.start, end: this.end },
                    severity: ProblemSeverity.Warning,
                    message: jsonParser04_localize('notSchemaWarning', 'Matches a schema that is not allowed.'),
                });
            }
            subMatchingSchemas.schemas.forEach(function (ms) {
                ms.inverted = !ms.inverted;
                matchingSchemas.add(ms);
            });
        }
        var testAlternatives = function (alternatives, maxOneMatch) {
            var matches = [];
            // remember the best match that is used for error messages
            var bestMatch = null;
            alternatives.forEach(function (subSchema) {
                var subValidationResult = new jsonParser04_ValidationResult();
                var subMatchingSchemas = matchingSchemas.newSub();
                _this.validate(subSchema, subValidationResult, subMatchingSchemas);
                if (!subValidationResult.hasProblems()) {
                    matches.push(subSchema);
                }
                if (!bestMatch) {
                    bestMatch = {
                        schema: subSchema,
                        validationResult: subValidationResult,
                        matchingSchemas: subMatchingSchemas,
                    };
                }
                else if (_this.parserSettings.isKubernetes) {
                    bestMatch = jsonParser04_alternativeComparison(subValidationResult, bestMatch, subSchema, subMatchingSchemas);
                }
                else {
                    bestMatch = jsonParser04_genericComparison(maxOneMatch, subValidationResult, bestMatch, subSchema, subMatchingSchemas);
                }
            });
            if (matches.length > 1 &&
                maxOneMatch &&
                !_this.parserSettings.isKubernetes) {
                validationResult.problems.push({
                    location: { start: _this.start, end: _this.start + 1 },
                    severity: ProblemSeverity.Warning,
                    message: jsonParser04_localize('oneOfWarning', 'Matches multiple schemas when only one must validate.'),
                });
            }
            if (bestMatch !== null) {
                validationResult.merge(bestMatch.validationResult);
                validationResult.propertiesMatches +=
                    bestMatch.validationResult.propertiesMatches;
                validationResult.propertiesValueMatches +=
                    bestMatch.validationResult.propertiesValueMatches;
                matchingSchemas.merge(bestMatch.matchingSchemas);
            }
            return matches.length;
        };
        if (Array.isArray(schema.anyOf)) {
            testAlternatives(schema.anyOf, false);
        }
        if (Array.isArray(schema.oneOf)) {
            testAlternatives(schema.oneOf, true);
        }
        if (Array.isArray(schema.enum)) {
            var val = this.getValue();
            var enumValueMatch = false;
            try {
                for (var _b = jsonParser04_values(schema.enum), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var e = _c.value;
                    if (utils_objects_equals(val, e)) {
                        enumValueMatch = true;
                        break;
                    }
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_1) throw e_1.error; }
            }
            validationResult.enumValues = schema.enum;
            validationResult.enumValueMatch = enumValueMatch;
            if (!enumValueMatch) {
                validationResult.problems.push({
                    location: { start: this.start, end: this.end },
                    severity: ProblemSeverity.Warning,
                    code: jsonParser04_ErrorCode.EnumValueMismatch,
                    message: schema.errorMessage ||
                        jsonParser04_localize('enumWarning', 'Value is not accepted. Valid values: {0}.', schema.enum.map(function (v) { return JSON.stringify(v); }).join(', ')),
                });
            }
        }
        if (schema.deprecationMessage && this.parent) {
            validationResult.problems.push({
                location: { start: this.parent.start, end: this.parent.end },
                severity: ProblemSeverity.Warning,
                message: schema.deprecationMessage,
            });
        }
        matchingSchemas.add({ node: this, schema: schema });
    };
    return ASTNode;
}());

var NullASTNode = /** @class */ (function (_super) {
    jsonParser04_extends(NullASTNode, _super);
    function NullASTNode(parent, name, start, end) {
        return _super.call(this, parent, 'null', name, start, end) || this;
    }
    // tslint:disable-next-line: no-any
    NullASTNode.prototype.getValue = function () {
        return null;
    };
    return NullASTNode;
}(jsonParser04_ASTNode));

var BooleanASTNode = /** @class */ (function (_super) {
    jsonParser04_extends(BooleanASTNode, _super);
    function BooleanASTNode(parent, name, value, start, end) {
        var _this = _super.call(this, parent, 'boolean', name, start, end) || this;
        _this.value = value;
        return _this;
    }
    // tslint:disable-next-line: no-any
    BooleanASTNode.prototype.getValue = function () {
        return this.value;
    };
    return BooleanASTNode;
}(jsonParser04_ASTNode));

var ArrayASTNode = /** @class */ (function (_super) {
    jsonParser04_extends(ArrayASTNode, _super);
    function ArrayASTNode(parent, name, start, end) {
        var _this = _super.call(this, parent, 'array', name, start, end) || this;
        _this.items = [];
        return _this;
    }
    ArrayASTNode.prototype.getChildNodes = function () {
        return this.items;
    };
    ArrayASTNode.prototype.getLastChild = function () {
        return this.items[this.items.length - 1];
    };
    // tslint:disable-next-line: no-any
    ArrayASTNode.prototype.getValue = function () {
        return this.items.map(function (v) { return v.getValue(); });
    };
    ArrayASTNode.prototype.addItem = function (item) {
        if (item) {
            this.items.push(item);
            return true;
        }
        return false;
    };
    ArrayASTNode.prototype.visit = function (visitor) {
        var ctn = visitor(this);
        for (var i = 0; i < this.items.length && ctn; i++) {
            ctn = this.items[i].visit(visitor);
        }
        return ctn;
    };
    ArrayASTNode.prototype.validate = function (schema, validationResult, matchingSchemas) {
        var _this = this;
        if (!matchingSchemas.include(this)) {
            return;
        }
        _super.prototype.validate.call(this, schema, validationResult, matchingSchemas);
        if (Array.isArray(schema.items)) {
            var subSchemas_1 = schema.items;
            subSchemas_1.forEach(function (subSchema, index) {
                var itemValidationResult = new jsonParser04_ValidationResult();
                var item = _this.items[index];
                if (item) {
                    item.validate(subSchema, itemValidationResult, matchingSchemas);
                    validationResult.mergePropertyMatch(itemValidationResult);
                }
                else if (_this.items.length >= subSchemas_1.length) {
                    validationResult.propertiesValueMatches++;
                }
            });
            if (this.items.length > subSchemas_1.length) {
                if (typeof schema.additionalItems === 'object') {
                    for (var i = subSchemas_1.length; i < this.items.length; i++) {
                        var itemValidationResult = new jsonParser04_ValidationResult();
                        // tslint:disable-next-line: no-any
                        this.items[i].validate(schema.additionalItems, itemValidationResult, matchingSchemas);
                        validationResult.mergePropertyMatch(itemValidationResult);
                    }
                }
                else if (schema.additionalItems === false) {
                    validationResult.problems.push({
                        location: { start: this.start, end: this.end },
                        severity: ProblemSeverity.Warning,
                        message: jsonParser04_localize('additionalItemsWarning', 'Array has too many items according to schema. Expected {0} or fewer.', subSchemas_1.length),
                    });
                }
            }
        }
        else if (schema.items) {
            this.items.forEach(function (item) {
                var itemValidationResult = new jsonParser04_ValidationResult();
                item.validate(schema.items, itemValidationResult, matchingSchemas);
                validationResult.mergePropertyMatch(itemValidationResult);
            });
        }
        if (schema.minItems && this.items.length < schema.minItems) {
            validationResult.problems.push({
                location: { start: this.start, end: this.end },
                severity: ProblemSeverity.Warning,
                message: jsonParser04_localize('minItemsWarning', 'Array has too few items. Expected {0} or more.', schema.minItems),
            });
        }
        if (schema.maxItems && this.items.length > schema.maxItems) {
            validationResult.problems.push({
                location: { start: this.start, end: this.end },
                severity: ProblemSeverity.Warning,
                message: jsonParser04_localize('maxItemsWarning', 'Array has too many items. Expected {0} or fewer.', schema.minItems),
            });
        }
        if (schema.uniqueItems === true) {
            var values_1 = this.items.map(function (node) { return node.getValue(); });
            var duplicates = values_1.some(function (value, index) { return index !== values_1.lastIndexOf(value); });
            if (duplicates) {
                validationResult.problems.push({
                    location: { start: this.start, end: this.end },
                    severity: ProblemSeverity.Warning,
                    message: jsonParser04_localize('uniqueItemsWarning', 'Array has duplicate items.'),
                });
            }
        }
    };
    return ArrayASTNode;
}(jsonParser04_ASTNode));

var NumberASTNode = /** @class */ (function (_super) {
    jsonParser04_extends(NumberASTNode, _super);
    function NumberASTNode(parent, name, start, end) {
        var _this = _super.call(this, parent, 'number', name, start, end) || this;
        _this.isInteger = true;
        _this.value = Number.NaN;
        return _this;
    }
    // tslint:disable-next-line: no-any
    NumberASTNode.prototype.getValue = function () {
        return this.value;
    };
    NumberASTNode.prototype.validate = function (schema, validationResult, matchingSchemas) {
        if (!matchingSchemas.include(this)) {
            return;
        }
        // work around type validation in the base class
        var typeIsInteger = false;
        if (schema.type === 'integer' ||
            (Array.isArray(schema.type) &&
                schema.type.indexOf('integer') !== -1)) {
            typeIsInteger = true;
        }
        if (typeIsInteger && this.isInteger === true) {
            this.type = 'integer';
        }
        _super.prototype.validate.call(this, schema, validationResult, matchingSchemas);
        this.type = 'number';
        var val = this.getValue();
        if (typeof schema.multipleOf === 'number') {
            if (val % schema.multipleOf !== 0) {
                validationResult.problems.push({
                    location: { start: this.start, end: this.end },
                    severity: ProblemSeverity.Warning,
                    message: jsonParser04_localize('multipleOfWarning', 'Value is not divisible by {0}.', schema.multipleOf),
                });
            }
        }
        if (typeof schema.minimum === 'number') {
            if (schema.exclusiveMinimum && val <= schema.minimum) {
                validationResult.problems.push({
                    location: { start: this.start, end: this.end },
                    severity: ProblemSeverity.Warning,
                    message: jsonParser04_localize('exclusiveMinimumWarning', 'Value is below the exclusive minimum of {0}.', schema.minimum),
                });
            }
            if (!schema.exclusiveMinimum && val < schema.minimum) {
                validationResult.problems.push({
                    location: { start: this.start, end: this.end },
                    severity: ProblemSeverity.Warning,
                    message: jsonParser04_localize('minimumWarning', 'Value is below the minimum of {0}.', schema.minimum),
                });
            }
        }
        if (typeof schema.maximum === 'number') {
            if (schema.exclusiveMaximum && val >= schema.maximum) {
                validationResult.problems.push({
                    location: { start: this.start, end: this.end },
                    severity: ProblemSeverity.Warning,
                    message: jsonParser04_localize('exclusiveMaximumWarning', 'Value is above the exclusive maximum of {0}.', schema.maximum),
                });
            }
            if (!schema.exclusiveMaximum && val > schema.maximum) {
                validationResult.problems.push({
                    location: { start: this.start, end: this.end },
                    severity: ProblemSeverity.Warning,
                    message: jsonParser04_localize('maximumWarning', 'Value is above the maximum of {0}.', schema.maximum),
                });
            }
        }
    };
    return NumberASTNode;
}(jsonParser04_ASTNode));

var StringASTNode = /** @class */ (function (_super) {
    jsonParser04_extends(StringASTNode, _super);
    function StringASTNode(parent, name, isKey, start, end) {
        var _this = _super.call(this, parent, 'string', name, start, end) || this;
        _this.isKey = isKey;
        _this.value = '';
        return _this;
    }
    // tslint:disable-next-line: no-any
    StringASTNode.prototype.getValue = function () {
        return this.value;
    };
    StringASTNode.prototype.validate = function (schema, validationResult, matchingSchemas) {
        if (!matchingSchemas.include(this)) {
            return;
        }
        _super.prototype.validate.call(this, schema, validationResult, matchingSchemas);
        if (schema.minLength && this.value.length < schema.minLength) {
            validationResult.problems.push({
                location: { start: this.start, end: this.end },
                severity: ProblemSeverity.Warning,
                message: jsonParser04_localize('minLengthWarning', 'String is shorter than the minimum length of {0}.', schema.minLength),
            });
        }
        if (schema.maxLength && this.value.length > schema.maxLength) {
            validationResult.problems.push({
                location: { start: this.start, end: this.end },
                severity: ProblemSeverity.Warning,
                message: jsonParser04_localize('maxLengthWarning', 'String is longer than the maximum length of {0}.', schema.maxLength),
            });
        }
        if (schema.pattern) {
            var regex = new RegExp(schema.pattern);
            if (!regex.test(this.value)) {
                validationResult.problems.push({
                    location: { start: this.start, end: this.end },
                    severity: ProblemSeverity.Warning,
                    message: schema.patternErrorMessage ||
                        schema.errorMessage ||
                        jsonParser04_localize('patternWarning', 'String does not match the pattern of "{0}".', schema.pattern),
                });
            }
        }
    };
    return StringASTNode;
}(jsonParser04_ASTNode));

var PropertyASTNode = /** @class */ (function (_super) {
    jsonParser04_extends(PropertyASTNode, _super);
    function PropertyASTNode(parent, key) {
        var _this = _super.call(this, parent, 'property', null, key.start) || this;
        _this.key = key;
        key.parent = _this;
        key.location = key.value;
        _this.colonOffset = -1;
        return _this;
    }
    PropertyASTNode.prototype.getChildNodes = function () {
        return this.value ? [this.key, this.value] : [this.key];
    };
    PropertyASTNode.prototype.getLastChild = function () {
        return this.value;
    };
    PropertyASTNode.prototype.setValue = function (value) {
        this.value = value;
        return value !== null;
    };
    PropertyASTNode.prototype.visit = function (visitor) {
        return (visitor(this) &&
            this.key.visit(visitor) &&
            this.value &&
            this.value.visit(visitor));
    };
    PropertyASTNode.prototype.validate = function (schema, validationResult, matchingSchemas) {
        if (!matchingSchemas.include(this)) {
            return;
        }
        if (this.value) {
            this.value.validate(schema, validationResult, matchingSchemas);
        }
    };
    return PropertyASTNode;
}(jsonParser04_ASTNode));

var ObjectASTNode = /** @class */ (function (_super) {
    jsonParser04_extends(ObjectASTNode, _super);
    function ObjectASTNode(parent, name, start, end) {
        var _this = _super.call(this, parent, 'object', name, start, end) || this;
        _this.properties = [];
        return _this;
    }
    ObjectASTNode.prototype.getChildNodes = function () {
        return this.properties;
    };
    ObjectASTNode.prototype.getLastChild = function () {
        return this.properties[this.properties.length - 1];
    };
    ObjectASTNode.prototype.addProperty = function (node) {
        if (!node) {
            return false;
        }
        this.properties.push(node);
        return true;
    };
    ObjectASTNode.prototype.getFirstProperty = function (key) {
        for (var i = 0; i < this.properties.length; i++) {
            if (this.properties[i].key.value === key) {
                return this.properties[i];
            }
        }
        return null;
    };
    ObjectASTNode.prototype.getKeyList = function () {
        return this.properties.map(function (p) { return p.key.getValue(); });
    };
    // tslint:disable-next-line: no-any
    ObjectASTNode.prototype.getValue = function () {
        // tslint:disable-next-line: no-any
        var value = Object.create(null);
        this.properties.forEach(function (p) {
            var v = p.value && p.value.getValue();
            if (typeof v !== 'undefined') {
                value[p.key.getValue()] = v;
            }
        });
        return value;
    };
    ObjectASTNode.prototype.visit = function (visitor) {
        var ctn = visitor(this);
        for (var i = 0; i < this.properties.length && ctn; i++) {
            ctn = this.properties[i].visit(visitor);
        }
        return ctn;
    };
    ObjectASTNode.prototype.validate = function (schema, validationResult, matchingSchemas) {
        var _this = this;
        if (!matchingSchemas.include(this)) {
            return;
        }
        _super.prototype.validate.call(this, schema, validationResult, matchingSchemas);
        var seenKeys = Object.create(null);
        var unprocessedProperties = [];
        this.properties.forEach(function (node) {
            var key = node.key.value;
            //Replace the merge key with the actual values of what the node value points to in seen keys
            if (key === '<<' && node.value) {
                switch (node.value.type) {
                    case 'object': {
                        node.value['properties'].forEach(function (propASTNode) {
                            var propKey = propASTNode.key.value;
                            seenKeys[propKey] = propASTNode.value;
                            unprocessedProperties.push(propKey);
                        });
                        break;
                    }
                    case 'array': {
                        node.value['items'].forEach(function (sequenceNode) {
                            sequenceNode['properties'].forEach(function (propASTNode) {
                                var seqKey = propASTNode.key.value;
                                seenKeys[seqKey] = propASTNode.value;
                                unprocessedProperties.push(seqKey);
                            });
                        });
                        break;
                    }
                    default: {
                        break;
                    }
                }
            }
            else {
                seenKeys[key] = node.value;
                unprocessedProperties.push(key);
            }
        });
        if (Array.isArray(schema.required)) {
            schema.required.forEach(function (propertyName) {
                if (!seenKeys[propertyName]) {
                    var key = _this.parent && _this.parent && _this.parent.key;
                    var location_1 = key
                        ? { start: key.start, end: key.end }
                        : { start: _this.start, end: _this.start + 1 };
                    validationResult.problems.push({
                        location: location_1,
                        severity: ProblemSeverity.Warning,
                        message: jsonParser04_localize('MissingRequiredPropWarning', 'Missing property "{0}".', propertyName),
                    });
                }
            });
        }
        var propertyProcessed = function (prop) {
            var index = unprocessedProperties.indexOf(prop);
            while (index >= 0) {
                unprocessedProperties.splice(index, 1);
                index = unprocessedProperties.indexOf(prop);
            }
        };
        if (schema.properties) {
            Object.keys(schema.properties).forEach(function (propertyName) {
                propertyProcessed(propertyName);
                var prop = schema.properties[propertyName];
                var child = seenKeys[propertyName];
                if (child) {
                    var propertyValidationResult = new jsonParser04_ValidationResult();
                    child.validate(prop, propertyValidationResult, matchingSchemas);
                    validationResult.mergePropertyMatch(propertyValidationResult);
                }
            });
        }
        if (schema.patternProperties) {
            Object.keys(schema.patternProperties).forEach(function (propertyPattern) {
                var regex = new RegExp(propertyPattern);
                unprocessedProperties.slice(0).forEach(function (propertyName) {
                    if (regex.test(propertyName)) {
                        propertyProcessed(propertyName);
                        var child = seenKeys[propertyName];
                        if (child) {
                            var propertyValidationResult = new jsonParser04_ValidationResult();
                            child.validate(schema.patternProperties[propertyPattern], propertyValidationResult, matchingSchemas);
                            validationResult.mergePropertyMatch(propertyValidationResult);
                        }
                    }
                });
            });
        }
        if (typeof schema.additionalProperties === 'object') {
            unprocessedProperties.forEach(function (propertyName) {
                var child = seenKeys[propertyName];
                if (child) {
                    var propertyValidationResult = new jsonParser04_ValidationResult();
                    // tslint:disable-next-line: no-any
                    child.validate(schema.additionalProperties, propertyValidationResult, matchingSchemas);
                    validationResult.mergePropertyMatch(propertyValidationResult);
                }
            });
        }
        else if (schema.additionalProperties === false) {
            if (unprocessedProperties.length > 0) {
                unprocessedProperties.forEach(function (propertyName) {
                    var child = seenKeys[propertyName];
                    if (child) {
                        var propertyNode = null;
                        if (child.type !== 'property') {
                            propertyNode = child.parent;
                            if (propertyNode.type === 'object') {
                                propertyNode = propertyNode.properties[0];
                            }
                        }
                        else {
                            propertyNode = child;
                        }
                        validationResult.problems.push({
                            location: {
                                start: propertyNode.key.start,
                                end: propertyNode.key.end,
                            },
                            severity: ProblemSeverity.Warning,
                            message: schema.errorMessage ||
                                jsonParser04_localize('DisallowedExtraPropWarning', 'Unexpected property {0}', propertyName),
                        });
                    }
                });
            }
        }
        if (schema.maxProperties) {
            if (this.properties.length > schema.maxProperties) {
                validationResult.problems.push({
                    location: { start: this.start, end: this.end },
                    severity: ProblemSeverity.Warning,
                    message: jsonParser04_localize('MaxPropWarning', 'Object has more properties than limit of {0}.', schema.maxProperties),
                });
            }
        }
        if (schema.minProperties) {
            if (this.properties.length < schema.minProperties) {
                validationResult.problems.push({
                    location: { start: this.start, end: this.end },
                    severity: ProblemSeverity.Warning,
                    message: jsonParser04_localize('MinPropWarning', 'Object has fewer properties than the required number of {0}', schema.minProperties),
                });
            }
        }
        if (schema.dependencies) {
            Object.keys(schema.dependencies).forEach(function (key) {
                var prop = seenKeys[key];
                if (prop) {
                    var propertyDep = schema.dependencies[key];
                    if (Array.isArray(propertyDep)) {
                        propertyDep.forEach(function (requiredProp) {
                            if (!seenKeys[requiredProp]) {
                                validationResult.problems.push({
                                    location: { start: _this.start, end: _this.end },
                                    severity: ProblemSeverity.Warning,
                                    message: jsonParser04_localize('RequiredDependentPropWarning', 'Object is missing property {0} required by property {1}.', requiredProp, key),
                                });
                            }
                            else {
                                validationResult.propertiesValueMatches++;
                            }
                        });
                    }
                    else if (propertyDep) {
                        var propertyvalidationResult = new jsonParser04_ValidationResult();
                        _this.validate(propertyDep, propertyvalidationResult, matchingSchemas);
                        validationResult.mergePropertyMatch(propertyvalidationResult);
                    }
                }
            });
        }
    };
    return ObjectASTNode;
}(jsonParser04_ASTNode));

var jsonParser04_EnumMatch;
(function (EnumMatch) {
    EnumMatch[EnumMatch["Key"] = 0] = "Key";
    EnumMatch[EnumMatch["Enum"] = 1] = "Enum";
})(jsonParser04_EnumMatch || (jsonParser04_EnumMatch = {}));
var jsonParser04_SchemaCollector = /** @class */ (function () {
    function SchemaCollector(focusOffset, exclude) {
        if (focusOffset === void 0) { focusOffset = -1; }
        if (exclude === void 0) { exclude = null; }
        this.focusOffset = focusOffset;
        this.exclude = exclude;
        this.schemas = [];
    }
    SchemaCollector.prototype.add = function (schema) {
        this.schemas.push(schema);
    };
    SchemaCollector.prototype.merge = function (other) {
        var _a;
        (_a = this.schemas).push.apply(_a, jsonParser04_spread(other.schemas));
    };
    SchemaCollector.prototype.include = function (node) {
        return ((this.focusOffset === -1 || node.contains(this.focusOffset)) &&
            node !== this.exclude);
    };
    SchemaCollector.prototype.newSub = function () {
        return new SchemaCollector(-1, this.exclude);
    };
    return SchemaCollector;
}());
var jsonParser04_NoOpSchemaCollector = /** @class */ (function () {
    function NoOpSchemaCollector() {
    }
    Object.defineProperty(NoOpSchemaCollector.prototype, "schemas", {
        get: function () {
            return [];
        },
        enumerable: true,
        configurable: true
    });
    NoOpSchemaCollector.prototype.add = function (schema) { };
    NoOpSchemaCollector.prototype.merge = function (other) { };
    NoOpSchemaCollector.prototype.include = function (node) {
        return true;
    };
    NoOpSchemaCollector.prototype.newSub = function () {
        return this;
    };
    return NoOpSchemaCollector;
}());
var jsonParser04_ValidationResult = /** @class */ (function () {
    function ValidationResult() {
        this.problems = [];
        this.propertiesMatches = 0;
        this.propertiesValueMatches = 0;
        this.primaryValueMatches = 0;
        this.enumValueMatch = false;
        this.enumValues = null;
        this.warnings = [];
        this.errors = [];
    }
    ValidationResult.prototype.hasProblems = function () {
        return !!this.problems.length;
    };
    ValidationResult.prototype.mergeAll = function (validationResults) {
        var _this = this;
        validationResults.forEach(function (validationResult) {
            _this.merge(validationResult);
        });
    };
    ValidationResult.prototype.merge = function (validationResult) {
        this.problems = this.problems.concat(validationResult.problems);
    };
    ValidationResult.prototype.mergeEnumValues = function (validationResult) {
        var e_2, _a;
        if (!this.enumValueMatch &&
            !validationResult.enumValueMatch &&
            this.enumValues &&
            validationResult.enumValues) {
            this.enumValues = this.enumValues.concat(validationResult.enumValues);
            try {
                for (var _b = jsonParser04_values(this.problems), _c = _b.next(); !_c.done; _c = _b.next()) {
                    var error = _c.value;
                    if (error.code === jsonParser04_ErrorCode.EnumValueMismatch) {
                        error.message = jsonParser04_localize('enumWarning', 'Value is not accepted. Valid values: {0}.', this.enumValues.map(function (v) { return JSON.stringify(v); }).join(', '));
                    }
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    };
    ValidationResult.prototype.mergePropertyMatch = function (propertyValidationResult) {
        this.merge(propertyValidationResult);
        this.propertiesMatches++;
        if (propertyValidationResult.enumValueMatch ||
            (!this.hasProblems() && propertyValidationResult.propertiesMatches)) {
            this.propertiesValueMatches++;
        }
        if (propertyValidationResult.enumValueMatch &&
            propertyValidationResult.enumValues) {
            this.primaryValueMatches++;
        }
    };
    ValidationResult.prototype.compareGeneric = function (other) {
        var hasProblems = this.hasProblems();
        if (hasProblems !== other.hasProblems()) {
            return hasProblems ? -1 : 1;
        }
        if (this.enumValueMatch !== other.enumValueMatch) {
            return other.enumValueMatch ? -1 : 1;
        }
        if (this.propertiesValueMatches !== other.propertiesValueMatches) {
            return this.propertiesValueMatches - other.propertiesValueMatches;
        }
        if (this.primaryValueMatches !== other.primaryValueMatches) {
            return this.primaryValueMatches - other.primaryValueMatches;
        }
        return this.propertiesMatches - other.propertiesMatches;
    };
    ValidationResult.prototype.compareKubernetes = function (other) {
        var hasProblems = this.hasProblems();
        if (this.propertiesMatches !== other.propertiesMatches) {
            return this.propertiesMatches - other.propertiesMatches;
        }
        if (this.enumValueMatch !== other.enumValueMatch) {
            return other.enumValueMatch ? -1 : 1;
        }
        if (this.primaryValueMatches !== other.primaryValueMatches) {
            return this.primaryValueMatches - other.primaryValueMatches;
        }
        if (this.propertiesValueMatches !== other.propertiesValueMatches) {
            return this.propertiesValueMatches - other.propertiesValueMatches;
        }
        if (hasProblems !== other.hasProblems()) {
            return hasProblems ? -1 : 1;
        }
        return this.propertiesMatches - other.propertiesMatches;
    };
    return ValidationResult;
}());

var jsonParser04_JSONDocument = /** @class */ (function () {
    function JSONDocument(root, syntaxErrors) {
        this.root = root;
        this.syntaxErrors = syntaxErrors;
    }
    JSONDocument.prototype.getNodeFromOffset = function (offset) {
        return this.root && this.root.getNodeFromOffset(offset);
    };
    JSONDocument.prototype.getNodeFromOffsetEndInclusive = function (offset) {
        return this.root && this.root.getNodeFromOffsetEndInclusive(offset);
    };
    JSONDocument.prototype.visit = function (visitor) {
        if (this.root) {
            this.root.visit(visitor);
        }
    };
    JSONDocument.prototype.configureSettings = function (parserSettings) {
        if (this.root) {
            this.root.setParserSettings(parserSettings);
        }
    };
    JSONDocument.prototype.validate = function (schema) {
        if (this.root && schema) {
            var validationResult = new jsonParser04_ValidationResult();
            this.root.validate(schema, validationResult, new jsonParser04_NoOpSchemaCollector());
            return validationResult.problems;
        }
        return null;
    };
    JSONDocument.prototype.getMatchingSchemas = function (schema, focusOffset, exclude) {
        if (focusOffset === void 0) { focusOffset = -1; }
        if (exclude === void 0) { exclude = null; }
        var matchingSchemas = new jsonParser04_SchemaCollector(focusOffset, exclude);
        var validationResult = new jsonParser04_ValidationResult();
        if (this.root && schema) {
            this.root.validate(schema, validationResult, matchingSchemas);
        }
        return matchingSchemas.schemas;
    };
    JSONDocument.prototype.getValidationProblems = function (schema, focusOffset, exclude) {
        if (focusOffset === void 0) { focusOffset = -1; }
        if (exclude === void 0) { exclude = null; }
        var matchingSchemas = new jsonParser04_SchemaCollector(focusOffset, exclude);
        var validationResult = new jsonParser04_ValidationResult();
        if (this.root && schema) {
            this.root.validate(schema, validationResult, matchingSchemas);
        }
        return validationResult.problems;
    };
    return JSONDocument;
}());

//Alternative comparison is specifically used by the kubernetes/openshift schema but may lead to better results then genericComparison depending on the schema
function jsonParser04_alternativeComparison(subValidationResult, bestMatch, subSchema, subMatchingSchemas) {
    var compareResult = subValidationResult.compareKubernetes(bestMatch.validationResult);
    if (compareResult > 0) {
        // our node is the best matching so far
        bestMatch = {
            schema: subSchema,
            validationResult: subValidationResult,
            matchingSchemas: subMatchingSchemas,
        };
    }
    else if (compareResult === 0) {
        // there's already a best matching but we are as good
        bestMatch.matchingSchemas.merge(subMatchingSchemas);
        bestMatch.validationResult.mergeEnumValues(subValidationResult);
    }
    return bestMatch;
}
//genericComparison tries to find the best matching schema using a generic comparison
function jsonParser04_genericComparison(maxOneMatch, subValidationResult, bestMatch, subSchema, subMatchingSchemas) {
    if (!maxOneMatch &&
        !subValidationResult.hasProblems() &&
        !bestMatch.validationResult.hasProblems()) {
        // no errors, both are equally good matches
        bestMatch.matchingSchemas.merge(subMatchingSchemas);
        bestMatch.validationResult.propertiesMatches +=
            subValidationResult.propertiesMatches;
        bestMatch.validationResult.propertiesValueMatches +=
            subValidationResult.propertiesValueMatches;
    }
    else {
        var compareResult = subValidationResult.compareGeneric(bestMatch.validationResult);
        if (compareResult > 0) {
            // our node is the best matching so far
            bestMatch = {
                schema: subSchema,
                validationResult: subValidationResult,
                matchingSchemas: subMatchingSchemas,
            };
        }
        else if (compareResult === 0) {
            // there's already a best matching but we are as good
            bestMatch.matchingSchemas.merge(subMatchingSchemas);
            bestMatch.validationResult.mergeEnumValues(subValidationResult);
        }
    }
    return bestMatch;
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/languageservice/parser/yamlParser04.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Red Hat, Inc. All rights reserved.
 *  Copyright (c) Adam Voss. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

var yamlParser04_extends = (undefined && undefined.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var yamlParser04_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};


var yamlParser04_localize = loadMessageBundle();





var yamlParser04_SingleYAMLDocument = /** @class */ (function (_super) {
    yamlParser04_extends(SingleYAMLDocument, _super);
    function SingleYAMLDocument(lines) {
        var _this = _super.call(this, null, []) || this;
        _this.lines = lines;
        _this.root = null;
        _this.errors = [];
        _this.warnings = [];
        return _this;
    }
    SingleYAMLDocument.prototype.getSchemas = function (schema, doc, node) {
        var matchingSchemas = [];
        doc.validate(schema, matchingSchemas, node.start);
        return matchingSchemas;
    };
    SingleYAMLDocument.prototype.getNodeFromOffset = function (offset) {
        return this.getNodeFromOffsetEndInclusive(offset);
    };
    return SingleYAMLDocument;
}(jsonParser04_JSONDocument));

function yamlParser04_recursivelyBuildAst(parent, node) {
    var e_1, _a, e_2, _b;
    if (!node) {
        return;
    }
    switch (node.kind) {
        case yamlAST["a" /* Kind */].MAP: {
            var instance = node;
            var result = new ObjectASTNode(parent, null, node.startPosition, node.endPosition);
            try {
                for (var _c = yamlParser04_values(instance.mappings), _d = _c.next(); !_d.done; _d = _c.next()) {
                    var mapping = _d.value;
                    result.addProperty(yamlParser04_recursivelyBuildAst(result, mapping));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
                }
                finally { if (e_1) throw e_1.error; }
            }
            return result;
        }
        case yamlAST["a" /* Kind */].MAPPING: {
            var instance = node;
            var key = instance.key;
            // Technically, this is an arbitrary node in YAML
            // I doubt we would get a better string representation by parsing it
            var keyNode = new StringASTNode(null, null, true, key.startPosition, key.endPosition);
            keyNode.value = key.value;
            var result = new PropertyASTNode(parent, keyNode);
            result.end = instance.endPosition;
            var valueNode = instance.value
                ? yamlParser04_recursivelyBuildAst(result, instance.value)
                : new NullASTNode(parent, key.value, instance.endPosition, instance.endPosition);
            valueNode.location = key.value;
            result.setValue(valueNode);
            return result;
        }
        case yamlAST["a" /* Kind */].SEQ: {
            var instance = node;
            var result = new ArrayASTNode(parent, null, instance.startPosition, instance.endPosition);
            var count = 0;
            try {
                for (var _e = yamlParser04_values(instance.items), _f = _e.next(); !_f.done; _f = _e.next()) {
                    var item = _f.value;
                    if (item === null && count === instance.items.length - 1) {
                        break;
                    }
                    // Be aware of https://github.com/nodeca/js-yaml/issues/321
                    // Cannot simply work around it here because we need to know if we are in Flow or Block
                    var itemNode = item === null
                        ? new NullASTNode(parent, null, instance.endPosition, instance.endPosition)
                        : yamlParser04_recursivelyBuildAst(result, item);
                    itemNode.location = count++;
                    result.addItem(itemNode);
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
                }
                finally { if (e_2) throw e_2.error; }
            }
            return result;
        }
        case yamlAST["a" /* Kind */].SCALAR: {
            var instance = node;
            var type = determineScalarType(instance);
            // The name is set either by the sequence or the mapping case.
            var name_1 = null;
            var value = instance.value;
            //This is a patch for redirecting values with these strings to be boolean nodes because its not supported in the parser.
            var possibleBooleanValues = [
                'y',
                'Y',
                'yes',
                'Yes',
                'YES',
                'n',
                'N',
                'no',
                'No',
                'NO',
                'on',
                'On',
                'ON',
                'off',
                'Off',
                'OFF',
            ];
            if (instance.plainScalar &&
                possibleBooleanValues.indexOf(value.toString()) !== -1) {
                return new BooleanASTNode(parent, name_1, scalar_type_parseYamlBoolean(value), node.startPosition, node.endPosition);
            }
            switch (type) {
                case ScalarType.null: {
                    return new StringASTNode(parent, name_1, false, instance.startPosition, instance.endPosition);
                }
                case ScalarType.bool: {
                    return new BooleanASTNode(parent, name_1, parseYamlBoolean(value), node.startPosition, node.endPosition);
                }
                case ScalarType.int: {
                    var result = new NumberASTNode(parent, name_1, node.startPosition, node.endPosition);
                    result.value = parseYamlInteger(value);
                    result.isInteger = true;
                    return result;
                }
                case ScalarType.float: {
                    var result = new NumberASTNode(parent, name_1, node.startPosition, node.endPosition);
                    result.value = parseYamlFloat(value);
                    result.isInteger = false;
                    return result;
                }
                case ScalarType.string: {
                    var result = new StringASTNode(parent, name_1, false, node.startPosition, node.endPosition);
                    result.value = node.value;
                    return result;
                }
            }
            break;
        }
        case yamlAST["a" /* Kind */].ANCHOR_REF: {
            var instance = node.value;
            return (yamlParser04_recursivelyBuildAst(parent, instance) ||
                new NullASTNode(parent, null, node.startPosition, node.endPosition));
        }
        case yamlAST["a" /* Kind */].INCLUDE_REF: {
            var result = new StringASTNode(parent, null, false, node.startPosition, node.endPosition);
            result.value = node.value;
            return result;
        }
    }
}
function yamlParser04_convertError(e) {
    return {
        message: "" + e.reason,
        location: {
            start: e.mark.position,
            end: e.mark.position + e.mark.column,
            code: jsonParser04_ErrorCode.Undefined,
        },
    };
}
function yamlParser04_createJSONDocument(yamlDoc, startPositions, text) {
    var _doc = new yamlParser04_SingleYAMLDocument(startPositions);
    _doc.root = yamlParser04_recursivelyBuildAst(null, yamlDoc);
    if (!_doc.root) {
        // TODO: When this is true, consider not pushing the other errors.
        _doc.errors.push({
            message: yamlParser04_localize('Invalid symbol', 'Expected a YAML object, array or literal'),
            code: jsonParser04_ErrorCode.Undefined,
            location: { start: yamlDoc.startPosition, end: yamlDoc.endPosition },
        });
    }
    var duplicateKeyReason = 'duplicate key';
    //Patch ontop of yaml-ast-parser to disable duplicate key message on merge key
    var isDuplicateAndNotMergeKey = function (error, yamlText) {
        var errorConverted = yamlParser04_convertError(error);
        var errorStart = errorConverted.location.start;
        var errorEnd = errorConverted.location.end;
        if (error.reason === duplicateKeyReason &&
            yamlText.substring(errorStart, errorEnd).startsWith('<<')) {
            return false;
        }
        return true;
    };
    var errors = yamlDoc.errors
        .filter(function (e) { return e.reason !== duplicateKeyReason && !e.isWarning; })
        .map(function (e) { return yamlParser04_convertError(e); });
    var warnings = yamlDoc.errors
        .filter(function (e) {
        return (e.reason === duplicateKeyReason &&
            isDuplicateAndNotMergeKey(e, text)) ||
            e.isWarning;
    })
        .map(function (e) { return yamlParser04_convertError(e); });
    errors.forEach(function (e) { return _doc.errors.push(e); });
    warnings.forEach(function (e) { return _doc.warnings.push(e); });
    return _doc;
}
var yamlParser04_YAMLDocument = /** @class */ (function () {
    function YAMLDocument(documents) {
        this.documents = documents;
        this.errors = [];
        this.warnings = [];
    }
    return YAMLDocument;
}());

function yamlParser04_parse(text, customTags) {
    if (customTags === void 0) { customTags = []; }
    var startPositions = getLineStartPositions(text);
    // This is documented to return a YAMLNode even though the
    // typing only returns a YAMLDocument
    var yamlDocs = [];
    var filteredTags = filterInvalidCustomTags(customTags);
    var schemaWithAdditionalTags = js_yaml["Schema"].create(filteredTags.map(function (tag) {
        var typeInfo = tag.split(' ');
        return new js_yaml["Type"](typeInfo[0], {
            kind: (typeInfo[1] && typeInfo[1].toLowerCase()) || 'scalar',
        });
    }));
    /**
     * Collect the additional tags into a map of string to possible tag types
     */
    var tagWithAdditionalItems = new Map();
    filteredTags.forEach(function (tag) {
        var typeInfo = tag.split(' ');
        var tagName = typeInfo[0];
        var tagType = (typeInfo[1] && typeInfo[1].toLowerCase()) || 'scalar';
        if (tagWithAdditionalItems.has(tagName)) {
            tagWithAdditionalItems.set(tagName, tagWithAdditionalItems.get(tagName).concat([tagType]));
        }
        else {
            tagWithAdditionalItems.set(tagName, [tagType]);
        }
    });
    tagWithAdditionalItems.forEach(function (additionalTagKinds, key) {
        var newTagType = new js_yaml["Type"](key, {
            kind: additionalTagKinds[0] || 'scalar',
        });
        newTagType.additionalKinds = additionalTagKinds;
        schemaWithAdditionalTags.compiledTypeMap[key] = newTagType;
    });
    var additionalOptions = {
        schema: schemaWithAdditionalTags,
    };
    loadAll(text, function (doc) { return yamlDocs.push(doc); }, additionalOptions);
    return new yamlParser04_YAMLDocument(yamlDocs.map(function (doc) { return yamlParser04_createJSONDocument(doc, startPositions, text); }));
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/languageservice/services/yamlCompletion.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Red Hat, Inc. All rights reserved.
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






var yamlCompletion_localize = loadMessageBundle();
var yamlCompletion_YAMLCompletion = /** @class */ (function () {
    function YAMLCompletion(schemaService, contributions, promiseConstructor) {
        if (contributions === void 0) { contributions = []; }
        this.schemaService = schemaService;
        this.contributions = contributions;
        this.promise = promiseConstructor || Promise;
        this.customTags = [];
        this.completion = true;
    }
    YAMLCompletion.prototype.configure = function (languageSettings, customTags) {
        if (languageSettings) {
            this.completion = languageSettings.completion;
        }
        this.customTags = customTags;
    };
    YAMLCompletion.prototype.doResolve = function (item) {
        for (var i = this.contributions.length - 1; i >= 0; i--) {
            if (this.contributions[i].resolveCompletion) {
                var resolver = this.contributions[i].resolveCompletion(item);
                if (resolver) {
                    return resolver;
                }
            }
        }
        return this.promise.resolve(item);
    };
    YAMLCompletion.prototype.doComplete = function (document, position, isKubernetes) {
        var _this = this;
        if (isKubernetes === void 0) { isKubernetes = false; }
        var result = {
            items: [],
            isIncomplete: false,
        };
        if (!this.completion) {
            return Promise.resolve(result);
        }
        var completionFix = this.completionHelper(document, position);
        var newText = completionFix.newText;
        var doc = yamlParser04_parse(newText);
        this.setKubernetesParserOption(doc.documents, isKubernetes);
        var offset = document.offsetAt(position);
        if (document.getText()[offset] === ':') {
            return Promise.resolve(result);
        }
        var currentDoc = matchOffsetToDocument(offset, doc);
        if (currentDoc === null) {
            return Promise.resolve(result);
        }
        var currentDocIndex = doc.documents.indexOf(currentDoc);
        var node = currentDoc.getNodeFromOffsetEndInclusive(offset);
        // if (this.isInComment(document, node ? node.start : 0, offset)) {
        // 	return Promise.resolve(result);
        // }
        var currentWord = this.getCurrentWord(document, offset);
        var overwriteRange = null;
        if (node && node.type === 'null') {
            var nodeStartPos = document.positionAt(node.start);
            nodeStartPos.character += 1;
            var nodeEndPos = document.positionAt(node.end);
            nodeEndPos.character += 1;
            overwriteRange = main_Range.create(nodeStartPos, nodeEndPos);
        }
        else if (node &&
            (node.type === 'string' ||
                node.type === 'number' ||
                node.type === 'boolean')) {
            overwriteRange = main_Range.create(document.positionAt(node.start), document.positionAt(node.end));
        }
        else {
            var overwriteStart = offset - currentWord.length;
            if (overwriteStart > 0 &&
                document.getText()[overwriteStart - 1] === '"') {
                overwriteStart--;
            }
            overwriteRange = main_Range.create(document.positionAt(overwriteStart), position);
        }
        var proposed = {};
        var collector = {
            add: function (suggestion) {
                var existing = proposed[suggestion.label];
                if (!existing) {
                    proposed[suggestion.label] = suggestion;
                    if (overwriteRange &&
                        overwriteRange.start.line === overwriteRange.end.line) {
                        suggestion.textEdit = TextEdit.replace(overwriteRange, suggestion.insertText);
                    }
                    result.items.push(suggestion);
                }
                else if (!existing.documentation) {
                    existing.documentation = suggestion.documentation;
                }
            },
            setAsIncomplete: function () {
                result.isIncomplete = true;
            },
            error: function (message) {
                console.error(message);
            },
            log: function (message) {
                console.log(message);
            },
            getNumberOfProposals: function () { return result.items.length; },
        };
        if (this.customTags.length > 0) {
            this.getCustomTagValueCompletions(collector);
        }
        currentDoc.currentDocIndex = currentDocIndex;
        return this.schemaService
            .getSchemaForResource(document.uri, currentDoc)
            .then(function (schema) {
            if (!schema) {
                return Promise.resolve(result);
            }
            var newSchema = schema;
            // tslint:disable-next-line: no-any
            var collectionPromises = [];
            var addValue = true;
            var currentKey = '';
            var currentProperty = null;
            if (node) {
                if (node.type === 'string') {
                    var stringNode = node;
                    if (stringNode.isKey) {
                        addValue = !(node.parent && node.parent.value);
                        currentProperty = node.parent
                            ? node.parent
                            : null;
                        currentKey = document
                            .getText()
                            .substring(node.start + 1, node.end - 1);
                        if (node.parent) {
                            node = node.parent.parent;
                        }
                    }
                }
            }
            // proposals for properties
            if (node && node.type === 'object') {
                // don't suggest properties that are already present
                var properties = node.properties;
                properties.forEach(function (p) {
                    if (!currentProperty || currentProperty !== p) {
                        proposed[p.key.value] = CompletionItem.create('__');
                    }
                });
                var separatorAfter = '';
                if (addValue) {
                    separatorAfter = _this.evaluateSeparatorAfter(document, document.offsetAt(overwriteRange.end));
                }
                if (newSchema) {
                    // property proposals with schema
                    _this.getPropertyCompletions(document, newSchema, currentDoc, node, addValue, collector, separatorAfter);
                }
                var location_1 = node.getPath();
                _this.contributions.forEach(function (contribution) {
                    var collectPromise = contribution.collectPropertyCompletions(document.uri, location_1, currentWord, addValue, false, collector);
                    if (collectPromise) {
                        collectionPromises.push(collectPromise);
                    }
                });
                if (!schema &&
                    currentWord.length > 0 &&
                    document.getText().charAt(offset - currentWord.length - 1) !== '"') {
                    collector.add({
                        kind: main_CompletionItemKind.Property,
                        label: _this.getLabelForValue(currentWord),
                        insertText: _this.getInsertTextForProperty(currentWord, null, false, separatorAfter),
                        insertTextFormat: InsertTextFormat.Snippet,
                        documentation: '',
                    });
                }
            }
            // proposals for values
            if (newSchema) {
                _this.getValueCompletions(newSchema, currentDoc, node, offset, document, collector);
            }
            if (_this.contributions.length > 0) {
                _this.getContributedValueCompletions(currentDoc, node, offset, document, collector, collectionPromises);
            }
            return _this.promise.all(collectionPromises).then(function () { return result; });
        });
    };
    YAMLCompletion.prototype.getPropertyCompletions = function (document, schema, doc, node, addValue, collector, separatorAfter) {
        var _this = this;
        var matchingSchemas = doc.getMatchingSchemas(schema.schema);
        matchingSchemas.forEach(function (s) {
            if (s.node === node && !s.inverted) {
                var schemaProperties_1 = s.schema.properties;
                if (schemaProperties_1) {
                    Object.keys(schemaProperties_1).forEach(function (key) {
                        var propertySchema = schemaProperties_1[key];
                        if (!propertySchema.deprecationMessage &&
                            !propertySchema['doNotSuggest']) {
                            var identCompensation = '';
                            if (node.parent && node.parent.type === 'array') {
                                // because there is a slash '-' to prevent the properties generated to have the correct
                                // indent
                                var sourceText = document.getText();
                                var indexOfSlash = sourceText.lastIndexOf('-', node.start - 1);
                                if (indexOfSlash > 0) {
                                    // add one space to compensate the '-'
                                    identCompensation =
                                        ' ' + sourceText.slice(indexOfSlash + 1, node.start);
                                }
                            }
                            collector.add({
                                kind: main_CompletionItemKind.Property,
                                label: key,
                                insertText: _this.getInsertTextForProperty(key, propertySchema, addValue, separatorAfter, identCompensation + '\t'),
                                insertTextFormat: InsertTextFormat.Snippet,
                                documentation: propertySchema.description || '',
                            });
                        }
                    });
                }
                // Error fix
                // If this is a array of string/boolean/number
                //  test:
                //    - item1
                // it will treated as a property key since `:` has been appended
                if (node.type === 'object' &&
                    node.parent &&
                    node.parent.type === 'array' &&
                    s.schema.type !== 'object') {
                    _this.addSchemaValueCompletions(s.schema, collector, separatorAfter);
                }
            }
        });
    };
    YAMLCompletion.prototype.getValueCompletions = function (schema, doc, node, offset, document, collector) {
        var _this = this;
        var offsetForSeparator = offset;
        var parentKey = null;
        var valueNode = null;
        if (node &&
            (node.type === 'string' ||
                node.type === 'number' ||
                node.type === 'boolean')) {
            offsetForSeparator = node.end;
            valueNode = node;
            node = node.parent;
        }
        if (node && node.type === 'null') {
            var nodeParent = node.parent;
            /*
             * This is going to be an object for some reason and we need to find the property
             * Its an issue with the null node
             */
            if (nodeParent && nodeParent.type === 'object') {
                for (var prop in nodeParent['properties']) {
                    var currNode = nodeParent['properties'][prop];
                    if (currNode.key && currNode.key.location === node.location) {
                        node = currNode;
                    }
                }
            }
        }
        if (!node) {
            this.addSchemaValueCompletions(schema.schema, collector, '');
            return;
        }
        if (node.type === 'property' &&
            offset > node.colonOffset) {
            var propertyNode = node;
            var valueNode_1 = propertyNode.value;
            if (valueNode_1 && offset > valueNode_1.end) {
                return; // we are past the value node
            }
            parentKey = propertyNode.key.value;
            node = node.parent;
        }
        var separatorAfter = this.evaluateSeparatorAfter(document, offsetForSeparator);
        if (node && (parentKey !== null || node.type === 'array')) {
            var matchingSchemas = doc.getMatchingSchemas(schema.schema);
            matchingSchemas.forEach(function (s) {
                if (s.node === node && !s.inverted && s.schema) {
                    if (s.schema.items) {
                        if (Array.isArray(s.schema.items)) {
                            var index = _this.findItemAtOffset(node, document, offset);
                            if (index < s.schema.items.length) {
                                _this.addSchemaValueCompletions(s.schema.items[index], collector, separatorAfter, true);
                            }
                        }
                        else if (s.schema.items.type === 'object') {
                            collector.add({
                                kind: _this.getSuggestionKind(s.schema.items.type),
                                label: '- (array item)',
                                documentation: "Create an item of an array" + (s.schema.description === undefined
                                    ? ''
                                    : '(' + s.schema.description + ')'),
                                insertText: "- " + _this.getInsertTextForObject(s.schema.items, separatorAfter).insertText.trimLeft(),
                                insertTextFormat: InsertTextFormat.Snippet,
                            });
                        }
                        else {
                            _this.addSchemaValueCompletions(s.schema.items, collector, separatorAfter, true);
                        }
                    }
                    if (s.schema.properties) {
                        var propertySchema = s.schema.properties[parentKey];
                        if (propertySchema) {
                            _this.addSchemaValueCompletions(propertySchema, collector, separatorAfter, false);
                        }
                    }
                }
            });
        }
    };
    YAMLCompletion.prototype.getContributedValueCompletions = function (doc, node, offset, document, collector, 
    // tslint:disable-next-line: no-any
    collectionPromises) {
        if (!node) {
            this.contributions.forEach(function (contribution) {
                var collectPromise = contribution.collectDefaultCompletions(document.uri, collector);
                if (collectPromise) {
                    collectionPromises.push(collectPromise);
                }
            });
        }
        else {
            if (node.type === 'string' ||
                node.type === 'number' ||
                node.type === 'boolean' ||
                node.type === 'null') {
                node = node.parent;
            }
            if (node.type === 'property' &&
                offset > node.colonOffset) {
                var parentKey_1 = node.key.value;
                var valueNode = node.value;
                if (!valueNode || offset <= valueNode.end) {
                    var location_2 = node.parent.getPath();
                    this.contributions.forEach(function (contribution) {
                        var collectPromise = contribution.collectValueCompletions(document.uri, location_2, parentKey_1, collector);
                        if (collectPromise) {
                            collectionPromises.push(collectPromise);
                        }
                    });
                }
            }
        }
    };
    YAMLCompletion.prototype.getCustomTagValueCompletions = function (collector) {
        var _this = this;
        var validCustomTags = filterInvalidCustomTags(this.customTags);
        validCustomTags.forEach(function (validTag) {
            // Valid custom tags are guarenteed to be strings
            var label = validTag.split(' ')[0];
            _this.addCustomTagValueCompletion(collector, ' ', label);
        });
    };
    YAMLCompletion.prototype.addSchemaValueCompletions = function (schema, collector, separatorAfter, forArrayItem) {
        if (forArrayItem === void 0) { forArrayItem = false; }
        var types = {};
        this.addSchemaValueCompletionsCore(schema, collector, types, separatorAfter, forArrayItem);
        if (types['boolean']) {
            this.addBooleanValueCompletion(true, collector, separatorAfter);
            this.addBooleanValueCompletion(false, collector, separatorAfter);
        }
        if (types['null']) {
            this.addNullValueCompletion(collector, separatorAfter);
        }
    };
    YAMLCompletion.prototype.addSchemaValueCompletionsCore = function (schema, collector, types, separatorAfter, forArrayItem) {
        var _this = this;
        if (forArrayItem === void 0) { forArrayItem = false; }
        this.addDefaultValueCompletions(schema, collector, separatorAfter, 0, forArrayItem);
        this.addEnumValueCompletions(schema, collector, separatorAfter, forArrayItem);
        this.collectTypes(schema, types);
        if (Array.isArray(schema.allOf)) {
            schema.allOf.forEach(function (s) {
                return _this.addSchemaValueCompletionsCore(s, collector, types, separatorAfter, forArrayItem);
            });
        }
        if (Array.isArray(schema.anyOf)) {
            schema.anyOf.forEach(function (s) {
                return _this.addSchemaValueCompletionsCore(s, collector, types, separatorAfter, forArrayItem);
            });
        }
        if (Array.isArray(schema.oneOf)) {
            schema.oneOf.forEach(function (s) {
                return _this.addSchemaValueCompletionsCore(s, collector, types, separatorAfter, forArrayItem);
            });
        }
    };
    YAMLCompletion.prototype.addDefaultValueCompletions = function (schema, collector, separatorAfter, arrayDepth, forArrayItem) {
        var _this = this;
        if (arrayDepth === void 0) { arrayDepth = 0; }
        if (forArrayItem === void 0) { forArrayItem = false; }
        var hasProposals = false;
        if (schema.default) {
            var type = schema.type;
            var value = schema.default;
            for (var i = arrayDepth; i > 0; i--) {
                value = [value];
                type = 'array';
            }
            collector.add({
                kind: this.getSuggestionKind(type),
                label: forArrayItem
                    ? "- " + this.getLabelForValue(value)
                    : this.getLabelForValue(value),
                insertText: forArrayItem
                    ? "- " + this.getInsertTextForValue(value, separatorAfter)
                    : this.getInsertTextForValue(value, separatorAfter),
                insertTextFormat: InsertTextFormat.Snippet,
                detail: yamlCompletion_localize('json.suggest.default', 'Default value'),
            });
            hasProposals = true;
        }
        if (Array.isArray(schema['examples'])) {
            schema['examples'].forEach(function (example) {
                var type = schema.type;
                var value = example;
                for (var i = arrayDepth; i > 0; i--) {
                    value = [value];
                    type = 'array';
                }
                collector.add({
                    kind: _this.getSuggestionKind(type),
                    label: _this.getLabelForValue(value),
                    insertText: _this.getInsertTextForValue(value, separatorAfter),
                    insertTextFormat: InsertTextFormat.Snippet,
                });
                hasProposals = true;
            });
        }
        if (!hasProposals && schema.items && !Array.isArray(schema.items)) {
            this.addDefaultValueCompletions(schema.items, collector, separatorAfter, arrayDepth + 1);
        }
    };
    YAMLCompletion.prototype.addEnumValueCompletions = function (schema, collector, separatorAfter, forArrayItem) {
        if (forArrayItem === void 0) { forArrayItem = false; }
        if (yamlCompletion_isDefined(schema['const'])) {
            collector.add({
                kind: this.getSuggestionKind(schema.type),
                label: this.getLabelForValue(schema['const']),
                insertText: this.getInsertTextForValue(schema['const'], separatorAfter),
                insertTextFormat: InsertTextFormat.Snippet,
                documentation: schema.description,
            });
        }
        if (Array.isArray(schema.enum)) {
            for (var i = 0, length_1 = schema.enum.length; i < length_1; i++) {
                var enm = schema.enum[i];
                var documentation = schema.description;
                if (schema.enumDescriptions && i < schema.enumDescriptions.length) {
                    documentation = schema.enumDescriptions[i];
                }
                collector.add({
                    kind: this.getSuggestionKind(schema.type),
                    label: forArrayItem
                        ? "- " + this.getLabelForValue(enm)
                        : this.getLabelForValue(enm),
                    insertText: forArrayItem
                        ? "- " + this.getInsertTextForValue(enm, separatorAfter)
                        : this.getInsertTextForValue(enm, separatorAfter),
                    insertTextFormat: InsertTextFormat.Snippet,
                    documentation: documentation,
                });
            }
        }
    };
    YAMLCompletion.prototype.collectTypes = function (schema, types) {
        var type = schema.type;
        if (Array.isArray(type)) {
            type.forEach(function (t) { return (types[t] = true); });
        }
        else {
            types[type] = true;
        }
    };
    YAMLCompletion.prototype.addBooleanValueCompletion = function (value, collector, separatorAfter) {
        collector.add({
            kind: this.getSuggestionKind('boolean'),
            label: value ? 'true' : 'false',
            insertText: this.getInsertTextForValue(value, separatorAfter),
            insertTextFormat: InsertTextFormat.Snippet,
            documentation: '',
        });
    };
    YAMLCompletion.prototype.addNullValueCompletion = function (collector, separatorAfter) {
        collector.add({
            kind: this.getSuggestionKind('null'),
            label: 'null',
            insertText: 'null' + separatorAfter,
            insertTextFormat: InsertTextFormat.Snippet,
            documentation: '',
        });
    };
    YAMLCompletion.prototype.addCustomTagValueCompletion = function (collector, separatorAfter, label) {
        collector.add({
            kind: this.getSuggestionKind('string'),
            label: label,
            insertText: label + separatorAfter,
            insertTextFormat: InsertTextFormat.Snippet,
            documentation: '',
        });
    };
    // tslint:disable-next-line: no-any
    YAMLCompletion.prototype.getLabelForValue = function (value) {
        var label = typeof value === 'string' ? value : JSON.stringify(value);
        if (label.length > 57) {
            return label.substr(0, 57).trim() + '...';
        }
        return label;
    };
    // tslint:disable-next-line: no-any
    YAMLCompletion.prototype.getSuggestionKind = function (type) {
        if (Array.isArray(type)) {
            // tslint:disable-next-line: no-any
            var array = type;
            type = array.length > 0 ? array[0] : null;
        }
        if (!type) {
            return main_CompletionItemKind.Value;
        }
        switch (type) {
            case 'string':
                return main_CompletionItemKind.Value;
            case 'object':
                return main_CompletionItemKind.Module;
            case 'property':
                return main_CompletionItemKind.Property;
            default:
                return main_CompletionItemKind.Value;
        }
    };
    YAMLCompletion.prototype.getCurrentWord = function (document, offset) {
        var i = offset - 1;
        var text = document.getText();
        while (i >= 0 && ' \t\n\r\v":{[,]}'.indexOf(text.charAt(i)) === -1) {
            i--;
        }
        return text.substring(i + 1, offset);
    };
    YAMLCompletion.prototype.findItemAtOffset = function (node, document, offset) {
        var scanner = jsonc_parser_main_createScanner(document.getText(), true);
        var children = node.getChildNodes();
        for (var i = children.length - 1; i >= 0; i--) {
            var child = children[i];
            if (offset > child.end) {
                scanner.setPosition(child.end);
                var token = scanner.scan();
                if (token === 5 /* CommaToken */ &&
                    offset >= scanner.getTokenOffset() + scanner.getTokenLength()) {
                    return i + 1;
                }
                return i;
            }
            else if (offset >= child.start) {
                return i;
            }
        }
        return 0;
    };
    // private isInComment(document: TextDocument, start: number, offset: number) {
    // 	let scanner = Json.createScanner(document.getText(), false);
    // 	scanner.setPosition(start);
    // 	let token = scanner.scan();
    // 	while (token !== Json.SyntaxKind.EOF && (scanner.getTokenOffset() + scanner.getTokenLength() < offset)) {
    // 		token = scanner.scan();
    // 	}
    // 	return (token === Json.SyntaxKind.LineCommentTrivia || token === Json.SyntaxKind.BlockCommentTrivia) && scanner.getTokenOffset() <= offset;
    // }
    YAMLCompletion.prototype.getInsertTextForPlainText = function (text) {
        return text.replace(/[\\\$\}]/g, '\\$&'); // escape $, \ and }
    };
    // tslint:disable-next-line: no-any
    YAMLCompletion.prototype.getInsertTextForValue = function (value, separatorAfter) {
        var text = value;
        if (text === '{}') {
            return '{\n\t$1\n}' + separatorAfter;
        }
        else if (text === '[]') {
            return '[\n\t$1\n]' + separatorAfter;
        }
        return this.getInsertTextForPlainText(text + separatorAfter);
    };
    YAMLCompletion.prototype.getInsertTextForObject = function (schema, separatorAfter, indent, insertIndex) {
        var _this = this;
        if (indent === void 0) { indent = '\t'; }
        if (insertIndex === void 0) { insertIndex = 1; }
        var insertText = '';
        if (!schema.properties) {
            insertText = indent + "$" + insertIndex++ + "\n";
            return { insertText: insertText, insertIndex: insertIndex };
        }
        Object.keys(schema.properties).forEach(function (key) {
            var propertySchema = schema.properties[key];
            var type = Array.isArray(propertySchema.type)
                ? propertySchema.type[0]
                : propertySchema.type;
            if (!type) {
                if (propertySchema.properties) {
                    type = 'object';
                }
                if (propertySchema.items) {
                    type = 'array';
                }
            }
            if (schema.required && schema.required.indexOf(key) > -1) {
                switch (type) {
                    case 'boolean':
                    case 'string':
                    case 'number':
                    case 'integer':
                        insertText += "" + indent + key + ": $" + insertIndex++ + "\n";
                        break;
                    case 'array':
                        var arrayInsertResult = _this.getInsertTextForArray(propertySchema.items, separatorAfter, indent + "\t", insertIndex++);
                        insertIndex = arrayInsertResult.insertIndex;
                        insertText += "" + indent + key + ":\n" + indent + "\t- " + arrayInsertResult.insertText + "\n";
                        break;
                    case 'object':
                        var objectInsertResult = _this.getInsertTextForObject(propertySchema, separatorAfter, indent + "\t", insertIndex++);
                        insertIndex = objectInsertResult.insertIndex;
                        insertText += "" + indent + key + ":\n" + objectInsertResult.insertText + "\n";
                        break;
                }
            }
            else if (propertySchema.default !== undefined) {
                switch (type) {
                    case 'boolean':
                    case 'string':
                    case 'number':
                    case 'integer':
                        insertText += "" + indent + key + ": ${" + insertIndex++ + ":" + propertySchema.default + "}\n";
                        break;
                    case 'array':
                    case 'object':
                        // TODO: support default value for array object
                        break;
                }
            }
        });
        if (insertText.trim().length === 0) {
            insertText = indent + "$" + insertIndex++ + "\n";
        }
        insertText = insertText.trimRight() + separatorAfter;
        return { insertText: insertText, insertIndex: insertIndex };
    };
    YAMLCompletion.prototype.getInsertTextForArray = function (schema, separatorAfter, indent, insertIndex) {
        if (indent === void 0) { indent = '\t'; }
        if (insertIndex === void 0) { insertIndex = 1; }
        var insertText = '';
        if (!schema) {
            insertText = "$" + insertIndex++;
        }
        var type = Array.isArray(schema.type) ? schema.type[0] : schema.type;
        if (!type) {
            if (schema.properties) {
                type = 'object';
            }
            if (schema.items) {
                type = 'array';
            }
        }
        switch (schema.type) {
            case 'boolean':
                insertText = "${" + insertIndex++ + ":false}";
                break;
            case 'number':
            case 'integer':
                insertText = "${" + insertIndex++ + ":0}";
                break;
            case 'string':
                insertText = "${" + insertIndex++ + ":null}";
                break;
            case 'object':
                var objectInsertResult = this.getInsertTextForObject(schema, separatorAfter, indent + "\t", insertIndex++);
                insertText = objectInsertResult.insertText.trimLeft();
                insertIndex = objectInsertResult.insertIndex;
                break;
        }
        return { insertText: insertText, insertIndex: insertIndex };
    };
    YAMLCompletion.prototype.getInsertTextForProperty = function (key, propertySchema, addValue, separatorAfter, ident) {
        if (ident === void 0) { ident = '\t'; }
        var propertyText = this.getInsertTextForValue(key, '');
        // if (!addValue) {
        //     return propertyText;
        // }
        var resultText = propertyText + ':';
        var value;
        if (propertySchema) {
            if (propertySchema.default !== undefined) {
                value = " ${1:" + propertySchema.default + "}";
            }
            else if (propertySchema.properties) {
                return resultText + "\n" + this.getInsertTextForObject(propertySchema, separatorAfter, ident)
                    .insertText;
            }
            else if (propertySchema.items) {
                return resultText + "\n\t- " + this.getInsertTextForArray(propertySchema.items, separatorAfter, ident).insertText;
            }
            else {
                var type = Array.isArray(propertySchema.type)
                    ? propertySchema.type[0]
                    : propertySchema.type;
                switch (type) {
                    case 'boolean':
                        value = ' $1';
                        break;
                    case 'string':
                        value = ' $1';
                        break;
                    case 'object':
                        value = '\n\t';
                        break;
                    case 'array':
                        value = '\n\t- ';
                        break;
                    case 'number':
                    case 'integer':
                        value = ' ${1:0}';
                        break;
                    case 'null':
                        value = ' ${1:null}';
                        break;
                    default:
                        return propertyText;
                }
            }
        }
        if (!value) {
            value = '$1';
        }
        return resultText + value + separatorAfter;
    };
    YAMLCompletion.prototype.evaluateSeparatorAfter = function (document, offset) {
        // let scanner = Json.createScanner(document.getText(), true);
        // scanner.setPosition(offset);
        // let token = scanner.scan();
        // switch (token) {
        // 	case Json.SyntaxKind.CommaToken:
        // 	case Json.SyntaxKind.CloseBraceToken:
        // 	case Json.SyntaxKind.CloseBracketToken:
        // 	case Json.SyntaxKind.EOF:
        // 		return '';
        // 	default:
        // 		return '';
        // }
        return '';
    };
    /**
     * Corrects simple syntax mistakes to load possible nodes even if a semicolon is missing
     */
    YAMLCompletion.prototype.completionHelper = function (document, textDocumentPosition) {
        // Get the string we are looking at via a substring
        var linePos = textDocumentPosition.line;
        var position = textDocumentPosition;
        var lineOffset = getLineOffsets(document.getText());
        var start = lineOffset[linePos]; // Start of where the autocompletion is happening
        var end = 0; // End of where the autocompletion is happening
        if (lineOffset[linePos + 1]) {
            end = lineOffset[linePos + 1];
        }
        else {
            end = document.getText().length;
        }
        while (end - 1 >= 0 &&
            this.is_EOL(document.getText().charCodeAt(end - 1))) {
            end--;
        }
        var textLine = document.getText().substring(start, end);
        // Check if the string we are looking at is a node
        if (textLine.indexOf(':') === -1) {
            // We need to add the ":" to load the nodes
            var newText = '';
            // This is for the empty line case
            var trimmedText = textLine.trim();
            if (trimmedText.length === 0 ||
                (trimmedText.length === 1 && trimmedText[0] === '-')) {
                // Add a temp node that is in the document but we don't use at all.
                newText =
                    document.getText().substring(0, start + textLine.length) +
                        (trimmedText[0] === '-' && !textLine.endsWith(' ') ? ' ' : '') +
                        'holder:\r\n' +
                        document
                            .getText()
                            .substr(lineOffset[linePos + 1] || document.getText().length);
                // For when missing semi colon case
            }
            else {
                // Add a semicolon to the end of the current line so we can validate the node
                newText =
                    document.getText().substring(0, start + textLine.length) +
                        ':\r\n' +
                        document
                            .getText()
                            .substr(lineOffset[linePos + 1] || document.getText().length);
            }
            return {
                newText: newText,
                newPosition: textDocumentPosition,
            };
        }
        else {
            // All the nodes are loaded
            position.character = position.character - 1;
            return {
                newText: document.getText(),
                newPosition: position,
            };
        }
    };
    YAMLCompletion.prototype.is_EOL = function (c) {
        return c === 0x0a /* LF */ || c === 0x0d /* CR */;
    };
    // Called by onCompletion
    YAMLCompletion.prototype.setKubernetesParserOption = function (jsonDocuments, option) {
        for (var jsonDoc in jsonDocuments) {
            jsonDocuments[jsonDoc].configureSettings({
                isKubernetes: option,
            });
        }
    };
    return YAMLCompletion;
}());

// tslint:disable-next-line: no-any
function yamlCompletion_isDefined(val) {
    return val !== undefined;
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/languageservice/services/yamlHover.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Red Hat, Inc. All rights reserved.
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/




var yamlHover_YAMLHover = /** @class */ (function () {
    function YAMLHover(schemaService, promiseConstructor) {
        this.promise = promiseConstructor || Promise;
        this.shouldHover = true;
        this.jsonHover = new jsonHover_JSONHover(schemaService, [], Promise);
    }
    YAMLHover.prototype.configure = function (languageSettings) {
        if (languageSettings) {
            this.shouldHover = languageSettings.hover;
        }
    };
    YAMLHover.prototype.doHover = function (document, position) {
        if (!this.shouldHover || !document) {
            return this.promise.resolve(void 0);
        }
        var doc = yamlParser07_parse(document.getText());
        var offset = document.offsetAt(position);
        var currentDoc = matchOffsetToDocument2(offset, doc);
        if (currentDoc === null) {
            return this.promise.resolve(void 0);
        }
        var currentDocIndex = doc.documents.indexOf(currentDoc);
        currentDoc.currentDocIndex = currentDocIndex;
        return this.jsonHover.doHover(document, position, currentDoc);
    };
    return YAMLHover;
}());


// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/languageservice/services/yamlValidation.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Red Hat, Inc. All rights reserved.
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

var yamlValidation_awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var yamlValidation_generator = (undefined && undefined.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var yamlValidation_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var yamlValidation_read = (undefined && undefined.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var yamlValidation_spread = (undefined && undefined.__spread) || function () {
    for (var ar = [], i = 0; i < arguments.length; i++) ar = ar.concat(yamlValidation_read(arguments[i]));
    return ar;
};


var yamlValidation_YAMLValidation = /** @class */ (function () {
    function YAMLValidation(schemaService, promiseConstructor) {
        this.MATCHES_MULTIPLE = 'Matches multiple schemas when only one must validate.';
        this.promise = promiseConstructor || Promise;
        this.validationEnabled = true;
        this.jsonValidation = new jsonValidation_JSONValidation(schemaService, this.promise);
    }
    YAMLValidation.prototype.configure = function (settings) {
        if (settings) {
            this.validationEnabled = settings.validate;
            this.customTags = settings.customTags;
        }
    };
    YAMLValidation.prototype.doValidation = function (textDocument, isKubernetes) {
        if (isKubernetes === void 0) { isKubernetes = false; }
        return yamlValidation_awaiter(this, void 0, void 0, function () {
            var yamlDocument, validationResult, index, _a, _b, currentYAMLDoc, validation, syd, e_1_1, foundSignatures, duplicateMessagesRemoved, _c, _d, err, errSig;
            var e_1, _e, e_2, _f;
            return yamlValidation_generator(this, function (_g) {
                switch (_g.label) {
                    case 0:
                        if (!this.validationEnabled) {
                            return [2 /*return*/, this.promise.resolve([])];
                        }
                        yamlDocument = yamlParser07_parse(textDocument.getText(), this.customTags);
                        validationResult = [];
                        index = 0;
                        _g.label = 1;
                    case 1:
                        _g.trys.push([1, 6, 7, 8]);
                        _a = yamlValidation_values(yamlDocument.documents), _b = _a.next();
                        _g.label = 2;
                    case 2:
                        if (!!_b.done) return [3 /*break*/, 5];
                        currentYAMLDoc = _b.value;
                        currentYAMLDoc.isKubernetes = isKubernetes;
                        currentYAMLDoc.currentDocIndex = index;
                        return [4 /*yield*/, this.jsonValidation.doValidation(textDocument, currentYAMLDoc)];
                    case 3:
                        validation = _g.sent();
                        syd = currentYAMLDoc;
                        if (syd.errors.length > 0) {
                            validationResult.push.apply(validationResult, yamlValidation_spread(syd.errors));
                        }
                        validationResult.push.apply(validationResult, yamlValidation_spread(validation));
                        index++;
                        _g.label = 4;
                    case 4:
                        _b = _a.next();
                        return [3 /*break*/, 2];
                    case 5: return [3 /*break*/, 8];
                    case 6:
                        e_1_1 = _g.sent();
                        e_1 = { error: e_1_1 };
                        return [3 /*break*/, 8];
                    case 7:
                        try {
                            if (_b && !_b.done && (_e = _a.return)) _e.call(_a);
                        }
                        finally { if (e_1) throw e_1.error; }
                        return [7 /*endfinally*/];
                    case 8:
                        foundSignatures = new Set();
                        duplicateMessagesRemoved = [];
                        try {
                            for (_c = yamlValidation_values(validationResult), _d = _c.next(); !_d.done; _d = _c.next()) {
                                err = _d.value;
                                /**
                                 * A patch ontop of the validation that removes the
                                 * 'Matches many schemas' error for kubernetes
                                 * for a better user experience.
                                 */
                                if (isKubernetes && err.message === this.MATCHES_MULTIPLE) {
                                    continue;
                                }
                                errSig = err.range.start.line +
                                    ' ' +
                                    err.range.start.character +
                                    ' ' +
                                    err.message;
                                if (!foundSignatures.has(errSig)) {
                                    duplicateMessagesRemoved.push(err);
                                    foundSignatures.add(errSig);
                                }
                            }
                        }
                        catch (e_2_1) { e_2 = { error: e_2_1 }; }
                        finally {
                            try {
                                if (_d && !_d.done && (_f = _c.return)) _f.call(_c);
                            }
                            finally { if (e_2) throw e_2.error; }
                        }
                        return [2 /*return*/, duplicateMessagesRemoved];
                }
            });
        });
    };
    return YAMLValidation;
}());


// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/languageservice/services/yamlFormatter.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Red Hat, Inc. All rights reserved.
 *  Copyright (c) Adam Voss. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/


var yamlFormatter_YAMLFormatter = /** @class */ (function () {
    function YAMLFormatter() {
        this.formatterEnabled = true;
    }
    YAMLFormatter.prototype.configure = function (shouldFormat) {
        if (shouldFormat) {
            this.formatterEnabled = shouldFormat.format;
        }
    };
    YAMLFormatter.prototype.format = function (document, options) {
        if (!this.formatterEnabled) {
            return [];
        }
        try {
            var prettier = __webpack_require__(43);
            var parser = __webpack_require__(44);
            var text = document.getText();
            var formatted = prettier.format(text, Object.assign(options, { parser: 'yaml', plugins: [parser] }));
            return [
                TextEdit.replace(main_Range.create(main_Position.create(0, 0), document.positionAt(text.length)), formatted),
            ];
        }
        catch (error) {
            return [];
        }
    };
    return YAMLFormatter;
}());


// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/languageservice/yamlLanguageService.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Red Hat, Inc. All rights reserved.
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/






function yamlLanguageService_getLanguageService(schemaRequestService, workspaceContext, contributions, promiseConstructor) {
    var promise = promiseConstructor || Promise;
    var schemaService = new yamlSchemaService_YAMLSchemaService(schemaRequestService, workspaceContext);
    var completer = new yamlCompletion_YAMLCompletion(schemaService, contributions, promise);
    var hover = new yamlHover_YAMLHover(schemaService, promise);
    var yamlDocumentSymbols = new documentSymbols_YAMLDocumentSymbols(schemaService);
    var yamlValidation = new yamlValidation_YAMLValidation(schemaService, promise);
    var formatter = new yamlFormatter_YAMLFormatter();
    return {
        configure: function (settings) {
            schemaService.clearExternalSchemas();
            if (settings.schemas) {
                settings.schemas.forEach(function (settings) {
                    schemaService.registerExternalSchema(settings.uri, settings.fileMatch, settings.schema);
                });
            }
            yamlValidation.configure(settings);
            hover.configure(settings);
            var customTagsSetting = settings && settings['customTags'] ? settings['customTags'] : [];
            completer.configure(settings, customTagsSetting);
            formatter.configure(settings);
        },
        registerCustomSchemaProvider: function (schemaProvider) {
            schemaService.registerCustomSchemaProvider(schemaProvider);
        },
        doComplete: completer.doComplete.bind(completer),
        doResolve: completer.doResolve.bind(completer),
        doValidation: yamlValidation.doValidation.bind(yamlValidation),
        doHover: hover.doHover.bind(hover),
        findDocumentSymbols: yamlDocumentSymbols.findDocumentSymbols.bind(yamlDocumentSymbols),
        findDocumentSymbols2: yamlDocumentSymbols.findHierarchicalDocumentSymbols.bind(yamlDocumentSymbols),
        resetSchema: function (uri) { return schemaService.onResourceChange(uri); },
        doFormat: formatter.format.bind(formatter),
    };
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yamlWorker.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Red Hat, Inc. All rights reserved.
 *  Copyright (c) Adam Voss. All rights reserved.
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

var __assign = (undefined && undefined.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var yamlWorker_values = (undefined && undefined.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
var yamlWorker_Promise = monaco.Promise;


var defaultSchemaRequestService;
if (typeof fetch !== 'undefined') {
    defaultSchemaRequestService = function (url) {
        return fetch(url).then(function (response) { return response.text(); });
    };
}
var yamlWorker_YAMLWorker = /** @class */ (function () {
    function YAMLWorker(ctx, createData) {
        var prefix = createData.prefix || '';
        var service = function (url) {
            return defaultSchemaRequestService("" + prefix + url);
        };
        this._ctx = ctx;
        this._languageSettings = createData.languageSettings;
        this._languageId = createData.languageId;
        this._languageService = yamlLanguageService_getLanguageService(createData.enableSchemaRequest && service, null, []);
        this._isKubernetes = createData.isKubernetes || false;
        this._languageService.configure(__assign(__assign({}, this._languageSettings), { hover: true, isKubernetes: this._isKubernetes }));
    }
    YAMLWorker.prototype.doValidation = function (uri) {
        var document = this._getTextDocument(uri);
        if (document) {
            return this._languageService.doValidation(document, this._isKubernetes);
        }
        return yamlWorker_Promise.as([]);
    };
    YAMLWorker.prototype.doComplete = function (uri, position) {
        var document = this._getTextDocument(uri);
        return this._languageService.doComplete(document, position, this._isKubernetes);
    };
    YAMLWorker.prototype.doResolve = function (item) {
        return this._languageService.doResolve(item);
    };
    YAMLWorker.prototype.doHover = function (uri, position) {
        var document = this._getTextDocument(uri);
        return this._languageService.doHover(document, position);
    };
    YAMLWorker.prototype.format = function (uri, range, options) {
        var document = this._getTextDocument(uri);
        var textEdits = this._languageService.doFormat(document, options);
        return yamlWorker_Promise.as(textEdits);
    };
    YAMLWorker.prototype.resetSchema = function (uri) {
        return yamlWorker_Promise.as(this._languageService.resetSchema(uri));
    };
    YAMLWorker.prototype.findDocumentSymbols = function (uri) {
        var document = this._getTextDocument(uri);
        var symbols = this._languageService.findDocumentSymbols2(document);
        return yamlWorker_Promise.as(symbols);
    };
    YAMLWorker.prototype._getTextDocument = function (uri) {
        var e_1, _a;
        var models = this._ctx.getMirrorModels();
        try {
            for (var models_1 = yamlWorker_values(models), models_1_1 = models_1.next(); !models_1_1.done; models_1_1 = models_1.next()) {
                var model = models_1_1.value;
                if (model.uri.toString() === uri) {
                    return TextDocument.create(uri, this._languageId, model.version, model.getValue());
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (models_1_1 && !models_1_1.done && (_a = models_1.return)) _a.call(models_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        return null;
    };
    return YAMLWorker;
}());

function yamlWorker_create(ctx, createData) {
    return new yamlWorker_YAMLWorker(ctx, createData);
}

// CONCATENATED MODULE: ../node_modules/monaco-yaml/esm/yaml.worker.js
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/



self.onmessage = function () {
    // ignore the first message
    initialize(function (ctx, createData) {
        return new yamlWorker_YAMLWorker(ctx, createData);
    });
};


/***/ })
/******/ ]);